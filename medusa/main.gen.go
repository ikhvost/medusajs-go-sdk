// Package medusa provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package medusa

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_tokenScopes   = "api_token.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
	Jwt_tokenScopes   = "jwt_token.Scopes"
)

// Defines values for AdminApiKeyType.
const (
	AdminApiKeyTypePublishable AdminApiKeyType = "publishable"
	AdminApiKeyTypeSecret      AdminApiKeyType = "secret"
)

// Defines values for AdminApplicationMethodAllocation.
const (
	AdminApplicationMethodAllocationAcross AdminApplicationMethodAllocation = "across"
	AdminApplicationMethodAllocationEach   AdminApplicationMethodAllocation = "each"
)

// Defines values for AdminApplicationMethodTargetType.
const (
	AdminApplicationMethodTargetTypeItems           AdminApplicationMethodTargetType = "items"
	AdminApplicationMethodTargetTypeOrder           AdminApplicationMethodTargetType = "order"
	AdminApplicationMethodTargetTypeShippingMethods AdminApplicationMethodTargetType = "shipping_methods"
)

// Defines values for AdminApplicationMethodType.
const (
	AdminApplicationMethodTypeFixed      AdminApplicationMethodType = "fixed"
	AdminApplicationMethodTypePercentage AdminApplicationMethodType = "percentage"
)

// Defines values for AdminCampaignBudgetType.
const (
	AdminCampaignBudgetTypeSpend AdminCampaignBudgetType = "spend"
	AdminCampaignBudgetTypeUsage AdminCampaignBudgetType = "usage"
)

// Defines values for AdminClaimType.
const (
	AdminClaimTypeRefund  AdminClaimType = "refund"
	AdminClaimTypeReplace AdminClaimType = "replace"
)

// Defines values for AdminCreateApiKeyType.
const (
	AdminCreateApiKeyTypePublishable AdminCreateApiKeyType = "publishable"
	AdminCreateApiKeyTypeSecret      AdminCreateApiKeyType = "secret"
)

// Defines values for AdminCreatePriceListStatus.
const (
	AdminCreatePriceListStatusActive AdminCreatePriceListStatus = "active"
	AdminCreatePriceListStatusDraft  AdminCreatePriceListStatus = "draft"
)

// Defines values for AdminCreatePriceListType.
const (
	AdminCreatePriceListTypeOverride AdminCreatePriceListType = "override"
	AdminCreatePriceListTypeSale     AdminCreatePriceListType = "sale"
)

// Defines values for AdminCreateProductStatus.
const (
	AdminCreateProductStatusDraft     AdminCreateProductStatus = "draft"
	AdminCreateProductStatusProposed  AdminCreateProductStatus = "proposed"
	AdminCreateProductStatusPublished AdminCreateProductStatus = "published"
	AdminCreateProductStatusRejected  AdminCreateProductStatus = "rejected"
)

// Defines values for AdminCreatePromotionRuleOperator.
const (
	AdminCreatePromotionRuleOperatorEq  AdminCreatePromotionRuleOperator = "eq"
	AdminCreatePromotionRuleOperatorGt  AdminCreatePromotionRuleOperator = "gt"
	AdminCreatePromotionRuleOperatorGte AdminCreatePromotionRuleOperator = "gte"
	AdminCreatePromotionRuleOperatorIn  AdminCreatePromotionRuleOperator = "in"
	AdminCreatePromotionRuleOperatorLt  AdminCreatePromotionRuleOperator = "lt"
	AdminCreatePromotionRuleOperatorLte AdminCreatePromotionRuleOperator = "lte"
	AdminCreatePromotionRuleOperatorNe  AdminCreatePromotionRuleOperator = "ne"
)

// Defines values for AdminCreateShippingOptionRuleOperator.
const (
	AdminCreateShippingOptionRuleOperatorEq  AdminCreateShippingOptionRuleOperator = "eq"
	AdminCreateShippingOptionRuleOperatorGt  AdminCreateShippingOptionRuleOperator = "gt"
	AdminCreateShippingOptionRuleOperatorGte AdminCreateShippingOptionRuleOperator = "gte"
	AdminCreateShippingOptionRuleOperatorIn  AdminCreateShippingOptionRuleOperator = "in"
	AdminCreateShippingOptionRuleOperatorLt  AdminCreateShippingOptionRuleOperator = "lt"
	AdminCreateShippingOptionRuleOperatorLte AdminCreateShippingOptionRuleOperator = "lte"
	AdminCreateShippingOptionRuleOperatorNe  AdminCreateShippingOptionRuleOperator = "ne"
	AdminCreateShippingOptionRuleOperatorNin AdminCreateShippingOptionRuleOperator = "nin"
)

// Defines values for AdminCreateWorkflowsAsyncResponseAction.
const (
	Compensate AdminCreateWorkflowsAsyncResponseAction = "compensate"
	Invoke     AdminCreateWorkflowsAsyncResponseAction = "invoke"
)

// Defines values for AdminGeoZoneType.
const (
	City     AdminGeoZoneType = "city"
	Country  AdminGeoZoneType = "country"
	Province AdminGeoZoneType = "province"
	Zip      AdminGeoZoneType = "zip"
)

// Defines values for AdminOrderFulfillmentStatus.
const (
	AdminOrderFulfillmentStatusCanceled           AdminOrderFulfillmentStatus = "canceled"
	AdminOrderFulfillmentStatusDelivered          AdminOrderFulfillmentStatus = "delivered"
	AdminOrderFulfillmentStatusFulfilled          AdminOrderFulfillmentStatus = "fulfilled"
	AdminOrderFulfillmentStatusNotFulfilled       AdminOrderFulfillmentStatus = "not_fulfilled"
	AdminOrderFulfillmentStatusPartiallyDelivered AdminOrderFulfillmentStatus = "partially_delivered"
	AdminOrderFulfillmentStatusPartiallyFulfilled AdminOrderFulfillmentStatus = "partially_fulfilled"
	AdminOrderFulfillmentStatusPartiallyShipped   AdminOrderFulfillmentStatus = "partially_shipped"
	AdminOrderFulfillmentStatusShipped            AdminOrderFulfillmentStatus = "shipped"
)

// Defines values for AdminOrderPaymentStatus.
const (
	AdminOrderPaymentStatusAuthorized          AdminOrderPaymentStatus = "authorized"
	AdminOrderPaymentStatusAwaiting            AdminOrderPaymentStatus = "awaiting"
	AdminOrderPaymentStatusCanceled            AdminOrderPaymentStatus = "canceled"
	AdminOrderPaymentStatusCaptured            AdminOrderPaymentStatus = "captured"
	AdminOrderPaymentStatusNotPaid             AdminOrderPaymentStatus = "not_paid"
	AdminOrderPaymentStatusPartiallyAuthorized AdminOrderPaymentStatus = "partially_authorized"
	AdminOrderPaymentStatusPartiallyCaptured   AdminOrderPaymentStatus = "partially_captured"
	AdminOrderPaymentStatusPartiallyRefunded   AdminOrderPaymentStatus = "partially_refunded"
	AdminOrderPaymentStatusRefunded            AdminOrderPaymentStatus = "refunded"
	AdminOrderPaymentStatusRequiresAction      AdminOrderPaymentStatus = "requires_action"
)

// Defines values for AdminOrderChangeChangeType.
const (
	AdminOrderChangeChangeTypeClaim    AdminOrderChangeChangeType = "claim"
	AdminOrderChangeChangeTypeEdit     AdminOrderChangeChangeType = "edit"
	AdminOrderChangeChangeTypeExchange AdminOrderChangeChangeType = "exchange"
	AdminOrderChangeChangeTypeReturn   AdminOrderChangeChangeType = "return"
)

// Defines values for AdminOrderChangeStatus.
const (
	AdminOrderChangeStatusCanceled  AdminOrderChangeStatus = "canceled"
	AdminOrderChangeStatusConfirmed AdminOrderChangeStatus = "confirmed"
	AdminOrderChangeStatusDeclined  AdminOrderChangeStatus = "declined"
	AdminOrderChangeStatusPending   AdminOrderChangeStatus = "pending"
	AdminOrderChangeStatusRequested AdminOrderChangeStatus = "requested"
)

// Defines values for AdminOrderChangeActionAction.
const (
	AdminOrderChangeActionActionCANCELITEMFULFILLMENT    AdminOrderChangeActionAction = "CANCEL_ITEM_FULFILLMENT"
	AdminOrderChangeActionActionCANCELRETURNITEM         AdminOrderChangeActionAction = "CANCEL_RETURN_ITEM"
	AdminOrderChangeActionActionDELIVERITEM              AdminOrderChangeActionAction = "DELIVER_ITEM"
	AdminOrderChangeActionActionFULFILLITEM              AdminOrderChangeActionAction = "FULFILL_ITEM"
	AdminOrderChangeActionActionITEMADD                  AdminOrderChangeActionAction = "ITEM_ADD"
	AdminOrderChangeActionActionITEMREMOVE               AdminOrderChangeActionAction = "ITEM_REMOVE"
	AdminOrderChangeActionActionITEMUPDATE               AdminOrderChangeActionAction = "ITEM_UPDATE"
	AdminOrderChangeActionActionRECEIVEDAMAGEDRETURNITEM AdminOrderChangeActionAction = "RECEIVE_DAMAGED_RETURN_ITEM"
	AdminOrderChangeActionActionRECEIVERETURNITEM        AdminOrderChangeActionAction = "RECEIVE_RETURN_ITEM"
	AdminOrderChangeActionActionREINSTATEITEM            AdminOrderChangeActionAction = "REINSTATE_ITEM"
	AdminOrderChangeActionActionRETURNITEM               AdminOrderChangeActionAction = "RETURN_ITEM"
	AdminOrderChangeActionActionSHIPITEM                 AdminOrderChangeActionAction = "SHIP_ITEM"
	AdminOrderChangeActionActionSHIPPINGADD              AdminOrderChangeActionAction = "SHIPPING_ADD"
	AdminOrderChangeActionActionSHIPPINGREMOVE           AdminOrderChangeActionAction = "SHIPPING_REMOVE"
	AdminOrderChangeActionActionWRITEOFFITEM             AdminOrderChangeActionAction = "WRITE_OFF_ITEM"
)

// Defines values for AdminOrderChangeActionReference.
const (
	AdminOrderChangeActionReferenceClaim               AdminOrderChangeActionReference = "claim"
	AdminOrderChangeActionReferenceExchange            AdminOrderChangeActionReference = "exchange"
	AdminOrderChangeActionReferenceOrderShippingMethod AdminOrderChangeActionReference = "order_shipping_method"
	AdminOrderChangeActionReferenceReturn              AdminOrderChangeActionReference = "return"
)

// Defines values for AdminOrderPreviewFulfillmentStatus.
const (
	AdminOrderPreviewFulfillmentStatusCanceled           AdminOrderPreviewFulfillmentStatus = "canceled"
	AdminOrderPreviewFulfillmentStatusDelivered          AdminOrderPreviewFulfillmentStatus = "delivered"
	AdminOrderPreviewFulfillmentStatusFulfilled          AdminOrderPreviewFulfillmentStatus = "fulfilled"
	AdminOrderPreviewFulfillmentStatusNotFulfilled       AdminOrderPreviewFulfillmentStatus = "not_fulfilled"
	AdminOrderPreviewFulfillmentStatusPartiallyDelivered AdminOrderPreviewFulfillmentStatus = "partially_delivered"
	AdminOrderPreviewFulfillmentStatusPartiallyFulfilled AdminOrderPreviewFulfillmentStatus = "partially_fulfilled"
	AdminOrderPreviewFulfillmentStatusPartiallyShipped   AdminOrderPreviewFulfillmentStatus = "partially_shipped"
	AdminOrderPreviewFulfillmentStatusShipped            AdminOrderPreviewFulfillmentStatus = "shipped"
)

// Defines values for AdminOrderPreviewPaymentStatus.
const (
	AdminOrderPreviewPaymentStatusAuthorized          AdminOrderPreviewPaymentStatus = "authorized"
	AdminOrderPreviewPaymentStatusAwaiting            AdminOrderPreviewPaymentStatus = "awaiting"
	AdminOrderPreviewPaymentStatusCanceled            AdminOrderPreviewPaymentStatus = "canceled"
	AdminOrderPreviewPaymentStatusCaptured            AdminOrderPreviewPaymentStatus = "captured"
	AdminOrderPreviewPaymentStatusNotPaid             AdminOrderPreviewPaymentStatus = "not_paid"
	AdminOrderPreviewPaymentStatusPartiallyAuthorized AdminOrderPreviewPaymentStatus = "partially_authorized"
	AdminOrderPreviewPaymentStatusPartiallyCaptured   AdminOrderPreviewPaymentStatus = "partially_captured"
	AdminOrderPreviewPaymentStatusPartiallyRefunded   AdminOrderPreviewPaymentStatus = "partially_refunded"
	AdminOrderPreviewPaymentStatusRefunded            AdminOrderPreviewPaymentStatus = "refunded"
	AdminOrderPreviewPaymentStatusRequiresAction      AdminOrderPreviewPaymentStatus = "requires_action"
)

// Defines values for AdminPaymentCollectionStatus.
const (
	AdminPaymentCollectionStatusAuthorized          AdminPaymentCollectionStatus = "authorized"
	AdminPaymentCollectionStatusAwaiting            AdminPaymentCollectionStatus = "awaiting"
	AdminPaymentCollectionStatusCanceled            AdminPaymentCollectionStatus = "canceled"
	AdminPaymentCollectionStatusNotPaid             AdminPaymentCollectionStatus = "not_paid"
	AdminPaymentCollectionStatusPartiallyAuthorized AdminPaymentCollectionStatus = "partially_authorized"
)

// Defines values for AdminPaymentSessionStatus.
const (
	AdminPaymentSessionStatusAuthorized   AdminPaymentSessionStatus = "authorized"
	AdminPaymentSessionStatusCanceled     AdminPaymentSessionStatus = "canceled"
	AdminPaymentSessionStatusCaptured     AdminPaymentSessionStatus = "captured"
	AdminPaymentSessionStatusError        AdminPaymentSessionStatus = "error"
	AdminPaymentSessionStatusPending      AdminPaymentSessionStatus = "pending"
	AdminPaymentSessionStatusRequiresMore AdminPaymentSessionStatus = "requires_more"
)

// Defines values for AdminPostClaimItemsReqSchemaItemsReason.
const (
	AdminPostClaimItemsReqSchemaItemsReasonMissingItem       AdminPostClaimItemsReqSchemaItemsReason = "missing_item"
	AdminPostClaimItemsReqSchemaItemsReasonOther             AdminPostClaimItemsReqSchemaItemsReason = "other"
	AdminPostClaimItemsReqSchemaItemsReasonProductionFailure AdminPostClaimItemsReqSchemaItemsReason = "production_failure"
	AdminPostClaimItemsReqSchemaItemsReasonWrongItem         AdminPostClaimItemsReqSchemaItemsReason = "wrong_item"
)

// Defines values for AdminPostOrderClaimsReqSchemaType.
const (
	AdminPostOrderClaimsReqSchemaTypeRefund  AdminPostOrderClaimsReqSchemaType = "refund"
	AdminPostOrderClaimsReqSchemaTypeReplace AdminPostOrderClaimsReqSchemaType = "replace"
)

// Defines values for AdminPriceListStatus.
const (
	AdminPriceListStatusActive AdminPriceListStatus = "active"
	AdminPriceListStatusDraft  AdminPriceListStatus = "draft"
)

// Defines values for AdminPriceListType.
const (
	AdminPriceListTypeOverride AdminPriceListType = "override"
	AdminPriceListTypeSale     AdminPriceListType = "sale"
)

// Defines values for AdminProductStatus.
const (
	AdminProductStatusDraft     AdminProductStatus = "draft"
	AdminProductStatusProposed  AdminProductStatus = "proposed"
	AdminProductStatusPublished AdminProductStatus = "published"
	AdminProductStatusRejected  AdminProductStatus = "rejected"
)

// Defines values for AdminPromotionType.
const (
	AdminPromotionTypeBuyget   AdminPromotionType = "buyget"
	AdminPromotionTypeStandard AdminPromotionType = "standard"
)

// Defines values for AdminPromotionRuleOperator.
const (
	AdminPromotionRuleOperatorEq  AdminPromotionRuleOperator = "eq"
	AdminPromotionRuleOperatorGt  AdminPromotionRuleOperator = "gt"
	AdminPromotionRuleOperatorGte AdminPromotionRuleOperator = "gte"
	AdminPromotionRuleOperatorIn  AdminPromotionRuleOperator = "in"
	AdminPromotionRuleOperatorLt  AdminPromotionRuleOperator = "lt"
	AdminPromotionRuleOperatorLte AdminPromotionRuleOperator = "lte"
	AdminPromotionRuleOperatorNe  AdminPromotionRuleOperator = "ne"
)

// Defines values for AdminReturnStatus.
const (
	AdminReturnStatusCanceled          AdminReturnStatus = "canceled"
	AdminReturnStatusPartiallyReceived AdminReturnStatus = "partially_received"
	AdminReturnStatusReceived          AdminReturnStatus = "received"
	AdminReturnStatusRequested         AdminReturnStatus = "requested"
)

// Defines values for AdminShippingOptionPriceType.
const (
	AdminShippingOptionPriceTypeCalculated AdminShippingOptionPriceType = "calculated"
	AdminShippingOptionPriceTypeFlat       AdminShippingOptionPriceType = "flat"
)

// Defines values for AdminUpdatePriceListStatus.
const (
	AdminUpdatePriceListStatusActive AdminUpdatePriceListStatus = "active"
	AdminUpdatePriceListStatusDraft  AdminUpdatePriceListStatus = "draft"
)

// Defines values for AdminUpdatePriceListType.
const (
	Override AdminUpdatePriceListType = "override"
	Sale     AdminUpdatePriceListType = "sale"
)

// Defines values for AdminUpdateProductStatus.
const (
	AdminUpdateProductStatusDraft     AdminUpdateProductStatus = "draft"
	AdminUpdateProductStatusProposed  AdminUpdateProductStatus = "proposed"
	AdminUpdateProductStatusPublished AdminUpdateProductStatus = "published"
	AdminUpdateProductStatusRejected  AdminUpdateProductStatus = "rejected"
)

// Defines values for AdminUpdatePromotionRuleOperator.
const (
	AdminUpdatePromotionRuleOperatorEq  AdminUpdatePromotionRuleOperator = "eq"
	AdminUpdatePromotionRuleOperatorGt  AdminUpdatePromotionRuleOperator = "gt"
	AdminUpdatePromotionRuleOperatorGte AdminUpdatePromotionRuleOperator = "gte"
	AdminUpdatePromotionRuleOperatorIn  AdminUpdatePromotionRuleOperator = "in"
	AdminUpdatePromotionRuleOperatorLt  AdminUpdatePromotionRuleOperator = "lt"
	AdminUpdatePromotionRuleOperatorLte AdminUpdatePromotionRuleOperator = "lte"
	AdminUpdatePromotionRuleOperatorNe  AdminUpdatePromotionRuleOperator = "ne"
)

// Defines values for AdminUpdateShippingOptionRuleOperator.
const (
	AdminUpdateShippingOptionRuleOperatorEq  AdminUpdateShippingOptionRuleOperator = "eq"
	AdminUpdateShippingOptionRuleOperatorGt  AdminUpdateShippingOptionRuleOperator = "gt"
	AdminUpdateShippingOptionRuleOperatorGte AdminUpdateShippingOptionRuleOperator = "gte"
	AdminUpdateShippingOptionRuleOperatorIn  AdminUpdateShippingOptionRuleOperator = "in"
	AdminUpdateShippingOptionRuleOperatorLt  AdminUpdateShippingOptionRuleOperator = "lt"
	AdminUpdateShippingOptionRuleOperatorLte AdminUpdateShippingOptionRuleOperator = "lte"
	AdminUpdateShippingOptionRuleOperatorNe  AdminUpdateShippingOptionRuleOperator = "ne"
	AdminUpdateShippingOptionRuleOperatorNin AdminUpdateShippingOptionRuleOperator = "nin"
)

// Defines values for AdminWorkflowExecutionState.
const (
	Compensating        AdminWorkflowExecutionState = "compensating"
	Done                AdminWorkflowExecutionState = "done"
	Failed              AdminWorkflowExecutionState = "failed"
	Invoking            AdminWorkflowExecutionState = "invoking"
	NotStarted          AdminWorkflowExecutionState = "not_started"
	Reverted            AdminWorkflowExecutionState = "reverted"
	WaitingToCompensate AdminWorkflowExecutionState = "waiting_to_compensate"
)

// Defines values for ApiKeyResponseType.
const (
	ApiKeyResponseTypePublishable ApiKeyResponseType = "publishable"
	ApiKeyResponseTypeSecret      ApiKeyResponseType = "secret"
)

// Defines values for BaseClaimItemReason.
const (
	BaseClaimItemReasonMissingItem       BaseClaimItemReason = "missing_item"
	BaseClaimItemReasonOther             BaseClaimItemReason = "other"
	BaseClaimItemReasonProductionFailure BaseClaimItemReason = "production_failure"
	BaseClaimItemReasonWrongItem         BaseClaimItemReason = "wrong_item"
)

// Defines values for BaseOrderFulfillmentStatus.
const (
	BaseOrderFulfillmentStatusCanceled           BaseOrderFulfillmentStatus = "canceled"
	BaseOrderFulfillmentStatusDelivered          BaseOrderFulfillmentStatus = "delivered"
	BaseOrderFulfillmentStatusFulfilled          BaseOrderFulfillmentStatus = "fulfilled"
	BaseOrderFulfillmentStatusNotFulfilled       BaseOrderFulfillmentStatus = "not_fulfilled"
	BaseOrderFulfillmentStatusPartiallyDelivered BaseOrderFulfillmentStatus = "partially_delivered"
	BaseOrderFulfillmentStatusPartiallyFulfilled BaseOrderFulfillmentStatus = "partially_fulfilled"
	BaseOrderFulfillmentStatusPartiallyShipped   BaseOrderFulfillmentStatus = "partially_shipped"
	BaseOrderFulfillmentStatusShipped            BaseOrderFulfillmentStatus = "shipped"
)

// Defines values for BaseOrderPaymentStatus.
const (
	BaseOrderPaymentStatusAuthorized          BaseOrderPaymentStatus = "authorized"
	BaseOrderPaymentStatusAwaiting            BaseOrderPaymentStatus = "awaiting"
	BaseOrderPaymentStatusCanceled            BaseOrderPaymentStatus = "canceled"
	BaseOrderPaymentStatusCaptured            BaseOrderPaymentStatus = "captured"
	BaseOrderPaymentStatusNotPaid             BaseOrderPaymentStatus = "not_paid"
	BaseOrderPaymentStatusPartiallyAuthorized BaseOrderPaymentStatus = "partially_authorized"
	BaseOrderPaymentStatusPartiallyCaptured   BaseOrderPaymentStatus = "partially_captured"
	BaseOrderPaymentStatusPartiallyRefunded   BaseOrderPaymentStatus = "partially_refunded"
	BaseOrderPaymentStatusRefunded            BaseOrderPaymentStatus = "refunded"
	BaseOrderPaymentStatusRequiresAction      BaseOrderPaymentStatus = "requires_action"
)

// Defines values for BaseOrderChangeActionReference.
const (
	BaseOrderChangeActionReferenceClaim               BaseOrderChangeActionReference = "claim"
	BaseOrderChangeActionReferenceExchange            BaseOrderChangeActionReference = "exchange"
	BaseOrderChangeActionReferenceOrderShippingMethod BaseOrderChangeActionReference = "order_shipping_method"
	BaseOrderChangeActionReferenceReturn              BaseOrderChangeActionReference = "return"
)

// Defines values for BaseOrderTransactionReference.
const (
	BaseOrderTransactionReferenceCapture BaseOrderTransactionReference = "capture"
	BaseOrderTransactionReferenceRefund  BaseOrderTransactionReference = "refund"
)

// Defines values for BasePaymentCollectionStatus.
const (
	BasePaymentCollectionStatusAuthorized          BasePaymentCollectionStatus = "authorized"
	BasePaymentCollectionStatusAwaiting            BasePaymentCollectionStatus = "awaiting"
	BasePaymentCollectionStatusCanceled            BasePaymentCollectionStatus = "canceled"
	BasePaymentCollectionStatusNotPaid             BasePaymentCollectionStatus = "not_paid"
	BasePaymentCollectionStatusPartiallyAuthorized BasePaymentCollectionStatus = "partially_authorized"
)

// Defines values for BasePaymentSessionStatus.
const (
	BasePaymentSessionStatusAuthorized   BasePaymentSessionStatus = "authorized"
	BasePaymentSessionStatusCanceled     BasePaymentSessionStatus = "canceled"
	BasePaymentSessionStatusCaptured     BasePaymentSessionStatus = "captured"
	BasePaymentSessionStatusError        BasePaymentSessionStatus = "error"
	BasePaymentSessionStatusPending      BasePaymentSessionStatus = "pending"
	BasePaymentSessionStatusRequiresMore BasePaymentSessionStatus = "requires_more"
)

// Defines values for BaseProductStatus.
const (
	BaseProductStatusDraft     BaseProductStatus = "draft"
	BaseProductStatusProposed  BaseProductStatus = "proposed"
	BaseProductStatusPublished BaseProductStatus = "published"
	BaseProductStatusRejected  BaseProductStatus = "rejected"
)

// Defines values for BasePromotionRuleOperator.
const (
	BasePromotionRuleOperatorEq  BasePromotionRuleOperator = "eq"
	BasePromotionRuleOperatorGt  BasePromotionRuleOperator = "gt"
	BasePromotionRuleOperatorGte BasePromotionRuleOperator = "gte"
	BasePromotionRuleOperatorIn  BasePromotionRuleOperator = "in"
	BasePromotionRuleOperatorLt  BasePromotionRuleOperator = "lt"
	BasePromotionRuleOperatorLte BasePromotionRuleOperator = "lte"
	BasePromotionRuleOperatorNe  BasePromotionRuleOperator = "ne"
)

// Defines values for CampaignResponseBudgetType.
const (
	CampaignResponseBudgetTypeSpend CampaignResponseBudgetType = "spend"
	CampaignResponseBudgetTypeUsage CampaignResponseBudgetType = "usage"
)

// Defines values for ErrorCode.
const (
	ErrorCodeApiError            ErrorCode = "api_error"
	ErrorCodeInvalidRequestError ErrorCode = "invalid_request_error"
	ErrorCodeInvalidStateError   ErrorCode = "invalid_state_error"
	ErrorCodeUnknownError        ErrorCode = "unknown_error"
)

// Defines values for ErrorType.
const (
	ErrorTypeConflict                        ErrorType = "conflict"
	ErrorTypeDatabaseError                   ErrorType = "database_error"
	ErrorTypeDuplicateError                  ErrorType = "duplicate_error"
	ErrorTypeInvalidArgument                 ErrorType = "invalid_argument"
	ErrorTypeInvalidData                     ErrorType = "invalid_data"
	ErrorTypeNotAllowed                      ErrorType = "not_allowed"
	ErrorTypeNotFound                        ErrorType = "not_found"
	ErrorTypePaymentAuthorizationError       ErrorType = "payment_authorization_error"
	ErrorTypeQueryRunnerAlreadyReleasedError ErrorType = "QueryRunnerAlreadyReleasedError"
	ErrorTypeTransactionAlreadyStartedError  ErrorType = "TransactionAlreadyStartedError"
	ErrorTypeTransactionNotStartedError      ErrorType = "TransactionNotStartedError"
	ErrorTypeUnauthorized                    ErrorType = "unauthorized"
	ErrorTypeUnexpectedState                 ErrorType = "unexpected_state"
	ErrorTypeUnknownError                    ErrorType = "unknown_error"
)

// Defines values for OrderStatus.
const (
	OrderStatusArchived       OrderStatus = "archived"
	OrderStatusCanceled       OrderStatus = "canceled"
	OrderStatusCompleted      OrderStatus = "completed"
	OrderStatusDraft          OrderStatus = "draft"
	OrderStatusPending        OrderStatus = "pending"
	OrderStatusRequiresAction OrderStatus = "requires_action"
)

// Defines values for OrderChangeChangeType.
const (
	OrderChangeChangeTypeClaim    OrderChangeChangeType = "claim"
	OrderChangeChangeTypeEdit     OrderChangeChangeType = "edit"
	OrderChangeChangeTypeExchange OrderChangeChangeType = "exchange"
	OrderChangeChangeTypeReturn   OrderChangeChangeType = "return"
)

// Defines values for OrderChangeStatus.
const (
	OrderChangeStatusCanceled  OrderChangeStatus = "canceled"
	OrderChangeStatusConfirmed OrderChangeStatus = "confirmed"
	OrderChangeStatusDeclined  OrderChangeStatus = "declined"
	OrderChangeStatusPending   OrderChangeStatus = "pending"
	OrderChangeStatusRequested OrderChangeStatus = "requested"
)

// Defines values for OrderChangeActionAction.
const (
	OrderChangeActionActionCANCELITEMFULFILLMENT    OrderChangeActionAction = "CANCEL_ITEM_FULFILLMENT"
	OrderChangeActionActionCANCELRETURNITEM         OrderChangeActionAction = "CANCEL_RETURN_ITEM"
	OrderChangeActionActionDELIVERITEM              OrderChangeActionAction = "DELIVER_ITEM"
	OrderChangeActionActionFULFILLITEM              OrderChangeActionAction = "FULFILL_ITEM"
	OrderChangeActionActionITEMADD                  OrderChangeActionAction = "ITEM_ADD"
	OrderChangeActionActionITEMREMOVE               OrderChangeActionAction = "ITEM_REMOVE"
	OrderChangeActionActionITEMUPDATE               OrderChangeActionAction = "ITEM_UPDATE"
	OrderChangeActionActionRECEIVEDAMAGEDRETURNITEM OrderChangeActionAction = "RECEIVE_DAMAGED_RETURN_ITEM"
	OrderChangeActionActionRECEIVERETURNITEM        OrderChangeActionAction = "RECEIVE_RETURN_ITEM"
	OrderChangeActionActionREINSTATEITEM            OrderChangeActionAction = "REINSTATE_ITEM"
	OrderChangeActionActionRETURNITEM               OrderChangeActionAction = "RETURN_ITEM"
	OrderChangeActionActionSHIPITEM                 OrderChangeActionAction = "SHIP_ITEM"
	OrderChangeActionActionSHIPPINGADD              OrderChangeActionAction = "SHIPPING_ADD"
	OrderChangeActionActionSHIPPINGREMOVE           OrderChangeActionAction = "SHIPPING_REMOVE"
	OrderChangeActionActionWRITEOFFITEM             OrderChangeActionAction = "WRITE_OFF_ITEM"
)

// Defines values for OrderChangeActionReference.
const (
	OrderChangeActionReferenceClaim               OrderChangeActionReference = "claim"
	OrderChangeActionReferenceExchange            OrderChangeActionReference = "exchange"
	OrderChangeActionReferenceOrderShippingMethod OrderChangeActionReference = "order_shipping_method"
	OrderChangeActionReferenceReturn              OrderChangeActionReference = "return"
)

// Defines values for OrderClaimFulfillmentStatus.
const (
	OrderClaimFulfillmentStatusCanceled           OrderClaimFulfillmentStatus = "canceled"
	OrderClaimFulfillmentStatusDelivered          OrderClaimFulfillmentStatus = "delivered"
	OrderClaimFulfillmentStatusFulfilled          OrderClaimFulfillmentStatus = "fulfilled"
	OrderClaimFulfillmentStatusNotFulfilled       OrderClaimFulfillmentStatus = "not_fulfilled"
	OrderClaimFulfillmentStatusPartiallyDelivered OrderClaimFulfillmentStatus = "partially_delivered"
	OrderClaimFulfillmentStatusPartiallyFulfilled OrderClaimFulfillmentStatus = "partially_fulfilled"
	OrderClaimFulfillmentStatusPartiallyShipped   OrderClaimFulfillmentStatus = "partially_shipped"
	OrderClaimFulfillmentStatusShipped            OrderClaimFulfillmentStatus = "shipped"
)

// Defines values for OrderClaimPaymentStatus.
const (
	OrderClaimPaymentStatusAuthorized          OrderClaimPaymentStatus = "authorized"
	OrderClaimPaymentStatusAwaiting            OrderClaimPaymentStatus = "awaiting"
	OrderClaimPaymentStatusCanceled            OrderClaimPaymentStatus = "canceled"
	OrderClaimPaymentStatusCaptured            OrderClaimPaymentStatus = "captured"
	OrderClaimPaymentStatusNotPaid             OrderClaimPaymentStatus = "not_paid"
	OrderClaimPaymentStatusPartiallyAuthorized OrderClaimPaymentStatus = "partially_authorized"
	OrderClaimPaymentStatusPartiallyCaptured   OrderClaimPaymentStatus = "partially_captured"
	OrderClaimPaymentStatusPartiallyRefunded   OrderClaimPaymentStatus = "partially_refunded"
	OrderClaimPaymentStatusRefunded            OrderClaimPaymentStatus = "refunded"
	OrderClaimPaymentStatusRequiresAction      OrderClaimPaymentStatus = "requires_action"
)

// Defines values for OrderExchangeFulfillmentStatus.
const (
	OrderExchangeFulfillmentStatusCanceled           OrderExchangeFulfillmentStatus = "canceled"
	OrderExchangeFulfillmentStatusDelivered          OrderExchangeFulfillmentStatus = "delivered"
	OrderExchangeFulfillmentStatusFulfilled          OrderExchangeFulfillmentStatus = "fulfilled"
	OrderExchangeFulfillmentStatusNotFulfilled       OrderExchangeFulfillmentStatus = "not_fulfilled"
	OrderExchangeFulfillmentStatusPartiallyDelivered OrderExchangeFulfillmentStatus = "partially_delivered"
	OrderExchangeFulfillmentStatusPartiallyFulfilled OrderExchangeFulfillmentStatus = "partially_fulfilled"
	OrderExchangeFulfillmentStatusPartiallyShipped   OrderExchangeFulfillmentStatus = "partially_shipped"
	OrderExchangeFulfillmentStatusShipped            OrderExchangeFulfillmentStatus = "shipped"
)

// Defines values for OrderExchangePaymentStatus.
const (
	OrderExchangePaymentStatusAuthorized          OrderExchangePaymentStatus = "authorized"
	OrderExchangePaymentStatusAwaiting            OrderExchangePaymentStatus = "awaiting"
	OrderExchangePaymentStatusCanceled            OrderExchangePaymentStatus = "canceled"
	OrderExchangePaymentStatusCaptured            OrderExchangePaymentStatus = "captured"
	OrderExchangePaymentStatusNotPaid             OrderExchangePaymentStatus = "not_paid"
	OrderExchangePaymentStatusPartiallyAuthorized OrderExchangePaymentStatus = "partially_authorized"
	OrderExchangePaymentStatusPartiallyCaptured   OrderExchangePaymentStatus = "partially_captured"
	OrderExchangePaymentStatusPartiallyRefunded   OrderExchangePaymentStatus = "partially_refunded"
	OrderExchangePaymentStatusRefunded            OrderExchangePaymentStatus = "refunded"
	OrderExchangePaymentStatusRequiresAction      OrderExchangePaymentStatus = "requires_action"
)

// Defines values for OrderTransactionReference.
const (
	OrderTransactionReferenceCapture OrderTransactionReference = "capture"
	OrderTransactionReferenceRefund  OrderTransactionReference = "refund"
)

// Defines values for ReturnStatus.
const (
	ReturnStatusCanceled          ReturnStatus = "canceled"
	ReturnStatusPartiallyReceived ReturnStatus = "partially_received"
	ReturnStatusReceived          ReturnStatus = "received"
	ReturnStatusRequested         ReturnStatus = "requested"
)

// Defines values for StoreOrderFulfillmentStatus.
const (
	StoreOrderFulfillmentStatusCanceled           StoreOrderFulfillmentStatus = "canceled"
	StoreOrderFulfillmentStatusDelivered          StoreOrderFulfillmentStatus = "delivered"
	StoreOrderFulfillmentStatusFulfilled          StoreOrderFulfillmentStatus = "fulfilled"
	StoreOrderFulfillmentStatusNotFulfilled       StoreOrderFulfillmentStatus = "not_fulfilled"
	StoreOrderFulfillmentStatusPartiallyDelivered StoreOrderFulfillmentStatus = "partially_delivered"
	StoreOrderFulfillmentStatusPartiallyFulfilled StoreOrderFulfillmentStatus = "partially_fulfilled"
	StoreOrderFulfillmentStatusPartiallyShipped   StoreOrderFulfillmentStatus = "partially_shipped"
	StoreOrderFulfillmentStatusShipped            StoreOrderFulfillmentStatus = "shipped"
)

// Defines values for StoreOrderPaymentStatus.
const (
	StoreOrderPaymentStatusAuthorized          StoreOrderPaymentStatus = "authorized"
	StoreOrderPaymentStatusAwaiting            StoreOrderPaymentStatus = "awaiting"
	StoreOrderPaymentStatusCanceled            StoreOrderPaymentStatus = "canceled"
	StoreOrderPaymentStatusCaptured            StoreOrderPaymentStatus = "captured"
	StoreOrderPaymentStatusNotPaid             StoreOrderPaymentStatus = "not_paid"
	StoreOrderPaymentStatusPartiallyAuthorized StoreOrderPaymentStatus = "partially_authorized"
	StoreOrderPaymentStatusPartiallyCaptured   StoreOrderPaymentStatus = "partially_captured"
	StoreOrderPaymentStatusPartiallyRefunded   StoreOrderPaymentStatus = "partially_refunded"
	StoreOrderPaymentStatusRefunded            StoreOrderPaymentStatus = "refunded"
	StoreOrderPaymentStatusRequiresAction      StoreOrderPaymentStatus = "requires_action"
)

// Defines values for StorePaymentCollectionStatus.
const (
	StorePaymentCollectionStatusAuthorized          StorePaymentCollectionStatus = "authorized"
	StorePaymentCollectionStatusAwaiting            StorePaymentCollectionStatus = "awaiting"
	StorePaymentCollectionStatusCanceled            StorePaymentCollectionStatus = "canceled"
	StorePaymentCollectionStatusNotPaid             StorePaymentCollectionStatus = "not_paid"
	StorePaymentCollectionStatusPartiallyAuthorized StorePaymentCollectionStatus = "partially_authorized"
)

// Defines values for StorePaymentSessionStatus.
const (
	StorePaymentSessionStatusAuthorized   StorePaymentSessionStatus = "authorized"
	StorePaymentSessionStatusCanceled     StorePaymentSessionStatus = "canceled"
	StorePaymentSessionStatusCaptured     StorePaymentSessionStatus = "captured"
	StorePaymentSessionStatusError        StorePaymentSessionStatus = "error"
	StorePaymentSessionStatusPending      StorePaymentSessionStatus = "pending"
	StorePaymentSessionStatusRequiresMore StorePaymentSessionStatus = "requires_more"
)

// Defines values for StoreProductStatus.
const (
	StoreProductStatusDraft     StoreProductStatus = "draft"
	StoreProductStatusProposed  StoreProductStatus = "proposed"
	StoreProductStatusPublished StoreProductStatus = "published"
	StoreProductStatusRejected  StoreProductStatus = "rejected"
)

// Defines values for StoreShippingOptionPriceType.
const (
	StoreShippingOptionPriceTypeCalculated StoreShippingOptionPriceType = "calculated"
	StoreShippingOptionPriceTypeFlat       StoreShippingOptionPriceType = "flat"
)

// Defines values for GetApiKeysParamsType.
const (
	GetApiKeysParamsTypePublishable GetApiKeysParamsType = "publishable"
	GetApiKeysParamsTypeSecret      GetApiKeysParamsType = "secret"
)

// Defines values for PostCampaignsJSONBodyBudgetType.
const (
	PostCampaignsJSONBodyBudgetTypeSpend PostCampaignsJSONBodyBudgetType = "spend"
	PostCampaignsJSONBodyBudgetTypeUsage PostCampaignsJSONBodyBudgetType = "usage"
)

// Defines values for GetDraftOrdersParamsFulfillmentStatus.
const (
	GetDraftOrdersParamsFulfillmentStatusCanceled           GetDraftOrdersParamsFulfillmentStatus = "canceled"
	GetDraftOrdersParamsFulfillmentStatusDelivered          GetDraftOrdersParamsFulfillmentStatus = "delivered"
	GetDraftOrdersParamsFulfillmentStatusFulfilled          GetDraftOrdersParamsFulfillmentStatus = "fulfilled"
	GetDraftOrdersParamsFulfillmentStatusNotFulfilled       GetDraftOrdersParamsFulfillmentStatus = "not_fulfilled"
	GetDraftOrdersParamsFulfillmentStatusPartiallyDelivered GetDraftOrdersParamsFulfillmentStatus = "partially_delivered"
	GetDraftOrdersParamsFulfillmentStatusPartiallyFulfilled GetDraftOrdersParamsFulfillmentStatus = "partially_fulfilled"
	GetDraftOrdersParamsFulfillmentStatusPartiallyShipped   GetDraftOrdersParamsFulfillmentStatus = "partially_shipped"
	GetDraftOrdersParamsFulfillmentStatusShipped            GetDraftOrdersParamsFulfillmentStatus = "shipped"
)

// Defines values for GetDraftOrdersParamsPaymentStatus.
const (
	GetDraftOrdersParamsPaymentStatusAuthorized          GetDraftOrdersParamsPaymentStatus = "authorized"
	GetDraftOrdersParamsPaymentStatusAwaiting            GetDraftOrdersParamsPaymentStatus = "awaiting"
	GetDraftOrdersParamsPaymentStatusCanceled            GetDraftOrdersParamsPaymentStatus = "canceled"
	GetDraftOrdersParamsPaymentStatusCaptured            GetDraftOrdersParamsPaymentStatus = "captured"
	GetDraftOrdersParamsPaymentStatusNotPaid             GetDraftOrdersParamsPaymentStatus = "not_paid"
	GetDraftOrdersParamsPaymentStatusPartiallyAuthorized GetDraftOrdersParamsPaymentStatus = "partially_authorized"
	GetDraftOrdersParamsPaymentStatusPartiallyCaptured   GetDraftOrdersParamsPaymentStatus = "partially_captured"
	GetDraftOrdersParamsPaymentStatusPartiallyRefunded   GetDraftOrdersParamsPaymentStatus = "partially_refunded"
	GetDraftOrdersParamsPaymentStatusRefunded            GetDraftOrdersParamsPaymentStatus = "refunded"
	GetDraftOrdersParamsPaymentStatusRequiresAction      GetDraftOrdersParamsPaymentStatus = "requires_action"
)

// Defines values for PostDraftOrdersJSONBodyStatus.
const (
	Completed PostDraftOrdersJSONBodyStatus = "completed"
)

// Defines values for GetOrdersParamsFulfillmentStatus.
const (
	GetOrdersParamsFulfillmentStatusCanceled           GetOrdersParamsFulfillmentStatus = "canceled"
	GetOrdersParamsFulfillmentStatusDelivered          GetOrdersParamsFulfillmentStatus = "delivered"
	GetOrdersParamsFulfillmentStatusFulfilled          GetOrdersParamsFulfillmentStatus = "fulfilled"
	GetOrdersParamsFulfillmentStatusNotFulfilled       GetOrdersParamsFulfillmentStatus = "not_fulfilled"
	GetOrdersParamsFulfillmentStatusPartiallyDelivered GetOrdersParamsFulfillmentStatus = "partially_delivered"
	GetOrdersParamsFulfillmentStatusPartiallyFulfilled GetOrdersParamsFulfillmentStatus = "partially_fulfilled"
	GetOrdersParamsFulfillmentStatusPartiallyShipped   GetOrdersParamsFulfillmentStatus = "partially_shipped"
	GetOrdersParamsFulfillmentStatusShipped            GetOrdersParamsFulfillmentStatus = "shipped"
)

// Defines values for GetOrdersParamsPaymentStatus.
const (
	GetOrdersParamsPaymentStatusAuthorized          GetOrdersParamsPaymentStatus = "authorized"
	GetOrdersParamsPaymentStatusAwaiting            GetOrdersParamsPaymentStatus = "awaiting"
	GetOrdersParamsPaymentStatusCanceled            GetOrdersParamsPaymentStatus = "canceled"
	GetOrdersParamsPaymentStatusCaptured            GetOrdersParamsPaymentStatus = "captured"
	GetOrdersParamsPaymentStatusNotPaid             GetOrdersParamsPaymentStatus = "not_paid"
	GetOrdersParamsPaymentStatusPartiallyAuthorized GetOrdersParamsPaymentStatus = "partially_authorized"
	GetOrdersParamsPaymentStatusPartiallyCaptured   GetOrdersParamsPaymentStatus = "partially_captured"
	GetOrdersParamsPaymentStatusPartiallyRefunded   GetOrdersParamsPaymentStatus = "partially_refunded"
	GetOrdersParamsPaymentStatusRefunded            GetOrdersParamsPaymentStatus = "refunded"
	GetOrdersParamsPaymentStatusRequiresAction      GetOrdersParamsPaymentStatus = "requires_action"
)

// Defines values for GetPriceListsParamsStatus.
const (
	GetPriceListsParamsStatusActive GetPriceListsParamsStatus = "active"
	GetPriceListsParamsStatusDraft  GetPriceListsParamsStatus = "draft"
)

// Defines values for PostProductsJSONBodyStatus.
const (
	PostProductsJSONBodyStatusDraft     PostProductsJSONBodyStatus = "draft"
	PostProductsJSONBodyStatusProposed  PostProductsJSONBodyStatus = "proposed"
	PostProductsJSONBodyStatusPublished PostProductsJSONBodyStatus = "published"
	PostProductsJSONBodyStatusRejected  PostProductsJSONBodyStatus = "rejected"
)

// Defines values for PostProductsIdJSONBodyStatus.
const (
	PostProductsIdJSONBodyStatusDraft     PostProductsIdJSONBodyStatus = "draft"
	PostProductsIdJSONBodyStatusProposed  PostProductsIdJSONBodyStatus = "proposed"
	PostProductsIdJSONBodyStatusPublished PostProductsIdJSONBodyStatus = "published"
	PostProductsIdJSONBodyStatusRejected  PostProductsIdJSONBodyStatus = "rejected"
)

// Defines values for PostPromotionsJSONBodyApplicationMethodAllocation.
const (
	PostPromotionsJSONBodyApplicationMethodAllocationAcross PostPromotionsJSONBodyApplicationMethodAllocation = "across"
	PostPromotionsJSONBodyApplicationMethodAllocationEach   PostPromotionsJSONBodyApplicationMethodAllocation = "each"
)

// Defines values for PostPromotionsJSONBodyApplicationMethodBuyRulesOperator.
const (
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorEq  PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "eq"
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorGt  PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "gt"
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorGte PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "gte"
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorIn  PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "in"
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorLt  PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "lt"
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorLte PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "lte"
	PostPromotionsJSONBodyApplicationMethodBuyRulesOperatorNe  PostPromotionsJSONBodyApplicationMethodBuyRulesOperator = "ne"
)

// Defines values for PostPromotionsJSONBodyApplicationMethodTargetRulesOperator.
const (
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorEq  PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "eq"
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorGt  PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "gt"
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorGte PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "gte"
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorIn  PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "in"
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorLt  PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "lt"
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorLte PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "lte"
	PostPromotionsJSONBodyApplicationMethodTargetRulesOperatorNe  PostPromotionsJSONBodyApplicationMethodTargetRulesOperator = "ne"
)

// Defines values for PostPromotionsJSONBodyApplicationMethodTargetType.
const (
	PostPromotionsJSONBodyApplicationMethodTargetTypeItems           PostPromotionsJSONBodyApplicationMethodTargetType = "items"
	PostPromotionsJSONBodyApplicationMethodTargetTypeOrder           PostPromotionsJSONBodyApplicationMethodTargetType = "order"
	PostPromotionsJSONBodyApplicationMethodTargetTypeShippingMethods PostPromotionsJSONBodyApplicationMethodTargetType = "shipping_methods"
)

// Defines values for PostPromotionsJSONBodyApplicationMethodType.
const (
	PostPromotionsJSONBodyApplicationMethodTypeFixed      PostPromotionsJSONBodyApplicationMethodType = "fixed"
	PostPromotionsJSONBodyApplicationMethodTypePercentage PostPromotionsJSONBodyApplicationMethodType = "percentage"
)

// Defines values for PostPromotionsJSONBodyCampaignBudgetType.
const (
	PostPromotionsJSONBodyCampaignBudgetTypeSpend PostPromotionsJSONBodyCampaignBudgetType = "spend"
	PostPromotionsJSONBodyCampaignBudgetTypeUsage PostPromotionsJSONBodyCampaignBudgetType = "usage"
)

// Defines values for PostPromotionsJSONBodyRulesOperator.
const (
	Eq  PostPromotionsJSONBodyRulesOperator = "eq"
	Gt  PostPromotionsJSONBodyRulesOperator = "gt"
	Gte PostPromotionsJSONBodyRulesOperator = "gte"
	In  PostPromotionsJSONBodyRulesOperator = "in"
	Lt  PostPromotionsJSONBodyRulesOperator = "lt"
	Lte PostPromotionsJSONBodyRulesOperator = "lte"
	Ne  PostPromotionsJSONBodyRulesOperator = "ne"
)

// Defines values for PostPromotionsJSONBodyType.
const (
	PostPromotionsJSONBodyTypeBuyget   PostPromotionsJSONBodyType = "buyget"
	PostPromotionsJSONBodyTypeStandard PostPromotionsJSONBodyType = "standard"
)

// Defines values for GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionType.
const (
	GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionTypeBuyget   GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionType = "buyget"
	GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionTypeStandard GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionType = "standard"
)

// Defines values for GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodType.
const (
	GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodTypeFixed      GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodType = "fixed"
	GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodTypePercentage GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodType = "percentage"
)

// Defines values for GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType.
const (
	GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleTypeBuyRules    GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType = "buy-rules"
	GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleTypeRules       GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType = "rules"
	GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleTypeTargetRules GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType = "target-rules"
)

// Defines values for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionType.
const (
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionTypeBuyget   GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionType = "buyget"
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionTypeStandard GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionType = "standard"
)

// Defines values for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodType.
const (
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodTypeFixed      GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodType = "fixed"
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodTypePercentage GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodType = "percentage"
)

// Defines values for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType.
const (
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleTypeBuyRules    GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType = "buy-rules"
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleTypeRules       GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType = "rules"
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleTypeTargetRules GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType = "target-rules"
)

// Defines values for PostPromotionsIdJSONBodyApplicationMethodAllocation.
const (
	Across PostPromotionsIdJSONBodyApplicationMethodAllocation = "across"
	Each   PostPromotionsIdJSONBodyApplicationMethodAllocation = "each"
)

// Defines values for PostPromotionsIdJSONBodyApplicationMethodTargetType.
const (
	PostPromotionsIdJSONBodyApplicationMethodTargetTypeItems           PostPromotionsIdJSONBodyApplicationMethodTargetType = "items"
	PostPromotionsIdJSONBodyApplicationMethodTargetTypeOrder           PostPromotionsIdJSONBodyApplicationMethodTargetType = "order"
	PostPromotionsIdJSONBodyApplicationMethodTargetTypeShippingMethods PostPromotionsIdJSONBodyApplicationMethodTargetType = "shipping_methods"
)

// Defines values for PostPromotionsIdJSONBodyApplicationMethodType.
const (
	Fixed      PostPromotionsIdJSONBodyApplicationMethodType = "fixed"
	Percentage PostPromotionsIdJSONBodyApplicationMethodType = "percentage"
)

// Defines values for PostPromotionsIdJSONBodyType.
const (
	Buyget   PostPromotionsIdJSONBodyType = "buyget"
	Standard PostPromotionsIdJSONBodyType = "standard"
)

// Defines values for GetPromotionsIdRuleTypeParamsRuleType.
const (
	BuyRules    GetPromotionsIdRuleTypeParamsRuleType = "buy-rules"
	Rules       GetPromotionsIdRuleTypeParamsRuleType = "rules"
	TargetRules GetPromotionsIdRuleTypeParamsRuleType = "target-rules"
)

// Defines values for GetReturnsParamsFulfillmentStatus.
const (
	GetReturnsParamsFulfillmentStatusCanceled           GetReturnsParamsFulfillmentStatus = "canceled"
	GetReturnsParamsFulfillmentStatusDelivered          GetReturnsParamsFulfillmentStatus = "delivered"
	GetReturnsParamsFulfillmentStatusFulfilled          GetReturnsParamsFulfillmentStatus = "fulfilled"
	GetReturnsParamsFulfillmentStatusNotFulfilled       GetReturnsParamsFulfillmentStatus = "not_fulfilled"
	GetReturnsParamsFulfillmentStatusPartiallyDelivered GetReturnsParamsFulfillmentStatus = "partially_delivered"
	GetReturnsParamsFulfillmentStatusPartiallyFulfilled GetReturnsParamsFulfillmentStatus = "partially_fulfilled"
	GetReturnsParamsFulfillmentStatusPartiallyShipped   GetReturnsParamsFulfillmentStatus = "partially_shipped"
	GetReturnsParamsFulfillmentStatusShipped            GetReturnsParamsFulfillmentStatus = "shipped"
)

// Defines values for GetReturnsParamsPaymentStatus.
const (
	GetReturnsParamsPaymentStatusAuthorized          GetReturnsParamsPaymentStatus = "authorized"
	GetReturnsParamsPaymentStatusAwaiting            GetReturnsParamsPaymentStatus = "awaiting"
	GetReturnsParamsPaymentStatusCanceled            GetReturnsParamsPaymentStatus = "canceled"
	GetReturnsParamsPaymentStatusCaptured            GetReturnsParamsPaymentStatus = "captured"
	GetReturnsParamsPaymentStatusNotPaid             GetReturnsParamsPaymentStatus = "not_paid"
	GetReturnsParamsPaymentStatusPartiallyAuthorized GetReturnsParamsPaymentStatus = "partially_authorized"
	GetReturnsParamsPaymentStatusPartiallyCaptured   GetReturnsParamsPaymentStatus = "partially_captured"
	GetReturnsParamsPaymentStatusPartiallyRefunded   GetReturnsParamsPaymentStatus = "partially_refunded"
	GetReturnsParamsPaymentStatusRefunded            GetReturnsParamsPaymentStatus = "refunded"
	GetReturnsParamsPaymentStatusRequiresAction      GetReturnsParamsPaymentStatus = "requires_action"
)

// Defines values for PostShippingOptionsIdJSONBodyPriceType.
const (
	Calculated PostShippingOptionsIdJSONBodyPriceType = "calculated"
	Flat       PostShippingOptionsIdJSONBodyPriceType = "flat"
)

// Defines values for GetTaxRatesParamsIsDefault.
const (
	False GetTaxRatesParamsIsDefault = "false"
	True  GetTaxRatesParamsIsDefault = "true"
)

// AdminApiKey The API key's details.
type AdminApiKey struct {
	// CreatedAt The date and time the API key was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the API key, if available.
	CreatedBy string `json:"created_by"`

	// Id The api key's ID.
	Id string `json:"id"`

	// LastUsedAt The date and time the API key was last used.
	LastUsedAt time.Time `json:"last_used_at"`

	// Redacted The redacted form of the API key's token. This is useful when showing portion of the token.
	Redacted string `json:"redacted"`

	// RevokedAt The date and time the API key was revoked. The API key is considered revoked when this property is set.
	RevokedAt time.Time `json:"revoked_at"`

	// RevokedBy The ID of the user that revoked the API key, if available.
	RevokedBy string `json:"revoked_by"`

	// Title The api key's title.
	Title string `json:"title"`

	// Token The api key's token.
	Token string `json:"token"`

	// Type The api key's type. `secret` is used for a user's API key, whereas `publishable` is used for Publishable API keys.
	Type AdminApiKeyType `json:"type"`
}

// AdminApiKeyType The api key's type. `secret` is used for a user's API key, whereas `publishable` is used for Publishable API keys.
type AdminApiKeyType string

// AdminApiKeyResponse The API key's details.
type AdminApiKeyResponse struct {
	// ApiKey The API key's details.
	ApiKey AdminApiKey `json:"api_key"`
}

// AdminApplicationMethod The application method's details.
type AdminApplicationMethod struct {
	// Allocation How is the promotion amount discounted. `each` means the discounted amount is applied on each applicable item; `across` means the discounted amount is split accross the applicable items.
	Allocation *AdminApplicationMethodAllocation `json:"allocation,omitempty"`

	// ApplyToQuantity The quantity that results from matching the `buyget` promotion's condition. For example, if the promotion is a "Buy 2 shirts get 1 free", the value of this attribute is `1`.
	ApplyToQuantity *float32 `json:"apply_to_quantity,omitempty"`

	// BuyRules The application method's buy rules.
	BuyRules *[]AdminPromotionRule `json:"buy_rules,omitempty"`

	// BuyRulesMinQuantity The minimum quantity required for a `buyget` promotion to be applied. For example, if the promotion is a "Buy 2 shirts get 1 free", the value of this attribute is `2`.
	BuyRulesMinQuantity *float32 `json:"buy_rules_min_quantity,omitempty"`

	// CurrencyCode The application method's currency code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// Id The application method's ID.
	Id string `json:"id"`

	// MaxQuantity The max quantity allowed in the cart for the associated promotion to be applied.
	MaxQuantity *float32 `json:"max_quantity,omitempty"`

	// Promotion The promotion's details.
	Promotion *AdminPromotion `json:"promotion,omitempty"`

	// TargetRules The application method's target rules.
	TargetRules *[]AdminPromotionRule `json:"target_rules,omitempty"`

	// TargetType Which item does the promotion apply to. `items` mean the promotion applies to the cart's items; `shipping_methods` means the promotion applies to the cart's shipping methods; `order` means the promotion applies on the entire order.
	TargetType *AdminApplicationMethodTargetType `json:"target_type,omitempty"`

	// Type The application method's type. If it's `fixed`, the promotion discounts a fixed amount. If it's `percentage`, the promotion discounts a percentage.
	Type *AdminApplicationMethodType `json:"type,omitempty"`

	// Value The amount to be discounted.
	Value *float32 `json:"value,omitempty"`
}

// AdminApplicationMethodAllocation How is the promotion amount discounted. `each` means the discounted amount is applied on each applicable item; `across` means the discounted amount is split accross the applicable items.
type AdminApplicationMethodAllocation string

// AdminApplicationMethodTargetType Which item does the promotion apply to. `items` mean the promotion applies to the cart's items; `shipping_methods` means the promotion applies to the cart's shipping methods; `order` means the promotion applies on the entire order.
type AdminApplicationMethodTargetType string

// AdminApplicationMethodType The application method's type. If it's `fixed`, the promotion discounts a fixed amount. If it's `percentage`, the promotion discounts a percentage.
type AdminApplicationMethodType string

// AdminBatchProductRequest The products to create, update, or delete.
type AdminBatchProductRequest struct {
	// Create The products to create.
	Create *[]AdminCreateProduct `json:"create,omitempty"`

	// Delete The products to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The products to update.
	Update *[]AdminUpdateProduct `json:"update,omitempty"`
}

// AdminBatchProductResponse The details of the products created, updated, or deleted.
type AdminBatchProductResponse struct {
	// Created The created products
	Created []AdminProduct `json:"created"`

	// Deleted The deleted products' details.
	Deleted struct {
		// Deleted Whether the products were deleted.
		Deleted bool `json:"deleted"`

		// Ids The IDs of deleted products.
		Ids []string `json:"ids"`

		// Object The name of the deleted objects.
		Object string `json:"object"`
	} `json:"deleted"`

	// Updated The updated products.
	Updated []AdminProduct `json:"updated"`
}

// AdminBatchProductVariantRequest The product variants to create, update, or delete.
type AdminBatchProductVariantRequest struct {
	// Create The product variants to create.
	Create *[]AdminCreateProductVariant `json:"create,omitempty"`

	// Delete The product variants to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The product variants to update.
	Update *[]AdminUpdateProductVariant `json:"update,omitempty"`
}

// AdminBatchProductVariantResponse The details of the product variants created, updated, or deleted.
type AdminBatchProductVariantResponse struct {
	// Created The created product variants.
	Created []AdminProductVariant `json:"created"`

	// Deleted The details of the deleted product variants.
	Deleted struct {
		// Deleted Whether the product variants were deleted.
		Deleted bool `json:"deleted"`

		// Ids The IDs of the deleted product variants.
		Ids []string `json:"ids"`

		// Object The name of the deleted objects.
		Object string `json:"object"`
	} `json:"deleted"`

	// Updated The updated product variants.
	Updated []AdminProductVariant `json:"updated"`
}

// AdminCampaign The campaign's details.
type AdminCampaign struct {
	// Budget The campaign's budget.
	Budget struct {
		// CurrencyCode The budget's currency code.
		CurrencyCode string `json:"currency_code"`

		// Id The budget's ID.
		Id string `json:"id"`

		// Limit The budget's limit.
		Limit float32 `json:"limit"`

		// Type The budget's type. `spend` means the limit is set on the total amount discounted by the campaign's promotions; `usage` means the limit is set on the total number of times the campaign's promotions can be used.
		Type AdminCampaignBudgetType `json:"type"`

		// Used How much of the budget has been used. If the limit is `spend`, this property holds the total amount discounted so far. If the limit is `usage`, it holds the number of times the campaign's promotions have been used so far.
		Used float32 `json:"used"`
	} `json:"budget"`

	// CampaignIdentifier The campaign's identifier.
	CampaignIdentifier string `json:"campaign_identifier"`

	// Currency The campaign's currency.
	Currency string `json:"currency"`

	// Description The campaign's description.
	Description string `json:"description"`

	// EndsAt The date and time that the campaign ends.
	EndsAt string `json:"ends_at"`

	// Id The campaign's ID.
	Id string `json:"id"`

	// Name The campaign's name.
	Name string `json:"name"`

	// StartsAt The date and time that the campaign starts.
	StartsAt string `json:"starts_at"`
}

// AdminCampaignBudgetType The budget's type. `spend` means the limit is set on the total amount discounted by the campaign's promotions; `usage` means the limit is set on the total number of times the campaign's promotions can be used.
type AdminCampaignBudgetType string

// AdminCampaignResponse The campaign's details.
type AdminCampaignResponse struct {
	// Campaign The campaign's details.
	Campaign AdminCampaign `json:"campaign"`
}

// AdminClaim The claim's details.
type AdminClaim struct {
	// AdditionalItems The outbound or new items of the claim.
	AdditionalItems []BaseClaimItem `json:"additional_items"`

	// CanceledAt The date the claim was canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// ClaimItems The order items targetted by the claim.
	ClaimItems []BaseClaimItem `json:"claim_items"`

	// CreatedAt The claim's creation date.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the claim.
	CreatedBy *string `json:"created_by,omitempty"`

	// DeletedAt The date the claim was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// DisplayId The claim's display ID.
	DisplayId float32 `json:"display_id"`

	// Id The claim's ID.
	Id string `json:"id"`

	// Metadata The claim's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification Whether the customer should be notified about changes in the claim.
	NoNotification *bool `json:"no_notification,omitempty"`

	// Order The order's details.
	Order AdminOrder `json:"order"`

	// OrderId The ID of the order associated with the claim.
	OrderId string `json:"order_id"`

	// OrderVersion The version of the order when the claim is applied.
	OrderVersion string `json:"order_version"`

	// RefundAmount The amount to be refunded.
	RefundAmount *float32 `json:"refund_amount,omitempty"`

	// Return The return's details.
	Return AdminReturn `json:"return"`

	// ReturnId The ID of the associated return.
	ReturnId *string `json:"return_id,omitempty"`

	// ShippingMethods The claim's shipping methods.
	ShippingMethods *[]AdminOrderShippingMethod `json:"shipping_methods,omitempty"`

	// Transactions The claim's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// Type The claim's type.
	Type AdminClaimType `json:"type"`

	// UpdatedAt The claim's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminClaimType The claim's type.
type AdminClaimType string

// AdminClaimDeleteResponse The details of the deleted claim.
type AdminClaimDeleteResponse struct {
	// Deleted Whether the claim was deleted.
	Deleted bool `json:"deleted"`

	// Id The claim's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminClaimListResponse The paginated list of claims.
type AdminClaimListResponse struct {
	// Claims The list of claims.
	Claims []AdminClaim `json:"claims"`

	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`
}

// AdminClaimOrderResponse The created claim's details.
type AdminClaimOrderResponse struct {
	// Claim The claim's details.
	Claim AdminClaim `json:"claim"`

	// Order The order change's order.
	Order Order `json:"order"`
}

// AdminClaimPreviewResponse The details of the claim, as well as a preview of the order when the claim is applied.
type AdminClaimPreviewResponse struct {
	// Claim The claim's details.
	Claim AdminClaim `json:"claim"`

	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`
}

// AdminClaimRequestResponse The details of the claim, its return, and a preview of the order when the claim is applied.
type AdminClaimRequestResponse struct {
	// Claim The claim's details.
	Claim AdminClaim `json:"claim"`

	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`

	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminClaimResponse The claim's details.
type AdminClaimResponse struct {
	// Claim The claim's details.
	Claim AdminClaim `json:"claim"`
}

// AdminClaimReturnPreviewResponse The details of the claim's return, with a preview of the order when the claim's return is applied.
type AdminClaimReturnPreviewResponse struct {
	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`

	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminCollection The product collection's details.
type AdminCollection struct {
	// CreatedAt The collection's creation date.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The collection's deletion date.
	DeletedAt time.Time `json:"deleted_at"`

	// Handle The collection's handle.
	Handle string `json:"handle"`

	// Id The collection's ID.
	Id string `json:"id"`

	// Metadata The collection's metadata, used to store custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Products The collection's products.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// Title The collection's title.
	Title string `json:"title"`

	// UpdatedAt The collection's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminCollectionDeleteResponse The details of the deleted collection.
type AdminCollectionDeleteResponse struct {
	// Deleted Whether the collection was deleted.
	Deleted bool `json:"deleted"`

	// Id The collection's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminCollectionListResponse The paginated list of product collections.
type AdminCollectionListResponse struct {
	// Collections The list of product collections.
	Collections []AdminCollection `json:"collections"`

	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned results.
	Offset float32 `json:"offset"`
}

// AdminCollectionResponse The collection's details.
type AdminCollectionResponse struct {
	// Collection The product collection's details.
	Collection AdminCollection `json:"collection"`
}

// AdminCreateApiKey The API key's details.
type AdminCreateApiKey struct {
	// Title The API key's title.
	Title string `json:"title"`

	// Type The API key's type. Use `secret` for a user's API key; Use `publishable` for Publishable API keys.
	Type AdminCreateApiKeyType `json:"type"`
}

// AdminCreateApiKeyType The API key's type. Use `secret` for a user's API key; Use `publishable` for Publishable API keys.
type AdminCreateApiKeyType string

// AdminCreateCollection the product collection's details.
type AdminCreateCollection struct {
	// Handle The collection's handle.
	Handle *string `json:"handle,omitempty"`

	// Metadata The collection's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Title The collection's title.
	Title string `json:"title"`
}

// AdminCreateCustomerGroup The customer group's details.
type AdminCreateCustomerGroup struct {
	// Metadata The customer group's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The customer group's name.
	Name string `json:"name"`
}

// AdminCreateFulfillment The filfillment's details.
type AdminCreateFulfillment struct {
	// CanceledAt The date and time the fulfillment was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// Data Any data useful for the fulfillment provider to handle the fulfillment.
	Data map[string]interface{} `json:"data"`

	// DeliveredAt The date and time the fulfillment was delivered.
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`

	// DeliveryAddress The address to deliver the items to.
	DeliveryAddress struct {
		// Address1 The delivery address's first line.
		Address1 *string `json:"address_1,omitempty"`

		// Address2 The delivery address's second line.
		Address2 *string `json:"address_2,omitempty"`

		// City The delivery address's city.
		City *string `json:"city,omitempty"`

		// Company The delivery address's company.
		Company *string `json:"company,omitempty"`

		// CountryCode The delivery address's country code.
		CountryCode *string `json:"country_code,omitempty"`

		// FirstName The customer's first name.
		FirstName *string `json:"first_name,omitempty"`

		// LastName The customer's last name.
		LastName *string `json:"last_name,omitempty"`

		// Metadata The delivery address's metadata, used to store custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Phone The customer's phone.
		Phone *string `json:"phone,omitempty"`

		// PostalCode The delivery address's postal code.
		PostalCode *string `json:"postal_code,omitempty"`

		// Province The delivery address's province.
		Province *string `json:"province,omitempty"`
	} `json:"delivery_address"`

	// Items The items to fulfill.
	Items []struct {
		// Barcode The item's barcode.
		Barcode string `json:"barcode"`

		// InventoryItemId The ID of the inventory item associated with the underlying variant.
		InventoryItemId *string `json:"inventory_item_id,omitempty"`

		// LineItemId The ID of the associated line item.
		LineItemId *string `json:"line_item_id,omitempty"`

		// Quantity The quantity to fulfill of the item.
		Quantity float32 `json:"quantity"`

		// Sku The item's SKU.
		Sku string `json:"sku"`

		// Title The item's title.
		Title string `json:"title"`
	} `json:"items"`

	// Labels The labels for the fulfillment's shipments.
	Labels []struct {
		// LabelUrl The label's URL.
		LabelUrl string `json:"label_url"`

		// TrackingNumber The label's tracking number.
		TrackingNumber string `json:"tracking_number"`

		// TrackingUrl The label's tracking URL.
		TrackingUrl string `json:"tracking_url"`
	} `json:"labels"`

	// LocationId The ID of the location the items are fulfilled from.
	LocationId string `json:"location_id"`

	// Metadata The fulfillment's metadata, used to store custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OrderId The ID of the order this fulfillment is created for.
	OrderId string `json:"order_id"`

	// PackedAt The date and time the fulfillment was packed.
	PackedAt *time.Time `json:"packed_at,omitempty"`

	// ProviderId The ID of the provider handling this fulfillment.
	ProviderId string `json:"provider_id"`

	// ShippedAt The date and time the fulfillment was shipped.
	ShippedAt *time.Time `json:"shipped_at,omitempty"`

	// ShippingOptionId The ID of the shipping option used in the order.
	ShippingOptionId *string `json:"shipping_option_id,omitempty"`
}

// AdminCreateInventoryItem The inventory item's details.
type AdminCreateInventoryItem struct {
	// Description The description of the variant associated with the inventory item.
	Description *string `json:"description,omitempty"`

	// Height The inventory item's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The inventory item's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Length The inventory item's length.
	Length *float32 `json:"length,omitempty"`

	// Material The inventory item's material.
	Material *string `json:"material,omitempty"`

	// Metadata The inventory item's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The inventory item's mid code.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The inventory item's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping *bool `json:"requires_shipping,omitempty"`

	// Sku The inventory item's SKU.
	Sku *string `json:"sku,omitempty"`

	// Thumbnail The inventory item's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The inventory item's title.
	Title *string `json:"title,omitempty"`

	// Weight The inventory item's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The inventory item's width.
	Width *float32 `json:"width,omitempty"`
}

// AdminCreatePriceList The price list's details.
type AdminCreatePriceList struct {
	// Description The price list's description.
	Description string `json:"description"`

	// EndsAt The date and time the price list ends at.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// Prices The price list's prices.
	Prices *[]struct {
		// Amount The price's amount.
		Amount float32 `json:"amount"`

		// CurrencyCode The price's currency code.
		CurrencyCode string `json:"currency_code"`

		// MaxQuantity The maximum quantity in the cart that shouldn't be crossed for this price to be applied.
		MaxQuantity *float32 `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity required in the cart for this price to be applied.
		MinQuantity *float32 `json:"min_quantity,omitempty"`

		// Rules The price's rules.
		Rules *map[string]interface{} `json:"rules,omitempty"`

		// VariantId The ID of the product variant this price is for.
		VariantId string `json:"variant_id"`
	} `json:"prices,omitempty"`

	// Rules The price list's rules.
	Rules *map[string]interface{} `json:"rules,omitempty"`

	// StartsAt The date and time the price list starts at.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// Status The price list's status.
	Status *AdminCreatePriceListStatus `json:"status,omitempty"`

	// Title The price list's title.
	Title string `json:"title"`

	// Type The price list's type.
	Type *AdminCreatePriceListType `json:"type,omitempty"`
}

// AdminCreatePriceListStatus The price list's status.
type AdminCreatePriceListStatus string

// AdminCreatePriceListType The price list's type.
type AdminCreatePriceListType string

// AdminCreatePricePreference The price preference's details.
type AdminCreatePricePreference struct {
	// Attribute The name of the attribute the price preference applies on.
	Attribute *string `json:"attribute,omitempty"`

	// IsTaxInclusive Whether the price is tax inclusive if the value of the specified attribute matches the specified value.
	IsTaxInclusive *bool `json:"is_tax_inclusive,omitempty"`

	// Value The attribute's value.
	Value *string `json:"value,omitempty"`
}

// AdminCreateProduct The product's details.
type AdminCreateProduct struct {
	// Categories The categories the product belongs to.
	Categories *[]struct {
		// Id The category's ID.
		Id string `json:"id"`
	} `json:"categories,omitempty"`

	// CollectionId The ID of the collection the product belongs to.
	CollectionId *string `json:"collection_id,omitempty"`

	// Description The product's description.
	Description *string `json:"description,omitempty"`

	// Discountable Whether the product is discountable.
	Discountable *bool `json:"discountable,omitempty"`

	// Handle The product's handle.
	Handle *string `json:"handle,omitempty"`

	// Height The product's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The product's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Images The product's images.
	Images *[]struct {
		// Url The image's URL.
		Url string `json:"url"`
	} `json:"images,omitempty"`

	// IsGiftcard Whether the product is a gift card.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// Length The product's length.
	Length *float32 `json:"length,omitempty"`

	// Material The product's material.
	Material *string `json:"material,omitempty"`

	// Metadata The product's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The product's options.
	Options *[]AdminCreateProductOption `json:"options,omitempty"`

	// OriginCountry The product's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// SalesChannels The sales channels the product is available in.
	SalesChannels *[]struct {
		// Id The sales channel's ID.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// Status The product's status.
	Status *AdminCreateProductStatus `json:"status,omitempty"`

	// Subtitle The product's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags The product's tags.
	Tags *[]struct {
		// Id The tag's ID.
		Id string `json:"id"`
	} `json:"tags,omitempty"`

	// Thumbnail The URL of the product's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The product's title.
	Title string `json:"title"`

	// TypeId The ID of the type the product belongs to.
	TypeId *string `json:"type_id,omitempty"`

	// Variants The product's variants.
	Variants *[]AdminCreateProductVariant `json:"variants,omitempty"`

	// Weight The product's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The product's width.
	Width *float32 `json:"width,omitempty"`
}

// AdminCreateProductStatus The product's status.
type AdminCreateProductStatus string

// AdminCreateProductCategory The product category's details.
type AdminCreateProductCategory struct {
	// Description The product category's description.
	Description *string `json:"description,omitempty"`

	// Handle The product category's handle.
	Handle *string `json:"handle,omitempty"`

	// IsActive Whether the product category is active.
	IsActive *bool `json:"is_active,omitempty"`

	// IsInternal Whether the product category is only used and seen by admin users.
	IsInternal *bool `json:"is_internal,omitempty"`

	// Metadata The product category's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The product category's name.
	Name string `json:"name"`

	// ParentCategoryId The ID of a category that's the parent of this one.
	ParentCategoryId *string `json:"parent_category_id,omitempty"`

	// Rank The sorting order of the product category among sibling categories.
	Rank *float32 `json:"rank,omitempty"`
}

// AdminCreateProductOption The product option's details.
type AdminCreateProductOption struct {
	// Title The product option's title.
	Title string `json:"title"`

	// Values The product option's values.
	Values []string `json:"values"`
}

// AdminCreateProductTag The product tag's details.
type AdminCreateProductTag struct {
	// Metadata The product tag's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value The product tag's value.
	Value string `json:"value"`
}

// AdminCreateProductType The details of the product type to create.
type AdminCreateProductType struct {
	// Metadata The product's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value The product type's value.
	Value string `json:"value"`
}

// AdminCreateProductVariant The product variant's details.
type AdminCreateProductVariant struct {
	// AllowBackorder Whether it's allowed to order this variant when it's out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode The variant's barcode.
	Barcode *string `json:"barcode,omitempty"`

	// Ean The variant's EAN.
	Ean *string `json:"ean,omitempty"`

	// Height The variant's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The variant's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// InventoryItems The variant's inventory items to create.
	InventoryItems *[]AdminCreateProductVariantInventoryKit `json:"inventory_items,omitempty"`

	// Length The variant's length.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether Medusa manages the variant's inventory quantity. If disabled, the product variant is always considered in stock.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The variant's material.
	Material *string `json:"material,omitempty"`

	// Metadata The variant's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The variant's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The variant's options, where the key is an option's name, and the value is the option's value.
	Options *map[string]interface{} `json:"options,omitempty"`

	// OriginCountry The variant's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Prices The variant's prices.
	Prices []AdminCreateProductVariantPrice `json:"prices"`

	// Sku The variant's SKU.
	Sku *string `json:"sku,omitempty"`

	// Title The variant's title.
	Title string `json:"title"`

	// Upc The variant's UPC.
	Upc *string `json:"upc,omitempty"`

	// VariantRank The sorting order of the variant among other variants in the product.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The variant's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The variant's width.
	Width *float32 `json:"width,omitempty"`
}

// AdminCreateProductVariantInventoryKit The details of a variant's inventory item.
type AdminCreateProductVariantInventoryKit struct {
	// InventoryItemId The inventory item's ID.
	InventoryItemId string `json:"inventory_item_id"`

	// RequiredQuantity The number of units a single quantity is equivalent to. For example, if a customer orders one quantity of the variant, Medusa checks the availability of the quantity multiplied by the value set for `required_quantity`. When the customer orders the quantity, Medusa reserves the ordered quantity multiplied by the value set for `required_quantity`.
	RequiredQuantity *float32 `json:"required_quantity,omitempty"`
}

// AdminCreateProductVariantPrice The details of a variant's price.
type AdminCreateProductVariantPrice struct {
	// Amount The price's amount.
	Amount float32 `json:"amount"`

	// CurrencyCode The price's currency code.
	CurrencyCode string `json:"currency_code"`

	// MaxQuantity The maximum quantity that must not be surpassed in the cart for this price to apply.
	MaxQuantity *float32 `json:"max_quantity,omitempty"`

	// MinQuantity The minimum quantity that must be available in the cart for this price to apply.
	MinQuantity *float32 `json:"min_quantity,omitempty"`

	// Rules The price's rules.
	Rules *struct {
		// RegionId The ID of a region.
		RegionId string `json:"region_id"`
	} `json:"rules,omitempty"`
}

// AdminCreatePromotionRule The promotion rule's details.
type AdminCreatePromotionRule struct {
	// Attribute The attribute to compare against when checking whether a promotion can be applied on a cart.
	Attribute string `json:"attribute"`

	// Description The rule's description.
	Description *string `json:"description,omitempty"`

	// Operator The operator used to check whether the buy rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
	Operator AdminCreatePromotionRuleOperator `json:"operator"`
	Values   AdminCreatePromotionRule_Values  `json:"values"`
}

// AdminCreatePromotionRuleOperator The operator used to check whether the buy rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
type AdminCreatePromotionRuleOperator string

// AdminCreatePromotionRuleValues0 The attribute's value.
type AdminCreatePromotionRuleValues0 = string

// AdminCreatePromotionRuleValues1 The allowed attribute values.
type AdminCreatePromotionRuleValues1 = []string

// AdminCreatePromotionRule_Values defines model for AdminCreatePromotionRule.Values.
type AdminCreatePromotionRule_Values struct {
	union json.RawMessage
}

// AdminCreateRefundReason The refund reason's details.
type AdminCreateRefundReason struct {
	// Description The refund reason's description.
	Description *string `json:"description,omitempty"`

	// Label The refund reason's label.
	Label string `json:"label"`
}

// AdminCreateRegion The region's details.
type AdminCreateRegion struct {
	// AutomaticTaxes Whether taxes are calculated automatically during checkout in this region.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// Countries The region's countries.
	Countries *[]string `json:"countries,omitempty"`

	// CurrencyCode The region's currency code.
	CurrencyCode string `json:"currency_code"`

	// IsTaxInclusive Whether prices in this region are tax inclusive.
	IsTaxInclusive *bool `json:"is_tax_inclusive,omitempty"`

	// Metadata The region's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The region's name.
	Name string `json:"name"`

	// PaymentProviders The payment providers enabled in this region.
	PaymentProviders *[]string `json:"payment_providers,omitempty"`
}

// AdminCreateReservation The reservation's details.
type AdminCreateReservation struct {
	// Description The reservation's description.
	Description *string `json:"description,omitempty"`

	// InventoryItemId The ID of the inventory item associated with the line item's variant.
	InventoryItemId string `json:"inventory_item_id"`

	// LineItemId The ID of the line item this reservation is created for.
	LineItemId *string `json:"line_item_id,omitempty"`

	// LocationId The ID of the location the quantity is reserved from.
	LocationId string `json:"location_id"`

	// Metadata The reservation's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The reserved quantity.
	Quantity float32 `json:"quantity"`
}

// AdminCreateReturnReason The details of the return reason to create.
type AdminCreateReturnReason struct {
	// Description The return reason's description.
	Description *string `json:"description,omitempty"`

	// Label The return reason's label.
	Label string `json:"label"`

	// Metadata The return reason's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ParentReturnReasonId The ID of the parent return reason.
	ParentReturnReasonId *string `json:"parent_return_reason_id,omitempty"`

	// Value The return reason's value.
	Value string `json:"value"`
}

// AdminCreateSalesChannel The sales channel's details.
type AdminCreateSalesChannel struct {
	// Description The sales channel's description.
	Description *string `json:"description,omitempty"`

	// IsDisabled Whether the sales channel is disabled.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Metadata The sales channel's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The sales channel's name.
	Name string `json:"name"`
}

// AdminCreateShipment The shipment's details.
type AdminCreateShipment struct {
	// Labels The shipment's labels.
	Labels []struct {
		// LabelUrl The label's URL.
		LabelUrl string `json:"label_url"`

		// TrackingNumber The label's tracking number.
		TrackingNumber string `json:"tracking_number"`

		// TrackingUrl The label's tracking URL.
		TrackingUrl string `json:"tracking_url"`
	} `json:"labels"`
}

// AdminCreateShippingOption The shipping option's details.
type AdminCreateShippingOption struct {
	// Code The type's code.
	Code string `json:"code"`

	// Description The type's description.
	Description string `json:"description"`

	// Label The type's label.
	Label string `json:"label"`
}

// AdminCreateShippingOptionRule The details of the shipping option rule.
type AdminCreateShippingOptionRule struct {
	// Attribute The name of a property or table that the rule applies to.
	Attribute string `json:"attribute"`

	// Operator The operator used to check whether a rule applies.
	Operator AdminCreateShippingOptionRuleOperator `json:"operator"`
	Value    AdminCreateShippingOptionRule_Value   `json:"value"`
}

// AdminCreateShippingOptionRuleOperator The operator used to check whether a rule applies.
type AdminCreateShippingOptionRuleOperator string

// AdminCreateShippingOptionRuleValue0 A value of the attribute that enables this rule.
type AdminCreateShippingOptionRuleValue0 = string

// AdminCreateShippingOptionRuleValue1 Values of the attribute that enable this rule.
type AdminCreateShippingOptionRuleValue1 = []string

// AdminCreateShippingOptionRule_Value defines model for AdminCreateShippingOptionRule.Value.
type AdminCreateShippingOptionRule_Value struct {
	union json.RawMessage
}

// AdminCreateShippingProfile The shipping profile's details.
type AdminCreateShippingProfile struct {
	// Metadata The shipping profile's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The shipping profile's name.
	Name string `json:"name"`

	// Type The shipping profile's type.
	Type string `json:"type"`
}

// AdminCreateStockLocation The stock location's details.
type AdminCreateStockLocation struct {
	// Address The details of the stock location address to create.
	Address *AdminUpsertStockLocationAddress `json:"address,omitempty"`

	// AddressId The ID of the stock location's address.
	AddressId *string `json:"address_id,omitempty"`

	// Metadata The stock location's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The stock location's name.
	Name string `json:"name"`
}

// AdminCreateTaxRate The tax rate's details.
type AdminCreateTaxRate struct {
	// Code The code the tax rate is identified by.
	Code string `json:"code"`

	// IsCombinable Whether the tax rate should be combined with parent rates.
	IsCombinable *bool `json:"is_combinable,omitempty"`

	// IsDefault Whether the tax rate is the default in its tax region.
	IsDefault *bool `json:"is_default,omitempty"`

	// Metadata The tax rate's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The tax rate's name.
	Name string `json:"name"`

	// Rate The rate to charge.
	Rate *float32 `json:"rate,omitempty"`

	// Rules The tax rate's rules.
	Rules *[]AdminCreateTaxRateRule `json:"rules,omitempty"`

	// TaxRegionId The ID of the tax region this rate belongs to.
	TaxRegionId string `json:"tax_region_id"`
}

// AdminCreateTaxRateRule The tax rate rule's details.
type AdminCreateTaxRateRule struct {
	// Reference The name of a table in the database that this rule points to.
	Reference string `json:"reference"`

	// ReferenceId The ID of a record in the table specified in reference.
	ReferenceId string `json:"reference_id"`
}

// AdminCreateTaxRegion The tax region's details.
type AdminCreateTaxRegion struct {
	// CountryCode The tax region's country code.
	CountryCode string `json:"country_code"`

	// DefaultTaxRate The tax region's default tax rate.
	DefaultTaxRate *struct {
		// Code The code the tax rate is identified by
		Code string `json:"code"`

		// IsCombinable Whether the tax rate should be combined with parent rates.
		IsCombinable *bool `json:"is_combinable,omitempty"`

		// Metadata The default tax rate's metadata, used to store custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Name The default tax rate's name.
		Name string `json:"name"`

		// Rate The rate to charge.
		Rate *float32 `json:"rate,omitempty"`
	} `json:"default_tax_rate,omitempty"`

	// Metadata The tax region's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ParentId The ID of the parent tax region.
	ParentId *string `json:"parent_id,omitempty"`

	// ProvinceCode The tax region's province code.
	ProvinceCode *string `json:"province_code,omitempty"`
}

// AdminCreateVariantInventoryItem The details of the variant-inventory item association.
type AdminCreateVariantInventoryItem struct {
	// InventoryItemId The inventory item's ID.
	InventoryItemId string `json:"inventory_item_id"`

	// RequiredQuantity The quantity of the variant in the inventory item.
	RequiredQuantity float32 `json:"required_quantity"`
}

// AdminCreateWorkflowsAsyncResponse The details of changing a workflow execution's step status.
type AdminCreateWorkflowsAsyncResponse struct {
	// Action Whether to invoke or compensate the step.
	Action *AdminCreateWorkflowsAsyncResponseAction `json:"action,omitempty"`

	// CompensateInput Sets the compensation function's input. It accepts any response.
	CompensateInput *interface{} `json:"compensate_input,omitempty"`

	// Response Sets the step's response. It accepts any type.
	Response *interface{} `json:"response,omitempty"`

	// StepId The ID of the step whose status was changed.
	StepId string `json:"step_id"`

	// TransactionId The workflows execution's transaction ID.
	TransactionId string `json:"transaction_id"`
}

// AdminCreateWorkflowsAsyncResponseAction Whether to invoke or compensate the step.
type AdminCreateWorkflowsAsyncResponseAction string

// AdminCreateWorkflowsRun The details of the workflow to execute.
type AdminCreateWorkflowsRun struct {
	// Input The input to pass to the workflow. Can be of any type.
	Input *interface{} `json:"input,omitempty"`

	// TransactionId The ID of the workflow execution's transaction.
	TransactionId *string `json:"transaction_id,omitempty"`
}

// AdminCurrency The currency's currencies.
type AdminCurrency struct {
	// Code The currency's code.
	Code string `json:"code"`

	// CreatedAt The currency's creation date.
	CreatedAt time.Time `json:"created_at"`

	// DecimalDigits The number of digits after the decimal for prices in this currency.
	DecimalDigits float32 `json:"decimal_digits"`

	// DeletedAt The currency's deletion date.
	DeletedAt time.Time `json:"deleted_at"`

	// Name The currency's name.
	Name string `json:"name"`

	// Rounding The rounding percision applied on prices in this currency.
	Rounding float32 `json:"rounding"`

	// Symbol The currency's symbol.
	Symbol string `json:"symbol"`

	// SymbolNative The currency's native symbol, if different than the symbol.
	SymbolNative string `json:"symbol_native"`

	// UpdatedAt The currency's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminCurrencyListResponse The paginated list of currencies.
type AdminCurrencyListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Currencies The list of currencies.
	Currencies []AdminCurrency `json:"currencies"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`
}

// AdminCurrencyResponse The currency's details.
type AdminCurrencyResponse struct {
	// Currency The currency's currencies.
	Currency AdminCurrency `json:"currency"`
}

// AdminCustomer The customer's details.
type AdminCustomer struct {
	// Addresses The customer's addresses.
	Addresses []AdminCustomerAddress `json:"addresses"`

	// CompanyName The customer's company name.
	CompanyName string `json:"company_name"`

	// CreatedAt The customer's creation date.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatedBy The ID of the user that created this customer, if available.
	CreatedBy *string `json:"created_by,omitempty"`

	// DefaultBillingAddressId The ID of the address used as the default billing address.
	DefaultBillingAddressId string `json:"default_billing_address_id"`

	// DefaultShippingAddressId The ID of the address used as the default shipping address.
	DefaultShippingAddressId string `json:"default_shipping_address_id"`

	// DeletedAt The customer's deletion date.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Email The customer's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// Groups The customer's groups.
	Groups *[]AdminCustomerGroup `json:"groups,omitempty"`

	// HasAccount Whether the customer is registered.
	HasAccount bool `json:"has_account"`

	// Id The customer's ID.
	Id string `json:"id"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata The customer's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The customer's phone.
	Phone *string `json:"phone,omitempty"`

	// UpdatedAt The customer's update date.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AdminCustomerAddress The customer's address.
type AdminCustomerAddress struct {
	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 string `json:"address_2"`

	// AddressName The address's name.
	AddressName string `json:"address_name"`

	// City The address's city.
	City string `json:"city"`

	// Company The customer's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// CreatedAt The address's creation date.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer that this address belongs to.
	CustomerId string `json:"customer_id"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// Id The address's ID.
	Id string `json:"id"`

	// IsDefaultBilling Whether the address is the default billing address.
	IsDefaultBilling bool `json:"is_default_billing"`

	// IsDefaultShipping Whether the address is the default shipping address.
	IsDefaultShipping bool `json:"is_default_shipping"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata The address's metadata, used to store custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`

	// UpdatedAt The address's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminCustomerAddressResponse The address's details.
type AdminCustomerAddressResponse struct {
	// Address The customer's address.
	Address AdminCustomerAddress `json:"address"`
}

// AdminCustomerGroup The customer group's details.
type AdminCustomerGroup struct {
	// CreatedAt The customer group's creation date.
	CreatedAt time.Time `json:"created_at"`

	// Customers The customer group's customers.
	Customers []map[string]interface{} `json:"customers"`

	// Id The customer group's ID.
	Id string `json:"id"`

	// Metadata The customer group's metadata, used to store custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The customer group's name.
	Name string `json:"name"`

	// UpdatedAt The customer group's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminCustomerGroupResponse The customer group's details.
type AdminCustomerGroupResponse struct {
	// CustomerGroup The customer group's details.
	CustomerGroup AdminCustomerGroup `json:"customer_group"`
}

// AdminCustomerInGroupFilters Filters to apply on customers to retrieve their groups.
type AdminCustomerInGroupFilters struct {
	CompanyName *AdminCustomerInGroupFilters_CompanyName `json:"company_name,omitempty"`

	// CreatedAt Filter the customer's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                 `json:"$contains,omitempty"`
		Eq       *AdminCustomerInGroupFilters_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                  `json:"$nin,omitempty"`
		Not *AdminCustomerInGroupFilters_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `json:"created_at,omitempty"`
	CreatedBy                *AdminCustomerInGroupFilters_CreatedBy                `json:"created_by,omitempty"`
	DefaultBillingAddressId  *AdminCustomerInGroupFilters_DefaultBillingAddressId  `json:"default_billing_address_id,omitempty"`
	DefaultShippingAddressId *AdminCustomerInGroupFilters_DefaultShippingAddressId `json:"default_shipping_address_id,omitempty"`

	// DeletedAt Filter the customer's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                 `json:"$contains,omitempty"`
		Eq       *AdminCustomerInGroupFilters_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                  `json:"$nin,omitempty"`
		Not *AdminCustomerInGroupFilters_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `json:"deleted_at,omitempty"`
	Email     *AdminCustomerInGroupFilters_Email     `json:"email,omitempty"`
	FirstName *AdminCustomerInGroupFilters_FirstName `json:"first_name,omitempty"`
	Id        *AdminCustomerInGroupFilters_Id        `json:"id,omitempty"`
	LastName  *AdminCustomerInGroupFilters_LastName  `json:"last_name,omitempty"`

	// UpdatedAt Filter the customer's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                 `json:"$contains,omitempty"`
		Eq       *AdminCustomerInGroupFilters_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                  `json:"$nin,omitempty"`
		Not *AdminCustomerInGroupFilters_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `json:"updated_at,omitempty"`
}

// AdminCustomerInGroupFiltersCompanyName0 Filter by a customer's company name.
type AdminCustomerInGroupFiltersCompanyName0 = string

// AdminCustomerInGroupFiltersCompanyName1 Filter by customers' company names.
type AdminCustomerInGroupFiltersCompanyName1 = []string

// AdminCustomerInGroupFilters_CompanyName defines model for AdminCustomerInGroupFilters.CompanyName.
type AdminCustomerInGroupFilters_CompanyName struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersCreatedAtEq0 Filter by an exact match.
type AdminCustomerInGroupFiltersCreatedAtEq0 = string

// AdminCustomerInGroupFiltersCreatedAtEq1 Filter by exact matches
type AdminCustomerInGroupFiltersCreatedAtEq1 = []string

// AdminCustomerInGroupFilters_CreatedAt_Eq defines model for AdminCustomerInGroupFilters.CreatedAt.Eq.
type AdminCustomerInGroupFilters_CreatedAt_Eq struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersCreatedAtNot0 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersCreatedAtNot0 = string

// AdminCustomerInGroupFiltersCreatedAtNot1 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersCreatedAtNot1 = map[string]interface{}

// AdminCustomerInGroupFiltersCreatedAtNot2 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersCreatedAtNot2 = []string

// AdminCustomerInGroupFilters_CreatedAt_Not defines model for AdminCustomerInGroupFilters.CreatedAt.Not.
type AdminCustomerInGroupFilters_CreatedAt_Not struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersCreatedBy0 Filter by the ID of a user to retrieve the groups of the customers they created.
type AdminCustomerInGroupFiltersCreatedBy0 = string

// AdminCustomerInGroupFiltersCreatedBy1 Filter by the ID of users to retrieve the groups of the customers they created.
type AdminCustomerInGroupFiltersCreatedBy1 = []string

// AdminCustomerInGroupFilters_CreatedBy defines model for AdminCustomerInGroupFilters.CreatedBy.
type AdminCustomerInGroupFilters_CreatedBy struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersDefaultBillingAddressId0 Filter by the ID of a customer's default billing address.
type AdminCustomerInGroupFiltersDefaultBillingAddressId0 = string

// AdminCustomerInGroupFiltersDefaultBillingAddressId1 Filter by the IDs of a customers' default billing address.
type AdminCustomerInGroupFiltersDefaultBillingAddressId1 = []string

// AdminCustomerInGroupFilters_DefaultBillingAddressId defines model for AdminCustomerInGroupFilters.DefaultBillingAddressId.
type AdminCustomerInGroupFilters_DefaultBillingAddressId struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersDefaultShippingAddressId0 Filter by the ID of a customer's default shipping address.
type AdminCustomerInGroupFiltersDefaultShippingAddressId0 = string

// AdminCustomerInGroupFiltersDefaultShippingAddressId1 Filter by the IDs of a customers' default shipping address.
type AdminCustomerInGroupFiltersDefaultShippingAddressId1 = []string

// AdminCustomerInGroupFilters_DefaultShippingAddressId defines model for AdminCustomerInGroupFilters.DefaultShippingAddressId.
type AdminCustomerInGroupFilters_DefaultShippingAddressId struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersDeletedAtEq0 Filter by an exact match.
type AdminCustomerInGroupFiltersDeletedAtEq0 = string

// AdminCustomerInGroupFiltersDeletedAtEq1 Filter by an exact match.
type AdminCustomerInGroupFiltersDeletedAtEq1 = []string

// AdminCustomerInGroupFilters_DeletedAt_Eq defines model for AdminCustomerInGroupFilters.DeletedAt.Eq.
type AdminCustomerInGroupFilters_DeletedAt_Eq struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersDeletedAtNot0 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersDeletedAtNot0 = string

// AdminCustomerInGroupFiltersDeletedAtNot1 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersDeletedAtNot1 = map[string]interface{}

// AdminCustomerInGroupFiltersDeletedAtNot2 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersDeletedAtNot2 = []string

// AdminCustomerInGroupFilters_DeletedAt_Not defines model for AdminCustomerInGroupFilters.DeletedAt.Not.
type AdminCustomerInGroupFilters_DeletedAt_Not struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersEmail0 Filter by a customer's email.
type AdminCustomerInGroupFiltersEmail0 = openapi_types.Email

// AdminCustomerInGroupFiltersEmail1 Filter by customer emails.
type AdminCustomerInGroupFiltersEmail1 = []openapi_types.Email

// AdminCustomerInGroupFiltersEmail2 Apply filters on the customer's email.
type AdminCustomerInGroupFiltersEmail2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                               `json:"$contains,omitempty"`
	Eq       *AdminCustomerInGroupFilters_Email_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                `json:"$nin,omitempty"`
	Not *AdminCustomerInGroupFilters_Email_2_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// AdminCustomerInGroupFilters_Email defines model for AdminCustomerInGroupFilters.Email.
type AdminCustomerInGroupFilters_Email struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersFirstName0 Filter by a customer's first name.
type AdminCustomerInGroupFiltersFirstName0 = string

// AdminCustomerInGroupFiltersFirstName1 Filter by customers' first names.
type AdminCustomerInGroupFiltersFirstName1 = []string

// AdminCustomerInGroupFilters_FirstName defines model for AdminCustomerInGroupFilters.FirstName.
type AdminCustomerInGroupFilters_FirstName struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersId0 Filter by a customer's ID.
type AdminCustomerInGroupFiltersId0 = string

// AdminCustomerInGroupFiltersId1 Filter by customer IDs.
type AdminCustomerInGroupFiltersId1 = []string

// AdminCustomerInGroupFilters_Id defines model for AdminCustomerInGroupFilters.Id.
type AdminCustomerInGroupFilters_Id struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersLastName0 Filter by a customer's last name.
type AdminCustomerInGroupFiltersLastName0 = string

// AdminCustomerInGroupFiltersLastName1 Filter by customers' last names.
type AdminCustomerInGroupFiltersLastName1 = []string

// AdminCustomerInGroupFilters_LastName defines model for AdminCustomerInGroupFilters.LastName.
type AdminCustomerInGroupFilters_LastName struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersUpdatedAtEq0 Filter by an exact match.
type AdminCustomerInGroupFiltersUpdatedAtEq0 = string

// AdminCustomerInGroupFiltersUpdatedAtEq1 Filter by an exact match.
type AdminCustomerInGroupFiltersUpdatedAtEq1 = []string

// AdminCustomerInGroupFilters_UpdatedAt_Eq defines model for AdminCustomerInGroupFilters.UpdatedAt.Eq.
type AdminCustomerInGroupFilters_UpdatedAt_Eq struct {
	union json.RawMessage
}

// AdminCustomerInGroupFiltersUpdatedAtNot0 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersUpdatedAtNot0 = string

// AdminCustomerInGroupFiltersUpdatedAtNot1 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersUpdatedAtNot1 = map[string]interface{}

// AdminCustomerInGroupFiltersUpdatedAtNot2 Filter by values not matching the conditions in this parameter.
type AdminCustomerInGroupFiltersUpdatedAtNot2 = []string

// AdminCustomerInGroupFilters_UpdatedAt_Not defines model for AdminCustomerInGroupFilters.UpdatedAt.Not.
type AdminCustomerInGroupFilters_UpdatedAt_Not struct {
	union json.RawMessage
}

// AdminCustomerResponse The customer's details.
type AdminCustomerResponse struct {
	// Customer The customer's details.
	Customer AdminCustomer `json:"customer"`
}

// AdminDeletePaymentCollectionResponse The result of deleting the payment collection.
type AdminDeletePaymentCollectionResponse struct {
	// Deleted Whether the object was deleted.
	Deleted bool `json:"deleted"`

	// Id The payment collection's ID.
	Id string `json:"id"`

	// Object The name of the object that was deleted.
	Object string `json:"object"`
}

// AdminDraftOrderResponse The draft order's details.
type AdminDraftOrderResponse struct {
	// DraftOrder The order's details.
	DraftOrder AdminOrder `json:"draft_order"`
}

// AdminExchange The exchange's details.
type AdminExchange struct {
	// AdditionalItems The new items (outbound) sent by the exchange.
	AdditionalItems []BaseExchangeItem `json:"additional_items"`

	// AllowBackorder Whether variants that are out-of-stock can still be added as additional or outbound items.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// CanceledAt The date the exchange was canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// CreatedAt The date that the exchange was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the exchange.
	CreatedBy *string `json:"created_by,omitempty"`

	// DeletedAt The date the exchange was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// DifferenceDue The amount to be exchanged or refunded. If the amount is negative, it must be refunded. If positive, additional payment is required from the customer.
	DifferenceDue *float32 `json:"difference_due,omitempty"`

	// DisplayId The exchange's display ID.
	DisplayId *string `json:"display_id,omitempty"`

	// Id The exchange's ID.
	Id string `json:"id"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification Whether to send the customer notifications when the exchange is updated.
	NoNotification *bool `json:"no_notification,omitempty"`

	// Order The order's details.
	Order *AdminOrder `json:"order,omitempty"`

	// OrderId The ID of the order the exchange is created for.
	OrderId string `json:"order_id"`

	// OrderVersion The version of the order once the exchange is applied.
	OrderVersion *string `json:"order_version,omitempty"`

	// Return The return's details.
	Return *AdminReturn `json:"return,omitempty"`

	// ReturnId The ID of the associated exchange.
	ReturnId *string `json:"return_id,omitempty"`

	// ReturnItems The items returned (inbound) by the exchange.
	ReturnItems []AdminReturnItem `json:"return_items"`

	// ShippingMethods The shipping methods used to send the new (outbound) items.
	ShippingMethods *[]BaseOrderShippingMethod `json:"shipping_methods,omitempty"`

	// Transactions The exchange's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date that the exchange was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminExchangeDeleteResponse The details of deleting an exchange.
type AdminExchangeDeleteResponse struct {
	// Deleted Whether the exchange was deleted.
	Deleted bool `json:"deleted"`

	// Id The exchange's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminExchangeOrderResponse The exchange's details.
type AdminExchangeOrderResponse struct {
	// Exchange The exchange's details.
	Exchange AdminExchange `json:"exchange"`

	// Order The order change's order.
	Order Order `json:"order"`
}

// AdminExchangePreviewResponse A preview of the order once the exchange is applied.
type AdminExchangePreviewResponse struct {
	// Exchange The exchange's details.
	Exchange AdminExchange `json:"exchange"`

	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`
}

// AdminExchangeRequestResponse The details of a requested exchange.
type AdminExchangeRequestResponse struct {
	// Exchange The exchange's details.
	Exchange AdminExchange `json:"exchange"`

	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`

	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminExchangeResponse The exchange's details.
type AdminExchangeResponse struct {
	// Exchange The exchange's details.
	Exchange AdminExchange `json:"exchange"`
}

// AdminExchangeReturnResponse The details of an exchange's return.
type AdminExchangeReturnResponse struct {
	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`

	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminExportProductResponse The details of the product export.
type AdminExportProductResponse struct {
	// TransactionId The ID of the workflow execution's transaction. Use it to check the status of the export by sending a GET request to `/admin/workflows-executions/export-products/:transaction-id`
	TransactionId string `json:"transaction_id"`
}

// AdminFile A file's details.
type AdminFile struct {
	// Id The file's ID.
	Id string `json:"id"`

	// Url The file's URL.
	Url string `json:"url"`
}

// AdminFileListResponse The list of uploaded files.
type AdminFileListResponse struct {
	// Files The list of uploaded files.
	Files []AdminFile `json:"files"`
}

// AdminFileResponse A file's details.
type AdminFileResponse struct {
	// File A file's details.
	File AdminFile `json:"file"`
}

// AdminFulfillment The fulfillment's details.
type AdminFulfillment struct {
	// CanceledAt The date the fulfillment was canceled at.
	CanceledAt string `json:"canceled_at"`

	// CreatedAt The date the fulfillment was created at.
	CreatedAt time.Time `json:"created_at"`

	// Data The fulfillment's data, useful for the third-party provider handling the fulfillment.
	Data map[string]interface{} `json:"data"`

	// DeletedAt The date the fulfillment was deleted at.
	DeletedAt time.Time `json:"deleted_at"`

	// DeliveredAt The date the fulfillment was delivered at.
	DeliveredAt string `json:"delivered_at"`

	// DeliveryAddress An address's details.
	DeliveryAddress AdminFulfillmentAddress `json:"delivery_address"`

	// Id The fulfillment's ID.
	Id string `json:"id"`

	// Items The fulfillment's items.
	Items []AdminFulfillmentItem `json:"items"`

	// Labels The fulfillment's shipment labels.
	Labels []AdminFulfillmentLabel `json:"labels"`

	// LocationId The ID of the location the fulfillment's items are shipped from.
	LocationId string `json:"location_id"`

	// Metadata The fulfillment's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// PackedAt The date the fulfillment was packed at.
	PackedAt string `json:"packed_at"`

	// Provider The fulfillment provider's details.
	Provider AdminFulfillmentProvider `json:"provider"`

	// ProviderId The ID of the fulfillment provider handling this fulfillment.
	ProviderId string `json:"provider_id"`

	// ShippedAt The date the fulfillment was shipped at.
	ShippedAt string `json:"shipped_at"`

	// ShippingOptionId The ID of the shipping option this fulfillment is created for.
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date the fulfillment was updated at.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminFulfillmentAddress An address's details.
type AdminFulfillmentAddress struct {
	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 string `json:"address_2"`

	// City The address's city.
	City string `json:"city"`

	// Company The address's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// CreatedAt The date the address was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the address was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// FirstName The address's first name.
	FirstName string `json:"first_name"`

	// FulfillmentId The ID of the fulfillment that the address belongs to.
	FulfillmentId string `json:"fulfillment_id"`

	// Id The address's ID.
	Id string `json:"id"`

	// LastName The address's last name.
	LastName string `json:"last_name"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`

	// UpdatedAt The date the address was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminFulfillmentItem The details of a fulfillment's item.
type AdminFulfillmentItem struct {
	// Barcode The item's barcode.
	Barcode string `json:"barcode"`

	// CreatedAt The date the item was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the item was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// FulfillmentId The ID of the fulfillment the item belongs to.
	FulfillmentId string `json:"fulfillment_id"`

	// Id The item's ID.
	Id string `json:"id"`

	// InventoryItemId The ID of the inventory item of the underlying product variant.
	InventoryItemId string `json:"inventory_item_id"`

	// LineItemId The ID of the order's line item to be fulfilled.
	LineItemId string `json:"line_item_id"`

	// Quantity The item's quantity to be fulfilled.
	Quantity float32 `json:"quantity"`

	// Sku The item's SKU.
	Sku string `json:"sku"`

	// Title The item's title.
	Title string `json:"title"`

	// UpdatedAt The date the item was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminFulfillmentLabel The details of a fulfillmet's shipment label.
type AdminFulfillmentLabel struct {
	// CreatedAt The date the label was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the label was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// FulfillmentId The ID of the fulfillment the label is associated with.
	FulfillmentId string `json:"fulfillment_id"`

	// Id The label's ID.
	Id string `json:"id"`

	// LabelUrl The label's URL.
	LabelUrl string `json:"label_url"`

	// TrackingNumber The label's tracking number.
	TrackingNumber string `json:"tracking_number"`

	// TrackingUrl The label's tracking URL.
	TrackingUrl string `json:"tracking_url"`

	// UpdatedAt The date the label was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminFulfillmentProvider The fulfillment provider's details.
type AdminFulfillmentProvider struct {
	// Id The provider's ID.
	Id string `json:"id"`

	// IsEnabled The provider's is enabled.
	IsEnabled bool `json:"is_enabled"`
}

// AdminFulfillmentProviderListResponse The paginated list of fulfillment providers.
type AdminFulfillmentProviderListResponse struct {
	// Count The total count of items.
	Count float32 `json:"count"`

	// FulfillmentProviders The list of fulfillment providers.
	FulfillmentProviders []AdminFulfillmentProvider `json:"fulfillment_providers"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`
}

// AdminFulfillmentResponse A fulfillment's details.
type AdminFulfillmentResponse struct {
	// Fulfillment The fulfillment's details.
	Fulfillment AdminFulfillment `json:"fulfillment"`
}

// AdminFulfillmentSet The service zone's fulfillment set.
type AdminFulfillmentSet struct {
	// CreatedAt The fulfillment set's created at.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The fulfillment set's deleted at.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The fulfillment set's ID.
	Id string `json:"id"`

	// Location The stock location's details.
	Location AdminStockLocation `json:"location"`

	// Name The fulfillment set's name.
	Name string `json:"name"`

	// ServiceZones The fulfillment set's service zones.
	ServiceZones []AdminServiceZone `json:"service_zones"`

	// Type The fulfillment set's type.
	Type string `json:"type"`

	// UpdatedAt The fulfillment set's updated at.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminFulfillmentSetDeleteResponse The deletion details.
type AdminFulfillmentSetDeleteResponse struct {
	// Deleted Whether the fulfillment set was deleted.
	Deleted bool `json:"deleted"`

	// Id The fulfillment set's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminFulfillmentSetResponse The fulfillment set's details.
type AdminFulfillmentSetResponse struct {
	// FulfillmentSet The service zone's fulfillment set.
	FulfillmentSet AdminFulfillmentSet `json:"fulfillment_set"`
}

// AdminGeoZone The geo zone's geo zones.
type AdminGeoZone struct {
	// City The geo zone's city.
	City string `json:"city"`

	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// CreatedAt The geo zone's created at.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The geo zone's deleted at.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The geo zone's ID.
	Id string `json:"id"`

	// PostalExpression The geo zone's postal expression.
	PostalExpression map[string]interface{} `json:"postal_expression"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type AdminGeoZoneType `json:"type"`

	// UpdatedAt The geo zone's updated at.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminGeoZoneType The geo zone's type.
type AdminGeoZoneType string

// AdminImportProductRequest The import's details.
type AdminImportProductRequest struct {
	// File A File to upload.
	File map[string]interface{} `json:"file"`
}

// AdminImportProductResponse The import process's details.
type AdminImportProductResponse struct {
	// Summary The import's summary.
	Summary struct {
		// ToCreate The number of products that will be created by this import.
		ToCreate float32 `json:"toCreate"`

		// ToUpdate The number of products that will be updated by this import.
		ToUpdate float32 `json:"toUpdate"`
	} `json:"summary"`

	// TransactionId The ID of the workflow execution's transaction. This is useful to confirm the import using the `/admin/products/:transaction-id/import` API route.
	TransactionId string `json:"transaction_id"`
}

// AdminInventoryItem The reservation's inventory item.
type AdminInventoryItem struct {
	// Description The inventory item's description.
	Description *string `json:"description,omitempty"`

	// Height The inventory item's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The inventory item's hs code.
	HsCode *string `json:"hs_code,omitempty"`

	// Id The inventory item's ID.
	Id string `json:"id"`

	// Length The inventory item's length.
	Length *float32 `json:"length,omitempty"`

	// LocationLevels The inventory item's location levels.
	LocationLevels *[]AdminInventoryLevel `json:"location_levels,omitempty"`

	// Material The inventory item's material.
	Material *string `json:"material,omitempty"`

	// Metadata The inventory item's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The inventory item's mid code.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The inventory item's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping The inventory item's requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// Sku The inventory item's sku.
	Sku *string `json:"sku,omitempty"`

	// Thumbnail The inventory item's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The inventory item's title.
	Title *string `json:"title,omitempty"`

	// Weight The inventory item's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The inventory item's width.
	Width *float32 `json:"width,omitempty"`
}

// AdminInventoryItemResponse The inventory item's details.
type AdminInventoryItemResponse struct {
	// InventoryItem The reservation's inventory item.
	InventoryItem AdminInventoryItem `json:"inventory_item"`
}

// AdminInventoryLevel The location level's location levels.
type AdminInventoryLevel struct {
	// AvailableQuantity The location level's available quantity.
	AvailableQuantity float32 `json:"available_quantity"`

	// CreatedAt The location level's created at.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The location level's deleted at.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The location level's ID.
	Id string `json:"id"`

	// IncomingQuantity The location level's incoming quantity.
	IncomingQuantity float32                 `json:"incoming_quantity"`
	InventoryItem    *map[string]interface{} `json:"inventory_item,omitempty"`

	// InventoryItemId The location level's inventory item id.
	InventoryItemId string `json:"inventory_item_id"`

	// LocationId The location level's location id.
	LocationId string `json:"location_id"`

	// Metadata The location level's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// ReservedQuantity The location level's reserved quantity.
	ReservedQuantity float32 `json:"reserved_quantity"`

	// StockedQuantity The location level's stocked quantity.
	StockedQuantity float32 `json:"stocked_quantity"`

	// UpdatedAt The location level's updated at.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminInvite The invite's details.
type AdminInvite struct {
	// Accepted Whether the invite has been accepted.
	Accepted bool `json:"accepted"`

	// CreatedAt The date the invite was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Email The invite's email.
	Email openapi_types.Email `json:"email"`

	// ExpiresAt The invite's expiry date.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id The invite's ID.
	Id string `json:"id"`

	// Metadata The invite's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Token The invite's token.
	Token string `json:"token"`

	// UpdatedAt The date the invite was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AdminInviteResponse The invite's details.
type AdminInviteResponse struct {
	// Invite The invite's details.
	Invite AdminInvite `json:"invite"`
}

// AdminLinkPriceListProducts The products removal details.
type AdminLinkPriceListProducts struct {
	// Remove The products to remove from the price list.
	Remove *[]string `json:"remove,omitempty"`
}

// AdminNotification The notification's details.
type AdminNotification struct {
	// Channel Through which channel is the notification sent through.
	Channel string `json:"channel"`

	// CreatedAt The date the notification was created.
	CreatedAt time.Time `json:"created_at"`

	// Data Data payload to send with the notification.
	Data *map[string]interface{} `json:"data,omitempty"`

	// ExternalId The ID of the notification in an external or third-party system.
	ExternalId *string `json:"external_id,omitempty"`

	// Id The notification's ID.
	Id string `json:"id"`

	// OriginalNotificationId The ID of the original notification, if this notification is resent.
	OriginalNotificationId *string `json:"original_notification_id,omitempty"`

	// ProviderId The ID of the provider used to send the notification.
	ProviderId string `json:"provider_id"`

	// ReceiverId The ID of the user or customer that's receiving this notification.
	ReceiverId *string `json:"receiver_id,omitempty"`

	// ResourceId The ID of the associated resource. For example, if the notification was triggered because an order was created, this would be the ID of the order.
	ResourceId *string `json:"resource_id,omitempty"`

	// ResourceType The type of the resource that triggered the notification.
	ResourceType *string `json:"resource_type,omitempty"`

	// Template The ID of the template in a third-party service used as the notification's shape.
	Template string `json:"template"`

	// To Where to send the notification to. For example, if `channel` is `email`, this can be an email number.
	To string `json:"to"`

	// TriggerType What triggered this notification.
	TriggerType *string `json:"trigger_type,omitempty"`
}

// AdminNotificationListResponse The paginated list of notifications.
type AdminNotificationListResponse struct {
	// Count The total count of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Notifications The list of notifications.
	Notifications []AdminNotification `json:"notifications"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`
}

// AdminNotificationResponse The notification's details.
type AdminNotificationResponse struct {
	// Notification The notification's details.
	Notification AdminNotification `json:"notification"`
}

// AdminOrder The order's details.
type AdminOrder struct {
	// BillingAddress An order address.
	BillingAddress *AdminOrderAddress `json:"billing_address,omitempty"`

	// CreatedAt The date the order was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The order's currency code.
	CurrencyCode string `json:"currency_code"`

	// Customer The customer's details.
	Customer *AdminCustomer `json:"customer,omitempty"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId string `json:"customer_id"`

	// DiscountTaxTotal The tax total of order's discount or promotion.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The order's discount or promotions total.
	DiscountTotal float32 `json:"discount_total"`

	// DisplayId The order's display ID.
	DisplayId *float32 `json:"display_id,omitempty"`

	// Email The email of the customer that placed the order.
	Email openapi_types.Email `json:"email"`

	// FulfillmentStatus The order's fulfillment status.
	FulfillmentStatus AdminOrderFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The order's fulfillments.
	Fulfillments *[]AdminOrderFulfillment `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The tax total of the order's gift card.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The order's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The order's ID.
	Id string `json:"id"`

	// ItemSubtotal The total of the order's items excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The tax total of the order's items including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total of the order's items including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Items The order's items.
	Items []AdminOrderLineItem `json:"items"`

	// Metadata The order's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OriginalItemSubtotal The total of the order's items excluding taxes, including promotions.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The tax total of the order's items excluding promotions.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The total of the order's items including taxes, excluding promotions.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The order's shipping total excluding taxes, including promotions.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The tax total of the order's shipping excluding promotions.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The order's shipping total including taxes, excluding promotions.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The order's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The order's tax total, excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The order's total excluding promotions, including taxes.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollections The order's payment collections.
	PaymentCollections []AdminPaymentCollection `json:"payment_collections"`

	// PaymentStatus The order's payment status.
	PaymentStatus AdminOrderPaymentStatus `json:"payment_status"`

	// RegionId The ID of the region associated with the order.
	RegionId string `json:"region_id"`

	// SalesChannel The sales channel's details.
	SalesChannel *AdminSalesChannel `json:"sales_channel,omitempty"`

	// SalesChannelId The ID of the sales channel the order is placed in.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress An order address.
	ShippingAddress *AdminOrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The order's shipping methods.
	ShippingMethods []AdminOrderShippingMethod `json:"shipping_methods"`

	// ShippingSubtotal The order's shipping total excluding taxes, including promotions.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The tax total of the order's shipping.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The order's shipping total including taxes and promotions.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The order's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary details.
	Summary BaseOrderSummary `json:"summary"`

	// TaxTotal The order's tax total including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The order's total including taxes and promotions.
	Total float32 `json:"total"`

	// Transactions The order's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date the order was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order's version.
	Version float32 `json:"version"`
}

// AdminOrderFulfillmentStatus The order's fulfillment status.
type AdminOrderFulfillmentStatus string

// AdminOrderPaymentStatus The order's payment status.
type AdminOrderPaymentStatus string

// AdminOrderAddress An order address.
type AdminOrderAddress struct {
	// Address1 The address's first line.
	Address1 *string `json:"address_1,omitempty"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// Country The country's details.
	Country *AdminRegionCountry `json:"country,omitempty"`

	// CountryCode The address's country code.
	CountryCode *string `json:"country_code,omitempty"`

	// CreatedAt The date the address was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer this address belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// FirstName The address's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Id The address's ID.
	Id string `json:"id"`

	// LastName The address's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`

	// UpdatedAt The date the address was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminOrderChange The order change's details.
type AdminOrderChange struct {
	// Actions The order change's actions.
	Actions []AdminOrderChangeAction `json:"actions"`

	// CanceledAt The date the order change was canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// CanceledBy The ID of the user that canceled the order change.
	CanceledBy string `json:"canceled_by"`

	// ChangeType The order change's type.
	ChangeType *AdminOrderChangeChangeType `json:"change_type,omitempty"`

	// Claim The claim's details.
	Claim AdminClaim `json:"claim"`

	// ClaimId The ID of the associated claim.
	ClaimId string `json:"claim_id"`

	// ConfirmedAt The date the order change was confirmed.
	ConfirmedAt time.Time `json:"confirmed_at"`

	// ConfirmedBy The ID of the user that confirmed the order change.
	ConfirmedBy string `json:"confirmed_by"`

	// CreatedAt The date the order change was created.
	CreatedAt time.Time `json:"created_at"`

	// DeclinedAt The date the order change was declined.
	DeclinedAt time.Time `json:"declined_at"`

	// DeclinedBy The ID of the user that declined the order change.
	DeclinedBy string `json:"declined_by"`

	// DeclinedReason The reason the order change was declined.
	DeclinedReason string `json:"declined_reason"`

	// Exchange The exchange's details.
	Exchange AdminExchange `json:"exchange"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId string `json:"exchange_id"`

	// Id The order change's ID.
	Id string `json:"id"`

	// Metadata The order change's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Order The order change's order.
	Order string `json:"order"`

	// OrderId The ID of the order this change applies on.
	OrderId string `json:"order_id"`

	// RequestedAt The date the order change was requested.
	RequestedAt time.Time `json:"requested_at"`

	// RequestedBy The ID of the user that requested the change.
	RequestedBy string `json:"requested_by"`

	// ReturnId The ID of the associated return.
	ReturnId string `json:"return_id"`

	// ReturnOrder The return's details.
	ReturnOrder AdminReturn `json:"return_order"`

	// Status The order change's status.
	Status AdminOrderChangeStatus `json:"status"`

	// UpdatedAt The date the order change was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order change's version. This will be the order's version when the change is applied.
	Version float32 `json:"version"`
}

// AdminOrderChangeChangeType The order change's type.
type AdminOrderChangeChangeType string

// AdminOrderChangeStatus The order change's status.
type AdminOrderChangeStatus string

// AdminOrderChangeAction The order change action's details.
type AdminOrderChangeAction struct {
	// Action The applied action.
	Action AdminOrderChangeActionAction `json:"action"`

	// ClaimId The ID of the associated claim.
	ClaimId string `json:"claim_id"`

	// CreatedAt The date the action was created.
	CreatedAt time.Time `json:"created_at"`

	// Details The action's details.
	Details map[string]interface{} `json:"details"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId string `json:"exchange_id"`

	// Id The action's ID.
	Id string `json:"id"`

	// InternalNote A note that's viewed only by admin users.
	InternalNote string `json:"internal_note"`

	// Order The order change's order.
	Order       string                 `json:"order"`
	OrderChange map[string]interface{} `json:"order_change"`

	// OrderChangeId The ID of the order change that the action belongs to.
	OrderChangeId string `json:"order_change_id"`

	// OrderId The ID of the order the associated change is for.
	OrderId string `json:"order_id"`

	// Reference The name of the table this action applies on.
	Reference AdminOrderChangeActionReference `json:"reference"`

	// ReferenceId The ID of the record in the referenced table.
	ReferenceId string `json:"reference_id"`

	// ReturnId The ID of the associated return.
	ReturnId string `json:"return_id"`

	// UpdatedAt The date the action was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminOrderChangeActionAction The applied action.
type AdminOrderChangeActionAction string

// AdminOrderChangeActionReference The name of the table this action applies on.
type AdminOrderChangeActionReference string

// AdminOrderChangesResponse The details of an order's changes.
type AdminOrderChangesResponse struct {
	// OrderChanges An order's changes.
	OrderChanges []AdminOrderChange `json:"order_changes"`
}

// AdminOrderEditPreviewResponse The preview of an order edit.
type AdminOrderEditPreviewResponse struct {
	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`
}

// AdminOrderEditResponse An order edit's details.
type AdminOrderEditResponse struct {
	// OrderChange The order change's details.
	OrderChange AdminOrderChange `json:"order_change"`
}

// AdminOrderFulfillment The fulfillment's details.
type AdminOrderFulfillment struct {
	// CanceledAt The date the items were canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// CreatedAt The date the fulfillment was created.
	CreatedAt time.Time `json:"created_at"`

	// Data Data useful for the fulfillment provider handling it. This is taken from the associated shipping option.
	Data map[string]interface{} `json:"data"`

	// DeliveredAt The date the items were delivered.
	DeliveredAt time.Time `json:"delivered_at"`

	// Id The fulfillment's ID.
	Id string `json:"id"`

	// LocationId The ID of the location the items are fulfilled from.
	LocationId string `json:"location_id"`

	// Metadata The fulfillment's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// PackedAt The date the items were packed.
	PackedAt time.Time `json:"packed_at"`

	// ProviderId The ID of the fulfillment provider used to handle the fulfillment.
	ProviderId string `json:"provider_id"`

	// RequiresShipping Whether the fulfillment requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// ShippedAt The date the items were shipped.
	ShippedAt time.Time `json:"shipped_at"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date the fulfillment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminOrderLineItem The item's details.
type AdminOrderLineItem struct {
	// Adjustments The item's adjustments.
	Adjustments *[]BaseOrderLineItemAdjustment `json:"adjustments,omitempty"`

	// CompareAtUnitPrice The original price of the item before a promotion or sale.
	CompareAtUnitPrice *float32 `json:"compare_at_unit_price,omitempty"`

	// CreatedAt The date the item was created.
	CreatedAt time.Time              `json:"created_at"`
	Detail    map[string]interface{} `json:"detail"`

	// DiscountTaxTotal The total taxes applied on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total discount amount of the item.
	DiscountTotal float32 `json:"discount_total"`

	// Id The item's ID.
	Id string `json:"id"`

	// IsDiscountable Whether the item is discountable.
	IsDiscountable bool `json:"is_discountable"`

	// IsTaxInclusive Whether the item is tax inclusive.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// ItemSubtotal The item's total excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The total taxes of the item, including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total taxes of the item, including promotions.
	ItemTotal float32 `json:"item_total"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OriginalSubtotal The item's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes of the item, excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The item's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// Product The product's details.
	Product *AdminProduct `json:"product,omitempty"`

	// ProductCollection The ID of the collection the item's product belongs to.
	ProductCollection string `json:"product_collection"`

	// ProductDescription The item's product description.
	ProductDescription string `json:"product_description"`

	// ProductHandle The item's product handle.
	ProductHandle string `json:"product_handle"`

	// ProductId The ID of the associated product.
	ProductId string `json:"product_id"`

	// ProductSubtitle The item's product subtitle.
	ProductSubtitle string `json:"product_subtitle"`

	// ProductTitle The item's product title.
	ProductTitle string `json:"product_title"`

	// ProductType The item's product type.
	ProductType string `json:"product_type"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// RefundableTotal The total refundable amount of the item's total.
	RefundableTotal float32 `json:"refundable_total"`

	// RefundableTotalPerUnit The total refundable amount of the item's total for a single quantity.
	RefundableTotalPerUnit float32 `json:"refundable_total_per_unit"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// Subtitle The item's subtitle.
	Subtitle string `json:"subtitle"`

	// Subtotal The item's subtotal excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The item's tax lines.
	TaxLines *[]BaseOrderLineItemTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The tax total of the item including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Thumbnail The URL of the item's thumbnail.
	Thumbnail string `json:"thumbnail"`

	// Title The item's title.
	Title string `json:"title"`

	// Total The item's total, including taxes and promotions.
	Total float32 `json:"total"`

	// UnitPrice The item's unit price.
	UnitPrice float32 `json:"unit_price"`

	// UpdatedAt The date the item was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variant The product variant's details.
	Variant *AdminProductVariant `json:"variant,omitempty"`

	// VariantBarcode The item's variant barcode.
	VariantBarcode string `json:"variant_barcode"`

	// VariantId The ID of the associated variant.
	VariantId string `json:"variant_id"`

	// VariantOptionValues The values of the item variant's options.
	VariantOptionValues map[string]interface{} `json:"variant_option_values"`

	// VariantSku The item's variant SKU.
	VariantSku string `json:"variant_sku"`

	// VariantTitle The item's variant title.
	VariantTitle string `json:"variant_title"`
}

// AdminOrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
type AdminOrderPreview struct {
	// BillingAddress An order address.
	BillingAddress *AdminOrderAddress `json:"billing_address,omitempty"`

	// CreatedAt The date the order was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The order's currency code.
	CurrencyCode string `json:"currency_code"`

	// Customer The customer's details.
	Customer *AdminCustomer `json:"customer,omitempty"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId string `json:"customer_id"`

	// DiscountTaxTotal The tax total of order's discount or promotion.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The order's discount or promotions total.
	DiscountTotal float32 `json:"discount_total"`

	// DisplayId The order's display ID.
	DisplayId *float32 `json:"display_id,omitempty"`

	// Email The email of the customer that placed the order.
	Email openapi_types.Email `json:"email"`

	// FulfillmentStatus The order's fulfillment status.
	FulfillmentStatus AdminOrderPreviewFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The order's fulfillments.
	Fulfillments *[]AdminOrderFulfillment `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The tax total of the order's gift card.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The order's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The order's ID.
	Id string `json:"id"`

	// ItemSubtotal The total of the order's items excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The tax total of the order's items including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total of the order's items including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Items The order's items.
	Items *[]struct {
		// Actions The actions applied on an item.
		Actions *[]map[string]interface{} `json:"actions,omitempty"`

		// Adjustments The item's adjustments.
		Adjustments *[]BaseOrderLineItemAdjustment `json:"adjustments,omitempty"`

		// CompareAtUnitPrice The original price of the item before a promotion or sale.
		CompareAtUnitPrice *float32 `json:"compare_at_unit_price,omitempty"`

		// CreatedAt The date the item was created.
		CreatedAt time.Time `json:"created_at"`

		// Detail The item's detail.
		Detail BaseOrderItemDetail `json:"detail"`

		// DiscountTaxTotal The tax total of the item's discount / promotion
		DiscountTaxTotal float32 `json:"discount_tax_total"`

		// DiscountTotal The total of the item's discount / promotion.
		DiscountTotal float32 `json:"discount_total"`

		// Id The item's ID.
		Id string `json:"id"`

		// IsDiscountable Whether the item is discountable.
		IsDiscountable bool `json:"is_discountable"`

		// IsTaxInclusive Whether the item's price includes taxes.
		IsTaxInclusive bool `json:"is_tax_inclusive"`

		// ItemSubtotal The item's total for a single unit excluding taxes, including promotions.
		ItemSubtotal float32 `json:"item_subtotal"`

		// ItemTaxTotal The tax total for a single unit of the item including promotions.
		ItemTaxTotal float32 `json:"item_tax_total"`

		// ItemTotal The item's total for a single unit including taxes and promotions.
		ItemTotal float32 `json:"item_total"`

		// Metadata The item's metadata, can hold custom key-value pairs.
		Metadata map[string]interface{} `json:"metadata"`

		// OriginalSubtotal The item's total excluding taxes, including promotions.
		OriginalSubtotal float32 `json:"original_subtotal"`

		// OriginalTaxTotal The tax total of the item excluding promotions.
		OriginalTaxTotal float32 `json:"original_tax_total"`

		// OriginalTotal The item's total including taxes, excluding promotions.
		OriginalTotal float32 `json:"original_total"`

		// Product The product's details.
		Product *AdminProduct `json:"product,omitempty"`

		// ProductCollection The ID of collection of the item's product.
		ProductCollection string `json:"product_collection"`

		// ProductDescription The description of the item's product.
		ProductDescription string `json:"product_description"`

		// ProductHandle The handle of the item's product.
		ProductHandle string `json:"product_handle"`

		// ProductId The ID of the associated product.
		ProductId string `json:"product_id"`

		// ProductSubtitle The subtitle of the item's product.
		ProductSubtitle string `json:"product_subtitle"`

		// ProductTitle The title of the item's product.
		ProductTitle string `json:"product_title"`

		// ProductType The ID of type of the item's product.
		ProductType string `json:"product_type"`

		// Quantity The item's quantity.
		Quantity float32 `json:"quantity"`

		// RefundableTotal The total refundable amount of the item's total.
		RefundableTotal float32 `json:"refundable_total"`

		// RefundableTotalPerUnit The total refundable amount of the item's total for a single unit.
		RefundableTotalPerUnit float32 `json:"refundable_total_per_unit"`

		// RequiresShipping Whether the item requires shipping.
		RequiresShipping bool `json:"requires_shipping"`

		// Subtitle The item's subtitle.
		Subtitle string `json:"subtitle"`

		// Subtotal The item's total excluding taxes, including promotions.
		Subtotal float32 `json:"subtotal"`

		// TaxLines The item's tax lines.
		TaxLines *[]BaseOrderLineItemTaxLine `json:"tax_lines,omitempty"`

		// TaxTotal The tax total of the item including promotions.
		TaxTotal float32 `json:"tax_total"`

		// Thumbnail The URL of the item's thumbnail.
		Thumbnail string `json:"thumbnail"`

		// Title The item's title.
		Title string `json:"title"`

		// Total The item's total including taxes and promotions.
		Total float32 `json:"total"`

		// UnitPrice The item's unit price.
		UnitPrice float32 `json:"unit_price"`

		// UpdatedAt The date the item was updated.
		UpdatedAt time.Time `json:"updated_at"`

		// Variant The product variant's details.
		Variant *BaseProductVariant `json:"variant,omitempty"`

		// VariantBarcode The barcode of the item's variant.
		VariantBarcode string `json:"variant_barcode"`

		// VariantId The ID of the associated variant.
		VariantId string `json:"variant_id"`

		// VariantOptionValues The option values of the item's variant as key-value pairs. The key is the title of an option, and the value is the option's value.
		VariantOptionValues map[string]interface{} `json:"variant_option_values"`

		// VariantSku The SKU of the item's variant.
		VariantSku string `json:"variant_sku"`

		// VariantTitle The title of the item's variant.
		VariantTitle string `json:"variant_title"`
	} `json:"items,omitempty"`

	// Metadata The order's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderChange The order change's details.
	OrderChange AdminOrderChange `json:"order_change"`

	// OriginalItemSubtotal The total of the order's items excluding taxes, including promotions.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The tax total of the order's items excluding promotions.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The total of the order's items including taxes, excluding promotions.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The order's shipping total excluding taxes, including promotions.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The tax total of the order's shipping excluding promotions.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The order's shipping total including taxes, excluding promotions.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The order's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The order's tax total, excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The order's total excluding promotions, including taxes.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollections The order's payment collections.
	PaymentCollections []AdminPaymentCollection `json:"payment_collections"`

	// PaymentStatus The order's payment status.
	PaymentStatus AdminOrderPreviewPaymentStatus `json:"payment_status"`

	// RegionId The ID of the order's associated region.
	RegionId string `json:"region_id"`

	// ReturnRequestedTotal The total of the requested return.
	ReturnRequestedTotal float32 `json:"return_requested_total"`

	// SalesChannel The sales channel's details.
	SalesChannel *AdminSalesChannel `json:"sales_channel,omitempty"`

	// SalesChannelId The ID of the sales channel that the order was placed in.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress An order address.
	ShippingAddress *AdminOrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The order's shipping methods.
	ShippingMethods *[]struct {
		// Actions The actions applied on the shipping method.
		Actions *[]map[string]interface{} `json:"actions,omitempty"`

		// Adjustments The shipping method's adjustments.
		Adjustments *[]BaseOrderShippingMethodAdjustment `json:"adjustments,omitempty"`

		// Amount The shipping method's amount.
		Amount float32 `json:"amount"`

		// CreatedAt The date the shipping method was created.
		CreatedAt time.Time `json:"created_at"`

		// Data The data relevant for the fulfillment provider to process this shipment.
		Data map[string]interface{} `json:"data"`

		// Description The shipping method's description.
		Description      *string                                            `json:"description,omitempty"`
		DiscountTaxTotal AdminOrderPreview_ShippingMethods_DiscountTaxTotal `json:"discount_tax_total"`
		DiscountTotal    AdminOrderPreview_ShippingMethods_DiscountTotal    `json:"discount_total"`

		// Id The shipping method's ID.
		Id string `json:"id"`

		// IsTaxInclusive Whether the shipping method's amount is tax inclusive.
		IsTaxInclusive bool `json:"is_tax_inclusive"`

		// Metadata The shipping method's metadata, can hold custom key-value pairs.
		Metadata map[string]interface{} `json:"metadata"`

		// Name The shipping method's name.
		Name string `json:"name"`

		// OrderId The ID of the order this shipping method belongs to.
		OrderId          string                                             `json:"order_id"`
		OriginalSubtotal AdminOrderPreview_ShippingMethods_OriginalSubtotal `json:"original_subtotal"`
		OriginalTaxTotal AdminOrderPreview_ShippingMethods_OriginalTaxTotal `json:"original_tax_total"`
		OriginalTotal    AdminOrderPreview_ShippingMethods_OriginalTotal    `json:"original_total"`

		// ShippingOptionId The ID of the shipping option this method was created from.
		ShippingOptionId string                                     `json:"shipping_option_id"`
		Subtotal         AdminOrderPreview_ShippingMethods_Subtotal `json:"subtotal"`

		// TaxLines The shipping method's tax lines.
		TaxLines *[]BaseOrderShippingMethodTaxLine          `json:"tax_lines,omitempty"`
		TaxTotal AdminOrderPreview_ShippingMethods_TaxTotal `json:"tax_total"`
		Total    AdminOrderPreview_ShippingMethods_Total    `json:"total"`

		// UpdatedAt The date the shipping method was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"shipping_methods,omitempty"`

	// ShippingSubtotal The order's shipping total excluding taxes, including promotions.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The tax total of the order's shipping.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The order's shipping total including taxes and promotions.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The order's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary details.
	Summary BaseOrderSummary `json:"summary"`

	// TaxTotal The order's tax total including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The order's total including taxes and promotions.
	Total float32 `json:"total"`

	// Transactions The order's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date the order was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order's version when this preview is applied.
	Version float32 `json:"version"`
}

// AdminOrderPreviewFulfillmentStatus The order's fulfillment status.
type AdminOrderPreviewFulfillmentStatus string

// AdminOrderPreviewPaymentStatus The order's payment status.
type AdminOrderPreviewPaymentStatus string

// AdminOrderPreviewShippingMethodsDiscountTaxTotal0 The tax total of the shipping method's promotion.
type AdminOrderPreviewShippingMethodsDiscountTaxTotal0 = string

// AdminOrderPreviewShippingMethodsDiscountTaxTotal1 The shipping method's discount tax total.
type AdminOrderPreviewShippingMethodsDiscountTaxTotal1 = float32

// AdminOrderPreview_ShippingMethods_DiscountTaxTotal defines model for AdminOrderPreview.ShippingMethods.DiscountTaxTotal.
type AdminOrderPreview_ShippingMethods_DiscountTaxTotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsDiscountTotal0 The total of the shipping method's promotion.
type AdminOrderPreviewShippingMethodsDiscountTotal0 = string

// AdminOrderPreviewShippingMethodsDiscountTotal1 The total of the shipping method's promotion.
type AdminOrderPreviewShippingMethodsDiscountTotal1 = float32

// AdminOrderPreview_ShippingMethods_DiscountTotal defines model for AdminOrderPreview.ShippingMethods.DiscountTotal.
type AdminOrderPreview_ShippingMethods_DiscountTotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsOriginalSubtotal0 The shipping method's total excluding taxes, including promotions.
type AdminOrderPreviewShippingMethodsOriginalSubtotal0 = string

// AdminOrderPreviewShippingMethodsOriginalSubtotal1 The shipping method's total excluding taxes, including promotions.
type AdminOrderPreviewShippingMethodsOriginalSubtotal1 = float32

// AdminOrderPreview_ShippingMethods_OriginalSubtotal defines model for AdminOrderPreview.ShippingMethods.OriginalSubtotal.
type AdminOrderPreview_ShippingMethods_OriginalSubtotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsOriginalTaxTotal0 The tax total of the shipping method excluding promotions.
type AdminOrderPreviewShippingMethodsOriginalTaxTotal0 = string

// AdminOrderPreviewShippingMethodsOriginalTaxTotal1 The tax total of the shipping method excluding promotions.
type AdminOrderPreviewShippingMethodsOriginalTaxTotal1 = float32

// AdminOrderPreview_ShippingMethods_OriginalTaxTotal defines model for AdminOrderPreview.ShippingMethods.OriginalTaxTotal.
type AdminOrderPreview_ShippingMethods_OriginalTaxTotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsOriginalTotal0 The shipping method's total including taxes, excluding promotions.
type AdminOrderPreviewShippingMethodsOriginalTotal0 = string

// AdminOrderPreviewShippingMethodsOriginalTotal1 The shipping method's total including taxes, excluding promotions.
type AdminOrderPreviewShippingMethodsOriginalTotal1 = float32

// AdminOrderPreview_ShippingMethods_OriginalTotal defines model for AdminOrderPreview.ShippingMethods.OriginalTotal.
type AdminOrderPreview_ShippingMethods_OriginalTotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsSubtotal0 The shipping method's total excluding taxes, including promotions.
type AdminOrderPreviewShippingMethodsSubtotal0 = string

// AdminOrderPreviewShippingMethodsSubtotal1 The shipping method's total excluding taxes, including promotions.
type AdminOrderPreviewShippingMethodsSubtotal1 = float32

// AdminOrderPreview_ShippingMethods_Subtotal defines model for AdminOrderPreview.ShippingMethods.Subtotal.
type AdminOrderPreview_ShippingMethods_Subtotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsTaxTotal0 The tax total of the shipping method including promotions.
type AdminOrderPreviewShippingMethodsTaxTotal0 = string

// AdminOrderPreviewShippingMethodsTaxTotal1 The tax total of the shipping method including promotions.
type AdminOrderPreviewShippingMethodsTaxTotal1 = float32

// AdminOrderPreview_ShippingMethods_TaxTotal defines model for AdminOrderPreview.ShippingMethods.TaxTotal.
type AdminOrderPreview_ShippingMethods_TaxTotal struct {
	union json.RawMessage
}

// AdminOrderPreviewShippingMethodsTotal0 The shipping method's total including taxes and promotions.
type AdminOrderPreviewShippingMethodsTotal0 = string

// AdminOrderPreviewShippingMethodsTotal1 The shipping method's total including taxes and promotions.
type AdminOrderPreviewShippingMethodsTotal1 = float32

// AdminOrderPreview_ShippingMethods_Total defines model for AdminOrderPreview.ShippingMethods.Total.
type AdminOrderPreview_ShippingMethods_Total struct {
	union json.RawMessage
}

// AdminOrderPreviewResponse The preview of an order.
type AdminOrderPreviewResponse struct {
	// Order A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	Order AdminOrderPreview `json:"order"`
}

// AdminOrderResponse An order's details.
type AdminOrderResponse struct {
	// Order The order's details.
	Order AdminOrder `json:"order"`
}

// AdminOrderReturnResponse The order return details.
type AdminOrderReturnResponse struct {
	// Order The order change's order.
	Order Order `json:"order"`

	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminOrderShippingMethod The shipping method's details.
type AdminOrderShippingMethod struct {
	// Adjustments The shipping method's adjustments.
	Adjustments *[]BaseOrderShippingMethodAdjustment `json:"adjustments,omitempty"`

	// Amount The shipping method's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the shipping method was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The shipping method's data, useful for fulfillment provider handling its fulfillment.
	Data map[string]interface{} `json:"data"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// Detail Details of changes to a shipping method.
	Detail *BaseOrderShippingDetail `json:"detail,omitempty"`

	// DiscountTaxTotal The taxes applied on the discount amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total discounts applied on the shipping method.
	DiscountTotal float32 `json:"discount_total"`

	// Id The shipping method's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether the shipping method's amount includes applied taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// Metadata The shipping method's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The shipping method's name.
	Name string `json:"name"`

	// OrderId The ID of the order the shipping method belongs to.
	OrderId string `json:"order_id"`

	// OriginalSubtotal The shipping method's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The shipping method's total taxes excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The shipping method's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// ShippingOptionId The ID of the shipping option this method was created from.
	ShippingOptionId string `json:"shipping_option_id"`

	// Subtotal The shipping method's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The shipping method's tax lines.
	TaxLines *[]BaseOrderShippingMethodTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The shipping method's tax total including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The shipping method's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the shipping method was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminPayment The payment's details.
type AdminPayment struct {
	// Amount The payment's amount.
	Amount float32 `json:"amount"`

	// AuthorizedAmount The amount authorized of the payment.
	AuthorizedAmount *float32 `json:"authorized_amount,omitempty"`

	// CanceledAt The date the payment was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// CapturedAmount The captured amount of the payment.
	CapturedAmount *float32 `json:"captured_amount,omitempty"`

	// CapturedAt The date the payment was captured.
	CapturedAt *time.Time `json:"captured_at,omitempty"`

	// Captures The details of payment captures.
	Captures *[]BaseCapture `json:"captures,omitempty"`

	// CartId The ID of the associated cart.
	CartId *string `json:"cart_id,omitempty"`

	// CreatedAt The date the payment was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The payment's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId ID of the associated customer.
	CustomerId *string `json:"customer_id,omitempty"`

	// Data The payment's data, useful for processing by the payment provider.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Id The payment's ID.
	Id string `json:"id"`

	// OrderEditId The ID of the associated order edit.
	OrderEditId *string `json:"order_edit_id,omitempty"`

	// OrderId The ID of the associated order.
	OrderId           *string                 `json:"order_id,omitempty"`
	PaymentCollection *map[string]interface{} `json:"payment_collection,omitempty"`

	// PaymentSession The payment session's details.
	PaymentSession *AdminPaymentSession `json:"payment_session,omitempty"`

	// ProviderId The ID of the payment provider used to process this payment.
	ProviderId string `json:"provider_id"`

	// RefundedAmount The refunded amount of the payment.
	RefundedAmount *float32 `json:"refunded_amount,omitempty"`

	// Refunds The details of payment refunds.
	Refunds *[]AdminRefund `json:"refunds,omitempty"`

	// UpdatedAt The date the payment was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AdminPaymentCollection The payment collection's details.
type AdminPaymentCollection struct {
	// Amount The total amount to be paid.
	Amount float32 `json:"amount"`

	// AuthorizedAmount The total authorized amount of the collection's payments.
	AuthorizedAmount *float32 `json:"authorized_amount,omitempty"`

	// CapturedAmount The total captured amount of the collection's payments.
	CapturedAmount *float32 `json:"captured_amount,omitempty"`

	// CompletedAt The date the payment collection was completed.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The date the payment collection was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The payment collection's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The payment collection's ID.
	Id string `json:"id"`

	// Metadata The payment collection's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PaymentProviders The payment provider used to process the collection's payments and sessions.
	PaymentProviders []AdminPaymentProvider `json:"payment_providers"`

	// PaymentSessions The payment collection's payment sessions.
	PaymentSessions *[]AdminPaymentSession `json:"payment_sessions,omitempty"`

	// Payments The payment collection's payments.
	Payments *[]AdminPayment `json:"payments,omitempty"`

	// RefundedAmount The total refunded amount of the collection's payments.
	RefundedAmount *float32 `json:"refunded_amount,omitempty"`

	// RegionId The ID of the region this payment collection is associated with.
	RegionId string `json:"region_id"`

	// Status The payment collection's status.
	Status AdminPaymentCollectionStatus `json:"status"`

	// UpdatedAt The date the payment collection was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AdminPaymentCollectionStatus The payment collection's status.
type AdminPaymentCollectionStatus string

// AdminPaymentCollectionResponse The payment collection's details.
type AdminPaymentCollectionResponse struct {
	// PaymentCollection The payment collection's details.
	PaymentCollection AdminPaymentCollection `json:"payment_collection"`
}

// AdminPaymentProvider The payment provider's details.
type AdminPaymentProvider struct {
	// Id The payment provider's ID.
	Id string `json:"id"`

	// IsEnabled Whether the payment provider is enabled.
	IsEnabled bool `json:"is_enabled"`
}

// AdminPaymentResponse The payment's details.
type AdminPaymentResponse struct {
	// Payment The payment's details.
	Payment AdminPayment `json:"payment"`
}

// AdminPaymentSession The payment session's details.
type AdminPaymentSession struct {
	// Amount The payment session's amount.
	Amount float32 `json:"amount"`

	// AuthorizedAt The date the payment session was authorized.
	AuthorizedAt *time.Time `json:"authorized_at,omitempty"`

	// Context The context around the payment, such as the customer's details.
	Context *map[string]interface{} `json:"context,omitempty"`

	// CurrencyCode The payment session's currency code.
	CurrencyCode string `json:"currency_code"`

	// Data The payment session's data, useful for the payment provider processing the payment.
	Data map[string]interface{} `json:"data"`

	// Id The payment session's ID.
	Id string `json:"id"`

	// Payment The payment's details.
	Payment           *BasePayment            `json:"payment,omitempty"`
	PaymentCollection *map[string]interface{} `json:"payment_collection,omitempty"`

	// ProviderId The ID of the payment provider processing this session.
	ProviderId string `json:"provider_id"`

	// Status The payment session's status.
	Status AdminPaymentSessionStatus `json:"status"`
}

// AdminPaymentSessionStatus The payment session's status.
type AdminPaymentSessionStatus string

// AdminPostCancelClaimReqSchema The details of canceling a claim.
type AdminPostCancelClaimReqSchema struct {
	// NoNotification Whether to send the customer a notification about the claim's cancelation.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostCancelExchangeReqSchema The details of canceling an exchange.
type AdminPostCancelExchangeReqSchema struct {
	// NoNotification Whether to send a notification to the customer about the exchange's cancelation.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostCancelReturnReqSchema The details of canceling a return.
type AdminPostCancelReturnReqSchema struct {
	// NoNotification Whether to send the customer a notification about the return's cancelation.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostClaimItemsReqSchema The details of the order items to add to the claim.
type AdminPostClaimItemsReqSchema struct {
	// Items The item's details.
	Items *[]struct {
		// Description The item's description.
		Description *string `json:"description,omitempty"`

		// Id The ID of the order's item.
		Id string `json:"id"`

		// InternalNote A note that's only viewed by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Quantity The quantity of the order's item to add to the claim.
		Quantity float32 `json:"quantity"`

		// Reason The reason the item is claimed.
		Reason *AdminPostClaimItemsReqSchemaItemsReason `json:"reason,omitempty"`
	} `json:"items,omitempty"`
}

// AdminPostClaimItemsReqSchemaItemsReason The reason the item is claimed.
type AdminPostClaimItemsReqSchemaItemsReason string

// AdminPostClaimsAddItemsReqSchema The details of the outbound items to add to the claim.
type AdminPostClaimsAddItemsReqSchema struct {
	// Items The outbound item's details.
	Items *[]struct {
		// InternalNote A note viewed only by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Metadata The item's metadata, can hold custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Quantity The quantity to send to the customer.
		Quantity float32 `json:"quantity"`

		// UnitPrice The item's unit price.
		UnitPrice *float32 `json:"unit_price,omitempty"`

		// VariantId The ID of the associated product variant.
		VariantId string `json:"variant_id"`
	} `json:"items,omitempty"`
}

// AdminPostClaimsItemsActionReqSchema The details to update in the item.
type AdminPostClaimsItemsActionReqSchema struct {
	// InternalNote A note that's only viewed by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`

	// ReasonId The ID of the return reason associated with the item.
	ReasonId *string `json:"reason_id,omitempty"`
}

// AdminPostClaimsShippingActionReqSchema The details to update in the shipping method.
type AdminPostClaimsShippingActionReqSchema struct {
	// CustomAmount The shipping method's custom amount.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// InternalNote A note only viewed by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The claim's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AdminPostClaimsShippingReqSchema The details of the shipping method used to ship outbound items.
type AdminPostClaimsShippingReqSchema struct {
	// CustomAmount Set a custom price for the shipping method.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note only viewed by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The claim's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`
}

// AdminPostExchangesAddItemsReqSchema The details of outbound items.
type AdminPostExchangesAddItemsReqSchema struct {
	// Items The details of outbound items.
	Items *[]struct {
		// AllowBackorder Whether the item can be added even if it's not in stock.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// InternalNote A note viewed only by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Metadata The item's metadata, can hold custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Quantity The item's quantity.
		Quantity float32 `json:"quantity"`

		// UnitPrice The item's unit price.
		UnitPrice *float32 `json:"unit_price,omitempty"`

		// VariantId The ID of the associated product variant.
		VariantId string `json:"variant_id"`
	} `json:"items,omitempty"`
}

// AdminPostExchangesItemsActionReqSchema The details to update in an outbound item.
type AdminPostExchangesItemsActionReqSchema struct {
	// InternalNote A note only viewed by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`
}

// AdminPostExchangesRequestItemsReturnActionReqSchema The details to update in an inbound (returned) item.
type AdminPostExchangesRequestItemsReturnActionReqSchema struct {
	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`

	// ReasonId The ID of the associated return reason.
	ReasonId *string `json:"reason_id,omitempty"`
}

// AdminPostExchangesReturnRequestItemsReqSchema The details of the inbound (return) items.
type AdminPostExchangesReturnRequestItemsReqSchema struct {
	// Items The details of the inbound (return) items.
	Items *[]struct {
		// Description The item's description.
		Description *string `json:"description,omitempty"`

		// Id The ID of the order's item.
		Id string `json:"id"`

		// InternalNote A note viewed only by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Metadata The item's metadata, can hold custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Quantity The item's quantity.
		Quantity float32 `json:"quantity"`

		// ReasonId The ID of the return reason to associate with the item.
		ReasonId *string `json:"reason_id,omitempty"`
	} `json:"items,omitempty"`
}

// AdminPostExchangesShippingActionReqSchema The details of the shipping method to update.
type AdminPostExchangesShippingActionReqSchema struct {
	// CustomAmount The shipping method's custom amount.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// InternalNote A note viewed by admin users only.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AdminPostExchangesShippingReqSchema The outbound shipping method's details.
type AdminPostExchangesShippingReqSchema struct {
	// CustomAmount Set a custom amount for the shipping method.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed by admin users only.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`
}

// AdminPostOrderClaimsReqSchema The claim's details.
type AdminPostOrderClaimsReqSchema struct {
	// Description The claim's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The claim's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderId The ID of the order the claim is created for.
	OrderId string `json:"order_id"`

	// ReasonId The ID of the associated return reason.
	ReasonId *string `json:"reason_id,omitempty"`

	// Type The claim's type.
	Type AdminPostOrderClaimsReqSchemaType `json:"type"`
}

// AdminPostOrderClaimsReqSchemaType The claim's type.
type AdminPostOrderClaimsReqSchemaType string

// AdminPostOrderEditsAddItemsReqSchema The details of items to be edited.
type AdminPostOrderEditsAddItemsReqSchema struct {
	// Items The details of items to be edited.
	Items *[]struct {
		// AllowBackorder Whether the item can be added even if there's no available invenotory quantity of the variant.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// InternalNote A note viewed only by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Metadata The item's metadata, can hold custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Quantity The item's quantity.
		Quantity float32 `json:"quantity"`

		// UnitPrice The item's unit price.
		UnitPrice *float32 `json:"unit_price,omitempty"`

		// VariantId The ID of the associated product variant.
		VariantId string `json:"variant_id"`
	} `json:"items,omitempty"`
}

// AdminPostOrderEditsItemsActionReqSchema The details to update in the item.
type AdminPostOrderEditsItemsActionReqSchema struct {
	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`
}

// AdminPostOrderEditsReqSchema The order edit's details.
type AdminPostOrderEditsReqSchema struct {
	// Description The order edit's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The order edit's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderId The ID of the order this edit is for.
	OrderId string `json:"order_id"`
}

// AdminPostOrderEditsShippingActionReqSchema The shipping method's details.
type AdminPostOrderEditsShippingActionReqSchema struct {
	// CustomAmount Set a custom price for the shipping method.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The order edit's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AdminPostOrderEditsShippingReqSchema The shipping method's details.
type AdminPostOrderEditsShippingReqSchema struct {
	// CustomAmount Set a custom price for the shipping method.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The shipping method's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`
}

// AdminPostOrderEditsUpdateItemQuantityReqSchema The order item's details to update.
type AdminPostOrderEditsUpdateItemQuantityReqSchema struct {
	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`
}

// AdminPostOrderExchangesReqSchema The exchange's details.
type AdminPostOrderExchangesReqSchema struct {
	// Description The exchange's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderId The ID of the order this exchange is created for.
	OrderId string `json:"order_id"`
}

// AdminPostReceiveReturnsReqSchema The return receival details.
type AdminPostReceiveReturnsReqSchema struct {
	// Description The return's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The return's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AdminPostReturnsConfirmRequestReqSchema The confirmation's details.
type AdminPostReturnsConfirmRequestReqSchema struct {
	// NoNotification Whether to send the customer a notification about the confirmation.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostReturnsDismissItemsActionReqSchema The details to update of the damaged item.
type AdminPostReturnsDismissItemsActionReqSchema struct {
	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`
}

// AdminPostReturnsReceiveItemsActionReqSchema The details of the received item.
type AdminPostReturnsReceiveItemsActionReqSchema struct {
	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`
}

// AdminPostReturnsReceiveItemsReqSchema The items details.
type AdminPostReturnsReceiveItemsReqSchema struct {
	// Items The items details.
	Items *[]struct {
		// Description The item's description.
		Description *string `json:"description,omitempty"`

		// Id The ID of the item in the order.
		Id string `json:"id"`

		// InternalNote A note viewed only by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Quantity The item's quantity.
		Quantity float32 `json:"quantity"`
	} `json:"items,omitempty"`
}

// AdminPostReturnsReqSchema The return's details.
type AdminPostReturnsReqSchema struct {
	// Description The return's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// LocationId The ID of the location the items are returned to.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata The return's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification Whether to send the customer a notification about the created return.
	NoNotification *bool `json:"no_notification,omitempty"`

	// OrderId The ID of the order the return belongs to.
	OrderId string `json:"order_id"`
}

// AdminPostReturnsRequestItemsActionReqSchema The details to update in the item.
type AdminPostReturnsRequestItemsActionReqSchema struct {
	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The claim's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The item's quantity.
	Quantity *float32 `json:"quantity,omitempty"`

	// ReasonId The ID of the associated return reason.
	ReasonId *string `json:"reason_id,omitempty"`
}

// AdminPostReturnsRequestItemsReqSchema The items' details.
type AdminPostReturnsRequestItemsReqSchema struct {
	// Items The items' details.
	Items *[]struct {
		// Description The item's description.
		Description *string `json:"description,omitempty"`

		// Id The item's ID.
		Id string `json:"id"`

		// InternalNote A note viewed only by admin users.
		InternalNote *string `json:"internal_note,omitempty"`

		// Metadata The item's metadata, can hold custom key-value pairs.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Quantity The item's quantity.
		Quantity float32 `json:"quantity"`

		// ReasonId The ID of the associated return reason.
		ReasonId *string `json:"reason_id,omitempty"`
	} `json:"items,omitempty"`
}

// AdminPostReturnsReturnReqSchema The return's details.
type AdminPostReturnsReturnReqSchema struct {
	// LocationId The ID of the location to return items to.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata The return's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification Whether the customer should receive notifications about updates to the return.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostReturnsShippingActionReqSchema The shipping method's details.
type AdminPostReturnsShippingActionReqSchema struct {
	// CustomAmount Set a custom price for the shipping method.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The return's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AdminPostReturnsShippingReqSchema The shipping method's details.
type AdminPostReturnsShippingReqSchema struct {
	// CustomAmount Set the price of the shipping method.
	CustomAmount *float32 `json:"custom_amount,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// InternalNote A note viewed only by admin users.
	InternalNote *string `json:"internal_note,omitempty"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`
}

// AdminPrice The price's details.
type AdminPrice struct {
	// Amount The price's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the price was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The price's currency code.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date the price was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The price's ID.
	Id string `json:"id"`

	// MaxQuantity The maximum quantity allowed to be available in the cart for the price to be applied.
	MaxQuantity float32 `json:"max_quantity"`

	// MinQuantity The minimum quantity that must be available in the cart for the price to be applied.
	MinQuantity float32 `json:"min_quantity"`

	// PriceSetId The ID of the associated price set.
	PriceSetId string `json:"price_set_id"`

	// RawAmount The price's raw amount.
	RawAmount map[string]interface{} `json:"raw_amount"`

	// Title The price's title.
	Title string `json:"title"`

	// UpdatedAt The date the price was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminPriceList The price list's details.
type AdminPriceList struct {
	// CreatedAt The date the price list was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the price list was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The price list's description.
	Description string `json:"description"`

	// EndsAt The date the price list ends.
	EndsAt string `json:"ends_at"`

	// Id The price list's ID.
	Id string `json:"id"`

	// Prices The price list's prices.
	Prices []AdminPriceListPrice `json:"prices"`

	// Rules The price list's rules.
	Rules map[string]interface{} `json:"rules"`

	// StartsAt The date the price list starts.
	StartsAt string `json:"starts_at"`

	// Status The price list's status.
	Status AdminPriceListStatus `json:"status"`

	// Title The price list's title.
	Title string `json:"title"`

	// Type The price list's type.
	Type AdminPriceListType `json:"type"`

	// UpdatedAt The date the price list was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminPriceListStatus The price list's status.
type AdminPriceListStatus string

// AdminPriceListType The price list's type.
type AdminPriceListType string

// AdminPriceListBatchResponse The details of the created, updated, and deleted prices in a price list.
type AdminPriceListBatchResponse struct {
	// Created The created prices.
	Created []AdminPrice `json:"created"`

	// Deleted The details of the deleted prices.
	Deleted struct {
		// Deleted Whether the prices were deleted.
		Deleted bool `json:"deleted"`

		// Ids The IDs of the deleted prices.
		Ids []string `json:"ids"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	} `json:"deleted"`

	// Updated The updated prices.
	Updated []AdminPrice `json:"updated"`
}

// AdminPriceListDeleteResponse The details of the deleted price list.
type AdminPriceListDeleteResponse struct {
	// Deleted Whether the price list was deleted.
	Deleted bool `json:"deleted"`

	// Id The price list's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminPriceListListResponse The paginated list of price lists.
type AdminPriceListListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// PriceLists The list of price lists.
	PriceLists []AdminPriceList `json:"price_lists"`
}

// AdminPriceListPrice The details of a price list's price.
type AdminPriceListPrice struct {
	// Amount The price's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the price was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The price's currency code.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date the price was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The price's ID.
	Id string `json:"id"`

	// MaxQuantity The maximum quantity allowed to be available in the cart for the price to be applied.
	MaxQuantity float32 `json:"max_quantity"`

	// MinQuantity The minimum quantity that must be available in the cart for the price to be applied.
	MinQuantity float32 `json:"min_quantity"`

	// PriceSetId The ID of the price set this price belongs to.
	PriceSetId string `json:"price_set_id"`

	// RawAmount The price's raw amount.
	RawAmount map[string]interface{} `json:"raw_amount"`

	// Rules The price's rules.
	Rules map[string]interface{} `json:"rules"`

	// Title The price's title.
	Title string `json:"title"`

	// UpdatedAt The date the price was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantId The ID of the product variant this price list is for.
	VariantId string `json:"variant_id"`
}

// AdminPriceListResponse The price list's details.
type AdminPriceListResponse struct {
	// PriceList The price list's details.
	PriceList AdminPriceList `json:"price_list"`
}

// AdminPricePreference The price preference's details.
type AdminPricePreference struct {
	// Attribute The price preference's attribute.
	Attribute string `json:"attribute"`

	// CreatedAt The date the price preference was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the price preference was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The price preference's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether prices matching this preference include taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// UpdatedAt The date the price preference was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The price preference's value.
	Value string `json:"value"`
}

// AdminPricePreferenceDeleteResponse The details of the deleted price preference.
type AdminPricePreferenceDeleteResponse struct {
	// Deleted Whether the price preference was deleted.
	Deleted bool `json:"deleted"`

	// Id The price preference's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminPricePreferenceListResponse The paginated list of price preferences.
type AdminPricePreferenceListResponse struct {
	// Count The total count of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// PricePreferences The list of price preferences.
	PricePreferences []AdminPricePreference `json:"price_preferences"`
}

// AdminPricePreferenceResponse The price preference's details.
type AdminPricePreferenceResponse struct {
	// PricePreference The price preference's details.
	PricePreference AdminPricePreference `json:"price_preference"`
}

// AdminProduct The product's details.
type AdminProduct struct {
	// Categories The product's categories.
	Categories *[]AdminProductCategory `json:"categories,omitempty"`

	// Collection The product collection's details.
	Collection *AdminCollection `json:"collection,omitempty"`

	// CollectionId The ID of the collection that the product belongs to.
	CollectionId string `json:"collection_id"`

	// CreatedAt The date the product was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the product was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The product's description.
	Description string `json:"description"`

	// Discountable Whether discounts can be applied on the product.
	Discountable bool `json:"discountable"`

	// ExternalId The ID of a product in an external system, such as an ERP or CMS.
	ExternalId string `json:"external_id"`

	// Handle The product's unique handle.
	Handle string `json:"handle"`

	// Height The product's height.
	Height float32 `json:"height"`

	// HsCode The product's HS code.
	HsCode string `json:"hs_code"`

	// Id The product's ID.
	Id string `json:"id"`

	// Images The product's images.
	Images []AdminProductImage `json:"images"`

	// IsGiftcard Whether the product is a gift card.
	IsGiftcard bool `json:"is_giftcard"`

	// Length The product's length.
	Length float32 `json:"length"`

	// Material The product's material.
	Material string `json:"material"`

	// Metadata The product's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's MID code.
	MidCode string `json:"mid_code"`

	// Options The product's options.
	Options []AdminProductOption `json:"options"`

	// OriginCountry The product's origin country.
	OriginCountry string `json:"origin_country"`

	// SalesChannels The sales channels that the product is available in.
	SalesChannels *[]AdminSalesChannel `json:"sales_channels,omitempty"`

	// Status The product's status.
	Status AdminProductStatus `json:"status"`

	// Subtitle The product's subtitle.
	Subtitle string `json:"subtitle"`

	// Tags The product's tags.
	Tags *[]AdminProductTag `json:"tags,omitempty"`

	// Thumbnail The product's thumbnail.
	Thumbnail string `json:"thumbnail"`

	// Title The product's title.
	Title string `json:"title"`

	// Type The product type's details.
	Type AdminProductType `json:"type"`

	// TypeId The ID of the product's type.
	TypeId string `json:"type_id"`

	// UpdatedAt The date the product was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variants The product's variants.
	Variants []AdminProductVariant `json:"variants"`

	// Weight The product's weight.
	Weight float32 `json:"weight"`

	// Width The product's width.
	Width float32 `json:"width"`
}

// AdminProductStatus The product's status.
type AdminProductStatus string

// AdminProductCategory The product category's details.
type AdminProductCategory struct {
	// CategoryChildren The category's children.
	CategoryChildren []map[string]interface{} `json:"category_children"`

	// CreatedAt The date the category was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the category was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The category's description.
	Description string `json:"description"`

	// Handle The category's unique handle.
	Handle string `json:"handle"`

	// Id The category's ID.
	Id string `json:"id"`

	// IsActive Whether the category is active. If disabled, the category isn't shown in the storefront.
	IsActive bool `json:"is_active"`

	// IsInternal Whether the category is internal. If enabled, the category is only seen by admin users.
	IsInternal bool `json:"is_internal"`

	// Metadata The category's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The category's name.
	Name           string                 `json:"name"`
	ParentCategory map[string]interface{} `json:"parent_category"`

	// ParentCategoryId The ID of the category's parent.
	ParentCategoryId string `json:"parent_category_id"`

	// Products The category's products.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// Rank The category's rank among sibling categories.
	Rank float32 `json:"rank"`

	// UpdatedAt The date the category was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminProductCategoryDeleteResponse The details of deleting the category.
type AdminProductCategoryDeleteResponse struct {
	// Deleted Whether the product category was deleted.
	Deleted bool `json:"deleted"`

	// Id The product category's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminProductCategoryListResponse The paginated list of product categories.
type AdminProductCategoryListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// ProductCategories The list of product categories.
	ProductCategories []AdminProductCategory `json:"product_categories"`
}

// AdminProductCategoryResponse The product category's details.
type AdminProductCategoryResponse struct {
	// ProductCategory The product category's details.
	ProductCategory AdminProductCategory `json:"product_category"`
}

// AdminProductDeleteResponse The details of the product deletion.
type AdminProductDeleteResponse struct {
	// Deleted Whether the product was deleted.
	Deleted bool `json:"deleted"`

	// Id The product's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminProductImage The image's details.
type AdminProductImage struct {
	// CreatedAt The date the image was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the image was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The image's ID.
	Id string `json:"id"`

	// Metadata The image's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the image was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url The image's URL.
	Url string `json:"url"`
}

// AdminProductOption The product option's details.
type AdminProductOption struct {
	// CreatedAt The date the product option was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the product option was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The product option's ID.
	Id string `json:"id"`

	// Metadata The product option's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Product  *map[string]interface{} `json:"product,omitempty"`

	// ProductId The ID of the product this option belongs to.
	ProductId *string `json:"product_id,omitempty"`

	// Title The product option's title.
	Title string `json:"title"`

	// UpdatedAt The date the product option was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Values The product option's values.
	Values *[]map[string]interface{} `json:"values,omitempty"`
}

// AdminProductOptionDeleteResponse The details of the product option deletion.
type AdminProductOptionDeleteResponse struct {
	// Deleted Whether the product option was deleted.
	Deleted bool `json:"deleted"`

	// Id The product option's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`

	// Parent The product's details.
	Parent *AdminProduct `json:"parent,omitempty"`
}

// AdminProductOptionResponse The product option's details.
type AdminProductOptionResponse struct {
	// ProductOption The product option's details.
	ProductOption AdminProductOption `json:"product_option"`
}

// AdminProductOptionValue The product option value's details.
type AdminProductOptionValue struct {
	// CreatedAt The date the value was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the value was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The value's ID.
	Id string `json:"id"`

	// Metadata The value's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Option The product option's details.
	Option *AdminProductOption `json:"option,omitempty"`

	// OptionId The ID of the option this value belongs to.
	OptionId *string `json:"option_id,omitempty"`

	// UpdatedAt The date the value was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value The value.
	Value string `json:"value"`
}

// AdminProductResponse The product's details.
type AdminProductResponse struct {
	// Product The product's details.
	Product AdminProduct `json:"product"`
}

// AdminProductTag The product tag's details.
type AdminProductTag struct {
	// CreatedAt The date the tag was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the tag was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The tag's ID.
	Id string `json:"id"`

	// Metadata The tag's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the tag was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The tag's value.
	Value string `json:"value"`
}

// AdminProductTagDeleteResponse The details of the product tag deletion.
type AdminProductTagDeleteResponse struct {
	// Deleted Whether the product tag was deleted.
	Deleted bool `json:"deleted"`

	// Id The product tag's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminProductTagListResponse The paginated list of product tags.
type AdminProductTagListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// ProductTags The list of product tags.
	ProductTags []AdminProductTag `json:"product_tags"`
}

// AdminProductTagResponse The product tag's details.
type AdminProductTagResponse struct {
	// ProductTag The product tag's details.
	ProductTag AdminProductTag `json:"product_tag"`
}

// AdminProductType The product type's details.
type AdminProductType struct {
	// CreatedAt The date the type was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the type was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The type's ID.
	Id string `json:"id"`

	// Metadata The type's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the type was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The type's value.
	Value string `json:"value"`
}

// AdminProductTypeDeleteResponse The details of the product type deletion.
type AdminProductTypeDeleteResponse struct {
	// Deleted Whether the product type was deleted.
	Deleted bool `json:"deleted"`

	// Id The product type's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminProductTypeListResponse The paginated list of product types.
type AdminProductTypeListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// ProductTypes The list of product types.
	ProductTypes []AdminProductType `json:"product_types"`
}

// AdminProductTypeResponse The product type's details.
type AdminProductTypeResponse struct {
	// ProductType The product type's details.
	ProductType AdminProductType `json:"product_type"`
}

// AdminProductVariant The product variant's details.
type AdminProductVariant struct {
	// AllowBackorder Whether the variant can be ordered even if it's out of stock.
	AllowBackorder bool `json:"allow_backorder"`

	// Barcode The variant's barcode.
	Barcode string `json:"barcode"`

	// CalculatedPrice The calculated price's details.
	CalculatedPrice *BaseCalculatedPriceSet `json:"calculated_price,omitempty"`

	// CreatedAt The date the variant was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the variant was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Ean The variant's EAN code.
	Ean string `json:"ean"`

	// Height The variant's height.
	Height float32 `json:"height"`

	// HsCode The variant's HS code.
	HsCode string `json:"hs_code"`

	// Id The variant's ID.
	Id string `json:"id"`

	// InventoryQuantity The variant's inventory quantity. This is only included if you pass in the `fields` query parameter a `+variants.inventory_quantity` parameter.
	InventoryQuantity *float32 `json:"inventory_quantity,omitempty"`

	// Length The variant's length.
	Length float32 `json:"length"`

	// ManageInventory Whether the Medusa application manages the variant's inventory quantity and availablility. If disabled, the variant is always considered in stock.
	ManageInventory bool `json:"manage_inventory"`

	// Material The variant's material.
	Material string `json:"material"`

	// Metadata The variant's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The variant's MID code.
	MidCode string `json:"mid_code"`

	// Options The variant's option values.
	Options []AdminProductOptionValue `json:"options"`

	// OriginCountry The variant's origin country.
	OriginCountry string `json:"origin_country"`

	// Prices The variant's prices.
	Prices  []AdminPrice            `json:"prices"`
	Product *map[string]interface{} `json:"product,omitempty"`

	// ProductId The ID of the product that the variant belongs to.
	ProductId *string `json:"product_id,omitempty"`

	// Sku The variant's SKU.
	Sku string `json:"sku"`

	// Title The variant's title.
	Title string `json:"title"`

	// Upc The variant's UPC.
	Upc string `json:"upc"`

	// UpdatedAt The date the variant was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantRank The variant's rank among its sibling variants.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The variant's weight.
	Weight float32 `json:"weight"`

	// Width The variant's width.
	Width float32 `json:"width"`
}

// AdminProductVariantDeleteResponse The details of the product variant's deletion.
type AdminProductVariantDeleteResponse struct {
	// Deleted Whether the product variant was deleted.
	Deleted bool `json:"deleted"`

	// Id The product variant's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`

	// Parent The product's details.
	Parent *AdminProduct `json:"parent,omitempty"`
}

// AdminProductVariantInventoryBatchResponse The created, updated, and deleted associations between variants and inventory items.
type AdminProductVariantInventoryBatchResponse struct {
	Created AdminProductVariantInventoryBatchResponse_Created `json:"created"`
	Deleted AdminProductVariantInventoryBatchResponse_Deleted `json:"deleted"`
	Updated AdminProductVariantInventoryBatchResponse_Updated `json:"updated"`
}

// AdminProductVariantInventoryBatchResponseCreated1 The created associations between product variants and inventory items.
type AdminProductVariantInventoryBatchResponseCreated1 = []struct {
	// InventoryService The inventory item's details.
	InventoryService struct {
		// InventoryItemId The ID of the inventory item.
		InventoryItemId string `json:"inventory_item_id"`
	} `json:"inventoryService"`

	// ProductService The product variant's details.
	ProductService struct {
		// VariantId The ID of the product variant.
		VariantId string `json:"variant_id"`
	} `json:"productService"`
}

// AdminProductVariantInventoryBatchResponse_Created defines model for AdminProductVariantInventoryBatchResponse.Created.
type AdminProductVariantInventoryBatchResponse_Created struct {
	union json.RawMessage
}

// AdminProductVariantInventoryBatchResponseDeleted1 The deleted associations between product variants and inventory items.
type AdminProductVariantInventoryBatchResponseDeleted1 = []struct {
	// InventoryService The inventory item's details.
	InventoryService struct {
		// InventoryItemId The ID of the inventory item.
		InventoryItemId string `json:"inventory_item_id"`
	} `json:"inventoryService"`

	// ProductService The product variant's details.
	ProductService struct {
		// VariantId The ID of the product variant.
		VariantId string `json:"variant_id"`
	} `json:"productService"`
}

// AdminProductVariantInventoryBatchResponse_Deleted defines model for AdminProductVariantInventoryBatchResponse.Deleted.
type AdminProductVariantInventoryBatchResponse_Deleted struct {
	union json.RawMessage
}

// AdminProductVariantInventoryBatchResponseUpdated1 The updated associations between product variants and inventory items.
type AdminProductVariantInventoryBatchResponseUpdated1 = []struct {
	// InventoryService The inventory item's details.
	InventoryService struct {
		// InventoryItemId The ID of the inventory item.
		InventoryItemId string `json:"inventory_item_id"`
	} `json:"inventoryService"`

	// ProductService The product variant's details.
	ProductService struct {
		// VariantId The ID of the product variant.
		VariantId string `json:"variant_id"`
	} `json:"productService"`
}

// AdminProductVariantInventoryBatchResponse_Updated defines model for AdminProductVariantInventoryBatchResponse.Updated.
type AdminProductVariantInventoryBatchResponse_Updated struct {
	union json.RawMessage
}

// AdminProductVariantInventoryLink The details of an association between a product variant and an inventory item.
type AdminProductVariantInventoryLink struct {
	// Inventory The inventory item's details.
	Inventory struct {
		// InventoryItemId The ID of the inventory item.
		InventoryItemId string `json:"inventory_item_id"`
	} `json:"Inventory"`

	// Product The product variant's details.
	Product struct {
		// VariantId The ID of the product variant.
		VariantId string `json:"variant_id"`
	} `json:"Product"`
}

// AdminProductVariantInventoryLinkDeleteResponse The details of the deleted associated between a product variant and an inventory item.
type AdminProductVariantInventoryLinkDeleteResponse struct {
	// Deleted Whether the association was deleted.
	Deleted bool `json:"deleted"`

	// Id The details of an association between a product variant and an inventory item.
	Id AdminProductVariantInventoryLink `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`

	// Parent The product variant's details.
	Parent AdminProductVariant `json:"parent"`
}

// AdminProductVariantResponse The product variant's details.
type AdminProductVariantResponse struct {
	// Variant The product variant's details.
	Variant AdminProductVariant `json:"variant"`
}

// AdminPromotion The promotion's details.
type AdminPromotion struct {
	ApplicationMethod *map[string]interface{} `json:"application_method,omitempty"`

	// Campaign The campaign's details.
	Campaign *AdminCampaign `json:"campaign,omitempty"`

	// CampaignId The ID of the campaign this promotion belongs to.
	CampaignId *string `json:"campaign_id,omitempty"`

	// Code The promotion's code.
	Code *string `json:"code,omitempty"`

	// Id The promotion's ID.
	Id string `json:"id"`

	// IsAutomatic Whether the promotion is applied on a cart automatically if it matches the promotion's rules.
	IsAutomatic *bool `json:"is_automatic,omitempty"`

	// Rules The promotion's rules.
	Rules *[]AdminPromotionRule `json:"rules,omitempty"`

	// Type The promotion's type.
	Type *AdminPromotionType `json:"type,omitempty"`
}

// AdminPromotionType The promotion's type.
type AdminPromotionType string

// AdminPromotionResponse The promotion's details.
type AdminPromotionResponse struct {
	// Promotion The promotion's details.
	Promotion AdminPromotion `json:"promotion"`
}

// AdminPromotionRule The promotion rule's details.
type AdminPromotionRule struct {
	// Attribute The promotion rule's attribute.
	Attribute *string `json:"attribute,omitempty"`

	// Description The promotion rule's description.
	Description *string `json:"description,omitempty"`

	// Id The promotion rule's ID.
	Id string `json:"id"`

	// Operator The rule's operator.
	Operator *AdminPromotionRuleOperator `json:"operator,omitempty"`

	// Values The rule's values.
	Values []BasePromotionRuleValue `json:"values"`
}

// AdminPromotionRuleOperator The rule's operator.
type AdminPromotionRuleOperator string

// AdminRefund The refund's details.
type AdminRefund struct {
	// Amount The refund's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the refund was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the refund.
	CreatedBy *string `json:"created_by,omitempty"`

	// Id The refund's ID.
	Id string `json:"id"`

	// Note More details about the refund.
	Note *string `json:"note,omitempty"`

	// Payment The payment's details.
	Payment BasePayment `json:"payment"`

	// RefundReason The refund reason's details.
	RefundReason *RefundReason `json:"refund_reason,omitempty"`

	// RefundReasonId The ID of the refund reason.
	RefundReasonId *string `json:"refund_reason_id,omitempty"`
}

// AdminRefundReason The refund reason's details.
type AdminRefundReason struct {
	// CreatedAt The date the refund reason was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The refund reason's description.
	Description *string `json:"description,omitempty"`

	// Id The refund reason's ID.
	Id string `json:"id"`

	// Label The refund reason's label.
	Label string `json:"label"`

	// Metadata The refund reason's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// UpdatedAt The date the refund reason was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminRegion The region's details.
type AdminRegion struct {
	// AutomaticTaxes Whether taxes are applied automatically during checkout.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// Countries The region's countries.
	Countries *[]AdminRegionCountry `json:"countries,omitempty"`

	// CreatedAt The date the region was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The region's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The region's ID.
	Id string `json:"id"`

	// Metadata The region's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The region's name.
	Name string `json:"name"`

	// PaymentProviders The region's payment providers.
	PaymentProviders *[]AdminPaymentProvider `json:"payment_providers,omitempty"`

	// UpdatedAt The date the region was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AdminRegionCountry The country's details.
type AdminRegionCountry struct {
	// DisplayName The country's display name.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The country's ID.
	Id string `json:"id"`

	// Iso2 The country's iso 2.
	Iso2 *string `json:"iso_2,omitempty"`

	// Iso3 The country's iso 3.
	Iso3 *string `json:"iso_3,omitempty"`

	// Name The country's name.
	Name *string `json:"name,omitempty"`

	// NumCode The country's num code.
	NumCode *string `json:"num_code,omitempty"`
}

// AdminRegionResponse The region's details.
type AdminRegionResponse struct {
	// Region The region's details.
	Region AdminRegion `json:"region"`
}

// AdminReservation The reservation's details.
type AdminReservation struct {
	// CreatedAt The date this reservation was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatedBy The ID of the user that created this reservation.
	CreatedBy *string `json:"created_by,omitempty"`

	// DeletedAt The date this reservation was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Description The reservation's description.
	Description string `json:"description"`

	// ExternalId An ID in an external system
	ExternalId string `json:"external_id"`

	// Id The reservation's ID.
	Id string `json:"id"`

	// InventoryItem The reservation's inventory item.
	InventoryItem *AdminInventoryItem `json:"inventory_item,omitempty"`

	// InventoryItemId The ID of the inventory item this reservation is associated with.
	InventoryItemId string `json:"inventory_item_id"`

	// LineItemId The ID of the line item this reservation is for.
	LineItemId string `json:"line_item_id"`

	// LocationId The ID of the location the quantity is reserved from.
	LocationId string `json:"location_id"`

	// Metadata The reservation's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The reservation's quantity.
	Quantity float32 `json:"quantity"`

	// UpdatedAt The date this reservation was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// AdminReservationResponse The reservation's details.
type AdminReservationResponse struct {
	// Reservation The reservation's details.
	Reservation AdminReservation `json:"reservation"`
}

// AdminReturn The return's details.
type AdminReturn struct {
	// CanceledAt The date the return was canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// ClaimId The return's claim id.
	ClaimId *string `json:"claim_id,omitempty"`

	// CreatedAt The date the return was created.
	CreatedAt time.Time `json:"created_at"`

	// DisplayId The return's display id.
	DisplayId float32 `json:"display_id"`

	// ExchangeId The return's exchange id.
	ExchangeId *string `json:"exchange_id,omitempty"`

	// Id The return's ID.
	Id string `json:"id"`

	// Items The return's items.
	Items []AdminReturnItem `json:"items"`

	// LocationId The return's location id.
	LocationId *string `json:"location_id,omitempty"`

	// NoNotification Whether the customer should receive notifications about the return's updates.
	NoNotification *bool `json:"no_notification,omitempty"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// OrderVersion The return's order version.
	OrderVersion float32 `json:"order_version"`

	// ReceivedAt The date the return was received.
	ReceivedAt string `json:"received_at"`

	// RefundAmount The amount refunded by this return.
	RefundAmount *float32 `json:"refund_amount,omitempty"`

	// Status The return's status.
	Status *AdminReturnStatus `json:"status,omitempty"`
}

// AdminReturnStatus The return's status.
type AdminReturnStatus string

// AdminReturnItem The return item's details.
type AdminReturnItem struct {
	// DamagedQuantity The received damaged quantity of the item, which isn't added to the stocked inventory quantity of the item.
	DamagedQuantity float32 `json:"damaged_quantity"`

	// Id The return item's ID.
	Id string `json:"id"`

	// ItemId The ID of the associated order item.
	ItemId string `json:"item_id"`

	// Metadata The return item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Note A note about why the item was returned.
	Note *string `json:"note,omitempty"`

	// Quantity The return item's quantity.
	Quantity float32 `json:"quantity"`

	// ReasonId The ID of the return reason associated with the item.
	ReasonId *string `json:"reason_id,omitempty"`

	// ReceivedQuantity The received quantity of the item. This quantity is added to the stocked inventory quantity of the item.
	ReceivedQuantity float32 `json:"received_quantity"`

	// ReturnId The ID of the return this return item belongs to.
	ReturnId string `json:"return_id"`
}

// AdminReturnPreviewResponse The details of a return and a preview of the order once the return is applied.
type AdminReturnPreviewResponse struct {
	// OrderPreview A preview of an order if a change, such as exchange, return, edit, or claim is applied on it.
	OrderPreview AdminOrderPreview `json:"order_preview"`

	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminReturnReason The return reason's details.
type AdminReturnReason struct {
	// CreatedAt The date the return reason was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The return reason's description.
	Description *string `json:"description,omitempty"`

	// Id The return reason's ID.
	Id string `json:"id"`

	// Label The return reason's label.
	Label string `json:"label"`

	// Metadata The return reason's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the return reason was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The return reason's value.
	Value string `json:"value"`
}

// AdminReturnReasonDeleteResponse The details of the return reason deletion.
type AdminReturnReasonDeleteResponse struct {
	// Deleted Whether the return reason was deleted.
	Deleted bool `json:"deleted"`

	// Id The return reason's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminReturnReasonListResponse The paginated list of return reasons.
type AdminReturnReasonListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// ReturnReasons The list of return reasons.
	ReturnReasons []AdminReturnReason `json:"return_reasons"`
}

// AdminReturnReasonResponse The return reason's details.
type AdminReturnReasonResponse struct {
	// ReturnReason The return reason's details.
	ReturnReason AdminReturnReason `json:"return_reason"`
}

// AdminReturnResponse The return's details.
type AdminReturnResponse struct {
	// Return The return's details.
	Return AdminReturn `json:"return"`
}

// AdminRevokeApiKey The details of revoking the API key.
type AdminRevokeApiKey struct {
	// RevokeIn The time in seconds to revoke the API key after. If not set, the API key is revoked immediately.
	RevokeIn *float32 `json:"revoke_in,omitempty"`
}

// AdminRuleAttributeOption The details of a potential rule attribute.
type AdminRuleAttributeOption struct {
	// Id The rule attribute's ID, which is a rule's `attribute` it refers to.
	Id string `json:"id"`

	// Label The rule attribute option's label.
	Label string `json:"label"`

	// Operators The attribute's operators.
	Operators []BaseRuleOperatorOptions `json:"operators"`

	// Value The rule attribute's value.
	Value string `json:"value"`
}

// AdminRuleValueOption The details of a potential rule value.
type AdminRuleValueOption struct {
	// Label The rule value's label.
	Label string `json:"label"`

	// Value The rule value's value.
	Value string `json:"value"`
}

// AdminSalesChannel The sales channel's details.
type AdminSalesChannel struct {
	// CreatedAt The date the sales channel was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the sales channel was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The sales channel's description.
	Description string `json:"description"`

	// Id The sales channel's ID.
	Id string `json:"id"`

	// IsDisabled Whether the sales channel is disabled.
	IsDisabled bool `json:"is_disabled"`

	// Metadata The sales channel's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The sales channel's name.
	Name string `json:"name"`

	// UpdatedAt The date the sales channel was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminSalesChannelDeleteResponse The details of deleting a sales channel.
type AdminSalesChannelDeleteResponse struct {
	// Deleted Whether the sales channel was deleted.
	Deleted bool `json:"deleted"`

	// Id The sales channel's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminSalesChannelResponse The sales channel's details.
type AdminSalesChannelResponse struct {
	// SalesChannel The sales channel's details.
	SalesChannel AdminSalesChannel `json:"sales_channel"`
}

// AdminServiceZone The shipping option's service zone.
type AdminServiceZone struct {
	// CreatedAt The service zone's created at.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The service zone's deleted at.
	DeletedAt      time.Time              `json:"deleted_at"`
	FulfillmentSet map[string]interface{} `json:"fulfillment_set"`

	// FulfillmentSetId The service zone's fulfillment set id.
	FulfillmentSetId string `json:"fulfillment_set_id"`

	// GeoZones The service zone's geo zones.
	GeoZones []AdminGeoZone `json:"geo_zones"`

	// Id The service zone's ID.
	Id string `json:"id"`

	// Name The service zone's name.
	Name string `json:"name"`

	// ShippingOptions The service zone's shipping options.
	ShippingOptions []AdminShippingOption `json:"shipping_options"`

	// UpdatedAt The service zone's updated at.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminServiceZoneDeleteResponse The details of the service zone deletion.
type AdminServiceZoneDeleteResponse struct {
	// Deleted Whether the service zone was deleted.
	Deleted bool `json:"deleted"`

	// Id The service zone's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`

	// Parent The service zone's fulfillment set.
	Parent *AdminFulfillmentSet `json:"parent,omitempty"`
}

// AdminServiceZoneResponse The service zone's details.
type AdminServiceZoneResponse struct {
	// ServiceZone The shipping option's service zone.
	ServiceZone AdminServiceZone `json:"service_zone"`
}

// AdminShippingOption The shipping option's details.
type AdminShippingOption struct {
	// CreatedAt The date the shipping option was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The shipping option's data, useful for the fulfillment provider handling fulfillments created from this option.
	Data map[string]interface{} `json:"data"`

	// DeletedAt The date the shipping option was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The shipping option's ID.
	Id string `json:"id"`

	// Metadata The shipping option's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The shipping option's name.
	Name string `json:"name"`

	// PriceType The shipping option's price type. If it's `flat`, the price is fixed and is set in the `prices` property. If it's `calculated`, the price is calculated on checkout by the associated fulfillment provider.
	PriceType AdminShippingOptionPriceType `json:"price_type"`

	// Prices The shipping option's prices. If the `price_type` is `calculated`, this array will be empty since the price is calculated by the fulfillment provider during checkout.
	Prices []AdminShippingOptionPrice `json:"prices"`

	// Provider The fulfillment provider's details.
	Provider AdminFulfillmentProvider `json:"provider"`

	// ProviderId The ID of the provider handling fulfillments created from this shipping option.
	ProviderId string `json:"provider_id"`

	// Rules The shipping option's rules.
	Rules       []AdminShippingOptionRule `json:"rules"`
	ServiceZone map[string]interface{}    `json:"service_zone"`

	// ServiceZoneId The ID of the service zone this option belongs to.
	ServiceZoneId string `json:"service_zone_id"`

	// ShippingOptionTypeId The ID of the associated shipping option type.
	ShippingOptionTypeId string `json:"shipping_option_type_id"`

	// ShippingProfile The shipping profile's details..
	ShippingProfile AdminShippingProfile `json:"shipping_profile"`

	// ShippingProfileId The ID of the associated shipping profile.
	ShippingProfileId string `json:"shipping_profile_id"`

	// Type The shipping option's details.
	Type AdminShippingOptionType `json:"type"`

	// UpdatedAt The date the shipping option was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminShippingOptionPriceType The shipping option's price type. If it's `flat`, the price is fixed and is set in the `prices` property. If it's `calculated`, the price is calculated on checkout by the associated fulfillment provider.
type AdminShippingOptionPriceType string

// AdminShippingOptionDeleteResponse The details of the shipping option's deletion.
type AdminShippingOptionDeleteResponse struct {
	// Deleted Whether the shipping option was deleted.
	Deleted bool `json:"deleted"`

	// Id The shipping option's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminShippingOptionPrice The details of the shipping option's price.
type AdminShippingOptionPrice struct {
	// Amount The price's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the price was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The price's currency code.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date the price was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The price's ID.
	Id string `json:"id"`

	// MaxQuantity The maximum quantity that the cart's items must not surpass for this price to apply.
	MaxQuantity float32 `json:"max_quantity"`

	// MinQuantity The minimum quantity required in the cart for this price to apply.
	MinQuantity float32 `json:"min_quantity"`

	// PriceRules The price's rules.
	PriceRules []AdminShippingOptionPriceRule `json:"price_rules"`

	// PriceSetId The ID of the price set this price belongs to.
	PriceSetId string `json:"price_set_id"`

	// RawAmount The price's raw amount.
	RawAmount map[string]interface{} `json:"raw_amount"`

	// RulesCount The number of rules the price has.
	RulesCount float32 `json:"rules_count"`

	// Title The price's title.
	Title string `json:"title"`

	// UpdatedAt The date the price was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminShippingOptionPriceRule The details of a shipping option price's rule.
type AdminShippingOptionPriceRule struct {
	// Id The price rule's ID.
	Id string `json:"id"`

	// Value The price rule's value.
	Value string `json:"value"`
}

// AdminShippingOptionResponse The shipping option's details.
type AdminShippingOptionResponse struct {
	// ShippingOption The shipping option's details.
	ShippingOption AdminShippingOption `json:"shipping_option"`
}

// AdminShippingOptionRule The shipping option rule's details.
type AdminShippingOptionRule struct {
	// Attribute The shipping option rule's attribute.
	Attribute string `json:"attribute"`

	// CreatedAt The date the shipping option rule was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the shipping option rule was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The shipping option rule's ID.
	Id string `json:"id"`

	// Operator The shipping option rule's operator.
	Operator string `json:"operator"`

	// ShippingOptionId The ID of the shipping option this rule is for.
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date the shipping option rule was updated.
	UpdatedAt time.Time                     `json:"updated_at"`
	Value     AdminShippingOptionRule_Value `json:"value"`
}

// AdminShippingOptionRuleValue0 The rule's value.
type AdminShippingOptionRuleValue0 = string

// AdminShippingOptionRuleValue1 The rule's values.
type AdminShippingOptionRuleValue1 = []string

// AdminShippingOptionRule_Value defines model for AdminShippingOptionRule.Value.
type AdminShippingOptionRule_Value struct {
	union json.RawMessage
}

// AdminShippingOptionType The shipping option's details.
type AdminShippingOptionType struct {
	// Code The type's code.
	Code string `json:"code"`

	// CreatedAt The date the shipping option was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the shipping option was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The type's description.
	Description string `json:"description"`

	// Id The shipping option's ID.
	Id string `json:"id"`

	// Label The type's label.
	Label string `json:"label"`

	// ShippingOptionId The type's shipping option id.
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date the shipping option was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminShippingProfile The shipping profile's details..
type AdminShippingProfile struct {
	// CreatedAt The date the shipping profile was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the shipping profile was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The shipping profile's ID.
	Id string `json:"id"`

	// Metadata The shipping profile's metadata, holds custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The shipping profile's name.
	Name string `json:"name"`

	// Type The shipping profile's type.
	Type string `json:"type"`

	// UpdatedAt The date the shipping profile was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminShippingProfileDeleteResponse The details of the shipping profile's deletion.
type AdminShippingProfileDeleteResponse struct {
	// Deleted Whether the shipping profile was deleted.
	Deleted bool `json:"deleted"`

	// Id The shipping profile's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminShippingProfileResponse The shipping profile's details.
type AdminShippingProfileResponse struct {
	// ShippingProfile The shipping profile's details..
	ShippingProfile AdminShippingProfile `json:"shipping_profile"`
}

// AdminStockLocation The stock location's details.
type AdminStockLocation struct {
	// Address The details of the stock location address.
	Address *AdminStockLocationAddress `json:"address,omitempty"`

	// AddressId The ID of the associated address.
	AddressId string `json:"address_id"`

	// FulfillmentProviders The fulfillment providers associated with the location.
	FulfillmentProviders *[]AdminFulfillmentProvider `json:"fulfillment_providers,omitempty"`

	// FulfillmentSets The fulfillment sets associated with the location.
	FulfillmentSets *[]map[string]interface{} `json:"fulfillment_sets,omitempty"`

	// Id The location's ID.
	Id string `json:"id"`

	// Name The location's name.
	Name string `json:"name"`

	// SalesChannels The sales channels associated with the location.
	SalesChannels *[]AdminSalesChannel `json:"sales_channels,omitempty"`
}

// AdminStockLocationAddress The details of the stock location address.
type AdminStockLocationAddress struct {
	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 string `json:"address_2"`

	// City The address's city.
	City string `json:"city"`

	// Company The address's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// Id The address's ID.
	Id string `json:"id"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`
}

// AdminStockLocationDeleteResponse The details of the stock location's deletion.
type AdminStockLocationDeleteResponse struct {
	// Deleted Whether the stock location was deleted.
	Deleted bool `json:"deleted"`

	// Id The stock location's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminStockLocationListResponse The paginated list of stock locations.
type AdminStockLocationListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// StockLocations The list of stock locations.
	StockLocations []AdminStockLocation `json:"stock_locations"`
}

// AdminStockLocationResponse The stock location's details.
type AdminStockLocationResponse struct {
	// StockLocation The stock location's details.
	StockLocation AdminStockLocation `json:"stock_location"`
}

// AdminStore The store's details.
type AdminStore struct {
	// CreatedAt The date the store was created.
	CreatedAt time.Time `json:"created_at"`

	// DefaultLocationId The ID of the stock location used by default in the store.
	DefaultLocationId string `json:"default_location_id"`

	// DefaultRegionId The ID of the region used by default in the store.
	DefaultRegionId string `json:"default_region_id"`

	// DefaultSalesChannelId The ID of the sales channel used by default in the store.
	DefaultSalesChannelId string `json:"default_sales_channel_id"`

	// Id The store's ID.
	Id string `json:"id"`

	// Metadata The store's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The store's name.
	Name string `json:"name"`

	// SupportedCurrencies The store's supported currencies.
	SupportedCurrencies []AdminStoreCurrency `json:"supported_currencies"`

	// UpdatedAt The date the store was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminStoreCurrency The details of a store's currency.
type AdminStoreCurrency struct {
	// CreatedAt The date the currency was created.
	CreatedAt time.Time `json:"created_at"`

	// Currency The currency's currencies.
	Currency AdminCurrency `json:"currency"`

	// CurrencyCode The currency's code.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date the currency was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The currency's ID.
	Id string `json:"id"`

	// IsDefault Whether this currency is the default in the store.
	IsDefault bool `json:"is_default"`

	// StoreId The ID of the store this currency belongs to.
	StoreId string `json:"store_id"`

	// UpdatedAt The date the currency was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminStoreListResponse The paginated list of stores.
type AdminStoreListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// Stores The list of stores.
	Stores []AdminStore `json:"stores"`
}

// AdminStoreResponse The store's details.
type AdminStoreResponse struct {
	// Store The store's details.
	Store AdminStore `json:"store"`
}

// AdminTaxRate The tax rate's details.
type AdminTaxRate struct {
	// Code The code the tax rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax rate was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the tax rate.
	CreatedBy string `json:"created_by"`

	// DeletedAt The date the tax rate was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The tax rate's ID.
	Id string `json:"id"`

	// IsCombinable Whether the tax rate should be combined with parent rates.
	IsCombinable bool `json:"is_combinable"`

	// IsDefault Whether this tax rate is the default in the tax region.
	IsDefault bool `json:"is_default"`

	// Metadata The tax rate's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The tax rate's name.
	Name string `json:"name"`

	// Rate The rate to charge.
	Rate float32 `json:"rate"`

	// Rules The tax rate's rules.
	Rules []AdminTaxRateRule `json:"rules"`

	// TaxRegion The tax region's details.
	TaxRegion AdminTaxRegion `json:"tax_region"`

	// TaxRegionId The ID of the tax region this rate belongs to.
	TaxRegionId string `json:"tax_region_id"`

	// UpdatedAt The date the tax rate was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminTaxRateDeleteResponse The details of the tax rate deletion.
type AdminTaxRateDeleteResponse struct {
	// Deleted Whether the tax rate was deleted.
	Deleted bool `json:"deleted"`

	// Id The tax rate's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminTaxRateResponse The tax rate's details.
type AdminTaxRateResponse struct {
	// TaxRate The tax rate's details.
	TaxRate AdminTaxRate `json:"tax_rate"`
}

// AdminTaxRateRule The tax rate rule's details.
type AdminTaxRateRule struct {
	// Reference The name of the table this rule references.
	Reference string `json:"reference"`

	// ReferenceId The ID of a record in the table that this rule references.
	ReferenceId string `json:"reference_id"`
}

// AdminTaxRegion The tax region's details.
type AdminTaxRegion struct {
	// Children The tax region's children.
	Children []map[string]interface{} `json:"children"`

	// CountryCode The tax region's country code.
	CountryCode string `json:"country_code"`

	// CreatedAt The date the tax region was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the tax region.
	CreatedBy string `json:"created_by"`

	// DeletedAt The date the tax region was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Id The tax region's ID.
	Id string `json:"id"`

	// Metadata The tax region's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`
	Parent   map[string]interface{} `json:"parent"`

	// ParentId The ID of the parent tax region.
	ParentId string `json:"parent_id"`

	// ProvinceCode The tax region's province code.
	ProvinceCode string `json:"province_code"`

	// TaxRates The tax region's rates.
	TaxRates []map[string]interface{} `json:"tax_rates"`

	// UpdatedAt The date the tax region was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminTaxRegionDeleteResponse The details of the tax region deletion.
type AdminTaxRegionDeleteResponse struct {
	// Deleted Whether the tax region was deleted.
	Deleted bool `json:"deleted"`

	// Id The tax region's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminTaxRegionResponse The tax region's details.
type AdminTaxRegionResponse struct {
	// TaxRegion The tax region's details.
	TaxRegion AdminTaxRegion `json:"tax_region"`
}

// AdminUpdateApiKey The details to update in an API key.
type AdminUpdateApiKey struct {
	// Title The API key's title.
	Title string `json:"title"`
}

// AdminUpdateCollection The details to update in a collection.
type AdminUpdateCollection struct {
	// Handle The collection's handle.
	Handle *string `json:"handle,omitempty"`

	// Metadata The collection's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Title The collection's title.
	Title *string `json:"title,omitempty"`
}

// AdminUpdateCustomerGroup The details to update in a customer group.
type AdminUpdateCustomerGroup struct {
	// Metadata The customer group's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The customer group's name.
	Name *string `json:"name,omitempty"`
}

// AdminUpdatePriceList the details to update in a price list.
type AdminUpdatePriceList struct {
	// Description The price list's description.
	Description *string `json:"description,omitempty"`

	// EndsAt The date the price list ends.
	EndsAt *string `json:"ends_at,omitempty"`

	// Rules The price list's rules.
	Rules *map[string]interface{} `json:"rules,omitempty"`

	// StartsAt The date the price list starts.
	StartsAt *string `json:"starts_at,omitempty"`

	// Status The price list's status.
	Status *AdminUpdatePriceListStatus `json:"status,omitempty"`

	// Title The price list's title.
	Title *string `json:"title,omitempty"`

	// Type The price list's type.
	Type *AdminUpdatePriceListType `json:"type,omitempty"`
}

// AdminUpdatePriceListStatus The price list's status.
type AdminUpdatePriceListStatus string

// AdminUpdatePriceListType The price list's type.
type AdminUpdatePriceListType string

// AdminUpdatePricePreference The details to update in the price preference.
type AdminUpdatePricePreference struct {
	// Attribute The price preference's attribute.
	Attribute *string `json:"attribute,omitempty"`

	// IsTaxInclusive Whether prices are tax inclusive for this price preference.
	IsTaxInclusive *bool `json:"is_tax_inclusive,omitempty"`

	// Value The price preference's value.
	Value *string `json:"value,omitempty"`
}

// AdminUpdateProduct The product's details.
type AdminUpdateProduct struct {
	// Categories The product's categories.
	Categories *[]struct {
		// Id The category's ID.
		Id string `json:"id"`
	} `json:"categories,omitempty"`

	// CollectionId The ID of the product's collection.
	CollectionId *string `json:"collection_id,omitempty"`

	// Description The product's description.
	Description *string `json:"description,omitempty"`

	// Discountable Whether discounts can be applied on the product.
	Discountable *bool `json:"discountable,omitempty"`

	// Handle The product's unique handle.
	Handle *string `json:"handle,omitempty"`

	// Height The product's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The product's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Images The product's images.
	Images *[]struct {
		// Url The image's URL.
		Url string `json:"url"`
	} `json:"images,omitempty"`

	// IsGiftcard Whether the product is a gift card.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// Length The product's length.
	Length *float32 `json:"length,omitempty"`

	// Material The product's material.
	Material *string `json:"material,omitempty"`

	// Metadata The product's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The product's options.
	Options *[]AdminUpdateProductOption `json:"options,omitempty"`

	// OriginCountry The product's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// SalesChannels The sales channels that the product is available in.
	SalesChannels *[]struct {
		// Id The sales channel's ID.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// Status The product's status.
	Status *AdminUpdateProductStatus `json:"status,omitempty"`

	// Subtitle The product's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags The product's tags.
	Tags *[]struct {
		// Id The tag's ID.
		Id string `json:"id"`
	} `json:"tags,omitempty"`

	// Thumbnail The product's thumbnail URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The product's title.
	Title *string `json:"title,omitempty"`

	// TypeId The ID of the product's type.
	TypeId *string `json:"type_id,omitempty"`

	// Variants The product's variants. You can add new variants or update existing ones, passing their IDs in the object.
	Variants *[]AdminUpdateProduct_Variants_Item `json:"variants,omitempty"`

	// Weight The product's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The product's width.
	Width *float32 `json:"width,omitempty"`
}

// AdminUpdateProductStatus The product's status.
type AdminUpdateProductStatus string

// AdminUpdateProduct_Variants_Item defines model for AdminUpdateProduct.variants.Item.
type AdminUpdateProduct_Variants_Item struct {
	union json.RawMessage
}

// AdminUpdateProductOption The details to update in a product option.
type AdminUpdateProductOption struct {
	// Title The option's title.
	Title *string `json:"title,omitempty"`

	// Values The option's values.
	Values *[]string `json:"values,omitempty"`
}

// AdminUpdateProductVariant The properties to update of a product variant.
type AdminUpdateProductVariant struct {
	// AllowBackorder Whether customers can order the variant even if it's not in stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode The product variant's barcode.
	Barcode *string `json:"barcode,omitempty"`

	// Ean The product variant's EAN.
	Ean *string `json:"ean,omitempty"`

	// Height The product variant's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The product variant's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Length The product variant's length.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether the Medusa application manages the variant's inventory. If disabled, the product variant is always considered in stock.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The product variant's material.
	Material *string `json:"material,omitempty"`

	// Metadata The product variant's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product variant's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The product variant's options.
	Options *map[string]interface{} `json:"options,omitempty"`

	// OriginCountry The product variant's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Prices The product variant's prices.
	Prices *[]AdminCreateProductVariantPrice `json:"prices,omitempty"`

	// Sku The product variant's SKU.
	Sku *string `json:"sku,omitempty"`

	// Title The product variant's title.
	Title *string `json:"title,omitempty"`

	// Upc The product variant's UPC.
	Upc *string `json:"upc,omitempty"`

	// VariantRank The product variant's rank among its siblings.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The product variant's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The product variant's width.
	Width *float32 `json:"width,omitempty"`
}

// AdminUpdatePromotionRule The properties to update in a buy rule.
type AdminUpdatePromotionRule struct {
	// Attribute The attribute to compare against when checking whether a promotion can be applied on a cart.
	Attribute *string `json:"attribute,omitempty"`

	// Description The buy rule's description.
	Description *string `json:"description,omitempty"`

	// Id The buy rule's ID.
	Id string `json:"id"`

	// Operator The operator used to check whether the buy rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
	Operator *AdminUpdatePromotionRuleOperator `json:"operator,omitempty"`
	Values   AdminUpdatePromotionRule_Values   `json:"values"`
}

// AdminUpdatePromotionRuleOperator The operator used to check whether the buy rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
type AdminUpdatePromotionRuleOperator string

// AdminUpdatePromotionRuleValues0 The attribute's value.
type AdminUpdatePromotionRuleValues0 = string

// AdminUpdatePromotionRuleValues1 The allowed attribute values.
type AdminUpdatePromotionRuleValues1 = []string

// AdminUpdatePromotionRule_Values defines model for AdminUpdatePromotionRule.Values.
type AdminUpdatePromotionRule_Values struct {
	union json.RawMessage
}

// AdminUpdateReturnReason The details to update in a return reason.
type AdminUpdateReturnReason struct {
	// Description The return reason's description.
	Description *string `json:"description,omitempty"`

	// Label The return reason's label.
	Label string `json:"label"`

	// Metadata The return reason's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value The return reason's value.
	Value string `json:"value"`
}

// AdminUpdateSalesChannel The properties to update in the sales channel.
type AdminUpdateSalesChannel struct {
	// Description The sales channel's description.
	Description *string `json:"description,omitempty"`

	// IsDisabled Whether the sales channel is disabled.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Metadata The sales channel's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The sales channel's name.
	Name *string `json:"name,omitempty"`
}

// AdminUpdateShippingOptionRule The properties to update in the shipping option rule.
type AdminUpdateShippingOptionRule struct {
	// Attribute The name of a property or table that the rule applies to.
	Attribute string `json:"attribute"`

	// Id The rule's ID.
	Id string `json:"id"`

	// Operator The operator used to check whether a rule applies.
	Operator AdminUpdateShippingOptionRuleOperator `json:"operator"`
	Value    AdminUpdateShippingOptionRule_Value   `json:"value"`
}

// AdminUpdateShippingOptionRuleOperator The operator used to check whether a rule applies.
type AdminUpdateShippingOptionRuleOperator string

// AdminUpdateShippingOptionRuleValue0 A value of the attribute that enables this rule.
type AdminUpdateShippingOptionRuleValue0 = string

// AdminUpdateShippingOptionRuleValue1 Values of the attribute that enable this rule.
type AdminUpdateShippingOptionRuleValue1 = []string

// AdminUpdateShippingOptionRule_Value defines model for AdminUpdateShippingOptionRule.Value.
type AdminUpdateShippingOptionRule_Value struct {
	union json.RawMessage
}

// AdminUpdateStockLocation The properties to update in a stock location.
type AdminUpdateStockLocation struct {
	// Address The stock location's address. Pass this property if you're creating a new address to associate with the location.
	Address *struct {
		// Address1 The address's first line.
		Address1 string `json:"address_1"`

		// Address2 The address's second line.
		Address2 *string `json:"address_2,omitempty"`

		// City The address's city.
		City *string `json:"city,omitempty"`

		// Company The address's company.
		Company *string `json:"company,omitempty"`

		// CountryCode The address's country code.
		CountryCode string `json:"country_code"`

		// Phone The address's phone.
		Phone *string `json:"phone,omitempty"`

		// PostalCode The address's postal code.
		PostalCode *string `json:"postal_code,omitempty"`

		// Province The address's province.
		Province *string `json:"province,omitempty"`
	} `json:"address,omitempty"`

	// AddressId The ID of an existing stock location address to associate the stock location with.
	AddressId *string `json:"address_id,omitempty"`

	// Metadata The stock location's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The stock location's name.
	Name *string `json:"name,omitempty"`
}

// AdminUpdateStore The properties to update in a store.
type AdminUpdateStore struct {
	// DefaultLocationId The ID of the default stock location in the store.
	DefaultLocationId *string `json:"default_location_id,omitempty"`

	// DefaultRegionId The ID of the default region in the store.
	DefaultRegionId *string `json:"default_region_id,omitempty"`

	// DefaultSalesChannelId The ID of the default sales channel in the store.
	DefaultSalesChannelId *string `json:"default_sales_channel_id,omitempty"`

	// Metadata The store's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The store's name.
	Name *string `json:"name,omitempty"`

	// SupportedCurrencies The store's supported currencies.
	SupportedCurrencies *[]struct {
		// CurrencyCode The currency's code.
		CurrencyCode string `json:"currency_code"`

		// IsDefault Whether the currency is the default in the store.
		IsDefault *bool `json:"is_default,omitempty"`

		// IsTaxInclusive Whether prices using this currency are tax inclusive.
		IsTaxInclusive *bool `json:"is_tax_inclusive,omitempty"`
	} `json:"supported_currencies,omitempty"`
}

// AdminUpdateTaxRate The properties to update in the tax rate.
type AdminUpdateTaxRate struct {
	// Code The code that the tax rate is identified by.
	Code *string `json:"code,omitempty"`

	// IsCombinable Whether the tax rate should be combined with parent rates.
	IsCombinable *bool `json:"is_combinable,omitempty"`

	// IsDefault Whether the tax rate is the default in the store.
	IsDefault *bool `json:"is_default,omitempty"`

	// Metadata The tax rate's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The tax rate's name.
	Name *string `json:"name,omitempty"`

	// Rate The rate to charge.
	Rate *float32 `json:"rate,omitempty"`

	// Rules The tax rate's rules.
	Rules *[]struct {
		// Reference The name of the table this rule references.
		Reference string `json:"reference"`

		// ReferenceId The ID of the record in the table that the rule references.
		ReferenceId string `json:"reference_id"`
	} `json:"rules,omitempty"`
}

// AdminUpdateUser The properties to update in a user.
type AdminUpdateUser struct {
	// AvatarUrl The URL of the user's avatar.
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// FirstName The user's first name.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The user's last name.
	LastName *string `json:"last_name,omitempty"`
}

// AdminUpdateVariantInventoryItem The properties to update of the variant's inventory item association.
type AdminUpdateVariantInventoryItem struct {
	// RequiredQuantity The number of units a single quantity is equivalent to. For example, if a customer orders one quantity of the variant, Medusa checks the availability of the quantity multiplied by the value set for `required_quantity`. When the customer orders the quantity, Medusa reserves the ordered quantity multiplied by the value set for `required_quantity`.
	RequiredQuantity float32 `json:"required_quantity"`
}

// AdminUpsertStockLocationAddress The details of the stock location address to create.
type AdminUpsertStockLocationAddress struct {
	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`
}

// AdminUser The user's details.
type AdminUser struct {
	// AvatarUrl The URL of the user's avatar.
	AvatarUrl string `json:"avatar_url"`

	// CreatedAt The date the user was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the user was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Email The user's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The user's first name.
	FirstName string `json:"first_name"`

	// Id The user's ID.
	Id string `json:"id"`

	// LastName The user's last name.
	LastName string `json:"last_name"`

	// Metadata The user's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// UpdatedAt The date the user was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AdminUserDeleteResponse The details of the deleted user.
type AdminUserDeleteResponse struct {
	// Deleted Whether the user was deleted.
	Deleted bool `json:"deleted"`

	// Id The user's ID.
	Id string `json:"id"`

	// Object The name of the deleted object.
	Object string `json:"object"`
}

// AdminUserListResponse The paginated list of users.
type AdminUserListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// Users The list of users.
	Users []AdminUser `json:"users"`
}

// AdminUserResponse The user's details.
type AdminUserResponse struct {
	// User The user's details.
	User AdminUser `json:"user"`
}

// AdminWorkflowExecution The workflows execution's details.
type AdminWorkflowExecution struct {
	// Context The workflow execution's context.
	Context WorkflowExecutionContext `json:"context"`

	// CreatedAt The date the workflow execution was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the workflow execution was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Execution The workflow execution's steps details.
	Execution AdminWorkflowExecutionExecution `json:"execution"`

	// Id The workflow execution's ID.
	Id string `json:"id"`

	// State The workflow execution's state.
	State AdminWorkflowExecutionState `json:"state"`

	// TransactionId The workflow execution's transaction ID.
	TransactionId string `json:"transaction_id"`

	// UpdatedAt The date the workflow execution was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// WorkflowId The ID of the workflow.
	WorkflowId string `json:"workflow_id"`
}

// AdminWorkflowExecutionState The workflow execution's state.
type AdminWorkflowExecutionState string

// AdminWorkflowExecutionExecution The workflow execution's steps details.
type AdminWorkflowExecutionExecution struct {
	// Steps The execution's steps. Each object key is a step ID, and the value is the object whose properties are shown below.
	Steps map[string]struct {
		// Compensate The state of the step's compensation function.
		Compensate *struct {
			// State The compensation function's state.
			State AdminWorkflowExecutionExecutionStepsCompensateState `json:"state"`

			// Status The compensation function's status.
			Status AdminWorkflowExecutionExecutionStepsCompensateStatus `json:"status"`
		} `json:"compensate,omitempty"`

		// Definition The step's definition details.
		Definition *struct {
			// Async Whether the step is async.
			Async *bool `json:"async,omitempty"`

			// CompensateAsync Whether the compensation function of the step is async.
			CompensateAsync *bool `json:"compensateAsync,omitempty"`

			// ContinueOnPermanentFailure Whether the step continues executing even if its status is changed to failed.
			ContinueOnPermanentFailure *bool `json:"continueOnPermanentFailure,omitempty"`

			// MaxRetries The maximum number of times to retry the step.
			MaxRetries *float32 `json:"maxRetries,omitempty"`

			// NoCompensation Whether the step doesn't have a compensation function.
			NoCompensation *bool `json:"noCompensation,omitempty"`

			// NoWait Whether the workflow shouldn't wait for the step to finish before moving to the next step.
			NoWait *bool `json:"noWait,omitempty"`

			// RetryInterval The interval in seconds between retry attempts when the step fails.
			RetryInterval *float32 `json:"retryInterval,omitempty"`

			// RetryIntervalAwaiting The interval in seconds to retry a step even if its status is `waiting_response`.
			RetryIntervalAwaiting *float32 `json:"retryIntervalAwaiting,omitempty"`

			// SaveResponse Whether the step's response is stored.
			SaveResponse *bool `json:"saveResponse,omitempty"`

			// Timeout The maximum time in seconds to wait for this step to complete. If the step exceeds this time, the step's state is changed to `timeout`, but the step continues executing.
			Timeout *float32 `json:"timeout,omitempty"`
		} `json:"definition,omitempty"`

		// Depth The step's depth in the workflow's execution.
		Depth *float32 `json:"depth,omitempty"`

		// Id The step's ID.
		Id *string `json:"id,omitempty"`

		// Invoke The state of the step's invokation function.
		Invoke *struct {
			// State The invokation step's state.
			State AdminWorkflowExecutionExecutionStepsInvokeState `json:"state"`

			// Status The invokation step's state.
			Status AdminWorkflowExecutionExecutionStepsInvokeStatus `json:"status"`
		} `json:"invoke,omitempty"`

		// StartedAt The timestamp the step started executing.
		StartedAt *float32 `json:"startedAt,omitempty"`
	} `json:"steps"`
}

// AdminWorkflowExecutionResponse The workflow execution's details.
type AdminWorkflowExecutionResponse struct {
	// WorkflowExecution The workflows execution's details.
	WorkflowExecution AdminWorkflowExecution `json:"workflow_execution"`
}

// ApiKeyResponse The API key's details.
type ApiKeyResponse struct {
	// CreatedAt The date the API key was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the API key.
	CreatedBy string `json:"created_by"`

	// Id The API key's ID.
	Id string `json:"id"`

	// LastUsedAt The date the API key was last used.
	LastUsedAt time.Time `json:"last_used_at"`

	// Redacted The redacted form of the API key's token. This is useful when showing portion of the token. For example `sk_...123`.
	Redacted string `json:"redacted"`

	// RevokedAt The date the API key was revoked.
	RevokedAt time.Time `json:"revoked_at"`

	// RevokedBy The ID of the user that revoked the API key.
	RevokedBy string `json:"revoked_by"`

	// Title The API key's title.
	Title string `json:"title"`

	// Token The API key's token.
	Token string `json:"token"`

	// Type The API key's type. `secret` API keys are used for authenticating admin users, and `publishable` API key are used for storefronts and similar clients to scope requests to sales channels.
	Type ApiKeyResponseType `json:"type"`
}

// ApiKeyResponseType The API key's type. `secret` API keys are used for authenticating admin users, and `publishable` API key are used for storefronts and similar clients to scope requests to sales channels.
type ApiKeyResponseType string

// AuthAdminSessionResponse The authenticated user's details.
type AuthAdminSessionResponse struct {
	// User The user's details.
	User AdminUser `json:"user"`
}

// AuthCallbackResponse The authentication's details.
type AuthCallbackResponse struct {
	// Location The location to redirect the user to for further authentication with the third-party provider.
	Location string `json:"location"`
}

// AuthResponse The authentication's details.
type AuthResponse struct {
	// Token The JWT token used for registration or authentication.
	Token string `json:"token"`
}

// AuthStoreSessionResponse The authenticated customer's details.
type AuthStoreSessionResponse struct {
	// User The customer's details.
	User StoreCustomer `json:"user"`
}

// BaseCalculatedPriceSet The calculated price's details.
type BaseCalculatedPriceSet struct {
	// CalculatedAmount The amount of the calculated price, or `null` if there isn't a calculated price. This is the amount shown to the customer.
	CalculatedAmount float32 `json:"calculated_amount"`

	// CalculatedAmountWithTax The calculated price's amount with taxes applied.
	CalculatedAmountWithTax *float32 `json:"calculated_amount_with_tax,omitempty"`

	// CalculatedAmountWithoutTax The calculated price's amount without taxes applied.
	CalculatedAmountWithoutTax *float32 `json:"calculated_amount_without_tax,omitempty"`

	// CalculatedPrice The calculated price's details.
	CalculatedPrice *struct {
		// Id The calculated price's ID.
		Id string `json:"id"`

		// MaxQuantity The maximum quantity required in the cart for this price to apply.
		MaxQuantity float32 `json:"max_quantity"`

		// MinQuantity The minimum quantity required in the cart for this price to apply.
		MinQuantity float32 `json:"min_quantity"`

		// PriceListId The ID of the price list that the price belongs to.
		PriceListId string `json:"price_list_id"`

		// PriceListType The price list's type. For example, `sale`.
		PriceListType string `json:"price_list_type"`
	} `json:"calculated_price,omitempty"`

	// CurrencyCode The calculated price's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The calculated price's ID.
	Id string `json:"id"`

	// IsCalculatedPricePriceList Whether the calculated price belongs to a price list.
	IsCalculatedPricePriceList *bool `json:"is_calculated_price_price_list,omitempty"`

	// IsCalculatedPriceTaxInclusive Whether the calculated price is tax inclusive.
	IsCalculatedPriceTaxInclusive *bool `json:"is_calculated_price_tax_inclusive,omitempty"`

	// IsOriginalPricePriceList Whether the original price belongs to a price list.
	IsOriginalPricePriceList *bool `json:"is_original_price_price_list,omitempty"`

	// IsOriginalPriceTaxInclusive Whether the original price is tax inclusive.
	IsOriginalPriceTaxInclusive *bool `json:"is_original_price_tax_inclusive,omitempty"`

	// OriginalAmount The amount of the original price, or `null` if there isn't an original price. This amount is useful to compare with the `calculated_amount`, such as to check for discounted value.
	OriginalAmount float32 `json:"original_amount"`

	// OriginalPrice The original price's details.
	OriginalPrice *struct {
		// Id The original price's ID.
		Id string `json:"id"`

		// MaxQuantity The maximum quantity required in the cart for this price to apply.
		MaxQuantity float32 `json:"max_quantity"`

		// MinQuantity The minimum quantity required in the cart for this price to apply.
		MinQuantity float32 `json:"min_quantity"`

		// PriceListId The ID of the price list that the price belongs to.
		PriceListId string `json:"price_list_id"`

		// PriceListType The price list's type. For example, `sale`.
		PriceListType string `json:"price_list_type"`
	} `json:"original_price,omitempty"`
}

// BaseCapture The details of a captured payment.
type BaseCapture struct {
	// Amount The captured amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the capture was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that captured the payment.
	CreatedBy *string `json:"created_by,omitempty"`

	// Id The payment capture's ID.
	Id      string                 `json:"id"`
	Payment map[string]interface{} `json:"payment"`
}

// BaseCart The item's cart.
type BaseCart struct {
	// BillingAddress The cart's shipping address.
	BillingAddress *BaseCartAddress `json:"billing_address,omitempty"`

	// CreatedAt The cart's created at.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The cart's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The cart's customer id.
	CustomerId *string `json:"customer_id,omitempty"`

	// DiscountTaxTotal The cart's discount tax total.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The cart's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// Email The cart's email.
	Email *openapi_types.Email `json:"email,omitempty"`

	// GiftCardTaxTotal The cart's gift card tax total.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The cart's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The cart's ID.
	Id string `json:"id"`

	// ItemSubtotal The cart's item subtotal.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The cart's item tax total.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The cart's item total.
	ItemTotal float32 `json:"item_total"`

	// Items The cart's items.
	Items *[]map[string]interface{} `json:"items,omitempty"`

	// Metadata The cart's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OriginalItemSubtotal The cart's original item subtotal.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The cart's original item tax total.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The cart's original item total.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The cart's original shipping subtotal.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The cart's original shipping tax total.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The cart's original shipping total.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The cart's original subtotal.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The cart's original tax total.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The cart's original total.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollection The payment collection's details.
	PaymentCollection *BasePaymentCollection `json:"payment_collection,omitempty"`

	// Region The region's details.
	Region *BaseRegion `json:"region,omitempty"`

	// RegionId The cart's region id.
	RegionId *string `json:"region_id,omitempty"`

	// SalesChannelId The cart's sales channel id.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`

	// ShippingAddress The cart's shipping address.
	ShippingAddress *BaseCartAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The cart's shipping methods.
	ShippingMethods *[]BaseCartShippingMethod `json:"shipping_methods,omitempty"`

	// ShippingSubtotal The cart's shipping subtotal.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The cart's shipping tax total.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The cart's shipping total.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The cart's subtotal.
	Subtotal float32 `json:"subtotal"`

	// TaxTotal The cart's tax total.
	TaxTotal float32 `json:"tax_total"`

	// Total The cart's total.
	Total float32 `json:"total"`

	// UpdatedAt The cart's updated at.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BaseCartAddress The cart's shipping address.
type BaseCartAddress = map[string]interface{}

// BaseCartLineItem The tax line's item.
type BaseCartLineItem struct {
	// Adjustments The item's adjustments.
	Adjustments *[]BaseLineItemAdjustment `json:"adjustments,omitempty"`

	// Cart The item's cart.
	Cart BaseCart `json:"cart"`

	// CartId The item's cart id.
	CartId string `json:"cart_id"`

	// CompareAtUnitPrice The item's compare at unit price.
	CompareAtUnitPrice *float32 `json:"compare_at_unit_price,omitempty"`

	// CreatedAt The item's created at.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The item's deleted at.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// DiscountTaxTotal The item's discount tax total.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The item's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// Id The item's ID.
	Id string `json:"id"`

	// IsDiscountable The item's is discountable.
	IsDiscountable bool `json:"is_discountable"`

	// IsTaxInclusive The item's is tax inclusive.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// ItemSubtotal The item's item subtotal.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The item's item tax total.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The item's item total.
	ItemTotal float32 `json:"item_total"`

	// Metadata The item's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OriginalSubtotal The item's original subtotal.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The item's original tax total.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The item's original total.
	OriginalTotal float32 `json:"original_total"`

	// Product The parent's product.
	Product *BaseProduct `json:"product,omitempty"`

	// ProductCollection The item's product collection.
	ProductCollection *string `json:"product_collection,omitempty"`

	// ProductDescription The item's product description.
	ProductDescription *string `json:"product_description,omitempty"`

	// ProductHandle The item's product handle.
	ProductHandle *string `json:"product_handle,omitempty"`

	// ProductId The item's product id.
	ProductId *string `json:"product_id,omitempty"`

	// ProductSubtitle The item's product subtitle.
	ProductSubtitle *string `json:"product_subtitle,omitempty"`

	// ProductTitle The item's product title.
	ProductTitle *string `json:"product_title,omitempty"`

	// ProductType The item's product type.
	ProductType *string `json:"product_type,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// RequiresShipping The item's requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// Subtitle The item's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Subtotal The item's subtotal.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The item's tax lines.
	TaxLines *[]map[string]interface{} `json:"tax_lines,omitempty"`

	// TaxTotal The item's tax total.
	TaxTotal float32 `json:"tax_total"`

	// Thumbnail The item's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The item's title.
	Title string `json:"title"`

	// Total The item's total.
	Total float32 `json:"total"`

	// UnitPrice The item's unit price.
	UnitPrice float32 `json:"unit_price"`

	// UpdatedAt The item's updated at.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Variant The product variant's details.
	Variant *BaseProductVariant `json:"variant,omitempty"`

	// VariantBarcode The item's variant barcode.
	VariantBarcode *string `json:"variant_barcode,omitempty"`

	// VariantId The item's variant id.
	VariantId *string `json:"variant_id,omitempty"`

	// VariantOptionValues The item's variant option values.
	VariantOptionValues *map[string]interface{} `json:"variant_option_values,omitempty"`

	// VariantSku The item's variant sku.
	VariantSku *string `json:"variant_sku,omitempty"`

	// VariantTitle The item's variant title.
	VariantTitle *string `json:"variant_title,omitempty"`
}

// BaseCartShippingMethod A cart's shipping method.
type BaseCartShippingMethod struct {
	// Adjustments The shipping method's adjustments, such as applied promotions.
	Adjustments *[]BaseShippingMethodAdjustment `json:"adjustments,omitempty"`

	// Amount The shipping method's amount.
	Amount float32 `json:"amount"`

	// CartId The ID of the cart this shipping method belongs to.
	CartId string `json:"cart_id"`

	// CreatedAt The date the shipping method was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The shipping method's data, useful for fulfillment handling by third-party services.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// DiscountTaxTotal The taxes applied on the discounted amount.
	DiscountTaxTotal string `json:"discount_tax_total"`

	// DiscountTotal The total amount discounted.
	DiscountTotal string `json:"discount_total"`

	// Id The shipping method's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether the shipping method's amount is tax inclusive.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// Metadata The shipping method's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The shipping method's name.
	Name string `json:"name"`

	// OriginalSubtotal The shipping method's total excluding taxes, including promotions.
	OriginalSubtotal string `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes applied on the shipping method's amount including promotions.
	OriginalTaxTotal string `json:"original_tax_total"`

	// OriginalTotal The shipping method's total including taxes, excluding promotions.
	OriginalTotal string `json:"original_total"`

	// ShippingOptionId The ID of the shipping option this method was created from.
	ShippingOptionId *string `json:"shipping_option_id,omitempty"`

	// Subtotal The shipping method's total amount excluding taxes, including promotions.
	Subtotal string `json:"subtotal"`

	// TaxLines The shipping method's tax lines.
	TaxLines *[]BaseShippingMethodTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The total taxes applied on the shipping method's amount including promotions.
	TaxTotal string `json:"tax_total"`

	// Total The shipping method's total amount including taxes and promotions.
	Total string `json:"total"`

	// UpdatedAt The date the shipping method was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseClaimItem The claim item's details.
type BaseClaimItem struct {
	// ClaimId The ID of the claim this item belongs to.
	ClaimId string `json:"claim_id"`

	// CreatedAt The date the claim was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id The claim item's ID.
	Id string `json:"id"`

	// ItemId The ID of the item in the order.
	ItemId string `json:"item_id"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderId The ID of the order this item belongs to.
	OrderId string `json:"order_id"`

	// Quantity The quantity claimed.
	Quantity float32 `json:"quantity"`

	// RawQuantity The quantity claimed.
	RawQuantity struct {
		Value BaseClaimItem_RawQuantity_Value `json:"value"`
	} `json:"raw_quantity"`

	// Reason The claim's reason.
	Reason BaseClaimItemReason `json:"reason"`

	// UpdatedAt The date the claim was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BaseClaimItemRawQuantityValue0 The raw quantity's value.
type BaseClaimItemRawQuantityValue0 = string

// BaseClaimItemRawQuantityValue1 The raw quantity's value.
type BaseClaimItemRawQuantityValue1 = float32

// BaseClaimItem_RawQuantity_Value defines model for BaseClaimItem.RawQuantity.Value.
type BaseClaimItem_RawQuantity_Value struct {
	union json.RawMessage
}

// BaseClaimItemReason The claim's reason.
type BaseClaimItemReason string

// BaseCollection The collection's details.
type BaseCollection = map[string]interface{}

// BaseCustomerAddress The customer's address.
type BaseCustomerAddress struct {
	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 string `json:"address_2"`

	// AddressName The address's name.
	AddressName string `json:"address_name"`

	// City The address's city.
	City string `json:"city"`

	// Company The customer's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// CreatedAt The address's creation date.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer that this address belongs to.
	CustomerId string `json:"customer_id"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// Id The address's ID.
	Id string `json:"id"`

	// IsDefaultBilling Whether the address is the default billing address.
	IsDefaultBilling bool `json:"is_default_billing"`

	// IsDefaultShipping Whether the address is the default shipping address.
	IsDefaultShipping bool `json:"is_default_shipping"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata The address's metadata, used to store custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`

	// UpdatedAt The address's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseExchangeItem The item's details.
type BaseExchangeItem struct {
	// CreatedAt The date the item was created.
	CreatedAt time.Time `json:"created_at"`

	// ExchangeId The ID of the exchange this item belongs to.
	ExchangeId string `json:"exchange_id"`

	// Id The item's ID.
	Id string `json:"id"`

	// ItemId The ID of the item in the order.
	ItemId string `json:"item_id"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderId The ID of the order this item belongs to.
	OrderId string `json:"order_id"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// UpdatedAt The date the item was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseFulfillmentProvider The fulfillment provider's details.
type BaseFulfillmentProvider struct {
	// Id The provider's ID.
	Id string `json:"id"`

	// IsEnabled Whether the provider is enabled.
	IsEnabled bool `json:"is_enabled"`
}

// BaseLineItemAdjustment The adjustment's details.
type BaseLineItemAdjustment struct {
	// Amount The adjustment's amount.
	Amount float32 `json:"amount"`

	// CartId The ID of the cart this adjustment belongs to.
	CartId string `json:"cart_id"`

	// Code The adjustment's code.
	Code *string `json:"code,omitempty"`

	// CreatedAt The date the adjustment was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The adjustment's description.
	Description *string `json:"description,omitempty"`

	// Id The adjustment's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId The ID of the item this adjustment applies on.
	ItemId string `json:"item_id"`

	// PromotionId The ID of the promotion applied by this adjustment.
	PromotionId *string `json:"promotion_id,omitempty"`

	// ProviderId The adjustment's provider ID.
	ProviderId *string `json:"provider_id,omitempty"`

	// UpdatedAt The date the adjustment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseLineItemTaxLine The tax line's details
type BaseLineItemTaxLine struct {
	// Code The code the tax rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax line was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The tax line's description.
	Description *string `json:"description,omitempty"`

	// Id The tax line's ID.
	Id string `json:"id"`

	// Item The tax line's item.
	Item BaseCartLineItem `json:"item"`

	// ItemId The ID of the item the tax line applies on.
	ItemId string `json:"item_id"`

	// ProviderId The ID of the tax provider.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rate The rate to charge.
	Rate float32 `json:"rate"`

	// Subtotal The item's subtotal excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxRateId The ID of the associated tax rate.
	TaxRateId *string `json:"tax_rate_id,omitempty"`

	// Total The item's total, including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the tax line was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrder The order's details.
type BaseOrder struct {
	// BillingAddress An order address.
	BillingAddress *AdminOrderAddress `json:"billing_address,omitempty"`

	// CreatedAt The date the order was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The order's currency code.
	CurrencyCode string `json:"currency_code"`

	// Customer The customer's details.
	Customer *AdminCustomer `json:"customer,omitempty"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId string `json:"customer_id"`

	// DiscountTaxTotal The tax total of order's discount or promotion.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The order's discount or promotions total.
	DiscountTotal float32 `json:"discount_total"`

	// DisplayId The order's display ID.
	DisplayId *float32 `json:"display_id,omitempty"`

	// Email The email of the customer that placed the order.
	Email openapi_types.Email `json:"email"`

	// FulfillmentStatus The order's fulfillment status.
	FulfillmentStatus BaseOrderFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The order's fulfillments.
	Fulfillments *[]BaseOrderFulfillment `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The tax total of the order's gift card.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The order's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The order's ID.
	Id string `json:"id"`

	// ItemSubtotal The total of the order's items excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The tax total of the order's items including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total of the order's items including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Items The order's items.
	Items []BaseOrderLineItem `json:"items"`

	// Metadata The order's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OriginalItemSubtotal The total of the order's items excluding taxes, including promotions.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The tax total of the order's items excluding promotions.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The total of the order's items including taxes, excluding promotions.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The order's shipping total excluding taxes, including promotions.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The tax total of the order's shipping excluding promotions.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The order's shipping total including taxes, excluding promotions.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The order's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The order's tax total, excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The order's total excluding promotions, including taxes.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollections The order's payment collections.
	PaymentCollections []AdminPaymentCollection `json:"payment_collections"`

	// PaymentStatus The order's payment status.
	PaymentStatus BaseOrderPaymentStatus `json:"payment_status"`

	// RegionId The ID of the region associated with the order.
	RegionId string `json:"region_id"`

	// SalesChannel The sales channel's details.
	SalesChannel *AdminSalesChannel `json:"sales_channel,omitempty"`

	// SalesChannelId The ID of the sales channel the order is placed in.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress An order address.
	ShippingAddress *AdminOrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The order's shipping methods.
	ShippingMethods []BaseOrderShippingMethod `json:"shipping_methods"`

	// ShippingSubtotal The order's shipping total excluding taxes, including promotions.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The tax total of the order's shipping.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The order's shipping total including taxes and promotions.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The order's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary details.
	Summary BaseOrderSummary `json:"summary"`

	// TaxTotal The order's tax total including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The order's total including taxes and promotions.
	Total float32 `json:"total"`

	// Transactions The order's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date the order was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order's version.
	Version float32 `json:"version"`
}

// BaseOrderFulfillmentStatus The order's fulfillment status.
type BaseOrderFulfillmentStatus string

// BaseOrderPaymentStatus The order's payment status.
type BaseOrderPaymentStatus string

// BaseOrderAddress An order address
type BaseOrderAddress struct {
	// Address1 The address's first line.
	Address1 *string `json:"address_1,omitempty"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// Country The country's details.
	Country *AdminRegionCountry `json:"country,omitempty"`

	// CountryCode The address's country code.
	CountryCode *string `json:"country_code,omitempty"`

	// CreatedAt The date the address was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer this address belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// FirstName The address's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Id The address's ID.
	Id string `json:"id"`

	// LastName The address's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`

	// UpdatedAt The date the address was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderChangeAction The action's actions.
type BaseOrderChangeAction struct {
	// Action The applied action.
	Action string `json:"action"`

	// ClaimId The ID of the associated claim.
	ClaimId string `json:"claim_id"`

	// CreatedAt The date the order change action was created.
	CreatedAt time.Time `json:"created_at"`

	// Details The action's details.
	Details map[string]interface{} `json:"details"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId string `json:"exchange_id"`

	// Id The action's ID.
	Id string `json:"id"`

	// InternalNote A note viewed only by admin users.
	InternalNote string `json:"internal_note"`

	// Order The order's details.
	Order       BaseOrder              `json:"order"`
	OrderChange map[string]interface{} `json:"order_change"`

	// OrderChangeId The ID of the order change this action belongs to.
	OrderChangeId string `json:"order_change_id"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// Reference The name of the table this action applies on.
	Reference BaseOrderChangeActionReference `json:"reference"`

	// ReferenceId The ID of the record in the referenced table.
	ReferenceId string `json:"reference_id"`

	// ReturnId The ID of the associated return.
	ReturnId string `json:"return_id"`

	// UpdatedAt The date the order change action was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderChangeActionReference The name of the table this action applies on.
type BaseOrderChangeActionReference string

// BaseOrderFulfillment The fulfillment's fulfillments.
type BaseOrderFulfillment struct {
	// CanceledAt The date the items were canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// CreatedAt The date the fulfillment was created.
	CreatedAt time.Time `json:"created_at"`

	// Data Data useful for the fulfillment provider handling it. This is taken from the associated shipping option.
	Data map[string]interface{} `json:"data"`

	// DeliveredAt The date the items were delivered.
	DeliveredAt time.Time `json:"delivered_at"`

	// Id The fulfillment's ID.
	Id string `json:"id"`

	// LocationId The ID of the location the items are fulfilled from.
	LocationId string `json:"location_id"`

	// Metadata The fulfillment's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// PackedAt The date the items were packed.
	PackedAt time.Time `json:"packed_at"`

	// ProviderId The ID of the fulfillment provider used to handle the fulfillment.
	ProviderId string `json:"provider_id"`

	// ShippedAt The date the items were shipped.
	ShippedAt time.Time `json:"shipped_at"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date the fulfillment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderItemDetail The item's detail.
type BaseOrderItemDetail struct {
	// CreatedAt The date the detail was created.
	CreatedAt time.Time `json:"created_at"`

	// DeliveredQuantity The item's delivered quantity.
	DeliveredQuantity float32 `json:"delivered_quantity"`

	// FulfilledQuantity The item's fulfilled quantity.
	FulfilledQuantity float32 `json:"fulfilled_quantity"`

	// Id the detail's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId the ID of the associated line item.
	ItemId string `json:"item_id"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// ReturnDismissedQuantity The item's quantity that's returned but damaged. So, it's not added to the underlying variant's stocked quantity.
	ReturnDismissedQuantity float32 `json:"return_dismissed_quantity"`

	// ReturnReceivedQuantity The item's quantity that's returned and added to the underlying variant's stocked quantity.
	ReturnReceivedQuantity float32 `json:"return_received_quantity"`

	// ReturnRequestedQuantity The item's quantity that's requested to be returned.
	ReturnRequestedQuantity float32 `json:"return_requested_quantity"`

	// ShippedQuantity The item's shipped quantity.
	ShippedQuantity float32 `json:"shipped_quantity"`

	// UpdatedAt The date the detail was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// WrittenOffQuantity The item's quantity that's removed from the order.
	WrittenOffQuantity float32 `json:"written_off_quantity"`
}

// BaseOrderLineItem The item's items.
type BaseOrderLineItem struct {
	// Adjustments The item's adjustments.
	Adjustments *[]BaseOrderLineItemAdjustment `json:"adjustments,omitempty"`

	// CompareAtUnitPrice The original price of the item before a promotion or sale.
	CompareAtUnitPrice *float32 `json:"compare_at_unit_price,omitempty"`

	// CreatedAt The date the item was created.
	CreatedAt time.Time `json:"created_at"`

	// Detail The item's detail.
	Detail BaseOrderItemDetail `json:"detail"`

	// DiscountTaxTotal The total taxes applied on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total discount amount of the item.
	DiscountTotal float32 `json:"discount_total"`

	// Id The item's ID.
	Id string `json:"id"`

	// IsDiscountable Whether the item is discountable.
	IsDiscountable bool `json:"is_discountable"`

	// IsTaxInclusive Whether the item is tax inclusive.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// ItemSubtotal The item's total excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The total taxes of the item, including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total taxes of the item, including promotions.
	ItemTotal float32 `json:"item_total"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OriginalSubtotal The item's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes of the item, excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The item's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// Product The parent's product.
	Product *BaseProduct `json:"product,omitempty"`

	// ProductCollection The ID of the collection the item's product belongs to.
	ProductCollection string `json:"product_collection"`

	// ProductDescription The item's product description.
	ProductDescription string `json:"product_description"`

	// ProductHandle The item's product handle.
	ProductHandle string `json:"product_handle"`

	// ProductId The ID of the associated product.
	ProductId string `json:"product_id"`

	// ProductSubtitle The item's product subtitle.
	ProductSubtitle string `json:"product_subtitle"`

	// ProductTitle The item's product title.
	ProductTitle string `json:"product_title"`

	// ProductType The item's product type.
	ProductType string `json:"product_type"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// RefundableTotal The total refundable amount of the item's total.
	RefundableTotal float32 `json:"refundable_total"`

	// RefundableTotalPerUnit The total refundable amount of the item's total for a single quantity.
	RefundableTotalPerUnit float32 `json:"refundable_total_per_unit"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// Subtitle The item's subtitle.
	Subtitle string `json:"subtitle"`

	// Subtotal The item's subtotal excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The item's tax lines.
	TaxLines *[]BaseOrderLineItemTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The tax total of the item including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Thumbnail The URL of the item's thumbnail.
	Thumbnail string `json:"thumbnail"`

	// Title The item's title.
	Title string `json:"title"`

	// Total The item's total, including taxes and promotions.
	Total float32 `json:"total"`

	// UnitPrice The item's unit price.
	UnitPrice float32 `json:"unit_price"`

	// UpdatedAt The date the item was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variant The product variant's details.
	Variant *BaseProductVariant `json:"variant,omitempty"`

	// VariantBarcode The item's variant barcode.
	VariantBarcode string `json:"variant_barcode"`

	// VariantId The ID of the associated variant.
	VariantId string `json:"variant_id"`

	// VariantOptionValues The values of the item variant's options.
	VariantOptionValues map[string]interface{} `json:"variant_option_values"`

	// VariantSku The item's variant SKU.
	VariantSku string `json:"variant_sku"`

	// VariantTitle The item's variant title.
	VariantTitle string `json:"variant_title"`
}

// BaseOrderLineItemAdjustment The adjustment's details.
type BaseOrderLineItemAdjustment struct {
	// Amount The adjustment's amount.
	Amount float32 `json:"amount"`

	// Code The adjustment's code.
	Code *string `json:"code,omitempty"`

	// CreatedAt The date the adjustment was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The adjustment's description.
	Description *string `json:"description,omitempty"`

	// Id The adjustment's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId The ID of the item this adjustment applies to.
	ItemId string `json:"item_id"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// PromotionId The ID of the promotion that this applies on the order's item.
	PromotionId *string `json:"promotion_id,omitempty"`

	// ProviderId The adjustment's provider ID.
	ProviderId *string `json:"provider_id,omitempty"`

	// UpdatedAt The date the adjustment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderLineItemTaxLine The tax line's tax lines.
type BaseOrderLineItemTaxLine struct {
	// Code The code that the tax rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax line was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The tax line's description.
	Description *string `json:"description,omitempty"`

	// Id The tax line's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId The ID of the associated line item.
	ItemId string `json:"item_id"`

	// ProviderId The ID of the tax provider used to calculate the tax line.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rate The rate to charge.
	Rate float32 `json:"rate"`

	// Subtotal The tax line's subtotal excluding promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxRateId The ID of the applied tax rate.
	TaxRateId *string `json:"tax_rate_id,omitempty"`

	// Total The tax line's total including promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the tax line was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderShippingDetail Details of changes to a shipping method.
type BaseOrderShippingDetail struct {
	// ClaimId The ID of the associated claim.
	ClaimId *string `json:"claim_id,omitempty"`

	// CreatedAt The date the shipping method change was created.
	CreatedAt time.Time `json:"created_at"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId *string `json:"exchange_id,omitempty"`

	// Id The ID of the new changes to the shipping method.
	Id string `json:"id"`

	// ReturnId The ID of the associated return.
	ReturnId       *string                `json:"return_id,omitempty"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the shipping method.
	ShippingMethodId string `json:"shipping_method_id"`

	// UpdatedAt The date the shipping method change was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderShippingMethod The shipping method's details.
type BaseOrderShippingMethod struct {
	// Adjustments The shipping method's adjustments.
	Adjustments *[]BaseOrderShippingMethodAdjustment `json:"adjustments,omitempty"`

	// Amount The shipping method's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the shipping method was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The shipping method's data, useful for fulfillment provider handling its fulfillment.
	Data map[string]interface{} `json:"data"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// Detail Details of changes to a shipping method.
	Detail *BaseOrderShippingDetail `json:"detail,omitempty"`

	// DiscountTaxTotal The taxes applied on the discount amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total discounts applied on the shipping method.
	DiscountTotal float32 `json:"discount_total"`

	// Id The shipping method's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether the shipping method's amount includes applied taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// Metadata The shipping method's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The shipping method's name.
	Name string `json:"name"`

	// OrderId The ID of the order the shipping method belongs to.
	OrderId string `json:"order_id"`

	// OriginalSubtotal The shipping method's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The shipping method's total taxes excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The shipping method's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// ShippingOptionId The ID of the shipping option this method was created from.
	ShippingOptionId string `json:"shipping_option_id"`

	// Subtotal The shipping method's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The shipping method's tax lines.
	TaxLines *[]BaseOrderShippingMethodTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The shipping method's tax total including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The shipping method's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the shipping method was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderShippingMethodAdjustment The adjustment's adjustments.
type BaseOrderShippingMethodAdjustment struct {
	// Amount The adjustment's amount.
	Amount float32 `json:"amount"`

	// Code The adjustment's code.
	Code *string `json:"code,omitempty"`

	// CreatedAt The date the adjustment was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The adjustment's description.
	Description *string `json:"description,omitempty"`

	// Id The adjustment's ID.
	Id string `json:"id"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// PromotionId The ID of the promotion applied by this adjustment.
	PromotionId *string `json:"promotion_id,omitempty"`

	// ProviderId The adjustment's provider ID.
	ProviderId     *string                `json:"provider_id,omitempty"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the shipping method this adjustment applies on.
	ShippingMethodId string `json:"shipping_method_id"`

	// UpdatedAt The date the adjustment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderShippingMethodTaxLine The tax line's details.
type BaseOrderShippingMethodTaxLine struct {
	// Code The code that the tax rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax line was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The tax line's description.
	Description *string `json:"description,omitempty"`

	// Id The tax line's ID.
	Id string `json:"id"`

	// ProviderId The ID of the tax provider handling the tax calculation.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rate The rate to charge.
	Rate           float32                `json:"rate"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the shipping method this tax line belongs to.
	ShippingMethodId string `json:"shipping_method_id"`

	// Subtotal The shipping method's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxRateId The ID of the applied tax rate.
	TaxRateId *string `json:"tax_rate_id,omitempty"`

	// Total The shipping method's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the tax line was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderSummary The order's summary details.
type BaseOrderSummary struct {
	// FulfilledTotal The total of the fulfilled items of the order.
	FulfilledTotal float32 `json:"fulfilled_total"`

	// OrderedTotal The order's total when it was placed.
	OrderedTotal float32 `json:"ordered_total"`

	// PaidTotal The total amount paid.
	PaidTotal float32 `json:"paid_total"`

	// RefundedTotal The total amount refunded.
	RefundedTotal float32 `json:"refunded_total"`

	// ReturnRequestTotal The total of the items requested to be returned.
	ReturnRequestTotal float32 `json:"return_request_total"`

	// ReturnedTotal The total of the order's returned items.
	ReturnedTotal float32 `json:"returned_total"`

	// Subtotal The order's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// Total The order's total including taxes and promotions.
	Total float32 `json:"total"`

	// TotalTax The order's total taxes.
	TotalTax float32 `json:"total_tax"`

	// WriteOffTotal The total of the items removed from the order.
	WriteOffTotal float32 `json:"write_off_total"`
}

// BaseOrderTransaction An order transaction's details.
type BaseOrderTransaction struct {
	// Amount The transaction's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date that the transaction was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The transaction's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The transaction's ID.
	Id string `json:"id"`

	// Metadata The transaction's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OrderId The ID of the order this transaction belongs to.
	OrderId string `json:"order_id"`

	// Reference The name of a table that this transaction references. If this transaction is for captured payment, its value is `capture`. If this transaction is for refunded payment, its value is `refund`.
	Reference BaseOrderTransactionReference `json:"reference"`

	// ReferenceId The ID of the referenced record in the referenced table.
	ReferenceId string `json:"reference_id"`

	// UpdatedAt The date that the transaction was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseOrderTransactionReference The name of a table that this transaction references. If this transaction is for captured payment, its value is `capture`. If this transaction is for refunded payment, its value is `refund`.
type BaseOrderTransactionReference string

// BasePayment The payment's details.
type BasePayment struct {
	// Amount The payment's amount.
	Amount float32 `json:"amount"`

	// AuthorizedAmount The amount authorized of the payment.
	AuthorizedAmount *float32 `json:"authorized_amount,omitempty"`

	// CanceledAt The date the payment was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// CapturedAmount The captured amount of the payment.
	CapturedAmount *float32 `json:"captured_amount,omitempty"`

	// CapturedAt The date the payment was captured.
	CapturedAt *time.Time `json:"captured_at,omitempty"`

	// Captures The details of payment captures.
	Captures *[]BaseCapture `json:"captures,omitempty"`

	// CartId The ID of the associated cart.
	CartId *string `json:"cart_id,omitempty"`

	// CreatedAt The date the payment was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The payment's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId ID of the associated customer.
	CustomerId *string `json:"customer_id,omitempty"`

	// Data The payment's data, useful for processing by the payment provider.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Id The payment's ID.
	Id string `json:"id"`

	// OrderEditId The ID of the associated order edit.
	OrderEditId *string `json:"order_edit_id,omitempty"`

	// OrderId The ID of the associated order.
	OrderId           *string                 `json:"order_id,omitempty"`
	PaymentCollection *map[string]interface{} `json:"payment_collection,omitempty"`
	PaymentSession    *map[string]interface{} `json:"payment_session,omitempty"`

	// ProviderId The ID of the payment provider used to process this payment.
	ProviderId string `json:"provider_id"`

	// RefundedAmount The refunded amount of the payment.
	RefundedAmount *float32 `json:"refunded_amount,omitempty"`

	// Refunds The details of payment refunds.
	Refunds *[]BaseRefund `json:"refunds,omitempty"`

	// UpdatedAt The date the payment was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BasePaymentCollection The payment collection's details.
type BasePaymentCollection struct {
	// Amount The total amount to be paid.
	Amount float32 `json:"amount"`

	// AuthorizedAmount The total authorized amount of the collection's payments.
	AuthorizedAmount *float32 `json:"authorized_amount,omitempty"`

	// CapturedAmount The total captured amount of the collection's payments.
	CapturedAmount *float32 `json:"captured_amount,omitempty"`

	// CompletedAt The date the payment collection was completed.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The date the payment collection was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The payment collection's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The payment collection's ID.
	Id string `json:"id"`

	// Metadata The payment collection's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PaymentProviders The payment provider used to process the collection's payments and sessions.
	PaymentProviders []BasePaymentProvider `json:"payment_providers"`

	// PaymentSessions The payment collection's payment sessions.
	PaymentSessions *[]BasePaymentSession `json:"payment_sessions,omitempty"`

	// Payments The payment collection's payments.
	Payments *[]BasePayment `json:"payments,omitempty"`

	// RefundedAmount The total refunded amount of the collection's payments.
	RefundedAmount *float32 `json:"refunded_amount,omitempty"`

	// RegionId The ID of the region this payment collection is associated with.
	RegionId string `json:"region_id"`

	// Status The payment collection's status.
	Status BasePaymentCollectionStatus `json:"status"`

	// UpdatedAt The date the payment collection was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BasePaymentCollectionStatus The payment collection's status.
type BasePaymentCollectionStatus string

// BasePaymentProvider The payment provider's payment providers.
type BasePaymentProvider struct {
	// Id The payment provider's ID.
	Id string `json:"id"`
}

// BasePaymentSession The payment session's details.
type BasePaymentSession struct {
	// Amount The payment session's amount.
	Amount float32 `json:"amount"`

	// AuthorizedAt The date the payment session was authorized.
	AuthorizedAt *time.Time `json:"authorized_at,omitempty"`

	// Context The context around the payment, such as the customer's details.
	Context *map[string]interface{} `json:"context,omitempty"`

	// CurrencyCode The payment session's currency code.
	CurrencyCode string `json:"currency_code"`

	// Data The payment session's data, useful for the payment provider processing the payment.
	Data map[string]interface{} `json:"data"`

	// Id The payment session's ID.
	Id string `json:"id"`

	// Payment The payment's details.
	Payment           *BasePayment            `json:"payment,omitempty"`
	PaymentCollection *map[string]interface{} `json:"payment_collection,omitempty"`

	// ProviderId The ID of the payment provider processing this session.
	ProviderId string `json:"provider_id"`

	// Status The payment session's status.
	Status BasePaymentSessionStatus `json:"status"`
}

// BasePaymentSessionStatus The payment session's status.
type BasePaymentSessionStatus string

// BaseProduct The parent's product.
type BaseProduct struct {
	// Categories The product's categories.
	Categories *[]BaseProductCategory `json:"categories,omitempty"`

	// Collection The collection's details.
	Collection *BaseCollection `json:"collection,omitempty"`

	// CollectionId The product's collection id.
	CollectionId string `json:"collection_id"`

	// CreatedAt The product's created at.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The product's deleted at.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The product's description.
	Description string `json:"description"`

	// Discountable The product's discountable.
	Discountable bool `json:"discountable"`

	// ExternalId The product's external id.
	ExternalId string `json:"external_id"`

	// Handle The product's handle.
	Handle string `json:"handle"`

	// Height The product's height.
	Height float32 `json:"height"`

	// HsCode The product's hs code.
	HsCode string `json:"hs_code"`

	// Id The product's ID.
	Id string `json:"id"`

	// Images The product's images.
	Images []BaseProductImage `json:"images"`

	// IsGiftcard The product's is giftcard.
	IsGiftcard bool `json:"is_giftcard"`

	// Length The product's length.
	Length float32 `json:"length"`

	// Material The product's material.
	Material string `json:"material"`

	// Metadata The product's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's mid code.
	MidCode string `json:"mid_code"`

	// Options The product's options.
	Options []BaseProductOption `json:"options"`

	// OriginCountry The product's origin country.
	OriginCountry string `json:"origin_country"`

	// Status The product's status.
	Status BaseProductStatus `json:"status"`

	// Subtitle The product's subtitle.
	Subtitle string `json:"subtitle"`

	// Tags The product's tags.
	Tags *[]BaseProductTag `json:"tags,omitempty"`

	// Thumbnail The product's thumbnail.
	Thumbnail string `json:"thumbnail"`

	// Title The product's title.
	Title string                  `json:"title"`
	Type  *map[string]interface{} `json:"type,omitempty"`

	// TypeId The product's type id.
	TypeId string `json:"type_id"`

	// UpdatedAt The product's updated at.
	UpdatedAt time.Time `json:"updated_at"`

	// Variants The product's variants.
	Variants []map[string]interface{} `json:"variants"`

	// Weight The product's weight.
	Weight float32 `json:"weight"`

	// Width The product's width.
	Width float32 `json:"width"`
}

// BaseProductStatus The product's status.
type BaseProductStatus string

// BaseProductCategory The category's categories.
type BaseProductCategory = map[string]interface{}

// BaseProductImage The image's details.
type BaseProductImage struct {
	// CreatedAt The date the image was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the image was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The image's ID.
	Id string `json:"id"`

	// Metadata The image's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the image was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url The image's URL.
	Url string `json:"url"`
}

// BaseProductOption The product option's details.
type BaseProductOption struct {
	// CreatedAt The option's created at.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The option's deleted at.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The option's ID.
	Id string `json:"id"`

	// Metadata The option's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Product  *map[string]interface{} `json:"product,omitempty"`

	// ProductId The option's product id.
	ProductId *string `json:"product_id,omitempty"`

	// Title The option's title.
	Title string `json:"title"`

	// UpdatedAt The option's updated at.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Values The option's values.
	Values *[]BaseProductOptionValue `json:"values,omitempty"`
}

// BaseProductOptionValue The product option value's details.
type BaseProductOptionValue struct {
	// CreatedAt The date the value was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the value was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The value's ID.
	Id string `json:"id"`

	// Metadata The value's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Option   *map[string]interface{} `json:"option,omitempty"`

	// OptionId The ID of the option this value belongs to.
	OptionId *string `json:"option_id,omitempty"`

	// UpdatedAt The date the value was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value The value.
	Value string `json:"value"`
}

// BaseProductTag The tag's tags.
type BaseProductTag = map[string]interface{}

// BaseProductVariant The product variant's details.
type BaseProductVariant struct {
	// AllowBackorder Whether the variant can be ordered even if it's out of stock.
	AllowBackorder bool `json:"allow_backorder"`

	// Barcode The variant's barcode.
	Barcode string `json:"barcode"`

	// CalculatedPrice The calculated price's details.
	CalculatedPrice *BaseCalculatedPriceSet `json:"calculated_price,omitempty"`

	// CreatedAt The date the variant was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the variant was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Ean The variant's EAN code.
	Ean string `json:"ean"`

	// Height The variant's height.
	Height float32 `json:"height"`

	// HsCode The variant's HS code.
	HsCode string `json:"hs_code"`

	// Id The variant's ID.
	Id string `json:"id"`

	// InventoryQuantity The variant's inventory quantity. This is only included if you pass in the `fields` query parameter a `+variants.inventory_quantity` parameter.
	InventoryQuantity *float32 `json:"inventory_quantity,omitempty"`

	// Length The variant's length.
	Length float32 `json:"length"`

	// ManageInventory Whether the Medusa application manages the variant's inventory quantity and availablility. If disabled, the variant is always considered in stock.
	ManageInventory bool `json:"manage_inventory"`

	// Material The variant's material.
	Material string `json:"material"`

	// Metadata The variant's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The variant's MID code.
	MidCode string `json:"mid_code"`

	// Options The variant's option values.
	Options []BaseProductOptionValue `json:"options"`

	// OriginCountry The variant's origin country.
	OriginCountry string `json:"origin_country"`

	// Product The parent's product.
	Product *BaseProduct `json:"product,omitempty"`

	// ProductId The ID of the product that the variant belongs to.
	ProductId *string `json:"product_id,omitempty"`

	// Sku The variant's SKU.
	Sku string `json:"sku"`

	// Title The variant's title.
	Title string `json:"title"`

	// Upc The variant's UPC.
	Upc string `json:"upc"`

	// UpdatedAt The date the variant was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantRank The variant's rank among its sibling variants.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The variant's weight.
	Weight float32 `json:"weight"`

	// Width The variant's width.
	Width float32 `json:"width"`
}

// BasePromotion The application method's promotion.
type BasePromotion = map[string]interface{}

// BasePromotionRule The rule's rules.
type BasePromotionRule struct {
	// Attribute The rule's attribute.
	Attribute *string `json:"attribute,omitempty"`

	// Description The rule's description.
	Description *string `json:"description,omitempty"`

	// Id The rule's ID.
	Id string `json:"id"`

	// Operator The rule's operator.
	Operator *BasePromotionRuleOperator `json:"operator,omitempty"`

	// Values The rule's values.
	Values []BasePromotionRuleValue `json:"values"`
}

// BasePromotionRuleOperator The rule's operator.
type BasePromotionRuleOperator string

// BasePromotionRuleValue The rule value's details.
type BasePromotionRuleValue struct {
	// Id The value's ID.
	Id string `json:"id"`

	// Value The value.
	Value *string `json:"value,omitempty"`
}

// BaseRefund The refund's details.
type BaseRefund struct {
	// Amount The refund's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the refund was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the refund.
	CreatedBy *string `json:"created_by,omitempty"`

	// Id The refund's ID.
	Id string `json:"id"`

	// Note More details about the refund.
	Note    *string                `json:"note,omitempty"`
	Payment map[string]interface{} `json:"payment"`

	// RefundReason The refund reason's details.
	RefundReason *RefundReason `json:"refund_reason,omitempty"`

	// RefundReasonId The ID of the refund reason.
	RefundReasonId *string `json:"refund_reason_id,omitempty"`
}

// BaseRegion The region's details.
type BaseRegion struct {
	// AutomaticTaxes The region's automatic taxes.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// Countries The region's countries.
	Countries *[]BaseRegionCountry `json:"countries,omitempty"`

	// CreatedAt The region's created at.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The region's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The region's ID.
	Id string `json:"id"`

	// Metadata The region's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The region's name.
	Name string `json:"name"`

	// PaymentProviders The region's payment providers.
	PaymentProviders *[]AdminPaymentProvider `json:"payment_providers,omitempty"`

	// UpdatedAt The region's updated at.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// BaseRegionCountry The country's details.
type BaseRegionCountry struct {
	// DisplayName The country's display name.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The country's ID.
	Id string `json:"id"`

	// Iso2 The country's iso 2.
	Iso2 *string `json:"iso_2,omitempty"`

	// Iso3 The country's iso 3.
	Iso3 *string `json:"iso_3,omitempty"`

	// Name The country's name.
	Name *string `json:"name,omitempty"`

	// NumCode The country's num code.
	NumCode *string `json:"num_code,omitempty"`
}

// BaseRuleOperatorOptions The operator's details.
type BaseRuleOperatorOptions struct {
	// Id The operator's ID.
	Id string `json:"id"`

	// Label The operator's label.
	Label string `json:"label"`

	// Value The operator's value.
	Value string `json:"value"`
}

// BaseShippingMethodAdjustment The adjustment's details.
type BaseShippingMethodAdjustment struct {
	// Amount The adjustment's amount.
	Amount float32 `json:"amount"`

	// CartId The ID of the associated cart.
	CartId string `json:"cart_id"`

	// Code The adjustment's code.
	Code *string `json:"code,omitempty"`

	// CreatedAt The date the adjustment was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The adjustment's description.
	Description *string `json:"description,omitempty"`

	// Id The adjustment's ID.
	Id string `json:"id"`

	// PromotionId The ID of the promotion applied by this adjustment.
	PromotionId *string `json:"promotion_id,omitempty"`

	// ProviderId The adjustment's provider ID.
	ProviderId     *string                `json:"provider_id,omitempty"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the shipping method the adjustment is applied on.
	ShippingMethodId string `json:"shipping_method_id"`

	// UpdatedAt The date the adjustment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BaseShippingMethodTaxLine The tax line's details.
type BaseShippingMethodTaxLine struct {
	// Code The code that the rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax line was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The tax line's description.
	Description *string `json:"description,omitempty"`

	// Id The tax line's ID.
	Id string `json:"id"`

	// ProviderId The ID of the tax provider that calculated the taxes.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rate The rate to charge.
	Rate           float32                `json:"rate"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of this shipping method the tax line belongs to.
	ShippingMethodId string `json:"shipping_method_id"`

	// Subtotal The method's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxRateId The ID of the applied tax rate.
	TaxRateId *string `json:"tax_rate_id,omitempty"`

	// Total The method's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the tax line was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// CampaignResponse The campaign's details.
type CampaignResponse struct {
	// Budget The campaign's budget.
	Budget struct {
		// CurrencyCode The budget's currency code.
		CurrencyCode string `json:"currency_code"`

		// Id The budget's ID.
		Id string `json:"id"`

		// Limit The budget's limit.
		Limit float32                    `json:"limit"`
		Type  CampaignResponseBudgetType `json:"type"`

		// Used The budget's used.
		Used float32 `json:"used"`
	} `json:"budget"`

	// CampaignIdentifier The campaign's campaign identifier.
	CampaignIdentifier string `json:"campaign_identifier"`

	// Currency The campaign's currency.
	Currency string `json:"currency"`

	// Description The campaign's description.
	Description string `json:"description"`

	// EndsAt The campaign's ends at.
	EndsAt string `json:"ends_at"`

	// Id The campaign's ID.
	Id string `json:"id"`

	// Name The campaign's name.
	Name string `json:"name"`

	// StartsAt The campaign's starts at.
	StartsAt string `json:"starts_at"`
}

// CampaignResponseBudgetType defines model for CampaignResponse.Budget.Type.
type CampaignResponseBudgetType string

// CreateAddress The address to create.
type CreateAddress struct {
	// Address1 The address's first line.
	Address1 *string `json:"address_1,omitempty"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// CountryCode The address's country code.
	CountryCode *string `json:"country_code,omitempty"`

	// CustomerId The ID of the customer this address belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// FirstName The address's first name.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The address's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`
}

// CustomerGroupInCustomerFilters Filter by customer groups to get their associated customers.
type CustomerGroupInCustomerFilters struct {
	// CreatedAt Filter by the group's creation date.
	CreatedAt struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                    `json:"$contains,omitempty"`
		Eq       *CustomerGroupInCustomerFilters_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                     `json:"$nin,omitempty"`
		Not *CustomerGroupInCustomerFilters_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `json:"created_at"`

	// DeletedAt Filter by the group's deletion date.
	DeletedAt struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                    `json:"$contains,omitempty"`
		Eq       *CustomerGroupInCustomerFilters_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                     `json:"$nin,omitempty"`
		Not *CustomerGroupInCustomerFilters_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `json:"deleted_at"`
	Id   CustomerGroupInCustomerFilters_Id   `json:"id"`
	Name CustomerGroupInCustomerFilters_Name `json:"name"`

	// UpdatedAt Filter by the group's update date.
	UpdatedAt struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                    `json:"$contains,omitempty"`
		Eq       *CustomerGroupInCustomerFilters_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                     `json:"$nin,omitempty"`
		Not *CustomerGroupInCustomerFilters_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `json:"updated_at"`
}

// CustomerGroupInCustomerFiltersCreatedAtEq0 Filter by an exact match.
type CustomerGroupInCustomerFiltersCreatedAtEq0 = string

// CustomerGroupInCustomerFiltersCreatedAtEq1 Filter by exact matches.
type CustomerGroupInCustomerFiltersCreatedAtEq1 = []string

// CustomerGroupInCustomerFilters_CreatedAt_Eq defines model for CustomerGroupInCustomerFilters.CreatedAt.Eq.
type CustomerGroupInCustomerFilters_CreatedAt_Eq struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersCreatedAtNot0 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersCreatedAtNot0 = string

// CustomerGroupInCustomerFiltersCreatedAtNot1 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersCreatedAtNot1 = map[string]interface{}

// CustomerGroupInCustomerFiltersCreatedAtNot2 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersCreatedAtNot2 = []string

// CustomerGroupInCustomerFilters_CreatedAt_Not defines model for CustomerGroupInCustomerFilters.CreatedAt.Not.
type CustomerGroupInCustomerFilters_CreatedAt_Not struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersDeletedAtEq0 Filter by an exact match.
type CustomerGroupInCustomerFiltersDeletedAtEq0 = string

// CustomerGroupInCustomerFiltersDeletedAtEq1 Filter by exact matches.
type CustomerGroupInCustomerFiltersDeletedAtEq1 = []string

// CustomerGroupInCustomerFilters_DeletedAt_Eq defines model for CustomerGroupInCustomerFilters.DeletedAt.Eq.
type CustomerGroupInCustomerFilters_DeletedAt_Eq struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersDeletedAtNot0 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersDeletedAtNot0 = string

// CustomerGroupInCustomerFiltersDeletedAtNot1 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersDeletedAtNot1 = map[string]interface{}

// CustomerGroupInCustomerFiltersDeletedAtNot2 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersDeletedAtNot2 = []string

// CustomerGroupInCustomerFilters_DeletedAt_Not defines model for CustomerGroupInCustomerFilters.DeletedAt.Not.
type CustomerGroupInCustomerFilters_DeletedAt_Not struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersId0 Filter by a group's ID.
type CustomerGroupInCustomerFiltersId0 = string

// CustomerGroupInCustomerFiltersId1 Filter by group IDs.
type CustomerGroupInCustomerFiltersId1 = []string

// CustomerGroupInCustomerFilters_Id defines model for CustomerGroupInCustomerFilters.Id.
type CustomerGroupInCustomerFilters_Id struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersName0 Filter by a group's name.
type CustomerGroupInCustomerFiltersName0 = string

// CustomerGroupInCustomerFiltersName1 Filter by group names.
type CustomerGroupInCustomerFiltersName1 = []string

// CustomerGroupInCustomerFilters_Name defines model for CustomerGroupInCustomerFilters.Name.
type CustomerGroupInCustomerFilters_Name struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersUpdatedAtEq0 Filter by an exact match.
type CustomerGroupInCustomerFiltersUpdatedAtEq0 = string

// CustomerGroupInCustomerFiltersUpdatedAtEq1 Filter by exact matches.
type CustomerGroupInCustomerFiltersUpdatedAtEq1 = []string

// CustomerGroupInCustomerFilters_UpdatedAt_Eq defines model for CustomerGroupInCustomerFilters.UpdatedAt.Eq.
type CustomerGroupInCustomerFilters_UpdatedAt_Eq struct {
	union json.RawMessage
}

// CustomerGroupInCustomerFiltersUpdatedAtNot0 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersUpdatedAtNot0 = string

// CustomerGroupInCustomerFiltersUpdatedAtNot1 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersUpdatedAtNot1 = map[string]interface{}

// CustomerGroupInCustomerFiltersUpdatedAtNot2 Filter by values not matching the conditions in this parameter.
type CustomerGroupInCustomerFiltersUpdatedAtNot2 = []string

// CustomerGroupInCustomerFilters_UpdatedAt_Not defines model for CustomerGroupInCustomerFilters.UpdatedAt.Not.
type CustomerGroupInCustomerFilters_UpdatedAt_Not struct {
	union json.RawMessage
}

// Error defines model for Error.
type Error struct {
	// Code A slug code to indicate the type of the error.
	Code *ErrorCode `json:"code,omitempty"`

	// Message Description of the error that occurred.
	Message *string `json:"message,omitempty"`

	// Type A slug indicating the type of the error.
	Type *ErrorType `json:"type,omitempty"`
}

// ErrorCode A slug code to indicate the type of the error.
type ErrorCode string

// ErrorType A slug indicating the type of the error.
type ErrorType string

// IBigNumber The shipping method's discount tax total.
type IBigNumber = map[string]interface{}

// InventoryLevel The inventory level's details
type InventoryLevel struct {
	// AvailableQuantity The inventory level's available quantity.
	AvailableQuantity float32 `json:"available_quantity"`

	// Id The inventory level's ID.
	Id string `json:"id"`

	// IncomingQuantity The inventory level's incoming quantity.
	IncomingQuantity float32 `json:"incoming_quantity"`

	// InventoryItemId The ID of the associated inventory item.
	InventoryItemId string `json:"inventory_item_id"`

	// LocationId The ID of the associated location.
	LocationId string `json:"location_id"`

	// Metadata The inventory level's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ReservedQuantity The inventory level's reserved quantity.
	ReservedQuantity float32 `json:"reserved_quantity"`

	// StockedQuantity The inventory level's stocked quantity.
	StockedQuantity float32 `json:"stocked_quantity"`
}

// Order The order change's order.
type Order struct {
	// BillingAddress The address's details.
	BillingAddress *OrderAddress `json:"billing_address,omitempty"`

	// CanceledAt The date the order was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// CreatedAt The date the order was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The order's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId *string `json:"customer_id,omitempty"`

	// DiscountSubtotal The total discount excluding taxes.
	DiscountSubtotal float32 `json:"discount_subtotal"`

	// DiscountTaxTotal The tax total applied on the discount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total discount including taxes.
	DiscountTotal float32 `json:"discount_total"`

	// Email The email of the customer that placed the order.
	Email *openapi_types.Email `json:"email,omitempty"`

	// GiftCardTaxTotal The order's gift card tax total.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The order's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The order's ID.
	Id string `json:"id"`

	// ItemSubtotal The order items' total excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The tax total of the order items including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The order items' total including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Items The order's items.
	Items *[]OrderLineItem `json:"items,omitempty"`

	// Metadata The order's metadata, can hold custom key-value pairs.
	Metadata    *map[string]interface{} `json:"metadata,omitempty"`
	OrderChange *map[string]interface{} `json:"order_change,omitempty"`

	// OriginalItemSubtotal The order items' total excluding taxes, including promotions.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The taxes total for order items, excluding promotions.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The order items' total including taxes, excluding promotions.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The order's shipping total excluding taxes, including promotions.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The total taxes of the order's shipping excluding promotions.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The order's shipping total including taxes, excluding promotions.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The order's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The tax total of the order excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The order's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// RawDiscountTaxTotal The order's raw discount tax total.
	RawDiscountTaxTotal map[string]interface{} `json:"raw_discount_tax_total"`

	// RawDiscountTotal The order's raw discount total.
	RawDiscountTotal map[string]interface{} `json:"raw_discount_total"`

	// RawGiftCardTaxTotal The order's raw gift card tax total.
	RawGiftCardTaxTotal map[string]interface{} `json:"raw_gift_card_tax_total"`

	// RawGiftCardTotal The order's raw gift card total.
	RawGiftCardTotal map[string]interface{} `json:"raw_gift_card_total"`

	// RawItemSubtotal The order's raw item subtotal.
	RawItemSubtotal map[string]interface{} `json:"raw_item_subtotal"`

	// RawItemTaxTotal The order's raw item tax total.
	RawItemTaxTotal map[string]interface{} `json:"raw_item_tax_total"`

	// RawItemTotal The order's raw item total.
	RawItemTotal map[string]interface{} `json:"raw_item_total"`

	// RawOriginalItemSubtotal The order's raw original item subtotal.
	RawOriginalItemSubtotal map[string]interface{} `json:"raw_original_item_subtotal"`

	// RawOriginalItemTaxTotal The order's raw original item tax total.
	RawOriginalItemTaxTotal map[string]interface{} `json:"raw_original_item_tax_total"`

	// RawOriginalItemTotal The order's raw original item total.
	RawOriginalItemTotal map[string]interface{} `json:"raw_original_item_total"`

	// RawOriginalShippingSubtotal The order's raw original shipping subtotal.
	RawOriginalShippingSubtotal map[string]interface{} `json:"raw_original_shipping_subtotal"`

	// RawOriginalShippingTaxTotal The order's raw original shipping tax total.
	RawOriginalShippingTaxTotal map[string]interface{} `json:"raw_original_shipping_tax_total"`

	// RawOriginalShippingTotal The order's raw original shipping total.
	RawOriginalShippingTotal map[string]interface{} `json:"raw_original_shipping_total"`

	// RawOriginalSubtotal The order's raw original subtotal.
	RawOriginalSubtotal map[string]interface{} `json:"raw_original_subtotal"`

	// RawOriginalTaxTotal The order's raw original tax total.
	RawOriginalTaxTotal map[string]interface{} `json:"raw_original_tax_total"`

	// RawOriginalTotal The order's raw original total.
	RawOriginalTotal map[string]interface{} `json:"raw_original_total"`

	// RawShippingSubtotal The order's raw shipping subtotal.
	RawShippingSubtotal map[string]interface{} `json:"raw_shipping_subtotal"`

	// RawShippingTaxTotal The order's raw shipping tax total.
	RawShippingTaxTotal map[string]interface{} `json:"raw_shipping_tax_total"`

	// RawShippingTotal The order's raw shipping total.
	RawShippingTotal map[string]interface{} `json:"raw_shipping_total"`

	// RawSubtotal The order's raw subtotal.
	RawSubtotal map[string]interface{} `json:"raw_subtotal"`

	// RawTaxTotal The order's raw tax total.
	RawTaxTotal map[string]interface{} `json:"raw_tax_total"`

	// RawTotal The order's raw total.
	RawTotal map[string]interface{} `json:"raw_total"`

	// RegionId The ID of the region the order belongs to.
	RegionId *string `json:"region_id,omitempty"`

	// SalesChannelId The ID of the sales channel the order was placed in.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`

	// ShippingAddress The address's details.
	ShippingAddress *OrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The order's shipping methods.
	ShippingMethods *[]OrderShippingMethod `json:"shipping_methods,omitempty"`

	// ShippingSubtotal The order's shipping total excluding taxes, including promotions.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The total taxes of the order's shipping including taxes.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The order's shipping total including taxes and promotions.
	ShippingTotal float32 `json:"shipping_total"`

	// Status The order's status.
	Status OrderStatus `json:"status"`

	// Subtotal The order's subtotal excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary.
	Summary *map[string]interface{} `json:"summary,omitempty"`

	// TaxTotal The tax total of the order including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The order's total including taxes and promotions.
	Total float32 `json:"total"`

	// Transactions The order's transactions.
	Transactions *[]OrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date the order was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order's version.
	Version float32 `json:"version"`
}

// OrderStatus The order's status.
type OrderStatus string

// OrderAddress The address's details.
type OrderAddress struct {
	// Address1 The address's first line.
	Address1 *string `json:"address_1,omitempty"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// CountryCode The address's country code.
	CountryCode *string `json:"country_code,omitempty"`

	// CreatedAt The date the address was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer the address belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// FirstName The address's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Id The address's ID.
	Id string `json:"id"`

	// LastName The address's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`

	// UpdatedAt The date the address was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderChange The order change's details.
type OrderChange struct {
	// Actions The order change's actions.
	Actions []OrderChangeAction `json:"actions"`

	// CanceledAt The date the order change was canceled.
	CanceledAt time.Time `json:"canceled_at"`

	// CanceledBy The ID of the user that canceled the order change.
	CanceledBy string `json:"canceled_by"`

	// ChangeType The order change's type.
	ChangeType *OrderChangeChangeType `json:"change_type,omitempty"`

	// Claim The order change's claim.
	Claim OrderClaim `json:"claim"`

	// ClaimId The ID of the associated claim.
	ClaimId string `json:"claim_id"`

	// ConfirmedAt The date the order change was confirmed.
	ConfirmedAt time.Time `json:"confirmed_at"`

	// ConfirmedBy The ID of the user that confirmed the order change.
	ConfirmedBy string `json:"confirmed_by"`

	// CreatedAt The date the order change was created.
	CreatedAt time.Time `json:"created_at"`

	// DeclinedAt The date the order change was declined.
	DeclinedAt time.Time `json:"declined_at"`

	// DeclinedBy The ID of the user that declined the order change.
	DeclinedBy string `json:"declined_by"`

	// DeclinedReason The reason the order change was declined.
	DeclinedReason string `json:"declined_reason"`

	// Exchange The order change's exchange.
	Exchange OrderExchange `json:"exchange"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId string `json:"exchange_id"`

	// Id The order change's ID.
	Id string `json:"id"`

	// Metadata The order change's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`
	Order    map[string]interface{} `json:"order"`

	// OrderId The ID of the order this change applies on.
	OrderId string `json:"order_id"`

	// RequestedAt The date the order change was requested.
	RequestedAt time.Time `json:"requested_at"`

	// RequestedBy The ID of the user that requested the change.
	RequestedBy string `json:"requested_by"`

	// ReturnId The ID of the associated return.
	ReturnId    string                 `json:"return_id"`
	ReturnOrder map[string]interface{} `json:"return_order"`

	// Status The order change's status.
	Status OrderChangeStatus `json:"status"`

	// UpdatedAt The date the order change was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order change's version. This will be the order's version when the change is applied.
	Version float32 `json:"version"`
}

// OrderChangeChangeType The order change's type.
type OrderChangeChangeType string

// OrderChangeStatus The order change's status.
type OrderChangeStatus string

// OrderChangeAction The order change action's details.
type OrderChangeAction struct {
	// Action The applied action.
	Action OrderChangeActionAction `json:"action"`

	// ClaimId The ID of the associated claim.
	ClaimId string `json:"claim_id"`

	// CreatedAt The date the action was created.
	CreatedAt time.Time `json:"created_at"`

	// Details The action's details.
	Details map[string]interface{} `json:"details"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId string `json:"exchange_id"`

	// Id The action's ID.
	Id string `json:"id"`

	// InternalNote A note that's viewed only by admin users.
	InternalNote string `json:"internal_note"`

	// Order The order change's order.
	Order       Order                  `json:"order"`
	OrderChange map[string]interface{} `json:"order_change"`

	// OrderChangeId The ID of the order change that the action belongs to.
	OrderChangeId string `json:"order_change_id"`

	// OrderId The ID of the order the associated change is for.
	OrderId string `json:"order_id"`

	// Reference The name of the table this action applies on.
	Reference OrderChangeActionReference `json:"reference"`

	// ReferenceId The ID of the record in the referenced table.
	ReferenceId string `json:"reference_id"`

	// ReturnId The ID of the associated return.
	ReturnId string `json:"return_id"`

	// UpdatedAt The date the action was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderChangeActionAction The applied action.
type OrderChangeActionAction string

// OrderChangeActionReference The name of the table this action applies on.
type OrderChangeActionReference string

// OrderClaim The order change's claim.
type OrderClaim struct {
	// AdditionalItems The outbound or new items of the claim.
	AdditionalItems []BaseClaimItem `json:"additional_items"`

	// BillingAddress An order address
	BillingAddress *BaseOrderAddress `json:"billing_address,omitempty"`

	// ClaimItems The order items targetted by the claim.
	ClaimItems []BaseClaimItem `json:"claim_items"`

	// CreatedAt The claim's creation date.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The claim's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the customer associated with the claim's order.
	CustomerId string `json:"customer_id"`

	// DiscountTaxTotal The claim's discount tax total.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The claim's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// DisplayId The claim's display ID.
	DisplayId *float32 `json:"display_id,omitempty"`

	// Email The email associated with the claim's order.
	Email openapi_types.Email `json:"email"`

	// FulfillmentStatus The claim's fulfillment status.
	FulfillmentStatus OrderClaimFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The claim's fulfillments.
	Fulfillments *[]BaseOrderFulfillment `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The claim's gift card tax total.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The claim's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The claim's ID.
	Id string `json:"id"`

	// ItemSubtotal The subtotal of the claim's items.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The tax total of the claim's items.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total of the claim's items.
	ItemTotal float32 `json:"item_total"`

	// Metadata The claim's metadata, used to store custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// NoNotification Whether the customer should be notified about changes in the claim.
	NoNotification *bool `json:"no_notification,omitempty"`

	// OrderId The ID of the order associated with the claim.
	OrderId string `json:"order_id"`

	// OriginalItemSubtotal The subtotal of the original items in the associated order.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The tax total of the original items in the associated order.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The total of the original items in the associated order.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The associated order's original shipping subtotal.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The associated order's original shipping tax total.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The associated order's original shipping total.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The associated order's original subtotal.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The associated order's original tax total.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The associated order's original total.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollections The claim's payment collections.
	PaymentCollections *[]BasePaymentCollection `json:"payment_collections,omitempty"`

	// PaymentStatus The claim's payment status.
	PaymentStatus OrderClaimPaymentStatus `json:"payment_status"`

	// RefundAmount The amount to be refunded.
	RefundAmount *float32 `json:"refund_amount,omitempty"`

	// RegionId The ID of the region associated with the claim.
	RegionId string                  `json:"region_id"`
	Return   *map[string]interface{} `json:"return,omitempty"`

	// ReturnId The ID of the associated return.
	ReturnId *string `json:"return_id,omitempty"`

	// SalesChannelId The ID of the sales channel the claim's order is created in.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress An order address
	ShippingAddress *BaseOrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The claim's shipping methods.
	ShippingMethods []BaseOrderShippingMethod `json:"shipping_methods"`

	// ShippingSubtotal The claim's shipping subtotal.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The claim's shipping tax total.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The claim's shipping total.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The claim's subtotal.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary details.
	Summary BaseOrderSummary `json:"summary"`

	// TaxTotal The claim's tax total.
	TaxTotal float32 `json:"tax_total"`

	// Total The associated order's total.
	Total float32 `json:"total"`

	// Transactions The claim's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The claim's update date.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderClaimFulfillmentStatus The claim's fulfillment status.
type OrderClaimFulfillmentStatus string

// OrderClaimPaymentStatus The claim's payment status.
type OrderClaimPaymentStatus string

// OrderExchange The order change's exchange.
type OrderExchange struct {
	// AdditionalItems The new items (outbound) sent by the exchange.
	AdditionalItems []BaseExchangeItem `json:"additional_items"`

	// BillingAddress An order address
	BillingAddress *BaseOrderAddress `json:"billing_address,omitempty"`

	// CreatedAt The date that the exchange was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The exchange's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId string `json:"customer_id"`

	// DifferenceDue The amount to be exchanged or refunded. If the amount is negative, it must be refunded. If positive, additional payment is required from the customer.
	DifferenceDue *float32 `json:"difference_due,omitempty"`

	// DiscountTaxTotal The total taxes on discount of the exchange.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The discount total of the exchange.
	DiscountTotal float32 `json:"discount_total"`

	// DisplayId The exchange's display ID.
	DisplayId *float32 `json:"display_id,omitempty"`

	// Email The email used when placing the order.
	Email openapi_types.Email `json:"email"`

	// FulfillmentStatus The exchange's fulfillment status.
	FulfillmentStatus OrderExchangeFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The exchange's fulfillments of new (outbound) items.
	Fulfillments *[]BaseOrderFulfillment `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The total taxes on the gift card of the exchange.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The gift cards total of the exchange.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The exchange's ID.
	Id string `json:"id"`

	// ItemSubtotal The subtotal of the exchange's new items.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The tax total of the exchange's new items.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The total of the exchange's new items.
	ItemTotal float32 `json:"item_total"`

	// Metadata The exchange's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// NoNotification Whether to send the customer notifications when the exchange is updated.
	NoNotification *bool `json:"no_notification,omitempty"`

	// OrderId The ID of the order the exchange is created for.
	OrderId string `json:"order_id"`

	// OriginalItemSubtotal The subtotal of the original items in the order.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The total tax of the original items in the order.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The total of the original items in the order.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The order's shipping subtotal.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The order's shipping tax total.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The order's shipping total.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The subtotal of the order.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The tax total of the order.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The total of the order.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollections The exchange's payment collections.
	PaymentCollections *[]BasePaymentCollection `json:"payment_collections,omitempty"`

	// PaymentStatus The exchange's payment status.
	PaymentStatus OrderExchangePaymentStatus `json:"payment_status"`

	// RegionId The ID of the associated order's region.
	RegionId string `json:"region_id"`

	// Return The return's details.
	Return *AdminReturn `json:"return,omitempty"`

	// ReturnId The ID of the associated exchange.
	ReturnId *string `json:"return_id,omitempty"`

	// ReturnItems The items returned (inbound) by the exchange.
	ReturnItems []AdminReturnItem `json:"return_items"`

	// SalesChannelId The ID of the sales channel the associated order belongs to.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress An order address
	ShippingAddress *BaseOrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The shipping methods used to send the new (outbound) items.
	ShippingMethods []BaseOrderShippingMethod `json:"shipping_methods"`

	// ShippingSubtotal The exchange's shipping subtotal.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The exchange's shipping tax total.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The exchange's shipping total.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The subtotal of the exchange.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary details.
	Summary BaseOrderSummary `json:"summary"`

	// TaxTotal The tax total of the exchange.
	TaxTotal float32 `json:"tax_total"`

	// Total The total of the exchange.
	Total float32 `json:"total"`

	// Transactions The exchange's transactions.
	Transactions *[]BaseOrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date that the exchange was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderExchangeFulfillmentStatus The exchange's fulfillment status.
type OrderExchangeFulfillmentStatus string

// OrderExchangePaymentStatus The exchange's payment status.
type OrderExchangePaymentStatus string

// OrderItem The order item's detail.
type OrderItem struct {
	// CreatedAt The date the item was created.
	CreatedAt time.Time `json:"created_at"`

	// DeliveredQuantity The item's delivered quantity.
	DeliveredQuantity float32 `json:"delivered_quantity"`

	// FulfilledQuantity The item's fulfilled quantity.
	FulfilledQuantity float32 `json:"fulfilled_quantity"`

	// Id The item's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId The ID of the associated line item.
	ItemId string `json:"item_id"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// RawDeliveredQuantity The item's raw delivered quantity.
	RawDeliveredQuantity map[string]interface{} `json:"raw_delivered_quantity"`

	// RawFulfilledQuantity The item's raw fulfilled quantity.
	RawFulfilledQuantity map[string]interface{} `json:"raw_fulfilled_quantity"`

	// RawQuantity The item's raw quantity.
	RawQuantity map[string]interface{} `json:"raw_quantity"`

	// RawReturnDismissedQuantity The item's raw return dismissed quantity.
	RawReturnDismissedQuantity map[string]interface{} `json:"raw_return_dismissed_quantity"`

	// RawReturnReceivedQuantity The item's raw return received quantity.
	RawReturnReceivedQuantity map[string]interface{} `json:"raw_return_received_quantity"`

	// RawReturnRequestedQuantity The item's raw return requested quantity.
	RawReturnRequestedQuantity map[string]interface{} `json:"raw_return_requested_quantity"`

	// RawShippedQuantity The item's raw shipped quantity.
	RawShippedQuantity map[string]interface{} `json:"raw_shipped_quantity"`

	// RawWrittenOffQuantity The item's raw written off quantity.
	RawWrittenOffQuantity map[string]interface{} `json:"raw_written_off_quantity"`

	// ReturnDismissedQuantity The item's quantity that's returned but dismissed because it's damaged.
	ReturnDismissedQuantity float32 `json:"return_dismissed_quantity"`

	// ReturnReceivedQuantity The item's quantity that's received through a return.
	ReturnReceivedQuantity float32 `json:"return_received_quantity"`

	// ReturnRequestedQuantity The item's quantity that's requested to be returned.
	ReturnRequestedQuantity float32 `json:"return_requested_quantity"`

	// ShippedQuantity The item's shipped quantity.
	ShippedQuantity float32 `json:"shipped_quantity"`

	// UpdatedAt The date the item was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// WrittenOffQuantity The item's quantity that's removed due to an order change.
	WrittenOffQuantity float32 `json:"written_off_quantity"`
}

// OrderLineItem The order line item's details.
type OrderLineItem struct {
	// Adjustments The item's adjustments.
	Adjustments *[]OrderLineItemAdjustment `json:"adjustments,omitempty"`

	// CompareAtUnitPrice The original price of the item before a promotion or sale.
	CompareAtUnitPrice *float32 `json:"compare_at_unit_price,omitempty"`

	// CreatedAt The date the item was created.
	CreatedAt time.Time `json:"created_at"`

	// Detail The order item's detail.
	Detail OrderItem `json:"detail"`

	// DiscountTaxTotal The total taxes on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The item's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// Id The item's ID.
	Id string `json:"id"`

	// IsDiscountable Whether the item is discountable.
	IsDiscountable bool `json:"is_discountable"`

	// IsTaxInclusive Whether the item's price includes taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// ItemSubtotal The item's total for a single quantity, excluding taxes and including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The total taxes of a single quantity of the item, including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The item's total for a single quantity, including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OriginalSubtotal The item's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes of the item excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The item's total including taxes and promotions.
	OriginalTotal float32 `json:"original_total"`

	// ProductCollection The ID of the associated product's collection.
	ProductCollection *string `json:"product_collection,omitempty"`

	// ProductDescription The item's product description.
	ProductDescription *string `json:"product_description,omitempty"`

	// ProductHandle The item's product handle.
	ProductHandle *string `json:"product_handle,omitempty"`

	// ProductId The ID of the associated product.
	ProductId *string `json:"product_id,omitempty"`

	// ProductSubtitle The item's product subtitle.
	ProductSubtitle *string `json:"product_subtitle,omitempty"`

	// ProductTitle The item's product title.
	ProductTitle *string `json:"product_title,omitempty"`

	// ProductType The ID of the associated product's type.
	ProductType *string `json:"product_type,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// RawCompareAtUnitPrice The item's raw compare at unit price.
	RawCompareAtUnitPrice *struct {
		Value OrderLineItem_RawCompareAtUnitPrice_Value `json:"value"`
	} `json:"raw_compare_at_unit_price,omitempty"`

	// RawDiscountTaxTotal The item's raw discount tax total.
	RawDiscountTaxTotal struct {
		Value OrderLineItem_RawDiscountTaxTotal_Value `json:"value"`
	} `json:"raw_discount_tax_total"`

	// RawDiscountTotal The item's raw discount total.
	RawDiscountTotal struct {
		Value OrderLineItem_RawDiscountTotal_Value `json:"value"`
	} `json:"raw_discount_total"`

	// RawItemSubtotal The item's raw item subtotal.
	RawItemSubtotal struct {
		Value OrderLineItem_RawItemSubtotal_Value `json:"value"`
	} `json:"raw_item_subtotal"`

	// RawItemTaxTotal The item's raw item tax total.
	RawItemTaxTotal struct {
		Value OrderLineItem_RawItemTaxTotal_Value `json:"value"`
	} `json:"raw_item_tax_total"`

	// RawItemTotal The item's raw item total.
	RawItemTotal struct {
		Value OrderLineItem_RawItemTotal_Value `json:"value"`
	} `json:"raw_item_total"`

	// RawOriginalSubtotal The item's raw original subtotal.
	RawOriginalSubtotal struct {
		Value OrderLineItem_RawOriginalSubtotal_Value `json:"value"`
	} `json:"raw_original_subtotal"`

	// RawOriginalTaxTotal The item's raw original tax total.
	RawOriginalTaxTotal struct {
		Value OrderLineItem_RawOriginalTaxTotal_Value `json:"value"`
	} `json:"raw_original_tax_total"`

	// RawOriginalTotal The item's raw original total.
	RawOriginalTotal struct {
		Value OrderLineItem_RawOriginalTotal_Value `json:"value"`
	} `json:"raw_original_total"`

	// RawQuantity The item's raw quantity.
	RawQuantity struct {
		Value OrderLineItem_RawQuantity_Value `json:"value"`
	} `json:"raw_quantity"`

	// RawRefundableTotal The item's raw refundable total.
	RawRefundableTotal struct {
		Value OrderLineItem_RawRefundableTotal_Value `json:"value"`
	} `json:"raw_refundable_total"`

	// RawRefundableTotalPerUnit The item's raw refundable total per unit.
	RawRefundableTotalPerUnit struct {
		Value OrderLineItem_RawRefundableTotalPerUnit_Value `json:"value"`
	} `json:"raw_refundable_total_per_unit"`

	// RawSubtotal The item's raw subtotal.
	RawSubtotal struct {
		Value OrderLineItem_RawSubtotal_Value `json:"value"`
	} `json:"raw_subtotal"`

	// RawTaxTotal The item's raw tax total.
	RawTaxTotal struct {
		Value OrderLineItem_RawTaxTotal_Value `json:"value"`
	} `json:"raw_tax_total"`

	// RawTotal The item's raw total.
	RawTotal struct {
		Value OrderLineItem_RawTotal_Value `json:"value"`
	} `json:"raw_total"`

	// RawUnitPrice The item's raw unit price.
	RawUnitPrice struct {
		Value OrderLineItem_RawUnitPrice_Value `json:"value"`
	} `json:"raw_unit_price"`

	// RefundableTotal The total amount of the item that can be refunded.
	RefundableTotal float32 `json:"refundable_total"`

	// RefundableTotalPerUnit The total amount that can be refunded of a single quantity of the item.
	RefundableTotalPerUnit float32 `json:"refundable_total_per_unit"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// Subtitle The item's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Subtotal The item's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The item's tax lines.
	TaxLines *[]OrderLineItemTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The total taxes of the item, including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Thumbnail The item's thumbnail URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The item's title.
	Title string `json:"title"`

	// Total The item's total including taxes and promotions.
	Total float32 `json:"total"`

	// UnitPrice The item's price for a single quantity.
	UnitPrice float32 `json:"unit_price"`

	// UpdatedAt The date the item was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantBarcode The item's variant barcode.
	VariantBarcode *string `json:"variant_barcode,omitempty"`

	// VariantId The ID of the associated variant.
	VariantId *string `json:"variant_id,omitempty"`

	// VariantOptionValues The associated variant's values for the associated product's options.
	VariantOptionValues *map[string]interface{} `json:"variant_option_values,omitempty"`

	// VariantSku The item's variant SKU.
	VariantSku *string `json:"variant_sku,omitempty"`

	// VariantTitle The item's variant title.
	VariantTitle *string `json:"variant_title,omitempty"`
}

// OrderLineItemRawCompareAtUnitPriceValue0 The raw compare at unit price's value.
type OrderLineItemRawCompareAtUnitPriceValue0 = string

// OrderLineItemRawCompareAtUnitPriceValue1 The raw compare at unit price's value.
type OrderLineItemRawCompareAtUnitPriceValue1 = float32

// OrderLineItem_RawCompareAtUnitPrice_Value defines model for OrderLineItem.RawCompareAtUnitPrice.Value.
type OrderLineItem_RawCompareAtUnitPrice_Value struct {
	union json.RawMessage
}

// OrderLineItemRawDiscountTaxTotalValue0 The raw discount tax total's value.
type OrderLineItemRawDiscountTaxTotalValue0 = string

// OrderLineItemRawDiscountTaxTotalValue1 The raw discount tax total's value.
type OrderLineItemRawDiscountTaxTotalValue1 = float32

// OrderLineItem_RawDiscountTaxTotal_Value defines model for OrderLineItem.RawDiscountTaxTotal.Value.
type OrderLineItem_RawDiscountTaxTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawDiscountTotalValue0 The raw discount total's value.
type OrderLineItemRawDiscountTotalValue0 = string

// OrderLineItemRawDiscountTotalValue1 The raw discount total's value.
type OrderLineItemRawDiscountTotalValue1 = float32

// OrderLineItem_RawDiscountTotal_Value defines model for OrderLineItem.RawDiscountTotal.Value.
type OrderLineItem_RawDiscountTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawItemSubtotalValue0 The raw item subtotal's value.
type OrderLineItemRawItemSubtotalValue0 = string

// OrderLineItemRawItemSubtotalValue1 The raw item subtotal's value.
type OrderLineItemRawItemSubtotalValue1 = float32

// OrderLineItem_RawItemSubtotal_Value defines model for OrderLineItem.RawItemSubtotal.Value.
type OrderLineItem_RawItemSubtotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawItemTaxTotalValue0 The raw item tax total's value.
type OrderLineItemRawItemTaxTotalValue0 = string

// OrderLineItemRawItemTaxTotalValue1 The raw item tax total's value.
type OrderLineItemRawItemTaxTotalValue1 = float32

// OrderLineItem_RawItemTaxTotal_Value defines model for OrderLineItem.RawItemTaxTotal.Value.
type OrderLineItem_RawItemTaxTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawItemTotalValue0 The raw item total's value.
type OrderLineItemRawItemTotalValue0 = string

// OrderLineItemRawItemTotalValue1 The raw item total's value.
type OrderLineItemRawItemTotalValue1 = float32

// OrderLineItem_RawItemTotal_Value defines model for OrderLineItem.RawItemTotal.Value.
type OrderLineItem_RawItemTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawOriginalSubtotalValue0 The raw original subtotal's value.
type OrderLineItemRawOriginalSubtotalValue0 = string

// OrderLineItemRawOriginalSubtotalValue1 The raw original subtotal's value.
type OrderLineItemRawOriginalSubtotalValue1 = float32

// OrderLineItem_RawOriginalSubtotal_Value defines model for OrderLineItem.RawOriginalSubtotal.Value.
type OrderLineItem_RawOriginalSubtotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawOriginalTaxTotalValue0 The raw original tax total's value.
type OrderLineItemRawOriginalTaxTotalValue0 = string

// OrderLineItemRawOriginalTaxTotalValue1 The raw original tax total's value.
type OrderLineItemRawOriginalTaxTotalValue1 = float32

// OrderLineItem_RawOriginalTaxTotal_Value defines model for OrderLineItem.RawOriginalTaxTotal.Value.
type OrderLineItem_RawOriginalTaxTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawOriginalTotalValue0 The raw original total's value.
type OrderLineItemRawOriginalTotalValue0 = string

// OrderLineItemRawOriginalTotalValue1 The raw original total's value.
type OrderLineItemRawOriginalTotalValue1 = float32

// OrderLineItem_RawOriginalTotal_Value defines model for OrderLineItem.RawOriginalTotal.Value.
type OrderLineItem_RawOriginalTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawQuantityValue0 The raw quantity's value.
type OrderLineItemRawQuantityValue0 = string

// OrderLineItemRawQuantityValue1 The raw quantity's value.
type OrderLineItemRawQuantityValue1 = float32

// OrderLineItem_RawQuantity_Value defines model for OrderLineItem.RawQuantity.Value.
type OrderLineItem_RawQuantity_Value struct {
	union json.RawMessage
}

// OrderLineItemRawRefundableTotalValue0 The raw refundable total's value.
type OrderLineItemRawRefundableTotalValue0 = string

// OrderLineItemRawRefundableTotalValue1 The raw refundable total's value.
type OrderLineItemRawRefundableTotalValue1 = float32

// OrderLineItem_RawRefundableTotal_Value defines model for OrderLineItem.RawRefundableTotal.Value.
type OrderLineItem_RawRefundableTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawRefundableTotalPerUnitValue0 The raw refundable total per unit's value.
type OrderLineItemRawRefundableTotalPerUnitValue0 = string

// OrderLineItemRawRefundableTotalPerUnitValue1 The raw refundable total per unit's value.
type OrderLineItemRawRefundableTotalPerUnitValue1 = float32

// OrderLineItem_RawRefundableTotalPerUnit_Value defines model for OrderLineItem.RawRefundableTotalPerUnit.Value.
type OrderLineItem_RawRefundableTotalPerUnit_Value struct {
	union json.RawMessage
}

// OrderLineItemRawSubtotalValue0 The raw subtotal's value.
type OrderLineItemRawSubtotalValue0 = string

// OrderLineItemRawSubtotalValue1 The raw subtotal's value.
type OrderLineItemRawSubtotalValue1 = float32

// OrderLineItem_RawSubtotal_Value defines model for OrderLineItem.RawSubtotal.Value.
type OrderLineItem_RawSubtotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawTaxTotalValue0 The raw tax total's value.
type OrderLineItemRawTaxTotalValue0 = string

// OrderLineItemRawTaxTotalValue1 The raw tax total's value.
type OrderLineItemRawTaxTotalValue1 = float32

// OrderLineItem_RawTaxTotal_Value defines model for OrderLineItem.RawTaxTotal.Value.
type OrderLineItem_RawTaxTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawTotalValue0 The raw total's value.
type OrderLineItemRawTotalValue0 = string

// OrderLineItemRawTotalValue1 The raw total's value.
type OrderLineItemRawTotalValue1 = float32

// OrderLineItem_RawTotal_Value defines model for OrderLineItem.RawTotal.Value.
type OrderLineItem_RawTotal_Value struct {
	union json.RawMessage
}

// OrderLineItemRawUnitPriceValue0 The raw unit price's value.
type OrderLineItemRawUnitPriceValue0 = string

// OrderLineItemRawUnitPriceValue1 The raw unit price's value.
type OrderLineItemRawUnitPriceValue1 = float32

// OrderLineItem_RawUnitPrice_Value defines model for OrderLineItem.RawUnitPrice.Value.
type OrderLineItem_RawUnitPrice_Value struct {
	union json.RawMessage
}

// OrderLineItemAdjustment The line item adjustment's details.
type OrderLineItemAdjustment struct {
	// Amount The adjustment's amount.
	Amount float32 `json:"amount"`

	// Code The adjustment's code.
	Code *string `json:"code,omitempty"`

	// CreatedAt The date the adjustment was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The adjustment's description.
	Description *string `json:"description,omitempty"`

	// Id The adjustment's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId The ID of the item this adjustment is for.
	ItemId string `json:"item_id"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// PromotionId The ID of the promotion applied by this adjustment.
	PromotionId *string `json:"promotion_id,omitempty"`

	// ProviderId The adjustment's provider ID.
	ProviderId *string `json:"provider_id,omitempty"`

	// UpdatedAt The date the adjustment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderLineItemTaxLine The line item tax line's details.
type OrderLineItemTaxLine struct {
	// Code The code that the tax rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax line was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The tax line's description.
	Description *string `json:"description,omitempty"`

	// Id The tax line's ID.
	Id   string                 `json:"id"`
	Item map[string]interface{} `json:"item"`

	// ItemId The ID of the line item that the tax line belongs to.
	ItemId string `json:"item_id"`

	// ProviderId The ID of the tax provider used to calculate the tax lines.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rate The rate to charge.
	Rate float32 `json:"rate"`

	// RawSubtotal The tax line's raw subtotal.
	RawSubtotal map[string]interface{} `json:"raw_subtotal"`

	// RawTotal The tax line's raw total.
	RawTotal map[string]interface{} `json:"raw_total"`

	// Subtotal The item's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxRateId The ID of the applied tax rate.
	TaxRateId *string `json:"tax_rate_id,omitempty"`

	// Total The item's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the tax line was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderReturnItem The item's items.
type OrderReturnItem struct {
	// DamagedQuantity The received damaged quantity of the item, which isn't added to the stocked inventory quantity of the item.
	DamagedQuantity float32 `json:"damaged_quantity"`

	// Id The return item's ID.
	Id string `json:"id"`

	// ItemId The ID of the associated order item.
	ItemId string `json:"item_id"`

	// Metadata The return item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Note A note about why the item was returned.
	Note *string `json:"note,omitempty"`

	// Quantity The return item's quantity.
	Quantity float32 `json:"quantity"`

	// ReasonId The ID of the return reason associated with the item.
	ReasonId *string `json:"reason_id,omitempty"`

	// ReceivedQuantity The received quantity of the item. This quantity is added to the stocked inventory quantity of the item.
	ReceivedQuantity float32 `json:"received_quantity"`

	// ReturnId The ID of the return this return item belongs to.
	ReturnId string `json:"return_id"`
}

// OrderShippingMethod The shipping method's details.
type OrderShippingMethod struct {
	// Adjustments The shipping method's adjustments.
	Adjustments *[]OrderShippingMethodAdjustment `json:"adjustments,omitempty"`

	// Amount The shipping method's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date the shipping method was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The shipping method's data, useful for the fulfillment provider handling the fulfillment.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// DiscountTaxTotal The total taxes of the discount amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The shipping method's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// Id The shipping method's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether the shipping method's amount includes taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// Metadata The shipping method's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The shipping method's name.
	Name string `json:"name"`

	// OrderId The ID of the order that the shipping method belongs to.
	OrderId string `json:"order_id"`

	// OriginalSubtotal The shipping method's subtotal excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes of the shipping method excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The shipping method's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// RawAmount The shipping method's raw amount.
	RawAmount struct {
		Value OrderShippingMethod_RawAmount_Value `json:"value"`
	} `json:"raw_amount"`

	// RawDiscountTaxTotal The shipping method's raw discount tax total.
	RawDiscountTaxTotal struct {
		Value OrderShippingMethod_RawDiscountTaxTotal_Value `json:"value"`
	} `json:"raw_discount_tax_total"`

	// RawDiscountTotal The shipping method's raw discount total.
	RawDiscountTotal struct {
		Value OrderShippingMethod_RawDiscountTotal_Value `json:"value"`
	} `json:"raw_discount_total"`

	// RawOriginalSubtotal The shipping method's raw original subtotal.
	RawOriginalSubtotal struct {
		Value OrderShippingMethod_RawOriginalSubtotal_Value `json:"value"`
	} `json:"raw_original_subtotal"`

	// RawOriginalTaxTotal The shipping method's raw original tax total.
	RawOriginalTaxTotal struct {
		Value OrderShippingMethod_RawOriginalTaxTotal_Value `json:"value"`
	} `json:"raw_original_tax_total"`

	// RawOriginalTotal The shipping method's raw original total.
	RawOriginalTotal struct {
		Value OrderShippingMethod_RawOriginalTotal_Value `json:"value"`
	} `json:"raw_original_total"`

	// RawSubtotal The shipping method's raw subtotal.
	RawSubtotal struct {
		Value OrderShippingMethod_RawSubtotal_Value `json:"value"`
	} `json:"raw_subtotal"`

	// RawTaxTotal The shipping method's raw tax total.
	RawTaxTotal struct {
		Value OrderShippingMethod_RawTaxTotal_Value `json:"value"`
	} `json:"raw_tax_total"`

	// RawTotal The shipping method's raw total.
	RawTotal struct {
		Value OrderShippingMethod_RawTotal_Value `json:"value"`
	} `json:"raw_total"`

	// ShippingOptionId The ID of the shipping option this method was created from.
	ShippingOptionId *string `json:"shipping_option_id,omitempty"`

	// Subtotal The shipping method's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The shipping method's tax lines.
	TaxLines *[]OrderShippingMethodTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The total taxes of the shipping method, including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The shipping method's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the shipping method was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderShippingMethodRawAmountValue0 The raw amount's value.
type OrderShippingMethodRawAmountValue0 = string

// OrderShippingMethodRawAmountValue1 The raw amount's value.
type OrderShippingMethodRawAmountValue1 = float32

// OrderShippingMethod_RawAmount_Value defines model for OrderShippingMethod.RawAmount.Value.
type OrderShippingMethod_RawAmount_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawDiscountTaxTotalValue0 The raw discount tax total's value.
type OrderShippingMethodRawDiscountTaxTotalValue0 = string

// OrderShippingMethodRawDiscountTaxTotalValue1 The raw discount tax total's value.
type OrderShippingMethodRawDiscountTaxTotalValue1 = float32

// OrderShippingMethod_RawDiscountTaxTotal_Value defines model for OrderShippingMethod.RawDiscountTaxTotal.Value.
type OrderShippingMethod_RawDiscountTaxTotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawDiscountTotalValue0 The raw discount total's value.
type OrderShippingMethodRawDiscountTotalValue0 = string

// OrderShippingMethodRawDiscountTotalValue1 The raw discount total's value.
type OrderShippingMethodRawDiscountTotalValue1 = float32

// OrderShippingMethod_RawDiscountTotal_Value defines model for OrderShippingMethod.RawDiscountTotal.Value.
type OrderShippingMethod_RawDiscountTotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawOriginalSubtotalValue0 The raw original subtotal's value.
type OrderShippingMethodRawOriginalSubtotalValue0 = string

// OrderShippingMethodRawOriginalSubtotalValue1 The raw original subtotal's value.
type OrderShippingMethodRawOriginalSubtotalValue1 = float32

// OrderShippingMethod_RawOriginalSubtotal_Value defines model for OrderShippingMethod.RawOriginalSubtotal.Value.
type OrderShippingMethod_RawOriginalSubtotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawOriginalTaxTotalValue0 The raw original tax total's value.
type OrderShippingMethodRawOriginalTaxTotalValue0 = string

// OrderShippingMethodRawOriginalTaxTotalValue1 The raw original tax total's value.
type OrderShippingMethodRawOriginalTaxTotalValue1 = float32

// OrderShippingMethod_RawOriginalTaxTotal_Value defines model for OrderShippingMethod.RawOriginalTaxTotal.Value.
type OrderShippingMethod_RawOriginalTaxTotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawOriginalTotalValue0 The raw original total's value.
type OrderShippingMethodRawOriginalTotalValue0 = string

// OrderShippingMethodRawOriginalTotalValue1 The raw original total's value.
type OrderShippingMethodRawOriginalTotalValue1 = float32

// OrderShippingMethod_RawOriginalTotal_Value defines model for OrderShippingMethod.RawOriginalTotal.Value.
type OrderShippingMethod_RawOriginalTotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawSubtotalValue0 The raw subtotal's value.
type OrderShippingMethodRawSubtotalValue0 = string

// OrderShippingMethodRawSubtotalValue1 The raw subtotal's value.
type OrderShippingMethodRawSubtotalValue1 = float32

// OrderShippingMethod_RawSubtotal_Value defines model for OrderShippingMethod.RawSubtotal.Value.
type OrderShippingMethod_RawSubtotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawTaxTotalValue0 The raw tax total's value.
type OrderShippingMethodRawTaxTotalValue0 = string

// OrderShippingMethodRawTaxTotalValue1 The raw tax total's value.
type OrderShippingMethodRawTaxTotalValue1 = float32

// OrderShippingMethod_RawTaxTotal_Value defines model for OrderShippingMethod.RawTaxTotal.Value.
type OrderShippingMethod_RawTaxTotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodRawTotalValue0 The raw total's value.
type OrderShippingMethodRawTotalValue0 = string

// OrderShippingMethodRawTotalValue1 The raw total's value.
type OrderShippingMethodRawTotalValue1 = float32

// OrderShippingMethod_RawTotal_Value defines model for OrderShippingMethod.RawTotal.Value.
type OrderShippingMethod_RawTotal_Value struct {
	union json.RawMessage
}

// OrderShippingMethodAdjustment The shipping method adjustment's details.
type OrderShippingMethodAdjustment struct {
	// Amount The adjustment's amount.
	Amount float32 `json:"amount"`

	// Code The adjustment's code.
	Code *string `json:"code,omitempty"`

	// CreatedAt The date the adjustment was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The adjustment's description.
	Description *string `json:"description,omitempty"`

	// Id The adjustment's ID.
	Id string `json:"id"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// PromotionId The ID of the promotion this adjustment applies.
	PromotionId *string `json:"promotion_id,omitempty"`

	// ProviderId The adjustment's provider ID.
	ProviderId     *string                `json:"provider_id,omitempty"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the shipping method this adjustment is for.
	ShippingMethodId string `json:"shipping_method_id"`

	// UpdatedAt The date the adjustment was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderShippingMethodTaxLine The shipping method tax line's details.
type OrderShippingMethodTaxLine struct {
	// Code The code that the tax rate is identified by.
	Code string `json:"code"`

	// CreatedAt The date the tax line was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The tax line's description.
	Description *string `json:"description,omitempty"`

	// Id The tax line's ID.
	Id string `json:"id"`

	// ProviderId The ID of the tax provider used to calculate taxes.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rate The rate to charge.
	Rate float32 `json:"rate"`

	// RawSubtotal The tax line's raw subtotal.
	RawSubtotal map[string]interface{} `json:"raw_subtotal"`

	// RawTotal The tax line's raw total.
	RawTotal       map[string]interface{} `json:"raw_total"`
	ShippingMethod map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the shipping method that this tax line is for.
	ShippingMethodId string `json:"shipping_method_id"`

	// Subtotal The shipping method's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxRateId The ID of the applied tax rate.
	TaxRateId *string `json:"tax_rate_id,omitempty"`

	// Total The shipping method's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the tax line was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderTransaction The transaction's details.
type OrderTransaction struct {
	// Amount The transaction's amount.
	Amount float32 `json:"amount"`

	// CreatedAt The date that the transaction was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The transaction's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The transaction's ID.
	Id string `json:"id"`

	// Metadata The transaction's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OrderId The ID of the order this transaction belongs to.
	OrderId string `json:"order_id"`

	// Reference The name of a table that this transaction references. If this transaction is for captured payment, its value is `capture`. If this transaction is for refunded payment, its value is `refund`.
	Reference OrderTransactionReference `json:"reference"`

	// ReferenceId The ID of the referenced record in the referenced table.
	ReferenceId string `json:"reference_id"`

	// UpdatedAt The date that the transaction was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderTransactionReference The name of a table that this transaction references. If this transaction is for captured payment, its value is `capture`. If this transaction is for refunded payment, its value is `refund`.
type OrderTransactionReference string

// RefundReason The refund reason's details.
type RefundReason struct {
	// CreatedAt The date the refund reason was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The refund reason's description.
	Description *string `json:"description,omitempty"`

	// Id The refund reason's ID.
	Id string `json:"id"`

	// Label The refund reason's label.
	Label string `json:"label"`

	// Metadata The refund reason's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// UpdatedAt The date the refund reason was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// RefundReasonResponse The refund reason's details.
type RefundReasonResponse struct {
	// RefundReason The refund reason's details.
	RefundReason AdminRefundReason `json:"refund_reason"`
}

// Return The return's details.
type Return struct {
	// BillingAddress The address's details.
	BillingAddress *OrderAddress `json:"billing_address,omitempty"`

	// CanceledAt The date the return was canceled.
	CanceledAt *time.Time `json:"canceled_at,omitempty"`

	// CreatedAt The date the return was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The return's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId *string `json:"customer_id,omitempty"`

	// DiscountSubtotal The return's discount subtotal.
	DiscountSubtotal float32 `json:"discount_subtotal"`

	// DiscountTaxTotal The return's discount tax total.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The return's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// Email The email of the customer that placed the order.
	Email *openapi_types.Email `json:"email,omitempty"`

	// GiftCardTaxTotal The return's gift card tax total.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The return's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The return's ID.
	Id string `json:"id"`

	// ItemSubtotal The return's item subtotal.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The return's item tax total.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The return's item total.
	ItemTotal float32 `json:"item_total"`

	// Items The return's items.
	Items []OrderReturnItem `json:"items"`

	// Metadata The return's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OrderChange The order change's details.
	OrderChange *OrderChange `json:"order_change,omitempty"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`

	// OriginalItemSubtotal The return's original item subtotal.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The return's original item tax total.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The return's original item total.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The return's original shipping subtotal.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The return's original shipping tax total.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The return's original shipping total.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The return's original subtotal.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The return's original tax total.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The return's original total.
	OriginalTotal float32 `json:"original_total"`

	// RawDiscountTaxTotal The return's raw discount tax total.
	RawDiscountTaxTotal map[string]interface{} `json:"raw_discount_tax_total"`

	// RawDiscountTotal The return's raw discount total.
	RawDiscountTotal map[string]interface{} `json:"raw_discount_total"`

	// RawGiftCardTaxTotal The return's raw gift card tax total.
	RawGiftCardTaxTotal map[string]interface{} `json:"raw_gift_card_tax_total"`

	// RawGiftCardTotal The return's raw gift card total.
	RawGiftCardTotal map[string]interface{} `json:"raw_gift_card_total"`

	// RawItemSubtotal The return's raw item subtotal.
	RawItemSubtotal map[string]interface{} `json:"raw_item_subtotal"`

	// RawItemTaxTotal The return's raw item tax total.
	RawItemTaxTotal map[string]interface{} `json:"raw_item_tax_total"`

	// RawItemTotal The return's raw item total.
	RawItemTotal map[string]interface{} `json:"raw_item_total"`

	// RawOriginalItemSubtotal The return's raw original item subtotal.
	RawOriginalItemSubtotal map[string]interface{} `json:"raw_original_item_subtotal"`

	// RawOriginalItemTaxTotal The return's raw original item tax total.
	RawOriginalItemTaxTotal map[string]interface{} `json:"raw_original_item_tax_total"`

	// RawOriginalItemTotal The return's raw original item total.
	RawOriginalItemTotal map[string]interface{} `json:"raw_original_item_total"`

	// RawOriginalShippingSubtotal The return's raw original shipping subtotal.
	RawOriginalShippingSubtotal map[string]interface{} `json:"raw_original_shipping_subtotal"`

	// RawOriginalShippingTaxTotal The return's raw original shipping tax total.
	RawOriginalShippingTaxTotal map[string]interface{} `json:"raw_original_shipping_tax_total"`

	// RawOriginalShippingTotal The return's raw original shipping total.
	RawOriginalShippingTotal map[string]interface{} `json:"raw_original_shipping_total"`

	// RawOriginalSubtotal The return's raw original subtotal.
	RawOriginalSubtotal map[string]interface{} `json:"raw_original_subtotal"`

	// RawOriginalTaxTotal The return's raw original tax total.
	RawOriginalTaxTotal map[string]interface{} `json:"raw_original_tax_total"`

	// RawOriginalTotal The return's raw original total.
	RawOriginalTotal map[string]interface{} `json:"raw_original_total"`

	// RawShippingSubtotal The return's raw shipping subtotal.
	RawShippingSubtotal map[string]interface{} `json:"raw_shipping_subtotal"`

	// RawShippingTaxTotal The return's raw shipping tax total.
	RawShippingTaxTotal map[string]interface{} `json:"raw_shipping_tax_total"`

	// RawShippingTotal The return's raw shipping total.
	RawShippingTotal map[string]interface{} `json:"raw_shipping_total"`

	// RawSubtotal The return's raw subtotal.
	RawSubtotal map[string]interface{} `json:"raw_subtotal"`

	// RawTaxTotal The return's raw tax total.
	RawTaxTotal map[string]interface{} `json:"raw_tax_total"`

	// RawTotal The return's raw total.
	RawTotal map[string]interface{} `json:"raw_total"`

	// RefundAmount The amount refunded by this return.
	RefundAmount *float32 `json:"refund_amount,omitempty"`

	// RegionId The ID of the region this return belongs to.
	RegionId *string `json:"region_id,omitempty"`

	// SalesChannelId The ID of the associated order's sales channel.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`

	// ShippingAddress The address's details.
	ShippingAddress *OrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The return's shipping methods.
	ShippingMethods *[]OrderShippingMethod `json:"shipping_methods,omitempty"`

	// ShippingSubtotal The return's shipping subtotal.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The return's shipping tax total.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The return's shipping total.
	ShippingTotal float32 `json:"shipping_total"`

	// Status The return's status.
	Status ReturnStatus `json:"status"`

	// Subtotal The return's subtotal.
	Subtotal float32 `json:"subtotal"`

	// Summary The return's summary.
	Summary *map[string]interface{} `json:"summary,omitempty"`

	// TaxTotal The return's tax total.
	TaxTotal float32 `json:"tax_total"`

	// Total The return's total.
	Total float32 `json:"total"`

	// Transactions The return's transactions.
	Transactions *[]OrderTransaction `json:"transactions,omitempty"`

	// UpdatedAt The date the return was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReturnStatus The return's status.
type ReturnStatus string

// StoreAddCartLineItem The details of the line item to add.
type StoreAddCartLineItem struct {
	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// VariantId The ID of the product variant to add to the cart.
	VariantId string `json:"variant_id"`
}

// StoreCart The cart's details.
type StoreCart struct {
	// BillingAddress The address's details.
	BillingAddress *StoreCartAddress `json:"billing_address,omitempty"`

	// CreatedAt The date the cart was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The cart's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the customer the cart belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// DiscountTaxTotal The tax total applied on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The cart's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// Email The email of the customer the cart belongs to.
	Email *openapi_types.Email `json:"email,omitempty"`

	// GiftCardTaxTotal The total taxes applied on the gift card amount.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The total gift card amount applied on the cart.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The cart's ID.
	Id string `json:"id"`

	// ItemSubtotal The cart items' total excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The cart items' tax total including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The cart items' total including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Items The cart's items.
	Items *[]StoreCartLineItem `json:"items,omitempty"`

	// Metadata The cart's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OriginalItemSubtotal The cart items' total excluding taxes, including promotions.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The cart items' tax total excluding promotions.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The cart items' total including taxes, excluding promotions.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The cart's shipping total excluding taxes, including promotions.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The total taxes applied on the cart's shipping amount.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The cart's shipping total including taxes, excluding promotions.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The cart's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The cart's tax total excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The cart's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollection The payment collection's details.
	PaymentCollection *StorePaymentCollection `json:"payment_collection,omitempty"`

	// Region The region's details.
	Region *StoreRegion `json:"region,omitempty"`

	// RegionId The ID of the region the cart belongs to.
	RegionId *string `json:"region_id,omitempty"`

	// SalesChannelId The ID of the cart's sales channel. Only products that belong to the same sales channel can be added to the cart. The created order will be associated with the same sales channel.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`

	// ShippingAddress The address's details.
	ShippingAddress *StoreCartAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The cart's shipping methods.
	ShippingMethods *[]StoreCartShippingMethod `json:"shipping_methods,omitempty"`

	// ShippingSubtotal The cart's shipping total excluding taxes, including promotions.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The total taxes applied on the cart's shipping amount.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The cart's shipping total including taxes and promotions.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The cart's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxTotal The cart's tax total including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The cart's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the cart was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// StoreCartAddress The address's details.
type StoreCartAddress struct {
	// Address1 The address's first line.
	Address1 *string `json:"address_1,omitempty"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// CountryCode The address's country code.
	CountryCode *string `json:"country_code,omitempty"`

	// CreatedAt The date the address was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer the address belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// FirstName The address's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Id The address's ID.
	Id string `json:"id"`

	// LastName The address's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`

	// UpdatedAt The date the address was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreCartLineItem The item's details.
type StoreCartLineItem struct {
	// Adjustments The item's adjustments.
	Adjustments *[]struct {
		// Amount The adjustment's amount.
		Amount float32 `json:"amount"`

		// CartId The ID of the associated cart.
		CartId string `json:"cart_id"`

		// Code The adjustment's code.
		Code *string `json:"code,omitempty"`

		// CreatedAt The date the adjustment was created.
		CreatedAt time.Time `json:"created_at"`

		// Description The adjustment's description.
		Description *string `json:"description,omitempty"`

		// Id The adjustment's ID.
		Id string `json:"id"`

		// Item The details of the item that the adjustment belongs to.
		Item map[string]interface{} `json:"item"`

		// ItemId The ID of the item that the adjustment belongs to.
		ItemId string `json:"item_id"`

		// PromotionId The ID of the applied promotion.
		PromotionId *string `json:"promotion_id,omitempty"`

		// ProviderId The adjustment's provider ID.
		ProviderId *string `json:"provider_id,omitempty"`

		// UpdatedAt The date the adjustment was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"adjustments,omitempty"`
	Cart map[string]interface{} `json:"cart"`

	// CartId The ID of the cart that the line item belongs to.
	CartId string `json:"cart_id"`

	// CompareAtUnitPrice The original price of the item before a promotion or sale.
	CompareAtUnitPrice *float32 `json:"compare_at_unit_price,omitempty"`

	// CreatedAt The date the item was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the item was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// DiscountTaxTotal The total taxes applied on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total discount of the item.
	DiscountTotal float32 `json:"discount_total"`

	// Id The item's ID.
	Id string `json:"id"`

	// IsDiscountable Whether the item is discountable.
	IsDiscountable bool `json:"is_discountable"`

	// IsTaxInclusive Whether the item's price includes taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// ItemSubtotal The item's total excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The total taxes of the item including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The item's total including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// OriginalSubtotal The item's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes of the item excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The item's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// Product The product's details.
	Product *StoreProduct `json:"product,omitempty"`

	// ProductCollection The ID of the associated product's collection.
	ProductCollection *string `json:"product_collection,omitempty"`

	// ProductDescription The item's product description.
	ProductDescription *string `json:"product_description,omitempty"`

	// ProductHandle The item's product handle.
	ProductHandle *string `json:"product_handle,omitempty"`

	// ProductId The ID of the associated product.
	ProductId *string `json:"product_id,omitempty"`

	// ProductSubtitle The item's product subtitle.
	ProductSubtitle *string `json:"product_subtitle,omitempty"`

	// ProductTitle The item's product title.
	ProductTitle *string `json:"product_title,omitempty"`

	// ProductType The ID of the associated product's type.
	ProductType *string `json:"product_type,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping bool `json:"requires_shipping"`

	// Subtitle The item's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Subtotal The item's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The item's tax lines.
	TaxLines *[]struct {
		// Code The code that the tax rate is identified by.
		Code string `json:"code"`

		// CreatedAt The date the tax line was created.
		CreatedAt time.Time `json:"created_at"`

		// Description The tax line's description.
		Description *string `json:"description,omitempty"`

		// Id The tax line's ID.
		Id string `json:"id"`

		// Item The details of the item that the tax line belongs to.
		Item map[string]interface{} `json:"item"`

		// ItemId The ID of the line item this tax line belongs to.
		ItemId string `json:"item_id"`

		// ProviderId The ID of the tax provider used to calculate the tax line.
		ProviderId *string `json:"provider_id,omitempty"`

		// Rate The charged rate.
		Rate float32 `json:"rate"`

		// Subtotal The item's total excluding taxes, including promotions.
		Subtotal float32 `json:"subtotal"`

		// TaxRateId The ID of the applied tax rate.
		TaxRateId *string `json:"tax_rate_id,omitempty"`

		// Total The item's total including taxes and promotions.
		Total float32 `json:"total"`

		// UpdatedAt The date the tax line was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"tax_lines,omitempty"`

	// TaxTotal The total taxes of the item including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Thumbnail The item's thumbnail URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The item's title.
	Title string `json:"title"`

	// Total The item's total including taxes and promotions.
	Total float32 `json:"total"`

	// UnitPrice The price of a single quantity of the item.
	UnitPrice float32 `json:"unit_price"`

	// UpdatedAt The date the item was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Variant The variant's details.
	Variant *StoreProductVariant `json:"variant,omitempty"`

	// VariantBarcode The item's variant barcode.
	VariantBarcode *string `json:"variant_barcode,omitempty"`

	// VariantId The ID of the associated product variant.
	VariantId *string `json:"variant_id,omitempty"`

	// VariantOptionValues The associated variant's value for the product's options.
	VariantOptionValues *map[string]interface{} `json:"variant_option_values,omitempty"`

	// VariantSku The item's variant SKU.
	VariantSku *string `json:"variant_sku,omitempty"`

	// VariantTitle The item's variant title.
	VariantTitle *string `json:"variant_title,omitempty"`
}

// StoreCartResponse The cart's details.
type StoreCartResponse struct {
	// Cart The cart's details.
	Cart StoreCart `json:"cart"`
}

// StoreCartShippingMethod A cart's shipping method.
type StoreCartShippingMethod struct {
	// Adjustments The shipping method's adjustments, such as applied promotions.
	Adjustments *[]struct {
		// Amount The adjustment's amount.
		Amount float32 `json:"amount"`

		// CartId The ID of the associated cart.
		CartId string `json:"cart_id"`

		// Code The adjustment's code.
		Code *string `json:"code,omitempty"`

		// CreatedAt The date the adjustment was created.
		CreatedAt time.Time `json:"created_at"`

		// Description The adjustment's description.
		Description *string `json:"description,omitempty"`

		// Id The adjustment's ID.
		Id string `json:"id"`

		// PromotionId The ID of the applied promotion.
		PromotionId *string `json:"promotion_id,omitempty"`

		// ProviderId The adjustment's provider ID.
		ProviderId *string `json:"provider_id,omitempty"`

		// ShippingMethod The details of the method that the adjustment belongs to.
		ShippingMethod map[string]interface{} `json:"shipping_method"`

		// UpdatedAt The date the adjustment was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"adjustments,omitempty"`

	// Amount The shipping method's amount.
	Amount float32 `json:"amount"`

	// CartId The ID of the cart this shipping method belongs to.
	CartId string `json:"cart_id"`

	// CreatedAt The date the shipping method was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The shipping method's data, useful for fulfillment handling by third-party services.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Description The shipping method's description.
	Description *string `json:"description,omitempty"`

	// DiscountTaxTotal The taxes applied on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The total amount discounted.
	DiscountTotal float32 `json:"discount_total"`

	// Id The shipping method's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether the shipping method's amount is tax inclusive.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// Metadata The shipping method's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The shipping method's name.
	Name string `json:"name"`

	// OriginalSubtotal The shipping method's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes applied on the shipping method's amount including promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The shipping method's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// ShippingOptionId The ID of the shipping option this method was created from.
	ShippingOptionId *string `json:"shipping_option_id,omitempty"`

	// Subtotal The shipping method's total amount excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// TaxLines The shipping method's tax lines.
	TaxLines *[]struct {
		// Code The code that the tax rate is identified by.
		Code string `json:"code"`

		// CreatedAt The date the tax line was created.
		CreatedAt time.Time `json:"created_at"`

		// Description The tax line's description.
		Description *string `json:"description,omitempty"`

		// Id The tax line's ID.
		Id string `json:"id"`

		// ProviderId The ID of the tax provider used to calculate the tax line.
		ProviderId *string `json:"provider_id,omitempty"`

		// Rate The charged rate.
		Rate float32 `json:"rate"`

		// ShippingMethod The details of the method that the tax line belongs to.
		ShippingMethod map[string]interface{} `json:"shipping_method"`

		// ShippingMethodId The ID of the shipping method this tax line belongs to.
		ShippingMethodId string `json:"shipping_method_id"`

		// Subtotal The method's total excluding taxes, including promotions.
		Subtotal float32 `json:"subtotal"`

		// TaxRateId The ID of the applied tax rate.
		TaxRateId *string `json:"tax_rate_id,omitempty"`

		// Total The method's total including taxes and promotions.
		Total float32 `json:"total"`

		// UpdatedAt The date the tax line was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"tax_lines,omitempty"`

	// TaxTotal The total taxes applied on the shipping method's amount including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The shipping method's total amount including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the shipping method was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreCollection The collection's details.
type StoreCollection struct {
	// CreatedAt The date the collection was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the collection was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Handle The collection's handle.
	Handle string `json:"handle"`

	// Id The collection's ID.
	Id string `json:"id"`

	// Metadata The collection's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Products The collection's products.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// Title The collection's title.
	Title string `json:"title"`

	// UpdatedAt The date the collection was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreCollectionResponse The collection's details.
type StoreCollectionResponse struct {
	// Collection The collection's details.
	Collection StoreCollection `json:"collection"`
}

// StoreCreateCart The details of the cart to be created.
type StoreCreateCart struct {
	// BillingAddress The address's details.
	BillingAddress *StoreCartAddress `json:"billing_address,omitempty"`

	// CurrencyCode The cart's currency code. If not provided, the region's currency is used. This affects prices in the cart, as well.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// Email The email of the cart's customer.
	Email *openapi_types.Email `json:"email,omitempty"`

	// Items The cart's items.
	Items *[]StoreCartLineItem `json:"items,omitempty"`

	// Metadata The cart's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// RegionId The ID of the cart's region. This affects the prices and currency of the cart.
	RegionId *string `json:"region_id,omitempty"`

	// SalesChannelId The ID of the sales channel that cart is created in. Only products available in that sales channel can be added to the cart. If not provided, the store's default sales channel is associated with the cart instead.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`

	// ShippingAddress The address's details.
	ShippingAddress *StoreCartAddress `json:"shipping_address,omitempty"`
}

// StoreCreateCustomer The details of the customer to create.
type StoreCreateCustomer struct {
	// CompanyName The customer's company name.
	CompanyName *string `json:"company_name,omitempty"`

	// Email The customer's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The customer's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The customer's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The customer's phone.
	Phone *string `json:"phone,omitempty"`
}

// StoreCreatePaymentCollection The details of the payment collection to create.
type StoreCreatePaymentCollection struct {
	// CartId The ID of the cart this payment collection is for.
	CartId string `json:"cart_id"`
}

// StoreCreateReturn The details of the return to create.
type StoreCreateReturn struct {
	// Items The return's items.
	Items []StoreCreateReturnItem `json:"items"`

	// LocationId The ID of the location that items are returned to.
	LocationId *string `json:"location_id,omitempty"`

	// Note A note with more details about the return.
	Note *string `json:"note,omitempty"`

	// OrderId The ID of the order this return is created for.
	OrderId string `json:"order_id"`

	// ReceiveNow Whether to mark the return as received.
	ReceiveNow *bool `json:"receive_now,omitempty"`

	// ReturnShipping The return's shipping details.
	ReturnShipping StoreCreateReturnShipping `json:"return_shipping"`
}

// StoreCreateReturnItem The details of the line item to create.
type StoreCreateReturnItem struct {
	// Id The item's ID.
	Id string `json:"id"`

	// Note A note with more details about the returned item.
	Note *string `json:"note,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// ReasonId The ID of the associated return reason.
	ReasonId *string `json:"reason_id,omitempty"`
}

// StoreCreateReturnShipping The return's shipping details.
type StoreCreateReturnShipping struct {
	// OptionId The ID of the shipping option to use.
	OptionId string `json:"option_id"`

	// Price The shipping's price.
	Price *float32 `json:"price,omitempty"`
}

// StoreCurrency The currency's details.
type StoreCurrency struct {
	// Code The currency's code.
	Code string `json:"code"`

	// CreatedAt The date the currency was created.
	CreatedAt time.Time `json:"created_at"`

	// DecimalDigits The currency's decimal digits.
	DecimalDigits float32 `json:"decimal_digits"`

	// DeletedAt The date the currency was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Name The currency's name.
	Name string `json:"name"`

	// Rounding The currency's rounding.
	Rounding float32 `json:"rounding"`

	// Symbol The currency's symbol.
	Symbol string `json:"symbol"`

	// SymbolNative The currency's symbol native.
	SymbolNative string `json:"symbol_native"`

	// UpdatedAt The date the currency was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreCurrencyListResponse The paginated list of currencies.
type StoreCurrencyListResponse struct {
	// Count The total count of items.
	Count float32 `json:"count"`

	// Currencies The list of currencies.
	Currencies []StoreCurrency `json:"currencies"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`
}

// StoreCurrencyResponse The currency's details.
type StoreCurrencyResponse struct {
	// Currency The currency's details.
	Currency StoreCurrency `json:"currency"`
}

// StoreCustomer The customer's details.
type StoreCustomer struct {
	// Addresses The customer's addresses.
	Addresses []StoreCustomerAddress `json:"addresses"`

	// CompanyName The customer's company name.
	CompanyName string `json:"company_name"`

	// CreatedAt The date the customer was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DefaultBillingAddressId The ID of the address used for billing by default.
	DefaultBillingAddressId string `json:"default_billing_address_id"`

	// DefaultShippingAddressId The ID of the address used for shipping by default.
	DefaultShippingAddressId string `json:"default_shipping_address_id"`

	// DeletedAt The date the customer was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Email The customer's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// Id The customer's ID.
	Id string `json:"id"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata The customer's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The customer's phone.
	Phone *string `json:"phone,omitempty"`

	// UpdatedAt The date the customer was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// StoreCustomerAddress The customer address's details
type StoreCustomerAddress struct {
	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 string `json:"address_2"`

	// AddressName The address's name.
	AddressName string `json:"address_name"`

	// City The address's city.
	City string `json:"city"`

	// Company The address's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// CreatedAt The date the address was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerId The ID of the customer the address belongs to.
	CustomerId string `json:"customer_id"`

	// FirstName The address's first name.
	FirstName string `json:"first_name"`

	// Id The address's ID.
	Id string `json:"id"`

	// IsDefaultBilling Whether the address is used for billing by default.
	IsDefaultBilling bool `json:"is_default_billing"`

	// IsDefaultShipping Whether the address is used for shipping by default.
	IsDefaultShipping bool `json:"is_default_shipping"`

	// LastName The address's last name.
	LastName string `json:"last_name"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`

	// UpdatedAt The date the address was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreCustomerAddressListResponse The paginated list of customer addresses.
type StoreCustomerAddressListResponse struct {
	// Addresses The list of addresses.
	Addresses []StoreCustomerAddress `json:"addresses"`

	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`
}

// StoreCustomerAddressResponse The address's details.
type StoreCustomerAddressResponse struct {
	// Address The customer address's details
	Address StoreCustomerAddress `json:"address"`
}

// StoreCustomerResponse The customer's details.
type StoreCustomerResponse struct {
	// Customer The customer's details.
	Customer StoreCustomer `json:"customer"`
}

// StoreOrder The order's details.
type StoreOrder struct {
	// BillingAddress An order address
	BillingAddress *BaseOrderAddress `json:"billing_address,omitempty"`

	// CreatedAt The date the order was created.
	CreatedAt time.Time `json:"created_at"`

	// CurrencyCode The order's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the customer that placed the order.
	CustomerId string `json:"customer_id"`

	// DiscountTaxTotal The total taxes applied on the discounted amount.
	DiscountTaxTotal float32 `json:"discount_tax_total"`

	// DiscountTotal The order's discount total.
	DiscountTotal float32 `json:"discount_total"`

	// DisplayId The order's display ID.
	DisplayId *float32 `json:"display_id,omitempty"`

	// Email The email of the customer that placed the order.
	Email openapi_types.Email `json:"email"`

	// FulfillmentStatus The order's fulfillment status.
	FulfillmentStatus StoreOrderFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The order's fulfillments.
	Fulfillments *[]BaseOrderFulfillment `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The total taxes applied on the gift card's amount.
	GiftCardTaxTotal float32 `json:"gift_card_tax_total"`

	// GiftCardTotal The order's gift card total.
	GiftCardTotal float32 `json:"gift_card_total"`

	// Id The order's ID.
	Id string `json:"id"`

	// ItemSubtotal The order items' total excluding taxes, including promotions.
	ItemSubtotal float32 `json:"item_subtotal"`

	// ItemTaxTotal The total taxes applied on the order's items, including promotions.
	ItemTaxTotal float32 `json:"item_tax_total"`

	// ItemTotal The order items' total including taxes and promotions.
	ItemTotal float32 `json:"item_total"`

	// Items The order's items.
	Items []BaseOrderLineItem `json:"items"`

	// Metadata The order's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// OriginalItemSubtotal The order items' total excluding taxes, including promotions.
	OriginalItemSubtotal float32 `json:"original_item_subtotal"`

	// OriginalItemTaxTotal The total taxes applied on the order items, excluding promotions.
	OriginalItemTaxTotal float32 `json:"original_item_tax_total"`

	// OriginalItemTotal The order items' total including taxes, excluding promotions.
	OriginalItemTotal float32 `json:"original_item_total"`

	// OriginalShippingSubtotal The order's shipping total excluding taxes, including promotions.
	OriginalShippingSubtotal float32 `json:"original_shipping_subtotal"`

	// OriginalShippingTaxTotal The total taxes of the order's shipping excluding promotions.
	OriginalShippingTaxTotal float32 `json:"original_shipping_tax_total"`

	// OriginalShippingTotal The order's shipping total including taxes, excluding promotions.
	OriginalShippingTotal float32 `json:"original_shipping_total"`

	// OriginalSubtotal The order's total excluding taxes, including promotions.
	OriginalSubtotal float32 `json:"original_subtotal"`

	// OriginalTaxTotal The total taxes of the order excluding promotions.
	OriginalTaxTotal float32 `json:"original_tax_total"`

	// OriginalTotal The order's total including taxes, excluding promotions.
	OriginalTotal float32 `json:"original_total"`

	// PaymentCollections The order's payment collections.
	PaymentCollections *[]BasePaymentCollection `json:"payment_collections,omitempty"`

	// PaymentStatus The order's payment status.
	PaymentStatus StoreOrderPaymentStatus `json:"payment_status"`

	// RegionId The ID of the associated region.
	RegionId string `json:"region_id"`

	// SalesChannelId The ID of the sales channel the order was placed in.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress An order address
	ShippingAddress *BaseOrderAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The order's shipping methods.
	ShippingMethods []BaseOrderShippingMethod `json:"shipping_methods"`

	// ShippingSubtotal The order's shipping total excluding taxes, including promotions.
	ShippingSubtotal float32 `json:"shipping_subtotal"`

	// ShippingTaxTotal The total taxes of the order's shipping including promotions.
	ShippingTaxTotal float32 `json:"shipping_tax_total"`

	// ShippingTotal The order's shipping total including taxes and promotions.
	ShippingTotal float32 `json:"shipping_total"`

	// Subtotal The order's total excluding taxes, including promotions.
	Subtotal float32 `json:"subtotal"`

	// Summary The order's summary details.
	Summary BaseOrderSummary `json:"summary"`

	// TaxTotal The tax totals of the order including promotions.
	TaxTotal float32 `json:"tax_total"`

	// Total The order's total including taxes and promotions.
	Total float32 `json:"total"`

	// UpdatedAt The date the order was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version The order's version.
	Version float32 `json:"version"`
}

// StoreOrderFulfillmentStatus The order's fulfillment status.
type StoreOrderFulfillmentStatus string

// StoreOrderPaymentStatus The order's payment status.
type StoreOrderPaymentStatus string

// StoreOrderResponse The order's details.
type StoreOrderResponse struct {
	// Order The order's details.
	Order StoreOrder `json:"order"`
}

// StorePaymentCollection The payment collection's details.
type StorePaymentCollection struct {
	// Amount The total amount to be paid.
	Amount float32 `json:"amount"`

	// AuthorizedAmount The total authorized amount of the collection's payments.
	AuthorizedAmount *float32 `json:"authorized_amount,omitempty"`

	// CapturedAmount The total captured amount of the collection's payments.
	CapturedAmount *float32 `json:"captured_amount,omitempty"`

	// CompletedAt The date the payment collection was completed.
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt The date the payment collection was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The payment collection's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The payment collection's ID.
	Id string `json:"id"`

	// Metadata The payment collection's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// PaymentProviders The payment provider used to process the collection's payments and sessions.
	PaymentProviders []StorePaymentProvider `json:"payment_providers"`

	// PaymentSessions The payment collection's payment sessions.
	PaymentSessions *[]StorePaymentSession `json:"payment_sessions,omitempty"`

	// Payments The payment collection's payments.
	Payments *[]BasePayment `json:"payments,omitempty"`

	// RefundedAmount The total refunded amount of the collection's payments.
	RefundedAmount *float32 `json:"refunded_amount,omitempty"`

	// RegionId The ID of the region this payment collection is associated with.
	RegionId string `json:"region_id"`

	// Status The payment collection's status.
	Status StorePaymentCollectionStatus `json:"status"`

	// UpdatedAt The date the payment collection was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// StorePaymentCollectionStatus The payment collection's status.
type StorePaymentCollectionStatus string

// StorePaymentCollectionResponse The payment collection's details.
type StorePaymentCollectionResponse struct {
	// PaymentCollection The payment collection's details.
	PaymentCollection StorePaymentCollection `json:"payment_collection"`
}

// StorePaymentProvider The payment provider's details
type StorePaymentProvider struct {
	// Id The payment provider's ID.
	Id string `json:"id"`
}

// StorePaymentSession The payment session's details.
type StorePaymentSession struct {
	// Amount The payment session's amount.
	Amount float32 `json:"amount"`

	// AuthorizedAt The date the payment session was authorized.
	AuthorizedAt *time.Time `json:"authorized_at,omitempty"`

	// Context The context around the payment, such as the customer's details.
	Context *map[string]interface{} `json:"context,omitempty"`

	// CurrencyCode The payment session's currency code.
	CurrencyCode string `json:"currency_code"`

	// Data The payment session's data, useful for the payment provider processing the payment.
	Data map[string]interface{} `json:"data"`

	// Id The payment session's ID.
	Id string `json:"id"`

	// Payment The payment's details.
	Payment           *BasePayment            `json:"payment,omitempty"`
	PaymentCollection *map[string]interface{} `json:"payment_collection,omitempty"`

	// ProviderId The ID of the payment provider processing this session.
	ProviderId string `json:"provider_id"`

	// Status The payment session's status.
	Status StorePaymentSessionStatus `json:"status"`
}

// StorePaymentSessionStatus The payment session's status.
type StorePaymentSessionStatus string

// StoreProduct The product's details.
type StoreProduct struct {
	// Categories The product's categories.
	Categories *[]map[string]interface{} `json:"categories,omitempty"`

	// Collection The collection's details.
	Collection *StoreCollection `json:"collection,omitempty"`

	// CollectionId The ID of the collection that the product belongs to.
	CollectionId string `json:"collection_id"`

	// CreatedAt The date the product was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the product was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The product's description.
	Description string `json:"description"`

	// Discountable Whether the product can be discounted.
	Discountable bool `json:"discountable"`

	// ExternalId The ID of the product in an external service or system.
	ExternalId string `json:"external_id"`

	// Handle The product's handle.
	Handle string `json:"handle"`

	// Height The product's height.
	Height float32 `json:"height"`

	// HsCode The product's HS code.
	HsCode string `json:"hs_code"`

	// Id The product's ID.
	Id string `json:"id"`

	// Images The product's images.
	Images []StoreProductImage `json:"images"`

	// IsGiftcard Whether the product is a gift card.
	IsGiftcard bool `json:"is_giftcard"`

	// Length The product's length.
	Length float32 `json:"length"`

	// Material The product's material.
	Material string `json:"material"`

	// Metadata The product's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's MID code.
	MidCode string `json:"mid_code"`

	// Options The product's options.
	Options []StoreProductOption `json:"options"`

	// OriginCountry The product's origin country.
	OriginCountry string `json:"origin_country"`

	// Status The product's status.
	Status StoreProductStatus `json:"status"`

	// Subtitle The product's subtitle.
	Subtitle string `json:"subtitle"`

	// Tags The product's tags.
	Tags *[]StoreProductTag `json:"tags,omitempty"`

	// Thumbnail The product's thumbnail URL.
	Thumbnail string `json:"thumbnail"`

	// Title The product's title.
	Title string                  `json:"title"`
	Type  *map[string]interface{} `json:"type,omitempty"`

	// TypeId The ID of the product's type.
	TypeId string `json:"type_id"`

	// UpdatedAt The date the product was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variants The product's variants.
	Variants []StoreProductVariant `json:"variants"`

	// Weight The product's weight.
	Weight float32 `json:"weight"`

	// Width The product's width.
	Width float32 `json:"width"`
}

// StoreProductStatus The product's status.
type StoreProductStatus string

// StoreProductCategory The category's details.
type StoreProductCategory struct {
	// CategoryChildren The category's children.
	CategoryChildren []map[string]interface{} `json:"category_children"`

	// CreatedAt The date the category was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the category was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The category's description.
	Description string `json:"description"`

	// Handle The category's handle.
	Handle string `json:"handle"`

	// Id The category's ID.
	Id string `json:"id"`

	// Metadata The category's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The category's name.
	Name           string                 `json:"name"`
	ParentCategory map[string]interface{} `json:"parent_category"`

	// ParentCategoryId The ID of the category's parent.
	ParentCategoryId string `json:"parent_category_id"`

	// Products The category's products.
	Products *[]StoreProduct `json:"products,omitempty"`

	// Rank The category's rank.
	Rank float32 `json:"rank"`

	// UpdatedAt The date the category was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreProductCategoryListResponse The paginated list of product categories.
type StoreProductCategoryListResponse struct {
	// Count The total number of items.
	Count float32 `json:"count"`

	// Limit The maximum number of items returned.
	Limit float32 `json:"limit"`

	// Offset The number of items skipped before retrieving the returned items.
	Offset float32 `json:"offset"`

	// ProductCategories The list of product categories.
	ProductCategories []StoreProductCategory `json:"product_categories"`
}

// StoreProductCategoryResponse The product category's details.
type StoreProductCategoryResponse struct {
	// ProductCategory The category's details.
	ProductCategory StoreProductCategory `json:"product_category"`
}

// StoreProductImage The image's details.
type StoreProductImage struct {
	// CreatedAt The date the image was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the image was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The image's ID.
	Id string `json:"id"`

	// Metadata The image's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the image was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url The image's URL.
	Url string `json:"url"`
}

// StoreProductOption The product option's details.
type StoreProductOption struct {
	// CreatedAt The date the product option was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the product option was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The option's ID.
	Id string `json:"id"`

	// Metadata The option's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Product  *map[string]interface{} `json:"product,omitempty"`

	// ProductId The ID of the product this option belongs to.
	ProductId *string `json:"product_id,omitempty"`

	// Title The option's title.
	Title string `json:"title"`

	// UpdatedAt The date the product option was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Values The option's values.
	Values *[]StoreProductOptionValue `json:"values,omitempty"`
}

// StoreProductOptionValue The product option value's details.
type StoreProductOptionValue struct {
	// CreatedAt The date the value was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date the value was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The value's ID.
	Id string `json:"id"`

	// Metadata The value's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
	Option   *map[string]interface{} `json:"option,omitempty"`

	// OptionId The ID of the option this value belongs to.
	OptionId *string `json:"option_id,omitempty"`

	// UpdatedAt The date the value was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value The value.
	Value string `json:"value"`
}

// StoreProductResponse The product's details.
type StoreProductResponse struct {
	// Product The product's details.
	Product StoreProduct `json:"product"`
}

// StoreProductTag The tag's details.
type StoreProductTag struct {
	// CreatedAt The date the tag was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the tag was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The tag's ID.
	Id string `json:"id"`

	// Metadata The tag's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the tag was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The tag's value.
	Value string `json:"value"`
}

// StoreProductVariant The variant's details.
type StoreProductVariant struct {
	// AllowBackorder Whether the variant can be ordered even if it's not in stock.
	AllowBackorder bool `json:"allow_backorder"`

	// Barcode The variant's barcode.
	Barcode string `json:"barcode"`

	// CalculatedPrice The calculated price's details.
	CalculatedPrice *BaseCalculatedPriceSet `json:"calculated_price,omitempty"`

	// CreatedAt The date the variant was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the variant was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Ean The variant's EAN.
	Ean string `json:"ean"`

	// Height The variant's height.
	Height float32 `json:"height"`

	// HsCode The variant's HS code.
	HsCode string `json:"hs_code"`

	// Id The variant's ID.
	Id string `json:"id"`

	// InventoryQuantity The variant's inventory quantity. This property is only available if you pass `+variants.inventory_quantity` in the `fields` query parameter.
	InventoryQuantity *float32 `json:"inventory_quantity,omitempty"`

	// Length The variant's length.
	Length float32 `json:"length"`

	// ManageInventory Whether Medusa manages the variant's inventory. If disabled, the variant is always considered in stock.
	ManageInventory bool `json:"manage_inventory"`

	// Material The variant's material.
	Material string `json:"material"`

	// Metadata The variant's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The variant's MID code.
	MidCode string `json:"mid_code"`

	// Options The variant's options.
	Options []StoreProductOptionValue `json:"options"`

	// OriginCountry The variant's origin country.
	OriginCountry string                  `json:"origin_country"`
	Product       *map[string]interface{} `json:"product,omitempty"`

	// ProductId The ID of the product this variant belongs to.
	ProductId *string `json:"product_id,omitempty"`

	// Sku The variant's SKU.
	Sku string `json:"sku"`

	// Title The variant's title.
	Title string `json:"title"`

	// Upc The variant's UPC.
	Upc string `json:"upc"`

	// UpdatedAt The date the variant was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantRank The variant's rank among its siblings.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The variant's weight.
	Weight float32 `json:"weight"`

	// Width The variant's width.
	Width float32 `json:"width"`
}

// StoreRegion The region's details.
type StoreRegion struct {
	// AutomaticTaxes Whether taxes are calculated automatically during checkout for carts that belong to this region.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// Countries The region's countries.
	Countries *[]BaseRegionCountry `json:"countries,omitempty"`

	// CreatedAt The date the region was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CurrencyCode The region's currency code.
	CurrencyCode string `json:"currency_code"`

	// Id The region's ID.
	Id string `json:"id"`

	// Metadata The region's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The region's name.
	Name string `json:"name"`

	// PaymentProviders The region's payment providers.
	PaymentProviders *[]AdminPaymentProvider `json:"payment_providers,omitempty"`

	// UpdatedAt The date the region was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// StoreRegionCountry The country's details.
type StoreRegionCountry struct {
	// DisplayName The country's display name.
	DisplayName *string `json:"display_name,omitempty"`

	// Id The country's ID.
	Id string `json:"id"`

	// Iso2 The country's ISO 2 code.
	Iso2 *string `json:"iso_2,omitempty"`

	// Iso3 The country's ISO 3 codel.
	Iso3 *string `json:"iso_3,omitempty"`

	// Name The country's name.
	Name *string `json:"name,omitempty"`

	// NumCode The country's num code.
	NumCode *string `json:"num_code,omitempty"`
}

// StoreReturn The return's details.
type StoreReturn struct {
	// CanceledAt The date the return was updated.
	CanceledAt string `json:"canceled_at"`

	// ClaimId The ID of the associated claim.
	ClaimId *string `json:"claim_id,omitempty"`

	// CreatedAt The date the return was created.
	CreatedAt time.Time `json:"created_at"`

	// DisplayId The return's display ID.
	DisplayId float32 `json:"display_id"`

	// ExchangeId The ID of the associated exchange.
	ExchangeId *string `json:"exchange_id,omitempty"`

	// Id The return's ID.
	Id string `json:"id"`

	// Items The return's items.
	Items []StoreReturnItem `json:"items"`

	// LocationId The ID of the location the items are returned to.
	LocationId *string `json:"location_id,omitempty"`

	// OrderId The ID of the order this return is created for.
	OrderId string `json:"order_id"`

	// ReceivedAt The date the return was received.
	ReceivedAt string `json:"received_at"`

	// RefundAmount The return's refunded amount.
	RefundAmount *float32 `json:"refund_amount,omitempty"`

	// Status The return's status.
	Status *string `json:"status,omitempty"`
}

// StoreReturnItem The return item's details.
type StoreReturnItem struct {
	// DamagedQuantity The item's damaged quantity.
	DamagedQuantity float32 `json:"damaged_quantity"`

	// Id The item's ID.
	Id string `json:"id"`

	// ItemId The ID of the item in the order.
	ItemId string `json:"item_id"`

	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Note A note with more details on why the item is returned.
	Note *string `json:"note,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`

	// ReasonId The ID of the item's reason.
	ReasonId *string `json:"reason_id,omitempty"`

	// ReceivedQuantity The item's received quantity.
	ReceivedQuantity float32 `json:"received_quantity"`

	// ReturnId The ID of the return this item belongs to.
	ReturnId string `json:"return_id"`
}

// StoreReturnReason The return reason's details.
type StoreReturnReason struct {
	// CreatedAt The date the return reason was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The return reason's description.
	Description *string `json:"description,omitempty"`

	// Id The return reason's ID.
	Id string `json:"id"`

	// Label The return reason's label.
	Label string `json:"label"`

	// Metadata The return reason's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UpdatedAt The date the return reason was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The return reason's value.
	Value string `json:"value"`
}

// StoreReturnReasonResponse The return reason's details.
type StoreReturnReasonResponse struct {
	// ReturnReason The return reason's details.
	ReturnReason StoreReturnReason `json:"return_reason"`
}

// StoreReturnResponse The return's details.
type StoreReturnResponse struct {
	// Return The return's details.
	Return StoreReturn `json:"return"`
}

// StoreShippingOption The shipping option's details.
type StoreShippingOption struct {
	// Amount The shipping option's amount.
	Amount float32 `json:"amount"`

	// Data The shipping option's data, useful for the provider handling fulfillment.
	Data map[string]interface{} `json:"data"`

	// Id The shipping option's ID.
	Id string `json:"id"`

	// IsTaxInclusive Whether the amount includes taxes.
	IsTaxInclusive bool `json:"is_tax_inclusive"`

	// Metadata The shipping option's metadata, can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// Name The shipping option's name.
	Name string `json:"name"`

	// PriceType The shipping option's price type. If it's `flat`, the price is fixed and is set in the `prices` property. If it's `calculated`, the price is calculated on checkout by the associated fulfillment provider.
	PriceType StoreShippingOptionPriceType `json:"price_type"`

	// Provider The fulfillment provider's details.
	Provider BaseFulfillmentProvider `json:"provider"`

	// ProviderId The ID of the fulfillment provider handling this option.
	ProviderId string `json:"provider_id"`

	// ServiceZoneId The ID of the service zone the shipping option belongs to.
	ServiceZoneId string `json:"service_zone_id"`

	// ShippingOptionTypeId The ID of the shipping option's type.
	ShippingOptionTypeId string `json:"shipping_option_type_id"`

	// ShippingProfileId The ID of the associated shipping profile.
	ShippingProfileId string `json:"shipping_profile_id"`

	// Type The shipping option type's details.
	Type StoreShippingOptionType `json:"type"`
}

// StoreShippingOptionPriceType The shipping option's price type. If it's `flat`, the price is fixed and is set in the `prices` property. If it's `calculated`, the price is calculated on checkout by the associated fulfillment provider.
type StoreShippingOptionPriceType string

// StoreShippingOptionListResponse The shipping option's details.
type StoreShippingOptionListResponse struct {
	// ShippingOptions The shipping option's shipping options.
	ShippingOptions []StoreShippingOption `json:"shipping_options"`
}

// StoreShippingOptionType The shipping option type's details.
type StoreShippingOptionType struct {
	// Code The type's code.
	Code string `json:"code"`

	// CreatedAt The date the type was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date the type was deleted.
	DeletedAt time.Time `json:"deleted_at"`

	// Description The type's description.
	Description string `json:"description"`

	// Id The type's ID.
	Id string `json:"id"`

	// Label The type's label.
	Label string `json:"label"`

	// ShippingOptionId The ID of the associated shipping option.
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date the type was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StoreUpdateCartLineItem The details to update in the line item.
type StoreUpdateCartLineItem struct {
	// Metadata The item's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The item's quantity.
	Quantity float32 `json:"quantity"`
}

// StoreUpdateCustomer The details to update in the customer.
type StoreUpdateCustomer struct {
	// CompanyName The customer's company name.
	CompanyName *string `json:"company_name,omitempty"`

	// FirstName The customer's first name.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The customer's last name.
	LastName *string `json:"last_name,omitempty"`

	// Phone The customer's phone.
	Phone *string `json:"phone,omitempty"`
}

// UpdateAddress The details to update in the address.
type UpdateAddress struct {
	// Address1 The address's first line.
	Address1 *string `json:"address_1,omitempty"`

	// Address2 The address's second line.
	Address2 *string `json:"address_2,omitempty"`

	// City The address's city.
	City *string `json:"city,omitempty"`

	// Company The address's company.
	Company *string `json:"company,omitempty"`

	// CountryCode The address's country code.
	CountryCode *string `json:"country_code,omitempty"`

	// CustomerId The ID of the customer that this address belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// FirstName The address's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Id The ID of an existing address to update.
	Id string `json:"id"`

	// LastName The address's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata The address's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone The address's phone.
	Phone *string `json:"phone,omitempty"`

	// PostalCode The address's postal code.
	PostalCode *string `json:"postal_code,omitempty"`

	// Province The address's province.
	Province *string `json:"province,omitempty"`
}

// UpdateCartData The details to update in a cart.
type UpdateCartData struct {
	BillingAddress *UpdateCartData_BillingAddress `json:"billing_address,omitempty"`

	// BillingAddressId The ID of the cart's billing address.
	BillingAddressId *string `json:"billing_address_id,omitempty"`

	// CurrencyCode The cart's currency code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// CustomerId The ID of the customer that the cart belongs to.
	CustomerId *string `json:"customer_id,omitempty"`

	// Email The email of the customer that the cart belongs to.
	Email *openapi_types.Email `json:"email,omitempty"`

	// Metadata The cart's metadata, ca hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// RegionId The ID of the associated region. This can affect the prices and currency code of the cart.
	RegionId *string `json:"region_id,omitempty"`

	// SalesChannelId The ID of the associated sales channel. Only products available in this channel can be added to the cart.
	SalesChannelId  *string                         `json:"sales_channel_id,omitempty"`
	ShippingAddress *UpdateCartData_ShippingAddress `json:"shipping_address,omitempty"`

	// ShippingAddressId The ID of the cart's shipping address.
	ShippingAddressId *string `json:"shipping_address_id,omitempty"`
}

// UpdateCartData_BillingAddress defines model for UpdateCartData.BillingAddress.
type UpdateCartData_BillingAddress struct {
	union json.RawMessage
}

// UpdateCartData_ShippingAddress defines model for UpdateCartData.ShippingAddress.
type UpdateCartData_ShippingAddress struct {
	union json.RawMessage
}

// WorkflowExecutionContext The workflow execution's context.
type WorkflowExecutionContext struct {
	// Compensate The context's compensate.
	Compensate map[string]interface{} `json:"compensate"`

	// Data The context's data.
	Data *struct {
		// Invoke The step's invokation details.
		Invoke map[string]struct {
			// Output The invokation's details.
			Output *struct {
				// CompensateInput the compensation function's input.
				CompensateInput interface{} `json:"compensateInput"`

				// Output the step's output
				Output interface{} `json:"output"`
			} `json:"output,omitempty"`
		} `json:"invoke"`

		// Payload the payload of the transaction.
		Payload *interface{} `json:"payload,omitempty"`
	} `json:"data,omitempty"`

	// Errors The context's errors.
	Errors []struct {
		// Action The error's action.
		Action string `json:"action"`

		// Error The error's details.
		Error map[string]interface{} `json:"error"`

		// HandlerType The error's handler type.
		HandlerType string `json:"handlerType"`
	} `json:"errors"`
}

// N400Error defines model for 400_error.
type N400Error = Error

// N500Error defines model for 500_error.
type N500Error = Error

// DefaultError defines model for default_error.
type DefaultError = Error

// InvalidRequestError defines model for invalid_request_error.
type InvalidRequestError = Error

// InvalidStateError defines model for invalid_state_error.
type InvalidStateError = Error

// NotFoundError defines model for not_found_error.
type NotFoundError = Error

// GetApiKeysParams defines parameters for GetApiKeys.
type GetApiKeysParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q A search term to search the API keys' searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Title *struct {
		union json.RawMessage
	} `form:"title,omitempty" json:"title,omitempty"`
	Token *struct {
		union json.RawMessage
	} `form:"token,omitempty" json:"token,omitempty"`

	// Type Filter by the API key's type.
	Type *GetApiKeysParamsType `form:"type,omitempty" json:"type,omitempty"`

	// CreatedAt Filter by the API key's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetApiKeysParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetApiKeysParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the API key's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetApiKeysParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetApiKeysParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the API key's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetApiKeysParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetApiKeysParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// RevokedAt Filter by the API key's revoke date.
	RevokedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetApiKeysParams_RevokedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetApiKeysParams_RevokedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"revoked_at,omitempty" json:"revoked_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetApiKeysParamsId0 defines parameters for GetApiKeys.
type GetApiKeysParamsId0 = string

// GetApiKeysParamsId1 defines parameters for GetApiKeys.
type GetApiKeysParamsId1 = []string

// GetApiKeysParamsTitle0 defines parameters for GetApiKeys.
type GetApiKeysParamsTitle0 = string

// GetApiKeysParamsTitle1 defines parameters for GetApiKeys.
type GetApiKeysParamsTitle1 = []string

// GetApiKeysParamsToken0 defines parameters for GetApiKeys.
type GetApiKeysParamsToken0 = string

// GetApiKeysParamsToken1 defines parameters for GetApiKeys.
type GetApiKeysParamsToken1 = []string

// GetApiKeysParamsType defines parameters for GetApiKeys.
type GetApiKeysParamsType string

// GetApiKeysParamsCreatedAtEq0 defines parameters for GetApiKeys.
type GetApiKeysParamsCreatedAtEq0 = string

// GetApiKeysParamsCreatedAtEq1 defines parameters for GetApiKeys.
type GetApiKeysParamsCreatedAtEq1 = []string

// GetApiKeysParams_CreatedAt_Eq defines parameters for GetApiKeys.
type GetApiKeysParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetApiKeysParamsCreatedAtNot0 defines parameters for GetApiKeys.
type GetApiKeysParamsCreatedAtNot0 = string

// GetApiKeysParamsCreatedAtNot1 defines parameters for GetApiKeys.
type GetApiKeysParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetApiKeysParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                             `json:"$nin,omitempty"`
	Not *GetApiKeysParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetApiKeysParamsCreatedAtNot2 defines parameters for GetApiKeys.
type GetApiKeysParamsCreatedAtNot2 = []string

// GetApiKeysParams_CreatedAt_Not defines parameters for GetApiKeys.
type GetApiKeysParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetApiKeysParamsUpdatedAtEq0 defines parameters for GetApiKeys.
type GetApiKeysParamsUpdatedAtEq0 = string

// GetApiKeysParamsUpdatedAtEq1 defines parameters for GetApiKeys.
type GetApiKeysParamsUpdatedAtEq1 = []string

// GetApiKeysParams_UpdatedAt_Eq defines parameters for GetApiKeys.
type GetApiKeysParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetApiKeysParamsUpdatedAtNot0 defines parameters for GetApiKeys.
type GetApiKeysParamsUpdatedAtNot0 = string

// GetApiKeysParamsUpdatedAtNot1 defines parameters for GetApiKeys.
type GetApiKeysParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetApiKeysParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                             `json:"$nin,omitempty"`
	Not *GetApiKeysParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetApiKeysParamsUpdatedAtNot2 defines parameters for GetApiKeys.
type GetApiKeysParamsUpdatedAtNot2 = []string

// GetApiKeysParams_UpdatedAt_Not defines parameters for GetApiKeys.
type GetApiKeysParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetApiKeysParamsDeletedAtEq0 defines parameters for GetApiKeys.
type GetApiKeysParamsDeletedAtEq0 = string

// GetApiKeysParamsDeletedAtEq1 defines parameters for GetApiKeys.
type GetApiKeysParamsDeletedAtEq1 = []string

// GetApiKeysParams_DeletedAt_Eq defines parameters for GetApiKeys.
type GetApiKeysParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetApiKeysParamsDeletedAtNot0 defines parameters for GetApiKeys.
type GetApiKeysParamsDeletedAtNot0 = string

// GetApiKeysParamsDeletedAtNot1 defines parameters for GetApiKeys.
type GetApiKeysParamsDeletedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetApiKeysParams_DeletedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                             `json:"$nin,omitempty"`
	Not *GetApiKeysParams_DeletedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetApiKeysParamsDeletedAtNot2 defines parameters for GetApiKeys.
type GetApiKeysParamsDeletedAtNot2 = []string

// GetApiKeysParams_DeletedAt_Not defines parameters for GetApiKeys.
type GetApiKeysParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetApiKeysParamsRevokedAtEq0 defines parameters for GetApiKeys.
type GetApiKeysParamsRevokedAtEq0 = string

// GetApiKeysParamsRevokedAtEq1 defines parameters for GetApiKeys.
type GetApiKeysParamsRevokedAtEq1 = []string

// GetApiKeysParams_RevokedAt_Eq defines parameters for GetApiKeys.
type GetApiKeysParams_RevokedAt_Eq struct {
	union json.RawMessage
}

// GetApiKeysParamsRevokedAtNot0 defines parameters for GetApiKeys.
type GetApiKeysParamsRevokedAtNot0 = string

// GetApiKeysParamsRevokedAtNot1 defines parameters for GetApiKeys.
type GetApiKeysParamsRevokedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetApiKeysParams_RevokedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                             `json:"$nin,omitempty"`
	Not *GetApiKeysParams_RevokedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetApiKeysParamsRevokedAtNot2 defines parameters for GetApiKeys.
type GetApiKeysParamsRevokedAtNot2 = []string

// GetApiKeysParams_RevokedAt_Not defines parameters for GetApiKeys.
type GetApiKeysParams_RevokedAt_Not struct {
	union json.RawMessage
}

// GetApiKeysIdParams defines parameters for GetApiKeysId.
type GetApiKeysIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostApiKeysIdParams defines parameters for PostApiKeysId.
type PostApiKeysIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostApiKeysIdRevokeParams defines parameters for PostApiKeysIdRevoke.
type PostApiKeysIdRevokeParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostApiKeysIdSalesChannelsJSONBody defines parameters for PostApiKeysIdSalesChannels.
type PostApiKeysIdSalesChannelsJSONBody struct {
	// Add The sales channels to add to the publishable API key.
	Add *[]string `json:"add,omitempty"`

	// Remove The sales channels to remove from the publishable API key.
	Remove *[]string `json:"remove,omitempty"`
}

// PostApiKeysIdSalesChannelsParams defines parameters for PostApiKeysIdSalesChannels.
type PostApiKeysIdSalesChannelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCampaignsParams defines parameters for GetCampaigns.
type GetCampaignsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// PostCampaignsJSONBody defines parameters for PostCampaigns.
type PostCampaignsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Budget The campaign's budget which, when crossed, ends the campaign.
	Budget struct {
		// CurrencyCode The campaign budget's currency code. This can't be edited later.
		CurrencyCode string `json:"currency_code"`

		// Limit The campaign budget's limit.
		Limit float32 `json:"limit"`

		// Type The budget's type. This can't be edited later. Use `spend` to set a limit on the total amount discounted by the campaign's promotions. Use `usage` to set a limit on the total number of times the campaign's promotions can be used.
		Type PostCampaignsJSONBodyBudgetType `json:"type"`
	} `json:"budget"`

	// CampaignIdentifier The campaign's identifier.
	CampaignIdentifier string `json:"campaign_identifier"`

	// Description The campaign's description.
	Description string `json:"description"`

	// EndsAt The campaign's end date.
	EndsAt time.Time `json:"ends_at"`

	// Name The campaign's name.
	Name string `json:"name"`

	// Promotions The campaign's promotions.
	Promotions *[]struct {
		// Id A promotion's ID.
		Id string `json:"id"`
	} `json:"promotions,omitempty"`

	// StartsAt The campaign's start date.
	StartsAt time.Time `json:"starts_at"`
}

// PostCampaignsParams defines parameters for PostCampaigns.
type PostCampaignsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCampaignsJSONBodyBudgetType defines parameters for PostCampaigns.
type PostCampaignsJSONBodyBudgetType string

// GetCampaignsIdParams defines parameters for GetCampaignsId.
type GetCampaignsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCampaignsIdJSONBody defines parameters for PostCampaignsId.
type PostCampaignsIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Budget The campaign's budget.
	Budget *struct {
		// Limit The campaign budget's limit.
		Limit float32 `json:"limit"`
	} `json:"budget,omitempty"`

	// CampaignIdentifier The campaign's identifier.
	CampaignIdentifier *string `json:"campaign_identifier,omitempty"`

	// Description The campaign's description.
	Description string `json:"description"`

	// EndsAt The campaign's end date.
	EndsAt time.Time `json:"ends_at"`

	// Name The campaign's name.
	Name *string `json:"name,omitempty"`

	// Promotions The campaign's promotions.
	Promotions *[]struct {
		// Id A promotion's ID.
		Id string `json:"id"`
	} `json:"promotions,omitempty"`

	// StartsAt The campaign's start date.
	StartsAt time.Time `json:"starts_at"`
}

// PostCampaignsIdParams defines parameters for PostCampaignsId.
type PostCampaignsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCampaignsIdPromotionsJSONBody defines parameters for PostCampaignsIdPromotions.
type PostCampaignsIdPromotionsJSONBody struct {
	// Add The promotions to add to the campaign.
	Add *[]string `json:"add,omitempty"`

	// Remove The promotions to remove from the campaign.
	Remove *[]string `json:"remove,omitempty"`
}

// PostCampaignsIdPromotionsParams defines parameters for PostCampaignsIdPromotions.
type PostCampaignsIdPromotionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetClaimsParams defines parameters for GetClaims.
type GetClaimsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DeletedAt The claim's deleted at.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                     `json:"$contains,omitempty"`
		Eq       *GetClaimsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                      `json:"$nin,omitempty"`
		Not *GetClaimsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Q The claim's q.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	OrderId *struct {
		union json.RawMessage
	} `form:"order_id,omitempty" json:"order_id,omitempty"`
	Status *struct {
		union json.RawMessage
	} `form:"status,omitempty" json:"status,omitempty"`

	// CreatedAt The claim's created at.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                     `json:"$contains,omitempty"`
		Eq       *GetClaimsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                      `json:"$nin,omitempty"`
		Not *GetClaimsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt The claim's updated at.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                     `json:"$contains,omitempty"`
		Eq       *GetClaimsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                      `json:"$nin,omitempty"`
		Not *GetClaimsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetClaimsParamsDeletedAtEq0 defines parameters for GetClaims.
type GetClaimsParamsDeletedAtEq0 = string

// GetClaimsParamsDeletedAtEq1 defines parameters for GetClaims.
type GetClaimsParamsDeletedAtEq1 = []string

// GetClaimsParams_DeletedAt_Eq defines parameters for GetClaims.
type GetClaimsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetClaimsParamsDeletedAtNot0 defines parameters for GetClaims.
type GetClaimsParamsDeletedAtNot0 = string

// GetClaimsParamsDeletedAtNot1 defines parameters for GetClaims.
type GetClaimsParamsDeletedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetClaimsParams_DeletedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetClaimsParams_DeletedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetClaimsParamsDeletedAtNot2 defines parameters for GetClaims.
type GetClaimsParamsDeletedAtNot2 = []string

// GetClaimsParams_DeletedAt_Not defines parameters for GetClaims.
type GetClaimsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetClaimsParamsId0 defines parameters for GetClaims.
type GetClaimsParamsId0 = string

// GetClaimsParamsId1 defines parameters for GetClaims.
type GetClaimsParamsId1 = []string

// GetClaimsParamsOrderId0 defines parameters for GetClaims.
type GetClaimsParamsOrderId0 = string

// GetClaimsParamsOrderId1 defines parameters for GetClaims.
type GetClaimsParamsOrderId1 = []string

// GetClaimsParamsStatus0 defines parameters for GetClaims.
type GetClaimsParamsStatus0 = string

// GetClaimsParamsStatus1 defines parameters for GetClaims.
type GetClaimsParamsStatus1 = []string

// GetClaimsParamsCreatedAtEq0 defines parameters for GetClaims.
type GetClaimsParamsCreatedAtEq0 = string

// GetClaimsParamsCreatedAtEq1 defines parameters for GetClaims.
type GetClaimsParamsCreatedAtEq1 = []string

// GetClaimsParams_CreatedAt_Eq defines parameters for GetClaims.
type GetClaimsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetClaimsParamsCreatedAtNot0 defines parameters for GetClaims.
type GetClaimsParamsCreatedAtNot0 = string

// GetClaimsParamsCreatedAtNot1 defines parameters for GetClaims.
type GetClaimsParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetClaimsParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetClaimsParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetClaimsParamsCreatedAtNot2 defines parameters for GetClaims.
type GetClaimsParamsCreatedAtNot2 = []string

// GetClaimsParams_CreatedAt_Not defines parameters for GetClaims.
type GetClaimsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetClaimsParamsUpdatedAtEq0 defines parameters for GetClaims.
type GetClaimsParamsUpdatedAtEq0 = string

// GetClaimsParamsUpdatedAtEq1 defines parameters for GetClaims.
type GetClaimsParamsUpdatedAtEq1 = []string

// GetClaimsParams_UpdatedAt_Eq defines parameters for GetClaims.
type GetClaimsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetClaimsParamsUpdatedAtNot0 defines parameters for GetClaims.
type GetClaimsParamsUpdatedAtNot0 = string

// GetClaimsParamsUpdatedAtNot1 defines parameters for GetClaims.
type GetClaimsParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetClaimsParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetClaimsParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetClaimsParamsUpdatedAtNot2 defines parameters for GetClaims.
type GetClaimsParamsUpdatedAtNot2 = []string

// GetClaimsParams_UpdatedAt_Not defines parameters for GetClaims.
type GetClaimsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// PostClaimsParams defines parameters for PostClaims.
type PostClaimsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetClaimsIdParams defines parameters for GetClaimsId.
type GetClaimsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdClaimItemsParams defines parameters for PostClaimsIdClaimItems.
type PostClaimsIdClaimItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteClaimsIdClaimItemsActionIdParams defines parameters for DeleteClaimsIdClaimItemsActionId.
type DeleteClaimsIdClaimItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdClaimItemsActionIdParams defines parameters for PostClaimsIdClaimItemsActionId.
type PostClaimsIdClaimItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdInboundShippingMethodActionIdParams defines parameters for PostClaimsIdInboundShippingMethodActionId.
type PostClaimsIdInboundShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdOutboundItemsParams defines parameters for PostClaimsIdOutboundItems.
type PostClaimsIdOutboundItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteClaimsIdOutboundItemsActionIdParams defines parameters for DeleteClaimsIdOutboundItemsActionId.
type DeleteClaimsIdOutboundItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdOutboundItemsActionIdParams defines parameters for PostClaimsIdOutboundItemsActionId.
type PostClaimsIdOutboundItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdOutboundShippingMethodParams defines parameters for PostClaimsIdOutboundShippingMethod.
type PostClaimsIdOutboundShippingMethodParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteClaimsIdOutboundShippingMethodActionIdParams defines parameters for DeleteClaimsIdOutboundShippingMethodActionId.
type DeleteClaimsIdOutboundShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdOutboundShippingMethodActionIdParams defines parameters for PostClaimsIdOutboundShippingMethodActionId.
type PostClaimsIdOutboundShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostClaimsIdRequestParams defines parameters for PostClaimsIdRequest.
type PostClaimsIdRequestParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCollectionsParams defines parameters for GetCollections.
type GetCollectionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DeletedAt Filter by the collection's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetCollectionsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetCollectionsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Q Search term to filter the collection's searchable properties by.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Handle *struct {
		union json.RawMessage
	} `form:"handle,omitempty" json:"handle,omitempty"`
	Title *struct {
		union json.RawMessage
	} `form:"title,omitempty" json:"title,omitempty"`

	// CreatedAt Filter by the collection's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetCollectionsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetCollectionsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the collection's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetCollectionsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetCollectionsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetCollectionsParamsDeletedAtEq0 defines parameters for GetCollections.
type GetCollectionsParamsDeletedAtEq0 = string

// GetCollectionsParamsDeletedAtEq1 defines parameters for GetCollections.
type GetCollectionsParamsDeletedAtEq1 = []string

// GetCollectionsParams_DeletedAt_Eq defines parameters for GetCollections.
type GetCollectionsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetCollectionsParamsDeletedAtNot0 defines parameters for GetCollections.
type GetCollectionsParamsDeletedAtNot0 = string

// GetCollectionsParamsDeletedAtNot1 defines parameters for GetCollections.
type GetCollectionsParamsDeletedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                `json:"$contains,omitempty"`
	Eq       *GetCollectionsParams_DeletedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                 `json:"$nin,omitempty"`
	Not *GetCollectionsParams_DeletedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCollectionsParamsDeletedAtNot2 defines parameters for GetCollections.
type GetCollectionsParamsDeletedAtNot2 = []string

// GetCollectionsParams_DeletedAt_Not defines parameters for GetCollections.
type GetCollectionsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetCollectionsParamsId0 defines parameters for GetCollections.
type GetCollectionsParamsId0 = string

// GetCollectionsParamsId1 defines parameters for GetCollections.
type GetCollectionsParamsId1 = []string

// GetCollectionsParamsHandle0 defines parameters for GetCollections.
type GetCollectionsParamsHandle0 = string

// GetCollectionsParamsHandle1 defines parameters for GetCollections.
type GetCollectionsParamsHandle1 = []string

// GetCollectionsParamsTitle0 defines parameters for GetCollections.
type GetCollectionsParamsTitle0 = string

// GetCollectionsParamsTitle1 defines parameters for GetCollections.
type GetCollectionsParamsTitle1 = []string

// GetCollectionsParamsCreatedAtEq0 defines parameters for GetCollections.
type GetCollectionsParamsCreatedAtEq0 = string

// GetCollectionsParamsCreatedAtEq1 defines parameters for GetCollections.
type GetCollectionsParamsCreatedAtEq1 = []string

// GetCollectionsParams_CreatedAt_Eq defines parameters for GetCollections.
type GetCollectionsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetCollectionsParamsCreatedAtNot0 defines parameters for GetCollections.
type GetCollectionsParamsCreatedAtNot0 = string

// GetCollectionsParamsCreatedAtNot1 defines parameters for GetCollections.
type GetCollectionsParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                `json:"$contains,omitempty"`
	Eq       *GetCollectionsParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                 `json:"$nin,omitempty"`
	Not *GetCollectionsParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCollectionsParamsCreatedAtNot2 defines parameters for GetCollections.
type GetCollectionsParamsCreatedAtNot2 = []string

// GetCollectionsParams_CreatedAt_Not defines parameters for GetCollections.
type GetCollectionsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetCollectionsParamsUpdatedAtEq0 defines parameters for GetCollections.
type GetCollectionsParamsUpdatedAtEq0 = string

// GetCollectionsParamsUpdatedAtEq1 defines parameters for GetCollections.
type GetCollectionsParamsUpdatedAtEq1 = []string

// GetCollectionsParams_UpdatedAt_Eq defines parameters for GetCollections.
type GetCollectionsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetCollectionsParamsUpdatedAtNot0 defines parameters for GetCollections.
type GetCollectionsParamsUpdatedAtNot0 = string

// GetCollectionsParamsUpdatedAtNot1 defines parameters for GetCollections.
type GetCollectionsParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                `json:"$contains,omitempty"`
	Eq       *GetCollectionsParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                 `json:"$nin,omitempty"`
	Not *GetCollectionsParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCollectionsParamsUpdatedAtNot2 defines parameters for GetCollections.
type GetCollectionsParamsUpdatedAtNot2 = []string

// GetCollectionsParams_UpdatedAt_Not defines parameters for GetCollections.
type GetCollectionsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// PostCollectionsParams defines parameters for PostCollections.
type PostCollectionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCollectionsIdParams defines parameters for GetCollectionsId.
type GetCollectionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCollectionsIdParams defines parameters for PostCollectionsId.
type PostCollectionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCollectionsIdProductsJSONBody defines parameters for PostCollectionsIdProducts.
type PostCollectionsIdProductsJSONBody struct {
	// Add The products to add to the collection.
	Add *[]string `json:"add,omitempty"`

	// Remove The products to remove from the collection.
	Remove *[]string `json:"remove,omitempty"`
}

// PostCollectionsIdProductsParams defines parameters for PostCollectionsIdProducts.
type PostCollectionsIdProductsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCurrenciesParams defines parameters for GetCurrencies.
type GetCurrenciesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q The search term to filter the currency's searchable properties by.
	Q    *string `form:"q,omitempty" json:"q,omitempty"`
	Code *struct {
		union json.RawMessage
	} `form:"code,omitempty" json:"code,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetCurrenciesParamsCode0 defines parameters for GetCurrencies.
type GetCurrenciesParamsCode0 = string

// GetCurrenciesParamsCode1 defines parameters for GetCurrencies.
type GetCurrenciesParamsCode1 = []string

// GetCurrenciesCodeParams defines parameters for GetCurrenciesCode.
type GetCurrenciesCodeParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomerGroupsParams defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the customer group's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Name *struct {
		union json.RawMessage
	} `form:"name,omitempty" json:"name,omitempty"`
	Customers *struct {
		union json.RawMessage
	} `form:"customers,omitempty" json:"customers,omitempty"`
	CreatedBy *struct {
		union json.RawMessage
	} `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedAt Filter the customer group by its creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                             `json:"$contains,omitempty"`
		Eq       *GetCustomerGroupsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                              `json:"$nin,omitempty"`
		Not *GetCustomerGroupsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter the customer groups by their update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                             `json:"$contains,omitempty"`
		Eq       *GetCustomerGroupsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                              `json:"$nin,omitempty"`
		Not *GetCustomerGroupsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter the customer groups by their deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                             `json:"$contains,omitempty"`
		Eq       *GetCustomerGroupsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                              `json:"$nin,omitempty"`
		Not *GetCustomerGroupsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetCustomerGroupsParamsId0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsId0 = string

// GetCustomerGroupsParamsId1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsId1 = []string

// GetCustomerGroupsParamsName0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsName0 = string

// GetCustomerGroupsParamsName1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsName1 = []string

// GetCustomerGroupsParamsCustomers0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCustomers0 = string

// GetCustomerGroupsParamsCustomers1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCustomers1 = []string

// GetCustomerGroupsParamsCreatedBy0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedBy0 = string

// GetCustomerGroupsParamsCreatedBy1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedBy1 = []string

// GetCustomerGroupsParamsCreatedAtEq0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedAtEq0 = string

// GetCustomerGroupsParamsCreatedAtEq1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedAtEq1 = []string

// GetCustomerGroupsParams_CreatedAt_Eq defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetCustomerGroupsParamsCreatedAtNot0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedAtNot0 = string

// GetCustomerGroupsParamsCreatedAtNot1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                   `json:"$contains,omitempty"`
	Eq       *GetCustomerGroupsParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                    `json:"$nin,omitempty"`
	Not *GetCustomerGroupsParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomerGroupsParamsCreatedAtNot2 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsCreatedAtNot2 = []string

// GetCustomerGroupsParams_CreatedAt_Not defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetCustomerGroupsParamsUpdatedAtEq0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsUpdatedAtEq0 = string

// GetCustomerGroupsParamsUpdatedAtEq1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsUpdatedAtEq1 = []string

// GetCustomerGroupsParams_UpdatedAt_Eq defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetCustomerGroupsParamsUpdatedAtNot0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsUpdatedAtNot0 = string

// GetCustomerGroupsParamsUpdatedAtNot1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                   `json:"$contains,omitempty"`
	Eq       *GetCustomerGroupsParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                    `json:"$nin,omitempty"`
	Not *GetCustomerGroupsParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomerGroupsParamsUpdatedAtNot2 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsUpdatedAtNot2 = []string

// GetCustomerGroupsParams_UpdatedAt_Not defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetCustomerGroupsParamsDeletedAtEq0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsDeletedAtEq0 = string

// GetCustomerGroupsParamsDeletedAtEq1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsDeletedAtEq1 = []string

// GetCustomerGroupsParams_DeletedAt_Eq defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetCustomerGroupsParamsDeletedAtNot0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsDeletedAtNot0 = string

// GetCustomerGroupsParamsDeletedAtNot1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsDeletedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                   `json:"$contains,omitempty"`
	Eq       *GetCustomerGroupsParams_DeletedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                    `json:"$nin,omitempty"`
	Not *GetCustomerGroupsParams_DeletedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomerGroupsParamsDeletedAtNot2 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsDeletedAtNot2 = []string

// GetCustomerGroupsParams_DeletedAt_Not defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostCustomerGroupsParams defines parameters for PostCustomerGroups.
type PostCustomerGroupsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomerGroupsIdParams defines parameters for GetCustomerGroupsId.
type GetCustomerGroupsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomerGroupsIdParams defines parameters for PostCustomerGroupsId.
type PostCustomerGroupsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomerGroupsIdCustomersJSONBody defines parameters for PostCustomerGroupsIdCustomers.
type PostCustomerGroupsIdCustomersJSONBody struct {
	// Add The customers to add to the group.
	Add *[]string `json:"add,omitempty"`

	// Remove The customers to remove from the group.
	Remove *[]string `json:"remove,omitempty"`
}

// PostCustomerGroupsIdCustomersParams defines parameters for PostCustomerGroupsIdCustomers.
type PostCustomerGroupsIdCustomersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomersParams defines parameters for GetCustomers.
type GetCustomersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order  *string `form:"order,omitempty" json:"order,omitempty"`
	Groups *struct {
		union json.RawMessage
	} `form:"groups,omitempty" json:"groups,omitempty"`

	// Q Search term to filter the customer's searchable properties by.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Email *struct {
		union json.RawMessage
	} `form:"email,omitempty" json:"email,omitempty"`
	CompanyName *struct {
		union json.RawMessage
	} `form:"company_name,omitempty" json:"company_name,omitempty"`
	FirstName *struct {
		union json.RawMessage
	} `form:"first_name,omitempty" json:"first_name,omitempty"`
	LastName *struct {
		union json.RawMessage
	} `form:"last_name,omitempty" json:"last_name,omitempty"`
	CreatedBy *struct {
		union json.RawMessage
	} `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedAt Filter by the customer's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetCustomersParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetCustomersParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a customer's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetCustomersParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetCustomersParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter a customer by their deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetCustomersParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetCustomersParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`

	// HasAccount Filter by whether the customer is registered.
	HasAccount *bool `form:"has_account,omitempty" json:"has_account,omitempty"`
}

// GetCustomersParamsGroups0 defines parameters for GetCustomers.
type GetCustomersParamsGroups0 = string

// GetCustomersParamsGroups2 defines parameters for GetCustomers.
type GetCustomersParamsGroups2 = []string

// GetCustomersParamsId0 defines parameters for GetCustomers.
type GetCustomersParamsId0 = string

// GetCustomersParamsId1 defines parameters for GetCustomers.
type GetCustomersParamsId1 = []string

// GetCustomersParamsId2 defines parameters for GetCustomers.
type GetCustomersParamsId2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                   `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_Id_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                      `json:"$fulltext,omitempty"`
	Gt       *GetCustomersParams_Id_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetCustomersParams_Id_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetCustomersParams_Id_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                      `json:"$like,omitempty"`
	Lt   *GetCustomersParams_Id_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetCustomersParams_Id_2_Lte `json:"$lte,omitempty"`
	Ne   *GetCustomersParams_Id_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetCustomersParams_Id_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetCustomersParams_Id_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsEmail0 defines parameters for GetCustomers.
type GetCustomersParamsEmail0 = openapi_types.Email

// GetCustomersParamsEmail1 defines parameters for GetCustomers.
type GetCustomersParamsEmail1 = []openapi_types.Email

// GetCustomersParamsEmail2 defines parameters for GetCustomers.
type GetCustomersParamsEmail2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                      `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_Email_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                         `json:"$fulltext,omitempty"`
	Gt       *GetCustomersParams_Email_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetCustomersParams_Email_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetCustomersParams_Email_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                         `json:"$like,omitempty"`
	Lt   *GetCustomersParams_Email_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetCustomersParams_Email_2_Lte `json:"$lte,omitempty"`
	Ne   *GetCustomersParams_Email_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetCustomersParams_Email_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetCustomersParams_Email_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsCompanyName0 defines parameters for GetCustomers.
type GetCustomersParamsCompanyName0 = string

// GetCustomersParamsCompanyName1 defines parameters for GetCustomers.
type GetCustomersParamsCompanyName1 = []string

// GetCustomersParamsCompanyName2 defines parameters for GetCustomers.
type GetCustomersParamsCompanyName2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_CompanyName_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                               `json:"$fulltext,omitempty"`
	Gt       *GetCustomersParams_CompanyName_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetCustomersParams_CompanyName_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetCustomersParams_CompanyName_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                               `json:"$like,omitempty"`
	Lt   *GetCustomersParams_CompanyName_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetCustomersParams_CompanyName_2_Lte `json:"$lte,omitempty"`
	Ne   *GetCustomersParams_CompanyName_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetCustomersParams_CompanyName_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetCustomersParams_CompanyName_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsFirstName0 defines parameters for GetCustomers.
type GetCustomersParamsFirstName0 = string

// GetCustomersParamsFirstName1 defines parameters for GetCustomers.
type GetCustomersParamsFirstName1 = []string

// GetCustomersParamsFirstName2 defines parameters for GetCustomers.
type GetCustomersParamsFirstName2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                          `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_FirstName_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                             `json:"$fulltext,omitempty"`
	Gt       *GetCustomersParams_FirstName_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetCustomersParams_FirstName_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetCustomersParams_FirstName_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                             `json:"$like,omitempty"`
	Lt   *GetCustomersParams_FirstName_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetCustomersParams_FirstName_2_Lte `json:"$lte,omitempty"`
	Ne   *GetCustomersParams_FirstName_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetCustomersParams_FirstName_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetCustomersParams_FirstName_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsLastName0 defines parameters for GetCustomers.
type GetCustomersParamsLastName0 = string

// GetCustomersParamsLastName1 defines parameters for GetCustomers.
type GetCustomersParamsLastName1 = []string

// GetCustomersParamsLastName2 defines parameters for GetCustomers.
type GetCustomersParamsLastName2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                         `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_LastName_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                            `json:"$fulltext,omitempty"`
	Gt       *GetCustomersParams_LastName_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetCustomersParams_LastName_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetCustomersParams_LastName_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                            `json:"$like,omitempty"`
	Lt   *GetCustomersParams_LastName_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetCustomersParams_LastName_2_Lte `json:"$lte,omitempty"`
	Ne   *GetCustomersParams_LastName_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetCustomersParams_LastName_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetCustomersParams_LastName_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsCreatedBy0 defines parameters for GetCustomers.
type GetCustomersParamsCreatedBy0 = string

// GetCustomersParamsCreatedBy1 defines parameters for GetCustomers.
type GetCustomersParamsCreatedBy1 = []string

// GetCustomersParamsCreatedBy2 defines parameters for GetCustomers.
type GetCustomersParamsCreatedBy2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                          `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_CreatedBy_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                             `json:"$fulltext,omitempty"`
	Gt       *GetCustomersParams_CreatedBy_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetCustomersParams_CreatedBy_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetCustomersParams_CreatedBy_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                             `json:"$like,omitempty"`
	Lt   *GetCustomersParams_CreatedBy_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetCustomersParams_CreatedBy_2_Lte `json:"$lte,omitempty"`
	Ne   *GetCustomersParams_CreatedBy_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetCustomersParams_CreatedBy_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetCustomersParams_CreatedBy_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsCreatedAtEq0 defines parameters for GetCustomers.
type GetCustomersParamsCreatedAtEq0 = string

// GetCustomersParamsCreatedAtEq1 defines parameters for GetCustomers.
type GetCustomersParamsCreatedAtEq1 = []string

// GetCustomersParams_CreatedAt_Eq defines parameters for GetCustomers.
type GetCustomersParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetCustomersParamsCreatedAtNot0 defines parameters for GetCustomers.
type GetCustomersParamsCreatedAtNot0 = string

// GetCustomersParamsCreatedAtNot1 defines parameters for GetCustomers.
type GetCustomersParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                              `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                               `json:"$nin,omitempty"`
	Not *GetCustomersParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsCreatedAtNot2 defines parameters for GetCustomers.
type GetCustomersParamsCreatedAtNot2 = []string

// GetCustomersParams_CreatedAt_Not defines parameters for GetCustomers.
type GetCustomersParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetCustomersParamsUpdatedAtEq0 defines parameters for GetCustomers.
type GetCustomersParamsUpdatedAtEq0 = string

// GetCustomersParamsUpdatedAtEq1 defines parameters for GetCustomers.
type GetCustomersParamsUpdatedAtEq1 = []string

// GetCustomersParams_UpdatedAt_Eq defines parameters for GetCustomers.
type GetCustomersParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetCustomersParamsUpdatedAtNot0 defines parameters for GetCustomers.
type GetCustomersParamsUpdatedAtNot0 = string

// GetCustomersParamsUpdatedAtNot1 defines parameters for GetCustomers.
type GetCustomersParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                              `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                               `json:"$nin,omitempty"`
	Not *GetCustomersParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsUpdatedAtNot2 defines parameters for GetCustomers.
type GetCustomersParamsUpdatedAtNot2 = []string

// GetCustomersParams_UpdatedAt_Not defines parameters for GetCustomers.
type GetCustomersParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetCustomersParamsDeletedAtEq0 defines parameters for GetCustomers.
type GetCustomersParamsDeletedAtEq0 = string

// GetCustomersParamsDeletedAtEq1 defines parameters for GetCustomers.
type GetCustomersParamsDeletedAtEq1 = []string

// GetCustomersParams_DeletedAt_Eq defines parameters for GetCustomers.
type GetCustomersParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetCustomersParamsDeletedAtNot0 defines parameters for GetCustomers.
type GetCustomersParamsDeletedAtNot0 = string

// GetCustomersParamsDeletedAtNot1 defines parameters for GetCustomers.
type GetCustomersParamsDeletedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                              `json:"$contains,omitempty"`
	Eq       *GetCustomersParams_DeletedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                               `json:"$nin,omitempty"`
	Not *GetCustomersParams_DeletedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetCustomersParamsDeletedAtNot2 defines parameters for GetCustomers.
type GetCustomersParamsDeletedAtNot2 = []string

// GetCustomersParams_DeletedAt_Not defines parameters for GetCustomers.
type GetCustomersParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostCustomersJSONBody defines parameters for PostCustomers.
type PostCustomersJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// CompanyName The customer's company name.
	CompanyName string `json:"company_name"`

	// Email The customer's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata The customer's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The customer's phone.
	Phone string `json:"phone"`
}

// PostCustomersParams defines parameters for PostCustomers.
type PostCustomersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomersIdParams defines parameters for GetCustomersId.
type GetCustomersIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomersIdJSONBody defines parameters for PostCustomersId.
type PostCustomersIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// CompanyName The customer's company name.
	CompanyName string `json:"company_name"`

	// Email The customer's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata The customer's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The customer's phone.
	Phone string `json:"phone"`
}

// PostCustomersIdParams defines parameters for PostCustomersId.
type PostCustomersIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomersIdAddressesParams defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to apply on the address's searchable properties.
	Q       *string `form:"q,omitempty" json:"q,omitempty"`
	Company *struct {
		union json.RawMessage
	} `form:"company,omitempty" json:"company,omitempty"`
	City *struct {
		union json.RawMessage
	} `form:"city,omitempty" json:"city,omitempty"`
	CountryCode *struct {
		union json.RawMessage
	} `form:"country_code,omitempty" json:"country_code,omitempty"`
	Province *struct {
		union json.RawMessage
	} `form:"province,omitempty" json:"province,omitempty"`
	PostalCode *struct {
		union json.RawMessage
	} `form:"postal_code,omitempty" json:"postal_code,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetCustomersIdAddressesParamsCompany0 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsCompany0 = string

// GetCustomersIdAddressesParamsCompany1 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsCompany1 = []string

// GetCustomersIdAddressesParamsCity0 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsCity0 = string

// GetCustomersIdAddressesParamsCity1 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsCity1 = []string

// GetCustomersIdAddressesParamsCountryCode0 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsCountryCode0 = string

// GetCustomersIdAddressesParamsCountryCode1 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsCountryCode1 = []string

// GetCustomersIdAddressesParamsProvince0 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsProvince0 = string

// GetCustomersIdAddressesParamsProvince1 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsProvince1 = []string

// GetCustomersIdAddressesParamsPostalCode0 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsPostalCode0 = string

// GetCustomersIdAddressesParamsPostalCode1 defines parameters for GetCustomersIdAddresses.
type GetCustomersIdAddressesParamsPostalCode1 = []string

// PostCustomersIdAddressesJSONBody defines parameters for PostCustomersIdAddresses.
type PostCustomersIdAddressesJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Address1 The address's first line.
	Address1 string `json:"address_1"`

	// Address2 The address's second line.
	Address2 string `json:"address_2"`

	// AddressName The name of the address.
	AddressName string `json:"address_name"`

	// City The address's city.
	City string `json:"city"`

	// Company The address's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// FirstName The address's first name.
	FirstName string `json:"first_name"`

	// IsDefaultBilling Whether this address is used by default for billing when placing an order.
	IsDefaultBilling *bool `json:"is_default_billing,omitempty"`

	// IsDefaultShipping Whether this address is used by default for shipping when placing an order.
	IsDefaultShipping *bool `json:"is_default_shipping,omitempty"`

	// LastName The address's last name.
	LastName string `json:"last_name"`

	// Metadata The address's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`
}

// PostCustomersIdAddressesParams defines parameters for PostCustomersIdAddresses.
type PostCustomersIdAddressesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteCustomersIdAddressesAddressIdParams defines parameters for DeleteCustomersIdAddressesAddressId.
type DeleteCustomersIdAddressesAddressIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomersIdAddressesAddressIdParams defines parameters for GetCustomersIdAddressesAddressId.
type GetCustomersIdAddressesAddressIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomersIdAddressesAddressIdJSONBody defines parameters for PostCustomersIdAddressesAddressId.
type PostCustomersIdAddressesAddressIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Address1 The address's first line
	Address1 string `json:"address_1"`

	// Address2 The address's second line
	Address2 string `json:"address_2"`

	// AddressName The name of the address.
	AddressName string `json:"address_name"`

	// City The address's city.
	City string `json:"city"`

	// Company The address's company.
	Company string `json:"company"`

	// CountryCode The address's country code.
	CountryCode string `json:"country_code"`

	// FirstName The address's first name.
	FirstName string `json:"first_name"`

	// IsDefaultBilling Whether this address is used by default for billing when placing an order.
	IsDefaultBilling *bool `json:"is_default_billing,omitempty"`

	// IsDefaultShipping Whether this address is used by default for shipping when placing an order.
	IsDefaultShipping *bool `json:"is_default_shipping,omitempty"`

	// LastName The address's last name.
	LastName string `json:"last_name"`

	// Metadata The address's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// Phone The address's phone.
	Phone string `json:"phone"`

	// PostalCode The address's postal code.
	PostalCode string `json:"postal_code"`

	// Province The address's province.
	Province string `json:"province"`
}

// PostCustomersIdAddressesAddressIdParams defines parameters for PostCustomersIdAddressesAddressId.
type PostCustomersIdAddressesAddressIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDraftOrdersParams defines parameters for GetDraftOrders.
type GetDraftOrdersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Status *struct {
		union json.RawMessage
	} `form:"status,omitempty" json:"status,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`

	// SalesChannelId Filter by the associated sales channels to retrieve its draft orders.
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// FulfillmentStatus Filter by the fulfillment status of the draft order.
	FulfillmentStatus *[]GetDraftOrdersParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// PaymentStatus Filter by the payment status of the draft order.
	PaymentStatus *[]GetDraftOrdersParamsPaymentStatus `form:"payment_status,omitempty" json:"payment_status,omitempty"`

	// RegionId Filter by region IDs to retrieve their associated draft orders.
	RegionId *[]string `form:"region_id,omitempty" json:"region_id,omitempty"`

	// Q Search term to filter the order's searchable properties.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// CreatedAt Filter by the draft order's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetDraftOrdersParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetDraftOrdersParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the draft order's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetDraftOrdersParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetDraftOrdersParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetDraftOrdersParamsId0 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsId0 = string

// GetDraftOrdersParamsId1 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsId1 = []string

// GetDraftOrdersParamsId2 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsId2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                     `json:"$contains,omitempty"`
	Eq       *GetDraftOrdersParams_Id_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                        `json:"$fulltext,omitempty"`
	Gt       *GetDraftOrdersParams_Id_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetDraftOrdersParams_Id_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetDraftOrdersParams_Id_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                        `json:"$like,omitempty"`
	Lt   *GetDraftOrdersParams_Id_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetDraftOrdersParams_Id_2_Lte `json:"$lte,omitempty"`
	Ne   *GetDraftOrdersParams_Id_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetDraftOrdersParams_Id_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetDraftOrdersParams_Id_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetDraftOrdersParamsStatus0 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsStatus0 = string

// GetDraftOrdersParamsStatus1 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsStatus1 = []string

// GetDraftOrdersParamsStatus2 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsStatus2 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                         `json:"$contains,omitempty"`
	Eq       *GetDraftOrdersParams_Status_2_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string                            `json:"$fulltext,omitempty"`
	Gt       *GetDraftOrdersParams_Status_2_Gt  `json:"$gt,omitempty"`
	Gte      *GetDraftOrdersParams_Status_2_Gte `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]GetDraftOrdersParams_Status_2_In_Item `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string                            `json:"$like,omitempty"`
	Lt   *GetDraftOrdersParams_Status_2_Lt  `json:"$lt,omitempty"`
	Lte  *GetDraftOrdersParams_Status_2_Lte `json:"$lte,omitempty"`
	Ne   *GetDraftOrdersParams_Status_2_Ne  `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]GetDraftOrdersParams_Status_2_Nin_Item `json:"$nin,omitempty"`
	Not *GetDraftOrdersParams_Status_2_Not        `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetDraftOrdersParamsFulfillmentStatus defines parameters for GetDraftOrders.
type GetDraftOrdersParamsFulfillmentStatus string

// GetDraftOrdersParamsPaymentStatus defines parameters for GetDraftOrders.
type GetDraftOrdersParamsPaymentStatus string

// GetDraftOrdersParamsCreatedAtEq0 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsCreatedAtEq0 = string

// GetDraftOrdersParamsCreatedAtEq1 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsCreatedAtEq1 = []string

// GetDraftOrdersParams_CreatedAt_Eq defines parameters for GetDraftOrders.
type GetDraftOrdersParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetDraftOrdersParamsCreatedAtNot0 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsCreatedAtNot0 = string

// GetDraftOrdersParamsCreatedAtNot1 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                `json:"$contains,omitempty"`
	Eq       *GetDraftOrdersParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                 `json:"$nin,omitempty"`
	Not *GetDraftOrdersParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetDraftOrdersParamsCreatedAtNot2 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsCreatedAtNot2 = []string

// GetDraftOrdersParams_CreatedAt_Not defines parameters for GetDraftOrders.
type GetDraftOrdersParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetDraftOrdersParamsUpdatedAtEq0 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsUpdatedAtEq0 = string

// GetDraftOrdersParamsUpdatedAtEq1 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsUpdatedAtEq1 = []string

// GetDraftOrdersParams_UpdatedAt_Eq defines parameters for GetDraftOrders.
type GetDraftOrdersParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetDraftOrdersParamsUpdatedAtNot0 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsUpdatedAtNot0 = string

// GetDraftOrdersParamsUpdatedAtNot1 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                                `json:"$contains,omitempty"`
	Eq       *GetDraftOrdersParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                                 `json:"$nin,omitempty"`
	Not *GetDraftOrdersParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetDraftOrdersParamsUpdatedAtNot2 defines parameters for GetDraftOrders.
type GetDraftOrdersParamsUpdatedAtNot2 = []string

// GetDraftOrdersParams_UpdatedAt_Not defines parameters for GetDraftOrders.
type GetDraftOrdersParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// PostDraftOrdersJSONBody defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// BillingAddress The billing address's details.
	BillingAddress *struct {
		// Address1 The billing address's first line.
		Address1 string `json:"address_1"`

		// Address2 The billing address's second line.
		Address2 string `json:"address_2"`

		// City The billing address's city.
		City string `json:"city"`

		// Company The billing address's company.
		Company string `json:"company"`

		// CountryCode The billing address's country code.
		CountryCode string `json:"country_code"`

		// FirstName The billing address's first name.
		FirstName string `json:"first_name"`

		// LastName The billing address's last name.
		LastName string `json:"last_name"`

		// Metadata The billing address's metadata.
		Metadata map[string]interface{} `json:"metadata"`

		// Phone The billing address's phone.
		Phone string `json:"phone"`

		// PostalCode The billing address's postal code.
		PostalCode string `json:"postal_code"`

		// Province The billing address's province.
		Province string `json:"province"`
	} `json:"billing_address,omitempty"`

	// CurrencyCode The draft order's currency code.
	CurrencyCode string `json:"currency_code"`

	// CustomerId The ID of the draft order's customer.
	CustomerId string `json:"customer_id"`

	// Email The email of the draft order's customer.
	Email openapi_types.Email `json:"email"`

	// Items The draft order's items.
	Items *[]struct {
		// Barcode The item's barcode.
		Barcode string `json:"barcode"`

		// Metadata The item's metadata.
		Metadata map[string]interface{} `json:"metadata"`

		// Quantity The item's ordered quantity.
		Quantity float32 `json:"quantity"`

		// Sku The item's SKU.
		Sku string `json:"sku"`

		// Title The item's title.
		Title     string                                  `json:"title"`
		UnitPrice PostDraftOrdersJSONBody_Items_UnitPrice `json:"unit_price"`

		// VariantId The ID of the associated product variant.
		VariantId string `json:"variant_id"`
	} `json:"items,omitempty"`

	// Metadata The draft order's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// NoNotificationOrder Whether to send the customer notifications on order changes.
	NoNotificationOrder *bool `json:"no_notification_order,omitempty"`

	// PromoCodes The promotion codes applied on the draft order.
	PromoCodes *[]string `json:"promo_codes,omitempty"`

	// RegionId The ID of the associated region.
	RegionId string `json:"region_id"`

	// SalesChannelId The ID of the associated sales channel.
	SalesChannelId string `json:"sales_channel_id"`

	// ShippingAddress The draft order's shipping address.
	ShippingAddress *struct {
		// Address1 The shipping address's first line.
		Address1 string `json:"address_1"`

		// Address2 The shipping address's second line.
		Address2 string `json:"address_2"`

		// City The shipping address's city.
		City string `json:"city"`

		// Company The shipping address's company.
		Company string `json:"company"`

		// CountryCode The shipping address's country code.
		CountryCode string `json:"country_code"`

		// FirstName The shipping address's first name.
		FirstName string `json:"first_name"`

		// LastName The shipping address's last name.
		LastName string `json:"last_name"`

		// Metadata The shipping address's metadata.
		Metadata map[string]interface{} `json:"metadata"`

		// Phone The shipping address's phone.
		Phone string `json:"phone"`

		// PostalCode The shipping address's postal code.
		PostalCode string `json:"postal_code"`

		// Province The shipping address's province.
		Province string `json:"province"`
	} `json:"shipping_address,omitempty"`

	// ShippingMethods The draft order's shipping methods.
	ShippingMethods []struct {
		Amount PostDraftOrdersJSONBody_ShippingMethods_Amount `json:"amount"`

		// Data The shipping method's data, useful for fulfillment providers.
		Data *map[string]interface{} `json:"data,omitempty"`

		// Name The shipping method's name.
		Name string `json:"name"`

		// OptionId The ID of the shipping option this method is created from.
		OptionId string `json:"option_id"`

		// ShippingMethodId The ID of an existing shipping method.
		ShippingMethodId *string `json:"shipping_method_id,omitempty"`
	} `json:"shipping_methods"`

	// Status The draft order's status.
	Status *PostDraftOrdersJSONBodyStatus `json:"status,omitempty"`
}

// PostDraftOrdersParams defines parameters for PostDraftOrders.
type PostDraftOrdersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDraftOrdersJSONBodyItemsUnitPrice0 defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyItemsUnitPrice0 = string

// PostDraftOrdersJSONBodyItemsUnitPrice1 defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyItemsUnitPrice1 = float32

// PostDraftOrdersJSONBodyItemsUnitPrice2 defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyItemsUnitPrice2 struct {
	// Precision The unit price's rounding precision.
	Precision float32 `json:"precision"`

	// Value The unit price's value.
	Value string `json:"value"`
}

// PostDraftOrdersJSONBody_Items_UnitPrice defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBody_Items_UnitPrice struct {
	union json.RawMessage
}

// PostDraftOrdersJSONBodyShippingMethodsAmount0 defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyShippingMethodsAmount0 = string

// PostDraftOrdersJSONBodyShippingMethodsAmount1 defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyShippingMethodsAmount1 = float32

// PostDraftOrdersJSONBodyShippingMethodsAmount2 defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyShippingMethodsAmount2 struct {
	// Precision The amount's rounding precision.
	Precision float32 `json:"precision"`

	// Value The amount's value.
	Value string `json:"value"`
}

// PostDraftOrdersJSONBody_ShippingMethods_Amount defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBody_ShippingMethods_Amount struct {
	union json.RawMessage
}

// PostDraftOrdersJSONBodyStatus defines parameters for PostDraftOrders.
type PostDraftOrdersJSONBodyStatus string

// GetExchangesParams defines parameters for GetExchanges.
type GetExchangesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DeletedAt Filter by an exchange's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetExchangesParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetExchangesParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Q Search term to apply on an exchange's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	OrderId *struct {
		union json.RawMessage
	} `form:"order_id,omitempty" json:"order_id,omitempty"`
	Status *struct {
		union json.RawMessage
	} `form:"status,omitempty" json:"status,omitempty"`

	// CreatedAt Filter by the exchange's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetExchangesParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetExchangesParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the exchange's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetExchangesParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetExchangesParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetExchangesParamsDeletedAtEq0 defines parameters for GetExchanges.
type GetExchangesParamsDeletedAtEq0 = string

// GetExchangesParamsDeletedAtEq1 defines parameters for GetExchanges.
type GetExchangesParamsDeletedAtEq1 = []string

// GetExchangesParams_DeletedAt_Eq defines parameters for GetExchanges.
type GetExchangesParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetExchangesParamsDeletedAtNot0 defines parameters for GetExchanges.
type GetExchangesParamsDeletedAtNot0 = string

// GetExchangesParamsDeletedAtNot1 defines parameters for GetExchanges.
type GetExchangesParamsDeletedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                              `json:"$contains,omitempty"`
	Eq       *GetExchangesParams_DeletedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                               `json:"$nin,omitempty"`
	Not *GetExchangesParams_DeletedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetExchangesParamsDeletedAtNot2 defines parameters for GetExchanges.
type GetExchangesParamsDeletedAtNot2 = []string

// GetExchangesParams_DeletedAt_Not defines parameters for GetExchanges.
type GetExchangesParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetExchangesParamsId0 defines parameters for GetExchanges.
type GetExchangesParamsId0 = string

// GetExchangesParamsId1 defines parameters for GetExchanges.
type GetExchangesParamsId1 = []string

// GetExchangesParamsOrderId0 defines parameters for GetExchanges.
type GetExchangesParamsOrderId0 = string

// GetExchangesParamsOrderId1 defines parameters for GetExchanges.
type GetExchangesParamsOrderId1 = []string

// GetExchangesParamsStatus0 defines parameters for GetExchanges.
type GetExchangesParamsStatus0 = string

// GetExchangesParamsStatus1 defines parameters for GetExchanges.
type GetExchangesParamsStatus1 = []string

// GetExchangesParamsCreatedAtEq0 defines parameters for GetExchanges.
type GetExchangesParamsCreatedAtEq0 = string

// GetExchangesParamsCreatedAtEq1 defines parameters for GetExchanges.
type GetExchangesParamsCreatedAtEq1 = []string

// GetExchangesParams_CreatedAt_Eq defines parameters for GetExchanges.
type GetExchangesParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetExchangesParamsCreatedAtNot0 defines parameters for GetExchanges.
type GetExchangesParamsCreatedAtNot0 = string

// GetExchangesParamsCreatedAtNot1 defines parameters for GetExchanges.
type GetExchangesParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                              `json:"$contains,omitempty"`
	Eq       *GetExchangesParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                               `json:"$nin,omitempty"`
	Not *GetExchangesParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetExchangesParamsCreatedAtNot2 defines parameters for GetExchanges.
type GetExchangesParamsCreatedAtNot2 = []string

// GetExchangesParams_CreatedAt_Not defines parameters for GetExchanges.
type GetExchangesParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetExchangesParamsUpdatedAtEq0 defines parameters for GetExchanges.
type GetExchangesParamsUpdatedAtEq0 = string

// GetExchangesParamsUpdatedAtEq1 defines parameters for GetExchanges.
type GetExchangesParamsUpdatedAtEq1 = []string

// GetExchangesParams_UpdatedAt_Eq defines parameters for GetExchanges.
type GetExchangesParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetExchangesParamsUpdatedAtNot0 defines parameters for GetExchanges.
type GetExchangesParamsUpdatedAtNot0 = string

// GetExchangesParamsUpdatedAtNot1 defines parameters for GetExchanges.
type GetExchangesParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                              `json:"$contains,omitempty"`
	Eq       *GetExchangesParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                               `json:"$nin,omitempty"`
	Not *GetExchangesParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetExchangesParamsUpdatedAtNot2 defines parameters for GetExchanges.
type GetExchangesParamsUpdatedAtNot2 = []string

// GetExchangesParams_UpdatedAt_Not defines parameters for GetExchanges.
type GetExchangesParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// PostExchangesParams defines parameters for PostExchanges.
type PostExchangesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetExchangesIdParams defines parameters for GetExchangesId.
type GetExchangesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostExchangesIdInboundShippingMethodActionIdParams defines parameters for PostExchangesIdInboundShippingMethodActionId.
type PostExchangesIdInboundShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostExchangesIdOutboundItemsParams defines parameters for PostExchangesIdOutboundItems.
type PostExchangesIdOutboundItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteExchangesIdOutboundItemsActionIdParams defines parameters for DeleteExchangesIdOutboundItemsActionId.
type DeleteExchangesIdOutboundItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostExchangesIdOutboundItemsActionIdParams defines parameters for PostExchangesIdOutboundItemsActionId.
type PostExchangesIdOutboundItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostExchangesIdOutboundShippingMethodParams defines parameters for PostExchangesIdOutboundShippingMethod.
type PostExchangesIdOutboundShippingMethodParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteExchangesIdOutboundShippingMethodActionIdParams defines parameters for DeleteExchangesIdOutboundShippingMethodActionId.
type DeleteExchangesIdOutboundShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostExchangesIdOutboundShippingMethodActionIdParams defines parameters for PostExchangesIdOutboundShippingMethodActionId.
type PostExchangesIdOutboundShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostExchangesIdRequestParams defines parameters for PostExchangesIdRequest.
type PostExchangesIdRequestParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetFulfillmentProvidersParams defines parameters for GetFulfillmentProviders.
type GetFulfillmentProvidersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// IsEnabled Filter by whether the fulfillment provider is enabled.
	IsEnabled *bool `form:"is_enabled,omitempty" json:"is_enabled,omitempty"`

	// Q Search term to filter a fulfillment provider's searchable properties.
	Q               *string `form:"q,omitempty" json:"q,omitempty"`
	StockLocationId *struct {
		union json.RawMessage
	} `form:"stock_location_id,omitempty" json:"stock_location_id,omitempty"`
}

// GetFulfillmentProvidersParamsId0 defines parameters for GetFulfillmentProviders.
type GetFulfillmentProvidersParamsId0 = string

// GetFulfillmentProvidersParamsId1 defines parameters for GetFulfillmentProviders.
type GetFulfillmentProvidersParamsId1 = []string

// GetFulfillmentProvidersParamsStockLocationId0 defines parameters for GetFulfillmentProviders.
type GetFulfillmentProvidersParamsStockLocationId0 = string

// GetFulfillmentProvidersParamsStockLocationId1 defines parameters for GetFulfillmentProviders.
type GetFulfillmentProvidersParamsStockLocationId1 = []string

// PostFulfillmentSetsIdServiceZonesJSONBody defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesJSONBody struct {
	// GeoZones The service zone's geo zones.
	GeoZones *[]PostFulfillmentSetsIdServiceZonesJSONBody_GeoZones_Item `json:"geo_zones,omitempty"`

	// Name The service zone's name.
	Name string `json:"name"`
}

// PostFulfillmentSetsIdServiceZonesParams defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones0 defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones0 struct {
	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones1 defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones1 struct {
	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones2 defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones2 struct {
	// City The geo zone's city.
	City string `json:"city"`

	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones3 defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesJSONBodyGeoZones3 struct {
	// City The geo zone's city.
	City string `json:"city"`

	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// PostalExpression The geo zone's postal expression or ZIP code.
	PostalExpression map[string]interface{} `json:"postal_expression"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesJSONBody_GeoZones_Item defines parameters for PostFulfillmentSetsIdServiceZones.
type PostFulfillmentSetsIdServiceZonesJSONBody_GeoZones_Item struct {
	union json.RawMessage
}

// GetFulfillmentSetsIdServiceZonesZoneIdParams defines parameters for GetFulfillmentSetsIdServiceZonesZoneId.
type GetFulfillmentSetsIdServiceZonesZoneIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdJSONBody defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONBody struct {
	// GeoZones The service zone's associated geo zones.
	GeoZones *[]PostFulfillmentSetsIdServiceZonesZoneIdJSONBody_GeoZones_Item `json:"geo_zones,omitempty"`

	// Name The service zone's name.
	Name *string `json:"name,omitempty"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdParams defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones0 defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones0 struct {
	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Id The ID of an existing geo zone.
	Id *string `json:"id,omitempty"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones1 defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones1 struct {
	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Id The ID of an existing geo zone.
	Id *string `json:"id,omitempty"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones2 defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones2 struct {
	// City The geo zone's city.
	City string `json:"city"`

	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Id The ID of an existing geo zone.
	Id *string `json:"id,omitempty"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones3 defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONBodyGeoZones3 struct {
	// City The geo zone's city.
	City string `json:"city"`

	// CountryCode The geo zone's country code.
	CountryCode string `json:"country_code"`

	// Id The ID of an existing geo zone.
	Id *string `json:"id,omitempty"`

	// Metadata The geo zone's metadata.
	Metadata map[string]interface{} `json:"metadata"`

	// PostalExpression The geo zone's postal expression or ZIP code.
	PostalExpression map[string]interface{} `json:"postal_expression"`

	// ProvinceCode The geo zone's province code.
	ProvinceCode string `json:"province_code"`

	// Type The geo zone's type.
	Type string `json:"type"`
}

// PostFulfillmentSetsIdServiceZonesZoneIdJSONBody_GeoZones_Item defines parameters for PostFulfillmentSetsIdServiceZonesZoneId.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONBody_GeoZones_Item struct {
	union json.RawMessage
}

// PostFulfillmentsParams defines parameters for PostFulfillments.
type PostFulfillmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostFulfillmentsIdCancelParams defines parameters for PostFulfillmentsIdCancel.
type PostFulfillmentsIdCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostFulfillmentsIdShipmentParams defines parameters for PostFulfillmentsIdShipment.
type PostFulfillmentsIdShipmentParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetInventoryItemsParams defines parameters for GetInventoryItems.
type GetInventoryItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q The inventory item's q.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Sku *struct {
		union json.RawMessage
	} `form:"sku,omitempty" json:"sku,omitempty"`
	OriginCountry *struct {
		union json.RawMessage
	} `form:"origin_country,omitempty" json:"origin_country,omitempty"`
	MidCode *struct {
		union json.RawMessage
	} `form:"mid_code,omitempty" json:"mid_code,omitempty"`
	HsCode *struct {
		union json.RawMessage
	} `form:"hs_code,omitempty" json:"hs_code,omitempty"`
	Material *struct {
		union json.RawMessage
	} `form:"material,omitempty" json:"material,omitempty"`

	// RequiresShipping The inventory item's requires shipping.
	RequiresShipping *bool `form:"requires_shipping,omitempty" json:"requires_shipping,omitempty"`

	// Weight Filter the inventory item's weight.
	Weight *struct {
		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string `json:"$contains,omitempty"`

		// Eq Filter by an exact match.
		Eq *string `json:"$eq,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array's items.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not matching this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array's items.
		Nin *[]string `json:"$nin,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"weight,omitempty" json:"weight,omitempty"`

	// Length Filter the inventory item's length.
	Length *struct {
		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string `json:"$contains,omitempty"`

		// Eq Filter by an exact match.
		Eq *string `json:"$eq,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array's items.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not matching this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array's items.
		Nin *[]string `json:"$nin,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"length,omitempty" json:"length,omitempty"`

	// Height Filter by the inventory item's height.
	Height *struct {
		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string `json:"$contains,omitempty"`

		// Eq Filter by an exact match.
		Eq *string `json:"$eq,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array's items.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not matching this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array's items.
		Nin *[]string `json:"$nin,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"height,omitempty" json:"height,omitempty"`

	// Width Filter by the inventory item's width.
	Width *struct {
		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string `json:"$contains,omitempty"`

		// Eq Filter by an exact match.
		Eq *string `json:"$eq,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array's items.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not matching this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array's items.
		Nin *[]string `json:"$nin,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"width,omitempty" json:"width,omitempty"`

	// LocationLevels Filter by the inventory item's associated location IDs.
	LocationLevels *struct {
		LocationId GetInventoryItemsParams_LocationLevels_LocationId `json:"location_id"`
	} `form:"location_levels,omitempty" json:"location_levels,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetInventoryItemsParamsId0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsId0 = string

// GetInventoryItemsParamsId1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsId1 = []string

// GetInventoryItemsParamsSku0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsSku0 = string

// GetInventoryItemsParamsSku1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsSku1 = []string

// GetInventoryItemsParamsOriginCountry0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsOriginCountry0 = string

// GetInventoryItemsParamsOriginCountry1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsOriginCountry1 = []string

// GetInventoryItemsParamsMidCode0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsMidCode0 = string

// GetInventoryItemsParamsMidCode1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsMidCode1 = []string

// GetInventoryItemsParamsHsCode0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsHsCode0 = string

// GetInventoryItemsParamsHsCode1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsHsCode1 = []string

// GetInventoryItemsParamsMaterial0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsMaterial0 = string

// GetInventoryItemsParamsMaterial1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsMaterial1 = []string

// GetInventoryItemsParamsLocationLevelsLocationId0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsLocationLevelsLocationId0 = string

// GetInventoryItemsParamsLocationLevelsLocationId1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsLocationLevelsLocationId1 = []string

// GetInventoryItemsParams_LocationLevels_LocationId defines parameters for GetInventoryItems.
type GetInventoryItemsParams_LocationLevels_LocationId struct {
	union json.RawMessage
}

// PostInventoryItemsParams defines parameters for PostInventoryItems.
type PostInventoryItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetInventoryItemsIdParams defines parameters for GetInventoryItemsId.
type GetInventoryItemsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInventoryItemsIdJSONBody defines parameters for PostInventoryItemsId.
type PostInventoryItemsIdJSONBody struct {
	// Description The inventory item's description.
	Description *string `json:"description,omitempty"`

	// Height The inventory item's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The inventory item's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Length The inventory item's length.
	Length *float32 `json:"length,omitempty"`

	// Material The inventory item's material.
	Material *string `json:"material,omitempty"`

	// Metadata The inventory item's metadata. Can be custom data in key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The inventory item's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The inventory item's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping Whether the inventory item requires shipping.
	RequiresShipping *bool `json:"requires_shipping,omitempty"`

	// Sku The inventory item's SKU.
	Sku *string `json:"sku,omitempty"`

	// Thumbnail The URL of an image to be used as the inventory item's thumbnail. You can use the Upload API routes to upload an image and get its URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The inventory item's title.
	Title *string `json:"title,omitempty"`

	// Weight The inventory item's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The inventory item's width.
	Width *float32 `json:"width,omitempty"`
}

// PostInventoryItemsIdParams defines parameters for PostInventoryItemsId.
type PostInventoryItemsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetInventoryItemsIdLocationLevelsParams defines parameters for GetInventoryItemsIdLocationLevels.
type GetInventoryItemsIdLocationLevelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order      *string `form:"order,omitempty" json:"order,omitempty"`
	LocationId *struct {
		union json.RawMessage
	} `form:"location_id,omitempty" json:"location_id,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetInventoryItemsIdLocationLevelsParamsLocationId0 defines parameters for GetInventoryItemsIdLocationLevels.
type GetInventoryItemsIdLocationLevelsParamsLocationId0 = string

// GetInventoryItemsIdLocationLevelsParamsLocationId1 defines parameters for GetInventoryItemsIdLocationLevels.
type GetInventoryItemsIdLocationLevelsParamsLocationId1 = []string

// PostInventoryItemsIdLocationLevelsJSONBody defines parameters for PostInventoryItemsIdLocationLevels.
type PostInventoryItemsIdLocationLevelsJSONBody struct {
	// IncomingQuantity The inventory level's incoming quantity.
	IncomingQuantity *float32 `json:"incoming_quantity,omitempty"`

	// LocationId The ID of the associated location.
	LocationId string `json:"location_id"`

	// StockedQuantity The inventory level's stocked quantity.
	StockedQuantity *float32 `json:"stocked_quantity,omitempty"`
}

// PostInventoryItemsIdLocationLevelsParams defines parameters for PostInventoryItemsIdLocationLevels.
type PostInventoryItemsIdLocationLevelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInventoryItemsIdLocationLevelsBatchJSONBody defines parameters for PostInventoryItemsIdLocationLevelsBatch.
type PostInventoryItemsIdLocationLevelsBatchJSONBody struct {
	// Create The inventory levels to create.
	Create *[]struct {
		// IncomingQuantity The inventory level's incoming quantity.
		IncomingQuantity *float32 `json:"incoming_quantity,omitempty"`

		// LocationId The ID of the associated location.
		LocationId string `json:"location_id"`

		// StockedQuantity The inventory level's stocked quantity.
		StockedQuantity *float32 `json:"stocked_quantity,omitempty"`
	} `json:"create,omitempty"`

	// Delete The inventory levels to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The inventory levels to update.
	Update *[]struct {
		// IncomingQuantity The inventory level's incoming quantity.
		IncomingQuantity *float32 `json:"incoming_quantity,omitempty"`

		// StockedQuantity The inventory level's stocked quantity.
		StockedQuantity *float32 `json:"stocked_quantity,omitempty"`
	} `json:"update,omitempty"`
}

// DeleteInventoryItemsIdLocationLevelsLocationIdParams defines parameters for DeleteInventoryItemsIdLocationLevelsLocationId.
type DeleteInventoryItemsIdLocationLevelsLocationIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInventoryItemsIdLocationLevelsLocationIdJSONBody defines parameters for PostInventoryItemsIdLocationLevelsLocationId.
type PostInventoryItemsIdLocationLevelsLocationIdJSONBody struct {
	// IncomingQuantity The inventory level's incoming quantity.
	IncomingQuantity *float32 `json:"incoming_quantity,omitempty"`

	// StockedQuantity The inventory level's stocked quantity.
	StockedQuantity *float32 `json:"stocked_quantity,omitempty"`
}

// PostInventoryItemsIdLocationLevelsLocationIdParams defines parameters for PostInventoryItemsIdLocationLevelsLocationId.
type PostInventoryItemsIdLocationLevelsLocationIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetInvitesParams defines parameters for GetInvites.
type GetInvitesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to apply on an invite's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Email *struct {
		union json.RawMessage
	} `form:"email,omitempty" json:"email,omitempty"`

	// CreatedAt Filter by the invite's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetInvitesParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetInvitesParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the invite's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetInvitesParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetInvitesParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the invite's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetInvitesParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetInvitesParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetInvitesParamsId0 defines parameters for GetInvites.
type GetInvitesParamsId0 = string

// GetInvitesParamsId1 defines parameters for GetInvites.
type GetInvitesParamsId1 = []string

// GetInvitesParamsEmail0 defines parameters for GetInvites.
type GetInvitesParamsEmail0 = openapi_types.Email

// GetInvitesParamsEmail1 defines parameters for GetInvites.
type GetInvitesParamsEmail1 = []openapi_types.Email

// GetInvitesParamsCreatedAtEq0 defines parameters for GetInvites.
type GetInvitesParamsCreatedAtEq0 = string

// GetInvitesParamsCreatedAtEq1 defines parameters for GetInvites.
type GetInvitesParamsCreatedAtEq1 = []string

// GetInvitesParams_CreatedAt_Eq defines parameters for GetInvites.
type GetInvitesParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetInvitesParamsCreatedAtNot0 defines parameters for GetInvites.
type GetInvitesParamsCreatedAtNot0 = string

// GetInvitesParamsCreatedAtNot1 defines parameters for GetInvites.
type GetInvitesParamsCreatedAtNot1 = map[string]interface{}

// GetInvitesParamsCreatedAtNot2 defines parameters for GetInvites.
type GetInvitesParamsCreatedAtNot2 = []string

// GetInvitesParams_CreatedAt_Not defines parameters for GetInvites.
type GetInvitesParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetInvitesParamsUpdatedAtEq0 defines parameters for GetInvites.
type GetInvitesParamsUpdatedAtEq0 = string

// GetInvitesParamsUpdatedAtEq1 defines parameters for GetInvites.
type GetInvitesParamsUpdatedAtEq1 = []string

// GetInvitesParams_UpdatedAt_Eq defines parameters for GetInvites.
type GetInvitesParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetInvitesParamsUpdatedAtNot0 defines parameters for GetInvites.
type GetInvitesParamsUpdatedAtNot0 = string

// GetInvitesParamsUpdatedAtNot1 defines parameters for GetInvites.
type GetInvitesParamsUpdatedAtNot1 = map[string]interface{}

// GetInvitesParamsUpdatedAtNot2 defines parameters for GetInvites.
type GetInvitesParamsUpdatedAtNot2 = []string

// GetInvitesParams_UpdatedAt_Not defines parameters for GetInvites.
type GetInvitesParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetInvitesParamsDeletedAtEq0 defines parameters for GetInvites.
type GetInvitesParamsDeletedAtEq0 = string

// GetInvitesParamsDeletedAtEq1 defines parameters for GetInvites.
type GetInvitesParamsDeletedAtEq1 = []string

// GetInvitesParams_DeletedAt_Eq defines parameters for GetInvites.
type GetInvitesParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetInvitesParamsDeletedAtNot0 defines parameters for GetInvites.
type GetInvitesParamsDeletedAtNot0 = string

// GetInvitesParamsDeletedAtNot1 defines parameters for GetInvites.
type GetInvitesParamsDeletedAtNot1 = map[string]interface{}

// GetInvitesParamsDeletedAtNot2 defines parameters for GetInvites.
type GetInvitesParamsDeletedAtNot2 = []string

// GetInvitesParams_DeletedAt_Not defines parameters for GetInvites.
type GetInvitesParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostInvitesJSONBody defines parameters for PostInvites.
type PostInvitesJSONBody struct {
	// Email The email of the user to invite.
	Email openapi_types.Email `json:"email"`

	// Metadata The invite's metadata. Can be custom data in key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// PostInvitesParams defines parameters for PostInvites.
type PostInvitesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInvitesAcceptJSONBody defines parameters for PostInvitesAccept.
type PostInvitesAcceptJSONBody struct {
	// Email The user's email.
	Email *openapi_types.Email `json:"email,omitempty"`

	// FirstName The user's first name.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The user's last name.
	LastName *string `json:"last_name,omitempty"`
}

// GetInvitesIdParams defines parameters for GetInvitesId.
type GetInvitesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInvitesIdResendParams defines parameters for PostInvitesIdResend.
type PostInvitesIdResendParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetNotificationsParams defines parameters for GetNotifications.
type GetNotificationsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to apply on the notification's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Channel *struct {
		union json.RawMessage
	} `form:"channel,omitempty" json:"channel,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetNotificationsParamsId0 defines parameters for GetNotifications.
type GetNotificationsParamsId0 = string

// GetNotificationsParamsId1 defines parameters for GetNotifications.
type GetNotificationsParamsId1 = []string

// GetNotificationsParamsChannel0 defines parameters for GetNotifications.
type GetNotificationsParamsChannel0 = string

// GetNotificationsParamsChannel1 defines parameters for GetNotifications.
type GetNotificationsParamsChannel1 = []string

// GetNotificationsIdParams defines parameters for GetNotificationsId.
type GetNotificationsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Status *struct {
		union json.RawMessage
	} `form:"status,omitempty" json:"status,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`

	// SalesChannelId Filter by sales channel IDs to retrieve the orders associated with them.
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// FulfillmentStatus Filter by the order's fulfillment status.
	FulfillmentStatus *[]GetOrdersParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// PaymentStatus Filter by the order's payment status.
	PaymentStatus *[]GetOrdersParamsPaymentStatus `form:"payment_status,omitempty" json:"payment_status,omitempty"`

	// RegionId Filter by region IDs to retrieve their associated orders.
	RegionId *[]string `form:"region_id,omitempty" json:"region_id,omitempty"`

	// Q Search term to filter the order's searchable properties.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// CreatedAt Filter by the order's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                     `json:"$contains,omitempty"`
		Eq       *GetOrdersParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                      `json:"$nin,omitempty"`
		Not *GetOrdersParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the order's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                     `json:"$contains,omitempty"`
		Eq       *GetOrdersParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                      `json:"$nin,omitempty"`
		Not *GetOrdersParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetOrdersParamsId0 defines parameters for GetOrders.
type GetOrdersParamsId0 = string

// GetOrdersParamsId1 defines parameters for GetOrders.
type GetOrdersParamsId1 = []string

// GetOrdersParamsStatus0 defines parameters for GetOrders.
type GetOrdersParamsStatus0 = string

// GetOrdersParamsStatus1 defines parameters for GetOrders.
type GetOrdersParamsStatus1 = []string

// GetOrdersParamsFulfillmentStatus defines parameters for GetOrders.
type GetOrdersParamsFulfillmentStatus string

// GetOrdersParamsPaymentStatus defines parameters for GetOrders.
type GetOrdersParamsPaymentStatus string

// GetOrdersParamsCreatedAtEq0 defines parameters for GetOrders.
type GetOrdersParamsCreatedAtEq0 = string

// GetOrdersParamsCreatedAtEq1 defines parameters for GetOrders.
type GetOrdersParamsCreatedAtEq1 = []string

// GetOrdersParams_CreatedAt_Eq defines parameters for GetOrders.
type GetOrdersParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetOrdersParamsCreatedAtNot0 defines parameters for GetOrders.
type GetOrdersParamsCreatedAtNot0 = string

// GetOrdersParamsCreatedAtNot1 defines parameters for GetOrders.
type GetOrdersParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetOrdersParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetOrdersParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetOrdersParamsCreatedAtNot2 defines parameters for GetOrders.
type GetOrdersParamsCreatedAtNot2 = []string

// GetOrdersParams_CreatedAt_Not defines parameters for GetOrders.
type GetOrdersParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetOrdersParamsUpdatedAtEq0 defines parameters for GetOrders.
type GetOrdersParamsUpdatedAtEq0 = string

// GetOrdersParamsUpdatedAtEq1 defines parameters for GetOrders.
type GetOrdersParamsUpdatedAtEq1 = []string

// GetOrdersParams_UpdatedAt_Eq defines parameters for GetOrders.
type GetOrdersParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetOrdersParamsUpdatedAtNot0 defines parameters for GetOrders.
type GetOrdersParamsUpdatedAtNot0 = string

// GetOrdersParamsUpdatedAtNot1 defines parameters for GetOrders.
type GetOrdersParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetOrdersParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetOrdersParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetOrdersParamsUpdatedAtNot2 defines parameters for GetOrders.
type GetOrdersParamsUpdatedAtNot2 = []string

// GetOrdersParams_UpdatedAt_Not defines parameters for GetOrders.
type GetOrdersParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetOrdersIdParams defines parameters for GetOrdersId.
type GetOrdersIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdParams defines parameters for PostOrdersId.
type PostOrdersIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdArchiveParams defines parameters for PostOrdersIdArchive.
type PostOrdersIdArchiveParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdCancelParams defines parameters for PostOrdersIdCancel.
type PostOrdersIdCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetOrdersIdChangesParams defines parameters for GetOrdersIdChanges.
type GetOrdersIdChangesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data.
	// if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields.
	// without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdCompleteJSONBody defines parameters for PostOrdersIdComplete.
type PostOrdersIdCompleteJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`
}

// PostOrdersIdCompleteParams defines parameters for PostOrdersIdComplete.
type PostOrdersIdCompleteParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdFulfillmentsJSONBody defines parameters for PostOrdersIdFulfillments.
type PostOrdersIdFulfillmentsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Items The items to fulfill.
	Items []struct {
		// Id The item's ID.
		Id string `json:"id"`

		// Quantity The item's quantity to fulfill.
		Quantity float32 `json:"quantity"`
	} `json:"items"`

	// LocationId The ID of the location to fulfill the items from. If not provided, the location associated with the shipping option of the order's shipping method is used.
	LocationId string `json:"location_id"`

	// Metadata The order's metadata. Can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// NoNotification Whether to send the customer a notification about the created fulfillment.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// PostOrdersIdFulfillmentsParams defines parameters for PostOrdersIdFulfillments.
type PostOrdersIdFulfillmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdFulfillmentsFulfillmentIdCancelJSONBody defines parameters for PostOrdersIdFulfillmentsFulfillmentIdCancel.
type PostOrdersIdFulfillmentsFulfillmentIdCancelJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// NoNotification Whether the customer should receive a notification about this change.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// PostOrdersIdFulfillmentsFulfillmentIdCancelParams defines parameters for PostOrdersIdFulfillmentsFulfillmentIdCancel.
type PostOrdersIdFulfillmentsFulfillmentIdCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams defines parameters for PostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered.
type PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data.
	// If a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields.
	// Without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONBody defines parameters for PostOrdersIdFulfillmentsFulfillmentIdShipments.
type PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Items The items to create shipment for.
	Items []struct {
		// Id The item's ID.
		Id string `json:"id"`

		// Quantity The item's quantity to ship.
		Quantity float32 `json:"quantity"`
	} `json:"items"`

	// Labels The labels to create for the shipment.
	Labels *[]struct {
		// LabelUrl The label's url.
		LabelUrl string `json:"label_url"`

		// TrackingNumber The label's tracking number.
		TrackingNumber string `json:"tracking_number"`

		// TrackingUrl The label's tracking url.
		TrackingUrl string `json:"tracking_url"`
	} `json:"labels,omitempty"`

	// Metadata The shipment's metadata. Can hold custom key-value pairs.
	Metadata map[string]interface{} `json:"metadata"`

	// NoNotification Whether to send the customer a notification about the created shipment.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams defines parameters for PostOrdersIdFulfillmentsFulfillmentIdShipments.
type PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPaymentCollectionsJSONBody defines parameters for PostPaymentCollections.
type PostPaymentCollectionsJSONBody struct {
	// Amount The amount to be paid.
	Amount float32 `json:"amount"`

	// OrderId The ID of the associated order.
	OrderId string `json:"order_id"`
}

// PostPaymentCollectionsParams defines parameters for PostPaymentCollections.
type PostPaymentCollectionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPaymentCollectionsIdMarkAsPaidJSONBody defines parameters for PostPaymentCollectionsIdMarkAsPaid.
type PostPaymentCollectionsIdMarkAsPaidJSONBody struct {
	// OrderId The ID of the order associated with the payment collection.
	OrderId string `json:"order_id"`
}

// PostPaymentCollectionsIdMarkAsPaidParams defines parameters for PostPaymentCollectionsIdMarkAsPaid.
type PostPaymentCollectionsIdMarkAsPaidParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPaymentsParams defines parameters for GetPayments.
type GetPaymentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the payment's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	PaymentSessionId *struct {
		union json.RawMessage
	} `form:"payment_session_id,omitempty" json:"payment_session_id,omitempty"`

	// CreatedAt Filter by the payment's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetPaymentsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetPaymentsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the payment's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetPaymentsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetPaymentsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the payment's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetPaymentsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetPaymentsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetPaymentsParamsId0 defines parameters for GetPayments.
type GetPaymentsParamsId0 = string

// GetPaymentsParamsId1 defines parameters for GetPayments.
type GetPaymentsParamsId1 = []string

// GetPaymentsParamsPaymentSessionId0 defines parameters for GetPayments.
type GetPaymentsParamsPaymentSessionId0 = string

// GetPaymentsParamsPaymentSessionId1 defines parameters for GetPayments.
type GetPaymentsParamsPaymentSessionId1 = []string

// GetPaymentsParamsCreatedAtEq0 defines parameters for GetPayments.
type GetPaymentsParamsCreatedAtEq0 = string

// GetPaymentsParamsCreatedAtEq1 defines parameters for GetPayments.
type GetPaymentsParamsCreatedAtEq1 = []string

// GetPaymentsParams_CreatedAt_Eq defines parameters for GetPayments.
type GetPaymentsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetPaymentsParamsCreatedAtNot0 defines parameters for GetPayments.
type GetPaymentsParamsCreatedAtNot0 = string

// GetPaymentsParamsCreatedAtNot1 defines parameters for GetPayments.
type GetPaymentsParamsCreatedAtNot1 = map[string]interface{}

// GetPaymentsParamsCreatedAtNot2 defines parameters for GetPayments.
type GetPaymentsParamsCreatedAtNot2 = []string

// GetPaymentsParams_CreatedAt_Not defines parameters for GetPayments.
type GetPaymentsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetPaymentsParamsUpdatedAtEq0 defines parameters for GetPayments.
type GetPaymentsParamsUpdatedAtEq0 = string

// GetPaymentsParamsUpdatedAtEq1 defines parameters for GetPayments.
type GetPaymentsParamsUpdatedAtEq1 = []string

// GetPaymentsParams_UpdatedAt_Eq defines parameters for GetPayments.
type GetPaymentsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetPaymentsParamsUpdatedAtNot0 defines parameters for GetPayments.
type GetPaymentsParamsUpdatedAtNot0 = string

// GetPaymentsParamsUpdatedAtNot1 defines parameters for GetPayments.
type GetPaymentsParamsUpdatedAtNot1 = map[string]interface{}

// GetPaymentsParamsUpdatedAtNot2 defines parameters for GetPayments.
type GetPaymentsParamsUpdatedAtNot2 = []string

// GetPaymentsParams_UpdatedAt_Not defines parameters for GetPayments.
type GetPaymentsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetPaymentsParamsDeletedAtEq0 defines parameters for GetPayments.
type GetPaymentsParamsDeletedAtEq0 = string

// GetPaymentsParamsDeletedAtEq1 defines parameters for GetPayments.
type GetPaymentsParamsDeletedAtEq1 = []string

// GetPaymentsParams_DeletedAt_Eq defines parameters for GetPayments.
type GetPaymentsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetPaymentsParamsDeletedAtNot0 defines parameters for GetPayments.
type GetPaymentsParamsDeletedAtNot0 = string

// GetPaymentsParamsDeletedAtNot1 defines parameters for GetPayments.
type GetPaymentsParamsDeletedAtNot1 = map[string]interface{}

// GetPaymentsParamsDeletedAtNot2 defines parameters for GetPayments.
type GetPaymentsParamsDeletedAtNot2 = []string

// GetPaymentsParams_DeletedAt_Not defines parameters for GetPayments.
type GetPaymentsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetPaymentsPaymentProvidersParams defines parameters for GetPaymentsPaymentProviders.
type GetPaymentsPaymentProvidersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    struct {
		union json.RawMessage
	} `form:"id" json:"id"`

	// IsEnabled Filter by whether the payment provider is enabled.
	IsEnabled *bool                     `form:"is_enabled,omitempty" json:"is_enabled,omitempty"`
	And       *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or        *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetPaymentsPaymentProvidersParamsId0 defines parameters for GetPaymentsPaymentProviders.
type GetPaymentsPaymentProvidersParamsId0 = string

// GetPaymentsPaymentProvidersParamsId1 defines parameters for GetPaymentsPaymentProviders.
type GetPaymentsPaymentProvidersParamsId1 = []string

// GetPaymentsIdParams defines parameters for GetPaymentsId.
type GetPaymentsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPaymentsIdCaptureJSONBody defines parameters for PostPaymentsIdCapture.
type PostPaymentsIdCaptureJSONBody struct {
	// Amount The amount to capture.
	Amount *float32 `json:"amount,omitempty"`
}

// PostPaymentsIdCaptureParams defines parameters for PostPaymentsIdCapture.
type PostPaymentsIdCaptureParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPaymentsIdRefundJSONBody defines parameters for PostPaymentsIdRefund.
type PostPaymentsIdRefundJSONBody struct {
	// Amount The amount to refund.
	Amount *float32 `json:"amount,omitempty"`

	// Note A note to attach to the refund.
	Note *string `json:"note,omitempty"`

	// RefundReasonId The ID of a refund reason.
	RefundReasonId *string `json:"refund_reason_id,omitempty"`
}

// PostPaymentsIdRefundParams defines parameters for PostPaymentsIdRefund.
type PostPaymentsIdRefundParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPriceListsParams defines parameters for GetPriceLists.
type GetPriceListsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the price list's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// StartsAt Filter by a price list's start date.
	StartsAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                        `json:"$contains,omitempty"`
		Eq       *GetPriceListsParams_StartsAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                         `json:"$nin,omitempty"`
		Not *GetPriceListsParams_StartsAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"starts_at,omitempty" json:"starts_at,omitempty"`

	// EndsAt Filter by the price list's end date.
	EndsAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetPriceListsParams_EndsAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetPriceListsParams_EndsAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"ends_at,omitempty" json:"ends_at,omitempty"`

	// Status Filter by the price list's status.
	Status *[]GetPriceListsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// RulesCount Filter by the price list's rules count.
	RulesCount *[]float32 `form:"rules_count,omitempty" json:"rules_count,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetPriceListsParamsId0 defines parameters for GetPriceLists.
type GetPriceListsParamsId0 = string

// GetPriceListsParamsId1 defines parameters for GetPriceLists.
type GetPriceListsParamsId1 = []string

// GetPriceListsParamsStartsAtEq0 defines parameters for GetPriceLists.
type GetPriceListsParamsStartsAtEq0 = string

// GetPriceListsParamsStartsAtEq1 defines parameters for GetPriceLists.
type GetPriceListsParamsStartsAtEq1 = []string

// GetPriceListsParams_StartsAt_Eq defines parameters for GetPriceLists.
type GetPriceListsParams_StartsAt_Eq struct {
	union json.RawMessage
}

// GetPriceListsParamsStartsAtNot0 defines parameters for GetPriceLists.
type GetPriceListsParamsStartsAtNot0 = string

// GetPriceListsParamsStartsAtNot1 defines parameters for GetPriceLists.
type GetPriceListsParamsStartsAtNot1 = map[string]interface{}

// GetPriceListsParamsStartsAtNot2 defines parameters for GetPriceLists.
type GetPriceListsParamsStartsAtNot2 = []string

// GetPriceListsParams_StartsAt_Not defines parameters for GetPriceLists.
type GetPriceListsParams_StartsAt_Not struct {
	union json.RawMessage
}

// GetPriceListsParamsEndsAtEq0 defines parameters for GetPriceLists.
type GetPriceListsParamsEndsAtEq0 = string

// GetPriceListsParamsEndsAtEq1 defines parameters for GetPriceLists.
type GetPriceListsParamsEndsAtEq1 = []string

// GetPriceListsParams_EndsAt_Eq defines parameters for GetPriceLists.
type GetPriceListsParams_EndsAt_Eq struct {
	union json.RawMessage
}

// GetPriceListsParamsEndsAtNot0 defines parameters for GetPriceLists.
type GetPriceListsParamsEndsAtNot0 = string

// GetPriceListsParamsEndsAtNot1 defines parameters for GetPriceLists.
type GetPriceListsParamsEndsAtNot1 = map[string]interface{}

// GetPriceListsParamsEndsAtNot2 defines parameters for GetPriceLists.
type GetPriceListsParamsEndsAtNot2 = []string

// GetPriceListsParams_EndsAt_Not defines parameters for GetPriceLists.
type GetPriceListsParams_EndsAt_Not struct {
	union json.RawMessage
}

// GetPriceListsParamsStatus defines parameters for GetPriceLists.
type GetPriceListsParamsStatus string

// PostPriceListsParams defines parameters for PostPriceLists.
type PostPriceListsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPriceListsIdParams defines parameters for GetPriceListsId.
type GetPriceListsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPriceListsIdParams defines parameters for PostPriceListsId.
type PostPriceListsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPriceListsIdPricesBatchJSONBody defines parameters for PostPriceListsIdPricesBatch.
type PostPriceListsIdPricesBatchJSONBody struct {
	// Create The prices to create.
	Create *[]struct {
		// Amount The price's amount.
		Amount float32 `json:"amount"`

		// CurrencyCode The price's currency code.
		CurrencyCode string `json:"currency_code"`

		// MaxQuantity The maximum quantity that must be available of the associated variant in the cart for this price list to apply.
		MaxQuantity *float32 `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity that must be available of the associated variant in the cart for this price to apply.
		MinQuantity *float32 `json:"min_quantity,omitempty"`

		// Rules Key-value pair rules to apply on the price.
		Rules *map[string]interface{} `json:"rules,omitempty"`

		// VariantId The ID of the variant this price is for.
		VariantId string `json:"variant_id"`
	} `json:"create,omitempty"`

	// Delete The prices to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The prices to update.
	Update *[]struct {
		// Amount The price's amount.
		Amount *float32 `json:"amount,omitempty"`

		// CurrencyCode The price's currency code.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// Id The price's ID.
		Id string `json:"id"`

		// MaxQuantity The maximum quantity that must be available of the associated variant in the cart for this price list to apply.
		MaxQuantity *float32 `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity that must be available of the associated variant in the cart for this price to apply.
		MinQuantity *float32 `json:"min_quantity,omitempty"`

		// Rules Key-value pair rules to apply on the price.
		Rules *map[string]interface{} `json:"rules,omitempty"`

		// VariantId The ID of the variant this price is for.
		VariantId string `json:"variant_id"`
	} `json:"update,omitempty"`
}

// PostPriceListsIdProductsParams defines parameters for PostPriceListsIdProducts.
type PostPriceListsIdProductsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPricePreferencesParams defines parameters for GetPricePreferences.
type GetPricePreferencesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Attribute *struct {
		union json.RawMessage
	} `form:"attribute,omitempty" json:"attribute,omitempty"`
	Value *struct {
		union json.RawMessage
	} `form:"value,omitempty" json:"value,omitempty"`

	// Q Search term to apply on the price preference's searchable properties.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetPricePreferencesParamsId0 defines parameters for GetPricePreferences.
type GetPricePreferencesParamsId0 = string

// GetPricePreferencesParamsId1 defines parameters for GetPricePreferences.
type GetPricePreferencesParamsId1 = []string

// GetPricePreferencesParamsAttribute0 defines parameters for GetPricePreferences.
type GetPricePreferencesParamsAttribute0 = string

// GetPricePreferencesParamsAttribute1 defines parameters for GetPricePreferences.
type GetPricePreferencesParamsAttribute1 = []string

// GetPricePreferencesParamsValue0 defines parameters for GetPricePreferences.
type GetPricePreferencesParamsValue0 = string

// GetPricePreferencesParamsValue1 defines parameters for GetPricePreferences.
type GetPricePreferencesParamsValue1 = []string

// PostPricePreferencesParams defines parameters for PostPricePreferences.
type PostPricePreferencesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPricePreferencesIdParams defines parameters for GetPricePreferencesId.
type GetPricePreferencesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPricePreferencesIdParams defines parameters for PostPricePreferencesId.
type PostPricePreferencesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductCategoriesParams defines parameters for GetProductCategories.
type GetProductCategoriesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter on the product category's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Description *struct {
		union json.RawMessage
	} `form:"description,omitempty" json:"description,omitempty"`
	Handle *struct {
		union json.RawMessage
	} `form:"handle,omitempty" json:"handle,omitempty"`
	ParentCategoryId *struct {
		union json.RawMessage
	} `form:"parent_category_id,omitempty" json:"parent_category_id,omitempty"`

	// IncludeAncestorsTree Whether to include the parent category of each category. If enabled, the parent category is set in the `parent_category` property of each category object.
	IncludeAncestorsTree *bool `form:"include_ancestors_tree,omitempty" json:"include_ancestors_tree,omitempty"`

	// IncludeDescendantsTree Whether to include the child categories of each category. If enabled, the child categories are added to the `category_children` property of each category object.
	IncludeDescendantsTree *bool `form:"include_descendants_tree,omitempty" json:"include_descendants_tree,omitempty"`

	// IsInternal Filter by whether the category is internal.
	IsInternal *bool `form:"is_internal,omitempty" json:"is_internal,omitempty"`

	// IsActive Filter by whether the category is active.
	IsActive *bool `form:"is_active,omitempty" json:"is_active,omitempty"`

	// CreatedAt Filter by the category's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                `json:"$contains,omitempty"`
		Eq       *GetProductCategoriesParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                 `json:"$nin,omitempty"`
		Not *GetProductCategoriesParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the category's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                `json:"$contains,omitempty"`
		Eq       *GetProductCategoriesParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                 `json:"$nin,omitempty"`
		Not *GetProductCategoriesParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the category's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                `json:"$contains,omitempty"`
		Eq       *GetProductCategoriesParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                 `json:"$nin,omitempty"`
		Not *GetProductCategoriesParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And  *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or   *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
	Name *struct {
		union json.RawMessage
	} `form:"name,omitempty" json:"name,omitempty"`
}

// GetProductCategoriesParamsId0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsId0 = string

// GetProductCategoriesParamsId1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsId1 = []string

// GetProductCategoriesParamsDescription0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDescription0 = string

// GetProductCategoriesParamsDescription1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDescription1 = []string

// GetProductCategoriesParamsHandle0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsHandle0 = string

// GetProductCategoriesParamsHandle1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsHandle1 = []string

// GetProductCategoriesParamsParentCategoryId0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsParentCategoryId0 = string

// GetProductCategoriesParamsParentCategoryId1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsParentCategoryId1 = []string

// GetProductCategoriesParamsCreatedAtEq0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsCreatedAtEq0 = string

// GetProductCategoriesParamsCreatedAtEq1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsCreatedAtEq1 = []string

// GetProductCategoriesParams_CreatedAt_Eq defines parameters for GetProductCategories.
type GetProductCategoriesParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductCategoriesParamsCreatedAtNot0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsCreatedAtNot0 = string

// GetProductCategoriesParamsCreatedAtNot1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsCreatedAtNot1 = map[string]interface{}

// GetProductCategoriesParamsCreatedAtNot2 defines parameters for GetProductCategories.
type GetProductCategoriesParamsCreatedAtNot2 = []string

// GetProductCategoriesParams_CreatedAt_Not defines parameters for GetProductCategories.
type GetProductCategoriesParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductCategoriesParamsUpdatedAtEq0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsUpdatedAtEq0 = string

// GetProductCategoriesParamsUpdatedAtEq1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsUpdatedAtEq1 = []string

// GetProductCategoriesParams_UpdatedAt_Eq defines parameters for GetProductCategories.
type GetProductCategoriesParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductCategoriesParamsUpdatedAtNot0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsUpdatedAtNot0 = string

// GetProductCategoriesParamsUpdatedAtNot1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsUpdatedAtNot1 = map[string]interface{}

// GetProductCategoriesParamsUpdatedAtNot2 defines parameters for GetProductCategories.
type GetProductCategoriesParamsUpdatedAtNot2 = []string

// GetProductCategoriesParams_UpdatedAt_Not defines parameters for GetProductCategories.
type GetProductCategoriesParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetProductCategoriesParamsDeletedAtEq0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDeletedAtEq0 = string

// GetProductCategoriesParamsDeletedAtEq1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDeletedAtEq1 = []string

// GetProductCategoriesParams_DeletedAt_Eq defines parameters for GetProductCategories.
type GetProductCategoriesParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductCategoriesParamsDeletedAtNot0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDeletedAtNot0 = string

// GetProductCategoriesParamsDeletedAtNot1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDeletedAtNot1 = map[string]interface{}

// GetProductCategoriesParamsDeletedAtNot2 defines parameters for GetProductCategories.
type GetProductCategoriesParamsDeletedAtNot2 = []string

// GetProductCategoriesParams_DeletedAt_Not defines parameters for GetProductCategories.
type GetProductCategoriesParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetProductCategoriesParamsName0 defines parameters for GetProductCategories.
type GetProductCategoriesParamsName0 = string

// GetProductCategoriesParamsName1 defines parameters for GetProductCategories.
type GetProductCategoriesParamsName1 = []string

// PostProductCategoriesParams defines parameters for PostProductCategories.
type PostProductCategoriesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductCategoriesIdParams defines parameters for GetProductCategoriesId.
type GetProductCategoriesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// IncludeAncestorsTree Whether to retrieve the category's parent. When enabled, the parent category is set in the `parent_category` property.
	IncludeAncestorsTree *bool `form:"include_ancestors_tree,omitempty" json:"include_ancestors_tree,omitempty"`

	// IncludeDescendantsTree Whether to retrieve a list of child categories. When enabled, the parent categories are added to the `category_children` property.
	IncludeDescendantsTree *bool `form:"include_descendants_tree,omitempty" json:"include_descendants_tree,omitempty"`
}

// PostProductCategoriesIdJSONBody defines parameters for PostProductCategoriesId.
type PostProductCategoriesIdJSONBody struct {
	// Description The product category's description.
	Description *string `json:"description,omitempty"`

	// Handle The product category's handle. Must be a unique value.
	Handle *string `json:"handle,omitempty"`

	// IsActive Whether the product category is active.
	IsActive *bool `json:"is_active,omitempty"`

	// IsInternal Whether the product category is only used for internal purposes and shouldn't be shown the customer.
	IsInternal *bool `json:"is_internal,omitempty"`

	// Metadata The product category's metadata. Can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The product category's name.
	Name *string `json:"name,omitempty"`

	// ParentCategoryId The ID of a parent category.
	ParentCategoryId *string `json:"parent_category_id,omitempty"`

	// Rank The product category's rank among other categories.
	Rank *float32 `json:"rank,omitempty"`
}

// PostProductCategoriesIdParams defines parameters for PostProductCategoriesId.
type PostProductCategoriesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductCategoriesIdProductsJSONBody defines parameters for PostProductCategoriesIdProducts.
type PostProductCategoriesIdProductsJSONBody struct {
	// Add The products to add.
	Add *[]string `json:"add,omitempty"`

	// Remove The product to remove.
	Remove *[]string `json:"remove,omitempty"`
}

// PostProductCategoriesIdProductsParams defines parameters for PostProductCategoriesIdProducts.
type PostProductCategoriesIdProductsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductTagsParams defines parameters for GetProductTags.
type GetProductTagsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the product tag's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Value *struct {
		union json.RawMessage
	} `form:"value,omitempty" json:"value,omitempty"`

	// CreatedAt Filter by the tag's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetProductTagsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetProductTagsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the tag's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetProductTagsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetProductTagsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the tag's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                          `json:"$contains,omitempty"`
		Eq       *GetProductTagsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                           `json:"$nin,omitempty"`
		Not *GetProductTagsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetProductTagsParamsId0 defines parameters for GetProductTags.
type GetProductTagsParamsId0 = string

// GetProductTagsParamsId1 defines parameters for GetProductTags.
type GetProductTagsParamsId1 = []string

// GetProductTagsParamsValue0 defines parameters for GetProductTags.
type GetProductTagsParamsValue0 = string

// GetProductTagsParamsValue1 defines parameters for GetProductTags.
type GetProductTagsParamsValue1 = []string

// GetProductTagsParamsCreatedAtEq0 defines parameters for GetProductTags.
type GetProductTagsParamsCreatedAtEq0 = string

// GetProductTagsParamsCreatedAtEq1 defines parameters for GetProductTags.
type GetProductTagsParamsCreatedAtEq1 = []string

// GetProductTagsParams_CreatedAt_Eq defines parameters for GetProductTags.
type GetProductTagsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductTagsParamsCreatedAtNot0 defines parameters for GetProductTags.
type GetProductTagsParamsCreatedAtNot0 = string

// GetProductTagsParamsCreatedAtNot1 defines parameters for GetProductTags.
type GetProductTagsParamsCreatedAtNot1 = map[string]interface{}

// GetProductTagsParamsCreatedAtNot2 defines parameters for GetProductTags.
type GetProductTagsParamsCreatedAtNot2 = []string

// GetProductTagsParams_CreatedAt_Not defines parameters for GetProductTags.
type GetProductTagsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductTagsParamsUpdatedAtEq0 defines parameters for GetProductTags.
type GetProductTagsParamsUpdatedAtEq0 = string

// GetProductTagsParamsUpdatedAtEq1 defines parameters for GetProductTags.
type GetProductTagsParamsUpdatedAtEq1 = []string

// GetProductTagsParams_UpdatedAt_Eq defines parameters for GetProductTags.
type GetProductTagsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductTagsParamsUpdatedAtNot0 defines parameters for GetProductTags.
type GetProductTagsParamsUpdatedAtNot0 = string

// GetProductTagsParamsUpdatedAtNot1 defines parameters for GetProductTags.
type GetProductTagsParamsUpdatedAtNot1 = map[string]interface{}

// GetProductTagsParamsUpdatedAtNot2 defines parameters for GetProductTags.
type GetProductTagsParamsUpdatedAtNot2 = []string

// GetProductTagsParams_UpdatedAt_Not defines parameters for GetProductTags.
type GetProductTagsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetProductTagsParamsDeletedAtEq0 defines parameters for GetProductTags.
type GetProductTagsParamsDeletedAtEq0 = string

// GetProductTagsParamsDeletedAtEq1 defines parameters for GetProductTags.
type GetProductTagsParamsDeletedAtEq1 = []string

// GetProductTagsParams_DeletedAt_Eq defines parameters for GetProductTags.
type GetProductTagsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductTagsParamsDeletedAtNot0 defines parameters for GetProductTags.
type GetProductTagsParamsDeletedAtNot0 = string

// GetProductTagsParamsDeletedAtNot1 defines parameters for GetProductTags.
type GetProductTagsParamsDeletedAtNot1 = map[string]interface{}

// GetProductTagsParamsDeletedAtNot2 defines parameters for GetProductTags.
type GetProductTagsParamsDeletedAtNot2 = []string

// GetProductTagsParams_DeletedAt_Not defines parameters for GetProductTags.
type GetProductTagsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostProductTagsParams defines parameters for PostProductTags.
type PostProductTagsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductTagsIdParams defines parameters for GetProductTagsId.
type GetProductTagsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductTagsIdJSONBody defines parameters for PostProductTagsId.
type PostProductTagsIdJSONBody struct {
	// Metadata The product tag's metadata. Can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value The product tag's value.
	Value *string `json:"value,omitempty"`
}

// PostProductTagsIdParams defines parameters for PostProductTagsId.
type PostProductTagsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductTypesParams defines parameters for GetProductTypes.
type GetProductTypesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the product type's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Value *struct {
		union json.RawMessage
	} `form:"value,omitempty" json:"value,omitempty"`

	// CreatedAt Filter by the type's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                           `json:"$contains,omitempty"`
		Eq       *GetProductTypesParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                            `json:"$nin,omitempty"`
		Not *GetProductTypesParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the type's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                           `json:"$contains,omitempty"`
		Eq       *GetProductTypesParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                            `json:"$nin,omitempty"`
		Not *GetProductTypesParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the type's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                           `json:"$contains,omitempty"`
		Eq       *GetProductTypesParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                            `json:"$nin,omitempty"`
		Not *GetProductTypesParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetProductTypesParamsId0 defines parameters for GetProductTypes.
type GetProductTypesParamsId0 = string

// GetProductTypesParamsId1 defines parameters for GetProductTypes.
type GetProductTypesParamsId1 = []string

// GetProductTypesParamsValue0 defines parameters for GetProductTypes.
type GetProductTypesParamsValue0 = string

// GetProductTypesParamsValue1 defines parameters for GetProductTypes.
type GetProductTypesParamsValue1 = []string

// GetProductTypesParamsCreatedAtEq0 defines parameters for GetProductTypes.
type GetProductTypesParamsCreatedAtEq0 = string

// GetProductTypesParamsCreatedAtEq1 defines parameters for GetProductTypes.
type GetProductTypesParamsCreatedAtEq1 = []string

// GetProductTypesParams_CreatedAt_Eq defines parameters for GetProductTypes.
type GetProductTypesParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductTypesParamsCreatedAtNot0 defines parameters for GetProductTypes.
type GetProductTypesParamsCreatedAtNot0 = string

// GetProductTypesParamsCreatedAtNot1 defines parameters for GetProductTypes.
type GetProductTypesParamsCreatedAtNot1 = map[string]interface{}

// GetProductTypesParamsCreatedAtNot2 defines parameters for GetProductTypes.
type GetProductTypesParamsCreatedAtNot2 = []string

// GetProductTypesParams_CreatedAt_Not defines parameters for GetProductTypes.
type GetProductTypesParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductTypesParamsUpdatedAtEq0 defines parameters for GetProductTypes.
type GetProductTypesParamsUpdatedAtEq0 = string

// GetProductTypesParamsUpdatedAtEq1 defines parameters for GetProductTypes.
type GetProductTypesParamsUpdatedAtEq1 = []string

// GetProductTypesParams_UpdatedAt_Eq defines parameters for GetProductTypes.
type GetProductTypesParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductTypesParamsUpdatedAtNot0 defines parameters for GetProductTypes.
type GetProductTypesParamsUpdatedAtNot0 = string

// GetProductTypesParamsUpdatedAtNot1 defines parameters for GetProductTypes.
type GetProductTypesParamsUpdatedAtNot1 = map[string]interface{}

// GetProductTypesParamsUpdatedAtNot2 defines parameters for GetProductTypes.
type GetProductTypesParamsUpdatedAtNot2 = []string

// GetProductTypesParams_UpdatedAt_Not defines parameters for GetProductTypes.
type GetProductTypesParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetProductTypesParamsDeletedAtEq0 defines parameters for GetProductTypes.
type GetProductTypesParamsDeletedAtEq0 = string

// GetProductTypesParamsDeletedAtEq1 defines parameters for GetProductTypes.
type GetProductTypesParamsDeletedAtEq1 = []string

// GetProductTypesParams_DeletedAt_Eq defines parameters for GetProductTypes.
type GetProductTypesParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductTypesParamsDeletedAtNot0 defines parameters for GetProductTypes.
type GetProductTypesParamsDeletedAtNot0 = string

// GetProductTypesParamsDeletedAtNot1 defines parameters for GetProductTypes.
type GetProductTypesParamsDeletedAtNot1 = map[string]interface{}

// GetProductTypesParamsDeletedAtNot2 defines parameters for GetProductTypes.
type GetProductTypesParamsDeletedAtNot2 = []string

// GetProductTypesParams_DeletedAt_Not defines parameters for GetProductTypes.
type GetProductTypesParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostProductTypesParams defines parameters for PostProductTypes.
type PostProductTypesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductTypesIdParams defines parameters for GetProductTypesId.
type GetProductTypesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductTypesIdJSONBody defines parameters for PostProductTypesId.
type PostProductTypesIdJSONBody struct {
	// Metadata The product type's metadata. Can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value The product type's value.
	Value *string `json:"value,omitempty"`
}

// PostProductTypesIdParams defines parameters for PostProductTypesId.
type PostProductTypesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductVariantsParams defines parameters for GetProductVariants.
type GetProductVariantsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the product variant's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// ManageInventory Filter by whether a variant's `manage_inventory` is enabled.
	ManageInventory *bool `form:"manage_inventory,omitempty" json:"manage_inventory,omitempty"`

	// AllowBackorder Filter by whether backorder is allowed for a variant.
	AllowBackorder *bool `form:"allow_backorder,omitempty" json:"allow_backorder,omitempty"`

	// CreatedAt Filter by the product variant's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                              `json:"$contains,omitempty"`
		Eq       *GetProductVariantsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                               `json:"$nin,omitempty"`
		Not *GetProductVariantsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the product variant's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                              `json:"$contains,omitempty"`
		Eq       *GetProductVariantsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                               `json:"$nin,omitempty"`
		Not *GetProductVariantsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the product variant's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                              `json:"$contains,omitempty"`
		Eq       *GetProductVariantsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                               `json:"$nin,omitempty"`
		Not *GetProductVariantsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetProductVariantsParamsId0 defines parameters for GetProductVariants.
type GetProductVariantsParamsId0 = string

// GetProductVariantsParamsId1 defines parameters for GetProductVariants.
type GetProductVariantsParamsId1 = []string

// GetProductVariantsParamsCreatedAtEq0 defines parameters for GetProductVariants.
type GetProductVariantsParamsCreatedAtEq0 = string

// GetProductVariantsParamsCreatedAtEq1 defines parameters for GetProductVariants.
type GetProductVariantsParamsCreatedAtEq1 = []string

// GetProductVariantsParams_CreatedAt_Eq defines parameters for GetProductVariants.
type GetProductVariantsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductVariantsParamsCreatedAtNot0 defines parameters for GetProductVariants.
type GetProductVariantsParamsCreatedAtNot0 = string

// GetProductVariantsParamsCreatedAtNot1 defines parameters for GetProductVariants.
type GetProductVariantsParamsCreatedAtNot1 = map[string]interface{}

// GetProductVariantsParamsCreatedAtNot2 defines parameters for GetProductVariants.
type GetProductVariantsParamsCreatedAtNot2 = []string

// GetProductVariantsParams_CreatedAt_Not defines parameters for GetProductVariants.
type GetProductVariantsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductVariantsParamsUpdatedAtEq0 defines parameters for GetProductVariants.
type GetProductVariantsParamsUpdatedAtEq0 = string

// GetProductVariantsParamsUpdatedAtEq1 defines parameters for GetProductVariants.
type GetProductVariantsParamsUpdatedAtEq1 = []string

// GetProductVariantsParams_UpdatedAt_Eq defines parameters for GetProductVariants.
type GetProductVariantsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductVariantsParamsUpdatedAtNot0 defines parameters for GetProductVariants.
type GetProductVariantsParamsUpdatedAtNot0 = string

// GetProductVariantsParamsUpdatedAtNot1 defines parameters for GetProductVariants.
type GetProductVariantsParamsUpdatedAtNot1 = map[string]interface{}

// GetProductVariantsParamsUpdatedAtNot2 defines parameters for GetProductVariants.
type GetProductVariantsParamsUpdatedAtNot2 = []string

// GetProductVariantsParams_UpdatedAt_Not defines parameters for GetProductVariants.
type GetProductVariantsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetProductVariantsParamsDeletedAtEq0 defines parameters for GetProductVariants.
type GetProductVariantsParamsDeletedAtEq0 = string

// GetProductVariantsParamsDeletedAtEq1 defines parameters for GetProductVariants.
type GetProductVariantsParamsDeletedAtEq1 = []string

// GetProductVariantsParams_DeletedAt_Eq defines parameters for GetProductVariants.
type GetProductVariantsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductVariantsParamsDeletedAtNot0 defines parameters for GetProductVariants.
type GetProductVariantsParamsDeletedAtNot0 = string

// GetProductVariantsParamsDeletedAtNot1 defines parameters for GetProductVariants.
type GetProductVariantsParamsDeletedAtNot1 = map[string]interface{}

// GetProductVariantsParamsDeletedAtNot2 defines parameters for GetProductVariants.
type GetProductVariantsParamsDeletedAtNot2 = []string

// GetProductVariantsParams_DeletedAt_Not defines parameters for GetProductVariants.
type GetProductVariantsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetProductsParams defines parameters for GetProducts.
type GetProductsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order       *string `form:"order,omitempty" json:"order,omitempty"`
	PriceListId *struct {
		union json.RawMessage
	} `form:"price_list_id,omitempty" json:"price_list_id,omitempty"`

	// Q Search term to filter a product's searchable properties.
	Q      *string `form:"q,omitempty" json:"q,omitempty"`
	Status *struct {
		union json.RawMessage
	} `form:"status,omitempty" json:"status,omitempty"`
	SalesChannelId *struct {
		union json.RawMessage
	} `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`
	Title *struct {
		union json.RawMessage
	} `form:"title,omitempty" json:"title,omitempty"`
	Handle *struct {
		union json.RawMessage
	} `form:"handle,omitempty" json:"handle,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// IsGiftcard Filter by whether a product is a gift card.
	IsGiftcard *bool `form:"is_giftcard,omitempty" json:"is_giftcard,omitempty"`

	// Tags Filter by associated tags to retrieve their products.
	Tags *struct {
		// Value Filter by tag values.
		Value *[]string `json:"value,omitempty"`
	} `form:"tags,omitempty" json:"tags,omitempty"`
	TypeId *struct {
		union json.RawMessage
	} `form:"type_id,omitempty" json:"type_id,omitempty"`
	CategoryId *struct {
		union json.RawMessage
	} `form:"category_id,omitempty" json:"category_id,omitempty"`

	// CreatedAt Filter by a product's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetProductsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetProductsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a product's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetProductsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetProductsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a product's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetProductsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetProductsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or           *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
	CollectionId *struct {
		union json.RawMessage
	} `form:"collection_id,omitempty" json:"collection_id,omitempty"`

	// Variants Filter the retrieved products' variants.
	Variants *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// AllowBackorder Filter by whether the variant can be ordered even if it's out of stock.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// CreatedAt Filter by the variant's creation date.
		CreatedAt *struct {
			// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
			And *[]map[string]interface{} `json:"$and,omitempty"`

			// Contained Filter arrays that contain all values of this parameter.
			Contained *[]string `json:"$contained,omitempty"`

			// Contains Filter arrays that contain some of the values of this parameter.
			Contains *[]string                                `json:"$contains,omitempty"`
			Eq       *GetProductsParams_Variants_CreatedAt_Eq `json:"$eq,omitempty"`

			// Exists Filter by whether a value for this parameter exists (not `null`).
			Exists *bool `json:"$exists,omitempty"`

			// Fulltext Filter to apply on full-text properties.
			Fulltext *string `json:"$fulltext,omitempty"`

			// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
			Gt *string `json:"$gt,omitempty"`

			// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
			Gte *string `json:"$gte,omitempty"`

			// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
			Ilike *string `json:"$ilike,omitempty"`

			// In Filter by values in this array.
			In *[]string `json:"$in,omitempty"`

			// Like Apply a `like` filter. Useful for strings only.
			Like *string `json:"$like,omitempty"`

			// Lt Filter by values less than this parameter. Useful for numbers and dates only.
			Lt *string `json:"$lt,omitempty"`

			// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
			Lte *string `json:"$lte,omitempty"`

			// Ne Filter by values not equal to this parameter.
			Ne *string `json:"$ne,omitempty"`

			// Nin Filter by values not in this array.
			Nin *[]string                                 `json:"$nin,omitempty"`
			Not *GetProductsParams_Variants_CreatedAt_Not `json:"$not,omitempty"`

			// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
			Or *[]map[string]interface{} `json:"$or,omitempty"`

			// Overlap Filter arrays that have overlapping values with this parameter.
			Overlap *[]string `json:"$overlap,omitempty"`

			// Re Apply a regex filter. Useful for strings only.
			Re *string `json:"$re,omitempty"`
		} `json:"created_at,omitempty"`

		// DeletedAt The variant's deleted at.
		DeletedAt *struct {
			// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
			And *[]map[string]interface{} `json:"$and,omitempty"`

			// Contained Filter arrays that contain all values of this parameter.
			Contained *[]string `json:"$contained,omitempty"`

			// Contains Filter arrays that contain some of the values of this parameter.
			Contains *[]string                                `json:"$contains,omitempty"`
			Eq       *GetProductsParams_Variants_DeletedAt_Eq `json:"$eq,omitempty"`

			// Exists Filter by whether a value for this parameter exists (not `null`).
			Exists *bool `json:"$exists,omitempty"`

			// Fulltext Filter to apply on full-text properties.
			Fulltext *string `json:"$fulltext,omitempty"`

			// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
			Gt *string `json:"$gt,omitempty"`

			// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
			Gte *string `json:"$gte,omitempty"`

			// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
			Ilike *string `json:"$ilike,omitempty"`

			// In Filter by values in this array.
			In *[]string `json:"$in,omitempty"`

			// Like Apply a `like` filter. Useful for strings only.
			Like *string `json:"$like,omitempty"`

			// Lt Filter by values less than this parameter. Useful for numbers and dates only.
			Lt *string `json:"$lt,omitempty"`

			// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
			Lte *string `json:"$lte,omitempty"`

			// Ne Filter by values not equal to this parameter.
			Ne *string `json:"$ne,omitempty"`

			// Nin Filter by values not in this array.
			Nin *[]string                                 `json:"$nin,omitempty"`
			Not *GetProductsParams_Variants_DeletedAt_Not `json:"$not,omitempty"`

			// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
			Or *[]map[string]interface{} `json:"$or,omitempty"`

			// Overlap Filter arrays that have overlapping values with this parameter.
			Overlap *[]string `json:"$overlap,omitempty"`

			// Re Apply a regex filter. Useful for strings only.
			Re *string `json:"$re,omitempty"`
		} `json:"deleted_at,omitempty"`

		// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
		Fields *string                        `json:"fields,omitempty"`
		Id     *GetProductsParams_Variants_Id `json:"id,omitempty"`

		// Limit Limit the number of items returned in the list.
		Limit *float32 `json:"limit,omitempty"`

		// ManageInventory Filter by whether the Medusa application manages the variant's inventory.
		ManageInventory *bool `json:"manage_inventory,omitempty"`

		// Offset The number of items to skip when retrieving a list.
		Offset *float32 `json:"offset,omitempty"`

		// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
		Order *string `json:"order,omitempty"`

		// Q Search term to apply on the variant's searchable properties.
		Q *string `json:"q,omitempty"`

		// UpdatedAt The variant's updated at.
		UpdatedAt *struct {
			// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
			And *[]map[string]interface{} `json:"$and,omitempty"`

			// Contained Filter arrays that contain all values of this parameter.
			Contained *[]string `json:"$contained,omitempty"`

			// Contains Filter arrays that contain some of the values of this parameter.
			Contains *[]string                                `json:"$contains,omitempty"`
			Eq       *GetProductsParams_Variants_UpdatedAt_Eq `json:"$eq,omitempty"`

			// Exists Filter by whether a value for this parameter exists (not `null`).
			Exists *bool `json:"$exists,omitempty"`

			// Fulltext Filter to apply on full-text properties.
			Fulltext *string `json:"$fulltext,omitempty"`

			// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
			Gt *string `json:"$gt,omitempty"`

			// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
			Gte *string `json:"$gte,omitempty"`

			// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
			Ilike *string `json:"$ilike,omitempty"`

			// In Filter by values in this array.
			In *[]string `json:"$in,omitempty"`

			// Like Apply a `like` filter. Useful for strings only.
			Like *string `json:"$like,omitempty"`

			// Lt Filter by values less than this parameter. Useful for numbers and dates only.
			Lt *string `json:"$lt,omitempty"`

			// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
			Lte *string `json:"$lte,omitempty"`

			// Ne Filter by values not equal to this parameter.
			Ne *string `json:"$ne,omitempty"`

			// Nin Filter by values not in this array.
			Nin *[]string                                 `json:"$nin,omitempty"`
			Not *GetProductsParams_Variants_UpdatedAt_Not `json:"$not,omitempty"`

			// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
			Or *[]map[string]interface{} `json:"$or,omitempty"`

			// Overlap Filter arrays that have overlapping values with this parameter.
			Overlap *[]string `json:"$overlap,omitempty"`

			// Re Apply a regex filter. Useful for strings only.
			Re *string `json:"$re,omitempty"`
		} `json:"updated_at,omitempty"`
	} `form:"variants,omitempty" json:"variants,omitempty"`
}

// GetProductsParamsPriceListId0 defines parameters for GetProducts.
type GetProductsParamsPriceListId0 = string

// GetProductsParamsPriceListId1 defines parameters for GetProducts.
type GetProductsParamsPriceListId1 = []string

// GetProductsParamsStatus0 defines parameters for GetProducts.
type GetProductsParamsStatus0 = string

// GetProductsParamsStatus1 defines parameters for GetProducts.
type GetProductsParamsStatus1 = []GetProductsParamsStatus1

// GetProductsParamsStatus1 defines parameters for GetProducts.
type GetProductsParamsStatus1 string

// GetProductsParamsSalesChannelId0 defines parameters for GetProducts.
type GetProductsParamsSalesChannelId0 = string

// GetProductsParamsSalesChannelId1 defines parameters for GetProducts.
type GetProductsParamsSalesChannelId1 = []string

// GetProductsParamsTitle0 defines parameters for GetProducts.
type GetProductsParamsTitle0 = string

// GetProductsParamsTitle1 defines parameters for GetProducts.
type GetProductsParamsTitle1 = []string

// GetProductsParamsHandle0 defines parameters for GetProducts.
type GetProductsParamsHandle0 = string

// GetProductsParamsHandle1 defines parameters for GetProducts.
type GetProductsParamsHandle1 = []string

// GetProductsParamsId0 defines parameters for GetProducts.
type GetProductsParamsId0 = string

// GetProductsParamsId1 defines parameters for GetProducts.
type GetProductsParamsId1 = []string

// GetProductsParamsTypeId0 defines parameters for GetProducts.
type GetProductsParamsTypeId0 = string

// GetProductsParamsTypeId1 defines parameters for GetProducts.
type GetProductsParamsTypeId1 = []string

// GetProductsParamsCategoryId0 defines parameters for GetProducts.
type GetProductsParamsCategoryId0 = string

// GetProductsParamsCategoryId1 defines parameters for GetProducts.
type GetProductsParamsCategoryId1 = []string

// GetProductsParamsCreatedAtEq0 defines parameters for GetProducts.
type GetProductsParamsCreatedAtEq0 = string

// GetProductsParamsCreatedAtEq1 defines parameters for GetProducts.
type GetProductsParamsCreatedAtEq1 = []string

// GetProductsParams_CreatedAt_Eq defines parameters for GetProducts.
type GetProductsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductsParamsCreatedAtNot0 defines parameters for GetProducts.
type GetProductsParamsCreatedAtNot0 = string

// GetProductsParamsCreatedAtNot1 defines parameters for GetProducts.
type GetProductsParamsCreatedAtNot1 = map[string]interface{}

// GetProductsParamsCreatedAtNot2 defines parameters for GetProducts.
type GetProductsParamsCreatedAtNot2 = []string

// GetProductsParams_CreatedAt_Not defines parameters for GetProducts.
type GetProductsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductsParamsUpdatedAtEq0 defines parameters for GetProducts.
type GetProductsParamsUpdatedAtEq0 = string

// GetProductsParamsUpdatedAtEq1 defines parameters for GetProducts.
type GetProductsParamsUpdatedAtEq1 = []string

// GetProductsParams_UpdatedAt_Eq defines parameters for GetProducts.
type GetProductsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductsParamsUpdatedAtNot0 defines parameters for GetProducts.
type GetProductsParamsUpdatedAtNot0 = string

// GetProductsParamsUpdatedAtNot1 defines parameters for GetProducts.
type GetProductsParamsUpdatedAtNot1 = map[string]interface{}

// GetProductsParamsUpdatedAtNot2 defines parameters for GetProducts.
type GetProductsParamsUpdatedAtNot2 = []string

// GetProductsParams_UpdatedAt_Not defines parameters for GetProducts.
type GetProductsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetProductsParamsDeletedAtEq0 defines parameters for GetProducts.
type GetProductsParamsDeletedAtEq0 = string

// GetProductsParamsDeletedAtEq1 defines parameters for GetProducts.
type GetProductsParamsDeletedAtEq1 = []string

// GetProductsParams_DeletedAt_Eq defines parameters for GetProducts.
type GetProductsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductsParamsDeletedAtNot0 defines parameters for GetProducts.
type GetProductsParamsDeletedAtNot0 = string

// GetProductsParamsDeletedAtNot1 defines parameters for GetProducts.
type GetProductsParamsDeletedAtNot1 = map[string]interface{}

// GetProductsParamsDeletedAtNot2 defines parameters for GetProducts.
type GetProductsParamsDeletedAtNot2 = []string

// GetProductsParams_DeletedAt_Not defines parameters for GetProducts.
type GetProductsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetProductsParamsCollectionId0 defines parameters for GetProducts.
type GetProductsParamsCollectionId0 = string

// GetProductsParamsCollectionId1 defines parameters for GetProducts.
type GetProductsParamsCollectionId1 = []string

// GetProductsParamsVariantsCreatedAtEq0 defines parameters for GetProducts.
type GetProductsParamsVariantsCreatedAtEq0 = string

// GetProductsParamsVariantsCreatedAtEq1 defines parameters for GetProducts.
type GetProductsParamsVariantsCreatedAtEq1 = []string

// GetProductsParams_Variants_CreatedAt_Eq defines parameters for GetProducts.
type GetProductsParams_Variants_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductsParamsVariantsCreatedAtNot0 defines parameters for GetProducts.
type GetProductsParamsVariantsCreatedAtNot0 = string

// GetProductsParamsVariantsCreatedAtNot1 defines parameters for GetProducts.
type GetProductsParamsVariantsCreatedAtNot1 = map[string]interface{}

// GetProductsParamsVariantsCreatedAtNot2 defines parameters for GetProducts.
type GetProductsParamsVariantsCreatedAtNot2 = []string

// GetProductsParams_Variants_CreatedAt_Not defines parameters for GetProducts.
type GetProductsParams_Variants_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductsParamsVariantsDeletedAtEq0 defines parameters for GetProducts.
type GetProductsParamsVariantsDeletedAtEq0 = string

// GetProductsParamsVariantsDeletedAtEq1 defines parameters for GetProducts.
type GetProductsParamsVariantsDeletedAtEq1 = []string

// GetProductsParams_Variants_DeletedAt_Eq defines parameters for GetProducts.
type GetProductsParams_Variants_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductsParamsVariantsDeletedAtNot0 defines parameters for GetProducts.
type GetProductsParamsVariantsDeletedAtNot0 = string

// GetProductsParamsVariantsDeletedAtNot1 defines parameters for GetProducts.
type GetProductsParamsVariantsDeletedAtNot1 = map[string]interface{}

// GetProductsParamsVariantsDeletedAtNot2 defines parameters for GetProducts.
type GetProductsParamsVariantsDeletedAtNot2 = []string

// GetProductsParams_Variants_DeletedAt_Not defines parameters for GetProducts.
type GetProductsParams_Variants_DeletedAt_Not struct {
	union json.RawMessage
}

// GetProductsParamsVariantsId0 defines parameters for GetProducts.
type GetProductsParamsVariantsId0 = string

// GetProductsParamsVariantsId1 defines parameters for GetProducts.
type GetProductsParamsVariantsId1 = []string

// GetProductsParams_Variants_Id defines parameters for GetProducts.
type GetProductsParams_Variants_Id struct {
	union json.RawMessage
}

// GetProductsParamsVariantsUpdatedAtEq0 defines parameters for GetProducts.
type GetProductsParamsVariantsUpdatedAtEq0 = string

// GetProductsParamsVariantsUpdatedAtEq1 defines parameters for GetProducts.
type GetProductsParamsVariantsUpdatedAtEq1 = []string

// GetProductsParams_Variants_UpdatedAt_Eq defines parameters for GetProducts.
type GetProductsParams_Variants_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductsParamsVariantsUpdatedAtNot0 defines parameters for GetProducts.
type GetProductsParamsVariantsUpdatedAtNot0 = string

// GetProductsParamsVariantsUpdatedAtNot1 defines parameters for GetProducts.
type GetProductsParamsVariantsUpdatedAtNot1 = map[string]interface{}

// GetProductsParamsVariantsUpdatedAtNot2 defines parameters for GetProducts.
type GetProductsParamsVariantsUpdatedAtNot2 = []string

// GetProductsParams_Variants_UpdatedAt_Not defines parameters for GetProducts.
type GetProductsParams_Variants_UpdatedAt_Not struct {
	union json.RawMessage
}

// PostProductsJSONBody defines parameters for PostProducts.
type PostProductsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Categories The categories the product belongs to.
	Categories *[]struct {
		// Id The category's ID.
		Id string `json:"id"`
	} `json:"categories,omitempty"`

	// CollectionId The ID of the collection the product belongs to.
	CollectionId *string `json:"collection_id,omitempty"`

	// Description The product's description.
	Description *string `json:"description,omitempty"`

	// Discountable Whether the product is discountable.
	Discountable *bool `json:"discountable,omitempty"`

	// Handle The product's handle.
	Handle *string `json:"handle,omitempty"`

	// Height The product's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The product's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Images The product's images.
	Images *[]struct {
		// Url The image's URL.
		Url string `json:"url"`
	} `json:"images,omitempty"`

	// IsGiftcard Whether the product is a gift card.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// Length The product's length.
	Length *float32 `json:"length,omitempty"`

	// Material The product's material.
	Material *string `json:"material,omitempty"`

	// Metadata The product's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The product's options.
	Options *[]AdminCreateProductOption `json:"options,omitempty"`

	// OriginCountry The product's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// SalesChannels The sales channels the product is available in.
	SalesChannels *[]struct {
		// Id The sales channel's ID.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// Status The product's status.
	Status *PostProductsJSONBodyStatus `json:"status,omitempty"`

	// Subtitle The product's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags The product's tags.
	Tags *[]struct {
		// Id The tag's ID.
		Id string `json:"id"`
	} `json:"tags,omitempty"`

	// Thumbnail The URL of the product's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The product's title.
	Title string `json:"title"`

	// TypeId The ID of the type the product belongs to.
	TypeId *string `json:"type_id,omitempty"`

	// Variants The product's variants.
	Variants *[]AdminCreateProductVariant `json:"variants,omitempty"`

	// Weight The product's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The product's width.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsParams defines parameters for PostProducts.
type PostProductsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsJSONBodyStatus defines parameters for PostProducts.
type PostProductsJSONBodyStatus string

// PostProductsBatchParams defines parameters for PostProductsBatch.
type PostProductsBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsExportParams defines parameters for PostProductsExport.
type PostProductsExportParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductsIdParams defines parameters for GetProductsId.
type GetProductsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdJSONBody defines parameters for PostProductsId.
type PostProductsIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Categories The product's categories.
	Categories *[]struct {
		// Id The category's ID.
		Id string `json:"id"`
	} `json:"categories,omitempty"`

	// CollectionId The ID of the product's collection.
	CollectionId *string `json:"collection_id,omitempty"`

	// Description The product's description.
	Description *string `json:"description,omitempty"`

	// Discountable Whether discounts can be applied on the product.
	Discountable *bool `json:"discountable,omitempty"`

	// Handle The product's unique handle.
	Handle *string `json:"handle,omitempty"`

	// Height The product's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The product's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Images The product's images.
	Images *[]struct {
		// Url The image's URL.
		Url string `json:"url"`
	} `json:"images,omitempty"`

	// IsGiftcard Whether the product is a gift card.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// Length The product's length.
	Length *float32 `json:"length,omitempty"`

	// Material The product's material.
	Material *string `json:"material,omitempty"`

	// Metadata The product's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The product's options.
	Options *[]AdminUpdateProductOption `json:"options,omitempty"`

	// OriginCountry The product's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// SalesChannels The sales channels that the product is available in.
	SalesChannels *[]struct {
		// Id The sales channel's ID.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// Status The product's status.
	Status *PostProductsIdJSONBodyStatus `json:"status,omitempty"`

	// Subtitle The product's subtitle.
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags The product's tags.
	Tags *[]struct {
		// Id The tag's ID.
		Id string `json:"id"`
	} `json:"tags,omitempty"`

	// Thumbnail The product's thumbnail URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The product's title.
	Title *string `json:"title,omitempty"`

	// TypeId The ID of the product's type.
	TypeId *string `json:"type_id,omitempty"`

	// Variants The product's variants. You can add new variants or update existing ones, passing their IDs in the object.
	Variants *[]PostProductsIdJSONBody_Variants_Item `json:"variants,omitempty"`

	// Weight The product's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The product's width.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsIdParams defines parameters for PostProductsId.
type PostProductsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdJSONBodyStatus defines parameters for PostProductsId.
type PostProductsIdJSONBodyStatus string

// PostProductsIdJSONBody_Variants_Item defines parameters for PostProductsId.
type PostProductsIdJSONBody_Variants_Item struct {
	union json.RawMessage
}

// GetProductsIdOptionsParams defines parameters for GetProductsIdOptions.
type GetProductsIdOptionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the product option's searchable fields.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Title *struct {
		union json.RawMessage
	} `form:"title,omitempty" json:"title,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetProductsIdOptionsParamsId0 defines parameters for GetProductsIdOptions.
type GetProductsIdOptionsParamsId0 = string

// GetProductsIdOptionsParamsId1 defines parameters for GetProductsIdOptions.
type GetProductsIdOptionsParamsId1 = []string

// GetProductsIdOptionsParamsTitle0 defines parameters for GetProductsIdOptions.
type GetProductsIdOptionsParamsTitle0 = string

// GetProductsIdOptionsParamsTitle1 defines parameters for GetProductsIdOptions.
type GetProductsIdOptionsParamsTitle1 = []string

// PostProductsIdOptionsJSONBody defines parameters for PostProductsIdOptions.
type PostProductsIdOptionsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Title The product option's title.
	Title string `json:"title"`

	// Values The product option's values.
	Values []string `json:"values"`
}

// PostProductsIdOptionsParams defines parameters for PostProductsIdOptions.
type PostProductsIdOptionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteProductsIdOptionsOptionIdParams defines parameters for DeleteProductsIdOptionsOptionId.
type DeleteProductsIdOptionsOptionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductsIdOptionsOptionIdParams defines parameters for GetProductsIdOptionsOptionId.
type GetProductsIdOptionsOptionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdOptionsOptionIdJSONBody defines parameters for PostProductsIdOptionsOptionId.
type PostProductsIdOptionsOptionIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// Title The option's title.
	Title *string `json:"title,omitempty"`

	// Values The option's values.
	Values *[]string `json:"values,omitempty"`
}

// PostProductsIdOptionsOptionIdParams defines parameters for PostProductsIdOptionsOptionId.
type PostProductsIdOptionsOptionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductsIdVariantsParams defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the variant's search attributes.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// ManageInventory Filter by whether a variant's `manage_inventory` property is enabled.
	ManageInventory *bool `form:"manage_inventory,omitempty" json:"manage_inventory,omitempty"`

	// AllowBackorder Filter by whether backorders are allowed for the variant.
	AllowBackorder *bool `form:"allow_backorder,omitempty" json:"allow_backorder,omitempty"`

	// CreatedAt Filter by the product's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                 `json:"$contains,omitempty"`
		Eq       *GetProductsIdVariantsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                  `json:"$nin,omitempty"`
		Not *GetProductsIdVariantsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the product's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                 `json:"$contains,omitempty"`
		Eq       *GetProductsIdVariantsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                  `json:"$nin,omitempty"`
		Not *GetProductsIdVariantsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by the product's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                                 `json:"$contains,omitempty"`
		Eq       *GetProductsIdVariantsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                  `json:"$nin,omitempty"`
		Not *GetProductsIdVariantsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetProductsIdVariantsParamsId0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsId0 = string

// GetProductsIdVariantsParamsId1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsId1 = []string

// GetProductsIdVariantsParamsCreatedAtEq0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsCreatedAtEq0 = string

// GetProductsIdVariantsParamsCreatedAtEq1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsCreatedAtEq1 = []string

// GetProductsIdVariantsParams_CreatedAt_Eq defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetProductsIdVariantsParamsCreatedAtNot0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsCreatedAtNot0 = string

// GetProductsIdVariantsParamsCreatedAtNot1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsCreatedAtNot1 = map[string]interface{}

// GetProductsIdVariantsParamsCreatedAtNot2 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsCreatedAtNot2 = []string

// GetProductsIdVariantsParams_CreatedAt_Not defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetProductsIdVariantsParamsUpdatedAtEq0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsUpdatedAtEq0 = string

// GetProductsIdVariantsParamsUpdatedAtEq1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsUpdatedAtEq1 = []string

// GetProductsIdVariantsParams_UpdatedAt_Eq defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetProductsIdVariantsParamsUpdatedAtNot0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsUpdatedAtNot0 = string

// GetProductsIdVariantsParamsUpdatedAtNot1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsUpdatedAtNot1 = map[string]interface{}

// GetProductsIdVariantsParamsUpdatedAtNot2 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsUpdatedAtNot2 = []string

// GetProductsIdVariantsParams_UpdatedAt_Not defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetProductsIdVariantsParamsDeletedAtEq0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsDeletedAtEq0 = string

// GetProductsIdVariantsParamsDeletedAtEq1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsDeletedAtEq1 = []string

// GetProductsIdVariantsParams_DeletedAt_Eq defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetProductsIdVariantsParamsDeletedAtNot0 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsDeletedAtNot0 = string

// GetProductsIdVariantsParamsDeletedAtNot1 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsDeletedAtNot1 = map[string]interface{}

// GetProductsIdVariantsParamsDeletedAtNot2 defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParamsDeletedAtNot2 = []string

// GetProductsIdVariantsParams_DeletedAt_Not defines parameters for GetProductsIdVariants.
type GetProductsIdVariantsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostProductsIdVariantsJSONBody defines parameters for PostProductsIdVariants.
type PostProductsIdVariantsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// AllowBackorder Whether it's allowed to order this variant when it's out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode The variant's barcode.
	Barcode *string `json:"barcode,omitempty"`

	// Ean The variant's EAN.
	Ean *string `json:"ean,omitempty"`

	// Height The variant's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The variant's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// InventoryItems The variant's inventory items to create.
	InventoryItems *[]AdminCreateProductVariantInventoryKit `json:"inventory_items,omitempty"`

	// Length The variant's length.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether Medusa manages the variant's inventory quantity. If disabled, the product variant is always considered in stock.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The variant's material.
	Material *string `json:"material,omitempty"`

	// Metadata The variant's metadata, used to store custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The variant's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The variant's options, where the key is an option's name, and the value is the option's value.
	Options *map[string]interface{} `json:"options,omitempty"`

	// OriginCountry The variant's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Prices The variant's prices.
	Prices []AdminCreateProductVariantPrice `json:"prices"`

	// Sku The variant's SKU.
	Sku *string `json:"sku,omitempty"`

	// Title The variant's title.
	Title string `json:"title"`

	// Upc The variant's UPC.
	Upc *string `json:"upc,omitempty"`

	// VariantRank The sorting order of the variant among other variants in the product.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The variant's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The variant's width.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsIdVariantsParams defines parameters for PostProductsIdVariants.
type PostProductsIdVariantsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdVariantsBatchParams defines parameters for PostProductsIdVariantsBatch.
type PostProductsIdVariantsBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdVariantsInventoryItemsBatchJSONBody defines parameters for PostProductsIdVariantsInventoryItemsBatch.
type PostProductsIdVariantsInventoryItemsBatchJSONBody struct {
	// Create The The associations to create between product variants and inventory items.
	Create *[]struct {
		// InventoryItemId The ID of the inventory item to associate the variant with.
		InventoryItemId string `json:"inventory_item_id"`

		// RequiredQuantity The variant's quantity.
		RequiredQuantity float32 `json:"required_quantity"`

		// VariantId The ID of the variant.
		VariantId string `json:"variant_id"`
	} `json:"create,omitempty"`

	// Delete The product variants to delete their association with inventory items.
	Delete *[]struct {
		// InventoryItemId The ID of the inventory item associated with the variant.
		InventoryItemId string `json:"inventory_item_id"`

		// VariantId The ID of the variant.
		VariantId string `json:"variant_id"`
	} `json:"delete,omitempty"`

	// Update The product variants to update their association with inventory items.
	Update *[]struct {
		// InventoryItemId The ID of the inventory item the variant is associated with.
		InventoryItemId string `json:"inventory_item_id"`

		// RequiredQuantity The variant's quantity.
		RequiredQuantity float32 `json:"required_quantity"`

		// VariantId The ID of the variant.
		VariantId string `json:"variant_id"`
	} `json:"update,omitempty"`
}

// DeleteProductsIdVariantsVariantIdParams defines parameters for DeleteProductsIdVariantsVariantId.
type DeleteProductsIdVariantsVariantIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductsIdVariantsVariantIdParams defines parameters for GetProductsIdVariantsVariantId.
type GetProductsIdVariantsVariantIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdVariantsVariantIdJSONBody defines parameters for PostProductsIdVariantsVariantId.
type PostProductsIdVariantsVariantIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// AllowBackorder Whether customers can order the variant even if it's not in stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode The product variant's barcode.
	Barcode *string `json:"barcode,omitempty"`

	// Ean The product variant's EAN.
	Ean *string `json:"ean,omitempty"`

	// Height The product variant's height.
	Height *float32 `json:"height,omitempty"`

	// HsCode The product variant's HS code.
	HsCode *string `json:"hs_code,omitempty"`

	// Length The product variant's length.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether the Medusa application manages the variant's inventory. If disabled, the product variant is always considered in stock.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The product variant's material.
	Material *string `json:"material,omitempty"`

	// Metadata The product variant's metadata, can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The product variant's MID code.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The product variant's options.
	Options *map[string]interface{} `json:"options,omitempty"`

	// OriginCountry The product variant's origin country.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Prices The product variant's prices.
	Prices *[]AdminCreateProductVariantPrice `json:"prices,omitempty"`

	// Sku The product variant's SKU.
	Sku *string `json:"sku,omitempty"`

	// Title The product variant's title.
	Title *string `json:"title,omitempty"`

	// Upc The product variant's UPC.
	Upc *string `json:"upc,omitempty"`

	// VariantRank The product variant's rank among its siblings.
	VariantRank *float32 `json:"variant_rank,omitempty"`

	// Weight The product variant's weight.
	Weight *float32 `json:"weight,omitempty"`

	// Width The product variant's width.
	Width *float32 `json:"width,omitempty"`
}

// PostProductsIdVariantsVariantIdParams defines parameters for PostProductsIdVariantsVariantId.
type PostProductsIdVariantsVariantIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdVariantsVariantIdInventoryItemsParams defines parameters for PostProductsIdVariantsVariantIdInventoryItems.
type PostProductsIdVariantsVariantIdInventoryItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams defines parameters for DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId.
type DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams defines parameters for PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId.
type PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPromotionsParams defines parameters for GetPromotions.
type GetPromotionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the promotion's searchable attributes.
	Q    *string `form:"q,omitempty" json:"q,omitempty"`
	Code *struct {
		union json.RawMessage
	} `form:"code,omitempty" json:"code,omitempty"`
	CampaignId *struct {
		union json.RawMessage
	} `form:"campaign_id,omitempty" json:"campaign_id,omitempty"`

	// ApplicationMethod Apply filters on the application methods to retrieve the promotions of the matching application methods.
	ApplicationMethod *struct {
		CurrencyCode *GetPromotionsParams_ApplicationMethod_CurrencyCode `json:"currency_code,omitempty"`
	} `form:"application_method,omitempty" json:"application_method,omitempty"`

	// CreatedAt Filter by a promotion's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                         `json:"$contains,omitempty"`
		Eq       *GetPromotionsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                          `json:"$nin,omitempty"`
		Not *GetPromotionsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a promotion's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                         `json:"$contains,omitempty"`
		Eq       *GetPromotionsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                          `json:"$nin,omitempty"`
		Not *GetPromotionsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a promotion's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                         `json:"$contains,omitempty"`
		Eq       *GetPromotionsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                          `json:"$nin,omitempty"`
		Not *GetPromotionsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetPromotionsParamsCode0 defines parameters for GetPromotions.
type GetPromotionsParamsCode0 = string

// GetPromotionsParamsCode1 defines parameters for GetPromotions.
type GetPromotionsParamsCode1 = []string

// GetPromotionsParamsCampaignId0 defines parameters for GetPromotions.
type GetPromotionsParamsCampaignId0 = string

// GetPromotionsParamsCampaignId1 defines parameters for GetPromotions.
type GetPromotionsParamsCampaignId1 = []string

// GetPromotionsParamsApplicationMethodCurrencyCode0 defines parameters for GetPromotions.
type GetPromotionsParamsApplicationMethodCurrencyCode0 = string

// GetPromotionsParamsApplicationMethodCurrencyCode1 defines parameters for GetPromotions.
type GetPromotionsParamsApplicationMethodCurrencyCode1 = []string

// GetPromotionsParams_ApplicationMethod_CurrencyCode defines parameters for GetPromotions.
type GetPromotionsParams_ApplicationMethod_CurrencyCode struct {
	union json.RawMessage
}

// GetPromotionsParamsCreatedAtEq0 defines parameters for GetPromotions.
type GetPromotionsParamsCreatedAtEq0 = string

// GetPromotionsParamsCreatedAtEq1 defines parameters for GetPromotions.
type GetPromotionsParamsCreatedAtEq1 = []string

// GetPromotionsParams_CreatedAt_Eq defines parameters for GetPromotions.
type GetPromotionsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetPromotionsParamsCreatedAtNot0 defines parameters for GetPromotions.
type GetPromotionsParamsCreatedAtNot0 = string

// GetPromotionsParamsCreatedAtNot1 defines parameters for GetPromotions.
type GetPromotionsParamsCreatedAtNot1 = map[string]interface{}

// GetPromotionsParamsCreatedAtNot2 defines parameters for GetPromotions.
type GetPromotionsParamsCreatedAtNot2 = []string

// GetPromotionsParams_CreatedAt_Not defines parameters for GetPromotions.
type GetPromotionsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetPromotionsParamsUpdatedAtEq0 defines parameters for GetPromotions.
type GetPromotionsParamsUpdatedAtEq0 = string

// GetPromotionsParamsUpdatedAtEq1 defines parameters for GetPromotions.
type GetPromotionsParamsUpdatedAtEq1 = []string

// GetPromotionsParams_UpdatedAt_Eq defines parameters for GetPromotions.
type GetPromotionsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetPromotionsParamsUpdatedAtNot0 defines parameters for GetPromotions.
type GetPromotionsParamsUpdatedAtNot0 = string

// GetPromotionsParamsUpdatedAtNot1 defines parameters for GetPromotions.
type GetPromotionsParamsUpdatedAtNot1 = map[string]interface{}

// GetPromotionsParamsUpdatedAtNot2 defines parameters for GetPromotions.
type GetPromotionsParamsUpdatedAtNot2 = []string

// GetPromotionsParams_UpdatedAt_Not defines parameters for GetPromotions.
type GetPromotionsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetPromotionsParamsDeletedAtEq0 defines parameters for GetPromotions.
type GetPromotionsParamsDeletedAtEq0 = string

// GetPromotionsParamsDeletedAtEq1 defines parameters for GetPromotions.
type GetPromotionsParamsDeletedAtEq1 = []string

// GetPromotionsParams_DeletedAt_Eq defines parameters for GetPromotions.
type GetPromotionsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetPromotionsParamsDeletedAtNot0 defines parameters for GetPromotions.
type GetPromotionsParamsDeletedAtNot0 = string

// GetPromotionsParamsDeletedAtNot1 defines parameters for GetPromotions.
type GetPromotionsParamsDeletedAtNot1 = map[string]interface{}

// GetPromotionsParamsDeletedAtNot2 defines parameters for GetPromotions.
type GetPromotionsParamsDeletedAtNot2 = []string

// GetPromotionsParams_DeletedAt_Not defines parameters for GetPromotions.
type GetPromotionsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostPromotionsJSONBody defines parameters for PostPromotions.
type PostPromotionsJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// ApplicationMethod The promotion's application method.
	ApplicationMethod struct {
		// Allocation The allocation value that indicates whether the associated promotion is applied on each item in a cart or split between the items in the cart.
		Allocation *PostPromotionsJSONBodyApplicationMethodAllocation `json:"allocation,omitempty"`

		// ApplyToQuantity The quantity that results from matching the `buyget` promotion's condition. For example, if the promotion is a "Buy 2 shirts get 1 free", the value f this attribute is `1`.
		ApplyToQuantity float32 `json:"apply_to_quantity"`

		// BuyRules The application method's buy rules.
		BuyRules *[]struct {
			// Attribute The attribute to compare against when checking whether a promotion can be applied on a cart.
			Attribute string `json:"attribute"`

			// Description The buy rule's description.
			Description string `json:"description"`

			// Operator The operator used to check whether the buy rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
			Operator PostPromotionsJSONBodyApplicationMethodBuyRulesOperator  `json:"operator"`
			Values   PostPromotionsJSONBody_ApplicationMethod_BuyRules_Values `json:"values"`
		} `json:"buy_rules,omitempty"`

		// BuyRulesMinQuantity The minimum quantity required for a `buyget` promotion to be applied. For example, if the promotion is a "Buy 2 shirts get 1 free", the value of this attribute is `2`.
		BuyRulesMinQuantity float32 `json:"buy_rules_min_quantity"`

		// CurrencyCode The application method's currency code.
		CurrencyCode string `json:"currency_code"`

		// Description The application method's description.
		Description string `json:"description"`

		// MaxQuantity The max quantity allowed in the cart for the associated promotion to be applied.
		MaxQuantity float32 `json:"max_quantity"`

		// TargetRules The application method's target rules.
		TargetRules *[]struct {
			// Attribute The attribute to compare against when checking whether a promotion can be applied on a cart.
			Attribute string `json:"attribute"`

			// Description The target rule's description.
			Description string `json:"description"`

			// Operator The operator used to check whether the target rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
			Operator PostPromotionsJSONBodyApplicationMethodTargetRulesOperator  `json:"operator"`
			Values   PostPromotionsJSONBody_ApplicationMethod_TargetRules_Values `json:"values"`
		} `json:"target_rules,omitempty"`

		// TargetType The target type of the application method indicating whether the associated promotion is applied to the cart's items, shipping methods, or the whole order.
		TargetType PostPromotionsJSONBodyApplicationMethodTargetType `json:"target_type"`

		// Type The type of the application method indicating how the associated promotion is applied.
		Type PostPromotionsJSONBodyApplicationMethodType `json:"type"`

		// Value The discounted amount applied by the associated promotion based on the `type`.
		Value float32 `json:"value"`
	} `json:"application_method"`

	// Campaign The details of a campaign to create and add the promotion to it.
	Campaign *struct {
		// Budget The campaign's budget which, when crossed, ends the campaign.
		Budget struct {
			// CurrencyCode The campaign budget's currency code. This can't be edited later.
			CurrencyCode string `json:"currency_code"`

			// Limit The budget's limit.
			Limit float32 `json:"limit"`

			// Type The budget's type. This can't be edited later. Use `spend` to set a limit on the total amount discounted by the campaign's promotions. Use `usage` to set a limit on the total number of times the campaign's promotions can be used.
			Type PostPromotionsJSONBodyCampaignBudgetType `json:"type"`
		} `json:"budget"`

		// CampaignIdentifier The campaign's identifier.
		CampaignIdentifier string `json:"campaign_identifier"`

		// Description The campaign's description.
		Description string `json:"description"`

		// EndsAt The campaign's end date.
		EndsAt time.Time `json:"ends_at"`

		// Name The campaign's name.
		Name string `json:"name"`

		// StartsAt The campaign's start date.
		StartsAt time.Time `json:"starts_at"`
	} `json:"campaign,omitempty"`

	// CampaignId The ID of the campaign that the promotion belongs to.
	CampaignId string `json:"campaign_id"`

	// Code The promotion's code.
	Code string `json:"code"`

	// IsAutomatic Whether the promotion is applied automatically.
	IsAutomatic *bool `json:"is_automatic,omitempty"`

	// Rules The promotion's rules.
	Rules *[]struct {
		// Attribute The attribute to compare against when checking whether a promotion can be applied on a cart.
		Attribute string `json:"attribute"`

		// Description The rule's description.
		Description string `json:"description"`

		// Operator The operator used to check whether the buy rule applies on a cart. For example, `eq` means that the cart's value for the specified attribute must match the specified value.
		Operator PostPromotionsJSONBodyRulesOperator `json:"operator"`
		Values   PostPromotionsJSONBody_Rules_Values `json:"values"`
	} `json:"rules,omitempty"`

	// Type The promotion's type.
	Type PostPromotionsJSONBodyType `json:"type"`
}

// PostPromotionsParams defines parameters for PostPromotions.
type PostPromotionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPromotionsJSONBodyApplicationMethodAllocation defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodAllocation string

// PostPromotionsJSONBodyApplicationMethodBuyRulesOperator defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodBuyRulesOperator string

// PostPromotionsJSONBodyApplicationMethodBuyRulesValues0 defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodBuyRulesValues0 = string

// PostPromotionsJSONBodyApplicationMethodBuyRulesValues1 defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodBuyRulesValues1 = []string

// PostPromotionsJSONBody_ApplicationMethod_BuyRules_Values defines parameters for PostPromotions.
type PostPromotionsJSONBody_ApplicationMethod_BuyRules_Values struct {
	union json.RawMessage
}

// PostPromotionsJSONBodyApplicationMethodTargetRulesOperator defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodTargetRulesOperator string

// PostPromotionsJSONBodyApplicationMethodTargetRulesValues0 defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodTargetRulesValues0 = string

// PostPromotionsJSONBodyApplicationMethodTargetRulesValues1 defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodTargetRulesValues1 = []string

// PostPromotionsJSONBody_ApplicationMethod_TargetRules_Values defines parameters for PostPromotions.
type PostPromotionsJSONBody_ApplicationMethod_TargetRules_Values struct {
	union json.RawMessage
}

// PostPromotionsJSONBodyApplicationMethodTargetType defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodTargetType string

// PostPromotionsJSONBodyApplicationMethodType defines parameters for PostPromotions.
type PostPromotionsJSONBodyApplicationMethodType string

// PostPromotionsJSONBodyCampaignBudgetType defines parameters for PostPromotions.
type PostPromotionsJSONBodyCampaignBudgetType string

// PostPromotionsJSONBodyRulesOperator defines parameters for PostPromotions.
type PostPromotionsJSONBodyRulesOperator string

// PostPromotionsJSONBodyRulesValues0 defines parameters for PostPromotions.
type PostPromotionsJSONBodyRulesValues0 = string

// PostPromotionsJSONBodyRulesValues1 defines parameters for PostPromotions.
type PostPromotionsJSONBodyRulesValues1 = []string

// PostPromotionsJSONBody_Rules_Values defines parameters for PostPromotions.
type PostPromotionsJSONBody_Rules_Values struct {
	union json.RawMessage
}

// PostPromotionsJSONBodyType defines parameters for PostPromotions.
type PostPromotionsJSONBodyType string

// GetPromotionsRuleAttributeOptionsRuleTypeParams defines parameters for GetPromotionsRuleAttributeOptionsRuleType.
type GetPromotionsRuleAttributeOptionsRuleTypeParams struct {
	// PromotionType The promotion type to retrieve rules for.
	PromotionType *GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionType `form:"promotion_type,omitempty" json:"promotion_type,omitempty"`

	// ApplicationMethodType The application method type to retrieve rules for.
	ApplicationMethodType *GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodType `form:"application_method_type,omitempty" json:"application_method_type,omitempty"`
}

// GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionType defines parameters for GetPromotionsRuleAttributeOptionsRuleType.
type GetPromotionsRuleAttributeOptionsRuleTypeParamsPromotionType string

// GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodType defines parameters for GetPromotionsRuleAttributeOptionsRuleType.
type GetPromotionsRuleAttributeOptionsRuleTypeParamsApplicationMethodType string

// GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType defines parameters for GetPromotionsRuleAttributeOptionsRuleType.
type GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType string

// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams defines parameters for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId.
type GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams struct {
	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// PromotionType The promotion type to retrieve rules for.
	PromotionType *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionType `form:"promotion_type,omitempty" json:"promotion_type,omitempty"`

	// ApplicationMethodType The application method type to retrieve rules for.
	ApplicationMethodType *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodType `form:"application_method_type,omitempty" json:"application_method_type,omitempty"`
}

// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionType defines parameters for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId.
type GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsPromotionType string

// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodType defines parameters for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId.
type GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsApplicationMethodType string

// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType defines parameters for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId.
type GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType string

// GetPromotionsIdParams defines parameters for GetPromotionsId.
type GetPromotionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPromotionsIdJSONBody defines parameters for PostPromotionsId.
type PostPromotionsIdJSONBody struct {
	// AdditionalData Pass additional custom data to the API route. This data is passed to the underlying workflow under the `additional_data` parameter.
	AdditionalData *map[string]interface{} `json:"additional_data,omitempty"`

	// ApplicationMethod The properties to update in the application method.
	ApplicationMethod *struct {
		// Allocation The allocation value that indicates whether the associated promotion is applied on each item in a cart or split between the items in the cart.
		Allocation *PostPromotionsIdJSONBodyApplicationMethodAllocation `json:"allocation,omitempty"`

		// ApplyToQuantity The quantity that results from matching the `buyget` promotion's condition. For example, if the promotion is a "Buy 2 shirts get 1 free", the value f this attribute is `1`.
		ApplyToQuantity float32 `json:"apply_to_quantity"`

		// BuyRulesMinQuantity The minimum quantity required for a `buyget` promotion to be applied. For example, if the promotion is a "Buy 2 shirts get 1 free", the value of this attribute is `2`.
		BuyRulesMinQuantity float32 `json:"buy_rules_min_quantity"`

		// CurrencyCode The application method's currency code.
		CurrencyCode string `json:"currency_code"`

		// Description The application method's description.
		Description string `json:"description"`

		// Id The application method's ID.
		Id string `json:"id"`

		// MaxQuantity The max quantity allowed in the cart for the associated promotion to be applied.
		MaxQuantity float32 `json:"max_quantity"`

		// TargetType The target type of the application method indicating whether the associated promotion is applied to the cart's items, shipping methods, or the whole order.
		TargetType *PostPromotionsIdJSONBodyApplicationMethodTargetType `json:"target_type,omitempty"`

		// Type The type of the application method indicating how the associated promotion is applied.
		Type *PostPromotionsIdJSONBodyApplicationMethodType `json:"type,omitempty"`

		// Value The discounted amount applied by the associated promotion based on the `type`.
		Value *float32 `json:"value,omitempty"`
	} `json:"application_method,omitempty"`

	// CampaignId The ID of the campaign that the promotion belongs to.
	CampaignId string `json:"campaign_id"`

	// Code The promotion's code.
	Code *string `json:"code,omitempty"`

	// IsAutomatic Whether the promotion is applied automatically.
	IsAutomatic *bool `json:"is_automatic,omitempty"`

	// Type The promotion's type.
	Type *PostPromotionsIdJSONBodyType `json:"type,omitempty"`
}

// PostPromotionsIdParams defines parameters for PostPromotionsId.
type PostPromotionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPromotionsIdJSONBodyApplicationMethodAllocation defines parameters for PostPromotionsId.
type PostPromotionsIdJSONBodyApplicationMethodAllocation string

// PostPromotionsIdJSONBodyApplicationMethodTargetType defines parameters for PostPromotionsId.
type PostPromotionsIdJSONBodyApplicationMethodTargetType string

// PostPromotionsIdJSONBodyApplicationMethodType defines parameters for PostPromotionsId.
type PostPromotionsIdJSONBodyApplicationMethodType string

// PostPromotionsIdJSONBodyType defines parameters for PostPromotionsId.
type PostPromotionsIdJSONBodyType string

// PostPromotionsIdBuyRulesBatchJSONBody defines parameters for PostPromotionsIdBuyRulesBatch.
type PostPromotionsIdBuyRulesBatchJSONBody struct {
	// Create The buy rules to create.
	Create *[]AdminCreatePromotionRule `json:"create,omitempty"`

	// Delete The buy rules to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The buy rules to update.
	Update *[]AdminUpdatePromotionRule `json:"update,omitempty"`
}

// PostPromotionsIdBuyRulesBatchParams defines parameters for PostPromotionsIdBuyRulesBatch.
type PostPromotionsIdBuyRulesBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPromotionsIdRulesBatchJSONBody defines parameters for PostPromotionsIdRulesBatch.
type PostPromotionsIdRulesBatchJSONBody struct {
	// Create The rules to create.
	Create *[]AdminCreatePromotionRule `json:"create,omitempty"`

	// Delete The rules to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The rules to update.
	Update *[]AdminUpdatePromotionRule `json:"update,omitempty"`
}

// PostPromotionsIdRulesBatchParams defines parameters for PostPromotionsIdRulesBatch.
type PostPromotionsIdRulesBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostPromotionsIdTargetRulesBatchJSONBody defines parameters for PostPromotionsIdTargetRulesBatch.
type PostPromotionsIdTargetRulesBatchJSONBody struct {
	// Create The target rules to create.
	Create *[]AdminCreatePromotionRule `json:"create,omitempty"`

	// Delete The target rules to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The target rules to update.
	Update *[]AdminUpdatePromotionRule `json:"update,omitempty"`
}

// PostPromotionsIdTargetRulesBatchParams defines parameters for PostPromotionsIdTargetRulesBatch.
type PostPromotionsIdTargetRulesBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPromotionsIdRuleTypeParams defines parameters for GetPromotionsIdRuleType.
type GetPromotionsIdRuleTypeParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPromotionsIdRuleTypeParamsRuleType defines parameters for GetPromotionsIdRuleType.
type GetPromotionsIdRuleTypeParamsRuleType string

// GetRefundReasonsParams defines parameters for GetRefundReasons.
type GetRefundReasonsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Q Search term to filter the refund reason's searchable properties.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetRefundReasonsParamsId0 defines parameters for GetRefundReasons.
type GetRefundReasonsParamsId0 = string

// GetRefundReasonsParamsId1 defines parameters for GetRefundReasons.
type GetRefundReasonsParamsId1 = []string

// PostRefundReasonsParams defines parameters for PostRefundReasons.
type PostRefundReasonsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetRefundReasonsIdParams defines parameters for GetRefundReasonsId.
type GetRefundReasonsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostRefundReasonsIdJSONBody defines parameters for PostRefundReasonsId.
type PostRefundReasonsIdJSONBody struct {
	// Description The refund reason's description.
	Description *string `json:"description,omitempty"`

	// Label The refund reason's label.
	Label *string `json:"label,omitempty"`
}

// PostRefundReasonsIdParams defines parameters for PostRefundReasonsId.
type PostRefundReasonsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetRegionsParams defines parameters for GetRegions.
type GetRegionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the region's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Name *struct {
		union json.RawMessage
	} `form:"name,omitempty" json:"name,omitempty"`

	// CreatedAt Filter by a region's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetRegionsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetRegionsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a region's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetRegionsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetRegionsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a region's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetRegionsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetRegionsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And          *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or           *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
	CurrencyCode *struct {
		union json.RawMessage
	} `form:"currency_code,omitempty" json:"currency_code,omitempty"`
}

// GetRegionsParamsId0 defines parameters for GetRegions.
type GetRegionsParamsId0 = string

// GetRegionsParamsId1 defines parameters for GetRegions.
type GetRegionsParamsId1 = []string

// GetRegionsParamsName0 defines parameters for GetRegions.
type GetRegionsParamsName0 = string

// GetRegionsParamsName1 defines parameters for GetRegions.
type GetRegionsParamsName1 = []string

// GetRegionsParamsCreatedAtEq0 defines parameters for GetRegions.
type GetRegionsParamsCreatedAtEq0 = string

// GetRegionsParamsCreatedAtEq1 defines parameters for GetRegions.
type GetRegionsParamsCreatedAtEq1 = []string

// GetRegionsParams_CreatedAt_Eq defines parameters for GetRegions.
type GetRegionsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetRegionsParamsCreatedAtNot0 defines parameters for GetRegions.
type GetRegionsParamsCreatedAtNot0 = string

// GetRegionsParamsCreatedAtNot1 defines parameters for GetRegions.
type GetRegionsParamsCreatedAtNot1 = map[string]interface{}

// GetRegionsParamsCreatedAtNot2 defines parameters for GetRegions.
type GetRegionsParamsCreatedAtNot2 = []string

// GetRegionsParams_CreatedAt_Not defines parameters for GetRegions.
type GetRegionsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetRegionsParamsUpdatedAtEq0 defines parameters for GetRegions.
type GetRegionsParamsUpdatedAtEq0 = string

// GetRegionsParamsUpdatedAtEq1 defines parameters for GetRegions.
type GetRegionsParamsUpdatedAtEq1 = []string

// GetRegionsParams_UpdatedAt_Eq defines parameters for GetRegions.
type GetRegionsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetRegionsParamsUpdatedAtNot0 defines parameters for GetRegions.
type GetRegionsParamsUpdatedAtNot0 = string

// GetRegionsParamsUpdatedAtNot1 defines parameters for GetRegions.
type GetRegionsParamsUpdatedAtNot1 = map[string]interface{}

// GetRegionsParamsUpdatedAtNot2 defines parameters for GetRegions.
type GetRegionsParamsUpdatedAtNot2 = []string

// GetRegionsParams_UpdatedAt_Not defines parameters for GetRegions.
type GetRegionsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetRegionsParamsDeletedAtEq0 defines parameters for GetRegions.
type GetRegionsParamsDeletedAtEq0 = string

// GetRegionsParamsDeletedAtEq1 defines parameters for GetRegions.
type GetRegionsParamsDeletedAtEq1 = []string

// GetRegionsParams_DeletedAt_Eq defines parameters for GetRegions.
type GetRegionsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetRegionsParamsDeletedAtNot0 defines parameters for GetRegions.
type GetRegionsParamsDeletedAtNot0 = string

// GetRegionsParamsDeletedAtNot1 defines parameters for GetRegions.
type GetRegionsParamsDeletedAtNot1 = map[string]interface{}

// GetRegionsParamsDeletedAtNot2 defines parameters for GetRegions.
type GetRegionsParamsDeletedAtNot2 = []string

// GetRegionsParams_DeletedAt_Not defines parameters for GetRegions.
type GetRegionsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetRegionsParamsCurrencyCode0 defines parameters for GetRegions.
type GetRegionsParamsCurrencyCode0 = string

// GetRegionsParamsCurrencyCode1 defines parameters for GetRegions.
type GetRegionsParamsCurrencyCode1 = []string

// PostRegionsParams defines parameters for PostRegions.
type PostRegionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetRegionsIdParams defines parameters for GetRegionsId.
type GetRegionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostRegionsIdJSONBody defines parameters for PostRegionsId.
type PostRegionsIdJSONBody struct {
	// AutomaticTaxes Whether taxes are calculated automatically for carts in the region.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// Countries The region's countries.
	Countries *[]string `json:"countries,omitempty"`

	// CurrencyCode The region's currency code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// IsTaxInclusive Whether the prices in the region are tax inclusive.
	IsTaxInclusive *bool `json:"is_tax_inclusive,omitempty"`

	// Metadata The region's metadata. Can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The region's name.
	Name *string `json:"name,omitempty"`

	// PaymentProviders The payment providers enabled in the region.
	PaymentProviders *[]string `json:"payment_providers,omitempty"`
}

// PostRegionsIdParams defines parameters for PostRegionsId.
type PostRegionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReservationsParams defines parameters for GetReservations.
type GetReservationsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order      *string `form:"order,omitempty" json:"order,omitempty"`
	LocationId *struct {
		union json.RawMessage
	} `form:"location_id,omitempty" json:"location_id,omitempty"`
	InventoryItemId *struct {
		union json.RawMessage
	} `form:"inventory_item_id,omitempty" json:"inventory_item_id,omitempty"`
	LineItemId *struct {
		union json.RawMessage
	} `form:"line_item_id,omitempty" json:"line_item_id,omitempty"`
	CreatedBy *struct {
		union json.RawMessage
	} `form:"created_by,omitempty" json:"created_by,omitempty"`
	Description *struct {
		union json.RawMessage
	} `form:"description,omitempty" json:"description,omitempty"`

	// CreatedAt Filter by a reservation's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                           `json:"$contains,omitempty"`
		Eq       *GetReservationsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                            `json:"$nin,omitempty"`
		Not *GetReservationsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a reservation's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                           `json:"$contains,omitempty"`
		Eq       *GetReservationsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                            `json:"$nin,omitempty"`
		Not *GetReservationsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a reservation's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                           `json:"$contains,omitempty"`
		Eq       *GetReservationsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                            `json:"$nin,omitempty"`
		Not *GetReservationsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// GetReservationsParamsLocationId0 defines parameters for GetReservations.
type GetReservationsParamsLocationId0 = string

// GetReservationsParamsLocationId1 defines parameters for GetReservations.
type GetReservationsParamsLocationId1 = []string

// GetReservationsParamsInventoryItemId0 defines parameters for GetReservations.
type GetReservationsParamsInventoryItemId0 = string

// GetReservationsParamsInventoryItemId1 defines parameters for GetReservations.
type GetReservationsParamsInventoryItemId1 = []string

// GetReservationsParamsLineItemId0 defines parameters for GetReservations.
type GetReservationsParamsLineItemId0 = string

// GetReservationsParamsLineItemId1 defines parameters for GetReservations.
type GetReservationsParamsLineItemId1 = []string

// GetReservationsParamsCreatedBy0 defines parameters for GetReservations.
type GetReservationsParamsCreatedBy0 = string

// GetReservationsParamsCreatedBy1 defines parameters for GetReservations.
type GetReservationsParamsCreatedBy1 = []string

// GetReservationsParamsDescription0 defines parameters for GetReservations.
type GetReservationsParamsDescription0 = string

// GetReservationsParamsDescription1 defines parameters for GetReservations.
type GetReservationsParamsDescription1 struct {
	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string `json:"$contains,omitempty"`

	// Eq Filter by an exact match.
	Eq *string `json:"$eq,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array's items.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array's items.
	Nin *[]string `json:"$nin,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetReservationsParamsCreatedAtEq0 defines parameters for GetReservations.
type GetReservationsParamsCreatedAtEq0 = string

// GetReservationsParamsCreatedAtEq1 defines parameters for GetReservations.
type GetReservationsParamsCreatedAtEq1 = []string

// GetReservationsParams_CreatedAt_Eq defines parameters for GetReservations.
type GetReservationsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetReservationsParamsCreatedAtNot0 defines parameters for GetReservations.
type GetReservationsParamsCreatedAtNot0 = string

// GetReservationsParamsCreatedAtNot1 defines parameters for GetReservations.
type GetReservationsParamsCreatedAtNot1 = map[string]interface{}

// GetReservationsParamsCreatedAtNot2 defines parameters for GetReservations.
type GetReservationsParamsCreatedAtNot2 = []string

// GetReservationsParams_CreatedAt_Not defines parameters for GetReservations.
type GetReservationsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetReservationsParamsUpdatedAtEq0 defines parameters for GetReservations.
type GetReservationsParamsUpdatedAtEq0 = string

// GetReservationsParamsUpdatedAtEq1 defines parameters for GetReservations.
type GetReservationsParamsUpdatedAtEq1 = []string

// GetReservationsParams_UpdatedAt_Eq defines parameters for GetReservations.
type GetReservationsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetReservationsParamsUpdatedAtNot0 defines parameters for GetReservations.
type GetReservationsParamsUpdatedAtNot0 = string

// GetReservationsParamsUpdatedAtNot1 defines parameters for GetReservations.
type GetReservationsParamsUpdatedAtNot1 = map[string]interface{}

// GetReservationsParamsUpdatedAtNot2 defines parameters for GetReservations.
type GetReservationsParamsUpdatedAtNot2 = []string

// GetReservationsParams_UpdatedAt_Not defines parameters for GetReservations.
type GetReservationsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetReservationsParamsDeletedAtEq0 defines parameters for GetReservations.
type GetReservationsParamsDeletedAtEq0 = string

// GetReservationsParamsDeletedAtEq1 defines parameters for GetReservations.
type GetReservationsParamsDeletedAtEq1 = []string

// GetReservationsParams_DeletedAt_Eq defines parameters for GetReservations.
type GetReservationsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetReservationsParamsDeletedAtNot0 defines parameters for GetReservations.
type GetReservationsParamsDeletedAtNot0 = string

// GetReservationsParamsDeletedAtNot1 defines parameters for GetReservations.
type GetReservationsParamsDeletedAtNot1 = map[string]interface{}

// GetReservationsParamsDeletedAtNot2 defines parameters for GetReservations.
type GetReservationsParamsDeletedAtNot2 = []string

// GetReservationsParams_DeletedAt_Not defines parameters for GetReservations.
type GetReservationsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostReservationsParams defines parameters for PostReservations.
type PostReservationsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReservationsIdParams defines parameters for GetReservationsId.
type GetReservationsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReservationsIdJSONBody defines parameters for PostReservationsId.
type PostReservationsIdJSONBody struct {
	// Description The reservation's description.
	Description *string `json:"description,omitempty"`

	// LocationId The ID of the associated location.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata The reservation's metadata. Can hold custom key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The reserved quantity.
	Quantity *float32 `json:"quantity,omitempty"`
}

// PostReservationsIdParams defines parameters for PostReservationsId.
type PostReservationsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReturnReasonsParams defines parameters for GetReturnReasons.
type GetReturnReasonsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the return reason's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Value *struct {
		union json.RawMessage
	} `form:"value,omitempty" json:"value,omitempty"`
	Label *struct {
		union json.RawMessage
	} `form:"label,omitempty" json:"label,omitempty"`
	Description *struct {
		union json.RawMessage
	} `form:"description,omitempty" json:"description,omitempty"`
	ParentReturnReasonId *struct {
		union json.RawMessage
	} `form:"parent_return_reason_id,omitempty" json:"parent_return_reason_id,omitempty"`

	// CreatedAt Filter by a return reason's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                            `json:"$contains,omitempty"`
		Eq       *GetReturnReasonsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                             `json:"$nin,omitempty"`
		Not *GetReturnReasonsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a return reason's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                            `json:"$contains,omitempty"`
		Eq       *GetReturnReasonsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                             `json:"$nin,omitempty"`
		Not *GetReturnReasonsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a return reason's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                            `json:"$contains,omitempty"`
		Eq       *GetReturnReasonsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                             `json:"$nin,omitempty"`
		Not *GetReturnReasonsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetReturnReasonsParamsId0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsId0 = string

// GetReturnReasonsParamsId1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsId1 = []string

// GetReturnReasonsParamsValue0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsValue0 = string

// GetReturnReasonsParamsValue1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsValue1 = []string

// GetReturnReasonsParamsLabel0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsLabel0 = string

// GetReturnReasonsParamsLabel1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsLabel1 = []string

// GetReturnReasonsParamsDescription0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDescription0 = string

// GetReturnReasonsParamsDescription1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDescription1 = []string

// GetReturnReasonsParamsParentReturnReasonId0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsParentReturnReasonId0 = string

// GetReturnReasonsParamsParentReturnReasonId1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsParentReturnReasonId1 = []string

// GetReturnReasonsParamsCreatedAtEq0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsCreatedAtEq0 = string

// GetReturnReasonsParamsCreatedAtEq1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsCreatedAtEq1 = []string

// GetReturnReasonsParams_CreatedAt_Eq defines parameters for GetReturnReasons.
type GetReturnReasonsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetReturnReasonsParamsCreatedAtNot0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsCreatedAtNot0 = string

// GetReturnReasonsParamsCreatedAtNot1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsCreatedAtNot1 = map[string]interface{}

// GetReturnReasonsParamsCreatedAtNot2 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsCreatedAtNot2 = []string

// GetReturnReasonsParams_CreatedAt_Not defines parameters for GetReturnReasons.
type GetReturnReasonsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetReturnReasonsParamsUpdatedAtEq0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsUpdatedAtEq0 = string

// GetReturnReasonsParamsUpdatedAtEq1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsUpdatedAtEq1 = []string

// GetReturnReasonsParams_UpdatedAt_Eq defines parameters for GetReturnReasons.
type GetReturnReasonsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetReturnReasonsParamsUpdatedAtNot0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsUpdatedAtNot0 = string

// GetReturnReasonsParamsUpdatedAtNot1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsUpdatedAtNot1 = map[string]interface{}

// GetReturnReasonsParamsUpdatedAtNot2 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsUpdatedAtNot2 = []string

// GetReturnReasonsParams_UpdatedAt_Not defines parameters for GetReturnReasons.
type GetReturnReasonsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetReturnReasonsParamsDeletedAtEq0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDeletedAtEq0 = string

// GetReturnReasonsParamsDeletedAtEq1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDeletedAtEq1 = []string

// GetReturnReasonsParams_DeletedAt_Eq defines parameters for GetReturnReasons.
type GetReturnReasonsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetReturnReasonsParamsDeletedAtNot0 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDeletedAtNot0 = string

// GetReturnReasonsParamsDeletedAtNot1 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDeletedAtNot1 = map[string]interface{}

// GetReturnReasonsParamsDeletedAtNot2 defines parameters for GetReturnReasons.
type GetReturnReasonsParamsDeletedAtNot2 = []string

// GetReturnReasonsParams_DeletedAt_Not defines parameters for GetReturnReasons.
type GetReturnReasonsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostReturnReasonsParams defines parameters for PostReturnReasons.
type PostReturnReasonsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReturnReasonsIdParams defines parameters for GetReturnReasonsId.
type GetReturnReasonsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnReasonsIdParams defines parameters for PostReturnReasonsId.
type PostReturnReasonsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReturnsParams defines parameters for GetReturns.
type GetReturnsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Status *struct {
		union json.RawMessage
	} `form:"status,omitempty" json:"status,omitempty"`

	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`

	// SalesChannelId Filter by sales channel IDs to retrieve their associated returns.
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// FulfillmentStatus Filter by fulfillment statuses.
	FulfillmentStatus *[]GetReturnsParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// PaymentStatus Filter by payment statuses.
	PaymentStatus *[]GetReturnsParamsPaymentStatus `form:"payment_status,omitempty" json:"payment_status,omitempty"`

	// RegionId Filter by region IDs to retrieve their associated returns.
	RegionId *[]string `form:"region_id,omitempty" json:"region_id,omitempty"`

	// Q Search term to filter the return's searchable properties.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// CreatedAt Filter by the return's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetReturnsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetReturnsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by the return's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                      `json:"$contains,omitempty"`
		Eq       *GetReturnsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                       `json:"$nin,omitempty"`
		Not *GetReturnsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetReturnsParamsId0 defines parameters for GetReturns.
type GetReturnsParamsId0 = string

// GetReturnsParamsId1 defines parameters for GetReturns.
type GetReturnsParamsId1 = []string

// GetReturnsParamsStatus0 defines parameters for GetReturns.
type GetReturnsParamsStatus0 = string

// GetReturnsParamsStatus1 defines parameters for GetReturns.
type GetReturnsParamsStatus1 = []string

// GetReturnsParamsFulfillmentStatus defines parameters for GetReturns.
type GetReturnsParamsFulfillmentStatus string

// GetReturnsParamsPaymentStatus defines parameters for GetReturns.
type GetReturnsParamsPaymentStatus string

// GetReturnsParamsCreatedAtEq0 defines parameters for GetReturns.
type GetReturnsParamsCreatedAtEq0 = string

// GetReturnsParamsCreatedAtEq1 defines parameters for GetReturns.
type GetReturnsParamsCreatedAtEq1 = []string

// GetReturnsParams_CreatedAt_Eq defines parameters for GetReturns.
type GetReturnsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetReturnsParamsCreatedAtNot0 defines parameters for GetReturns.
type GetReturnsParamsCreatedAtNot0 = string

// GetReturnsParamsCreatedAtNot1 defines parameters for GetReturns.
type GetReturnsParamsCreatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetReturnsParams_CreatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                             `json:"$nin,omitempty"`
	Not *GetReturnsParams_CreatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetReturnsParamsCreatedAtNot2 defines parameters for GetReturns.
type GetReturnsParamsCreatedAtNot2 = []string

// GetReturnsParams_CreatedAt_Not defines parameters for GetReturns.
type GetReturnsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetReturnsParamsUpdatedAtEq0 defines parameters for GetReturns.
type GetReturnsParamsUpdatedAtEq0 = string

// GetReturnsParamsUpdatedAtEq1 defines parameters for GetReturns.
type GetReturnsParamsUpdatedAtEq1 = []string

// GetReturnsParams_UpdatedAt_Eq defines parameters for GetReturns.
type GetReturnsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetReturnsParamsUpdatedAtNot0 defines parameters for GetReturns.
type GetReturnsParamsUpdatedAtNot0 = string

// GetReturnsParamsUpdatedAtNot1 defines parameters for GetReturns.
type GetReturnsParamsUpdatedAtNot1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                            `json:"$contains,omitempty"`
	Eq       *GetReturnsParams_UpdatedAt_Not_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                             `json:"$nin,omitempty"`
	Not *GetReturnsParams_UpdatedAt_Not_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetReturnsParamsUpdatedAtNot2 defines parameters for GetReturns.
type GetReturnsParamsUpdatedAtNot2 = []string

// GetReturnsParams_UpdatedAt_Not defines parameters for GetReturns.
type GetReturnsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// PostReturnsParams defines parameters for PostReturns.
type PostReturnsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReturnsIdParams defines parameters for GetReturnsId.
type GetReturnsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdParams defines parameters for PostReturnsId.
type PostReturnsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdDismissItemsParams defines parameters for PostReturnsIdDismissItems.
type PostReturnsIdDismissItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteReturnsIdDismissItemsActionIdParams defines parameters for DeleteReturnsIdDismissItemsActionId.
type DeleteReturnsIdDismissItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdDismissItemsActionIdParams defines parameters for PostReturnsIdDismissItemsActionId.
type PostReturnsIdDismissItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdReceiveParams defines parameters for PostReturnsIdReceive.
type PostReturnsIdReceiveParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdReceiveItemsParams defines parameters for PostReturnsIdReceiveItems.
type PostReturnsIdReceiveItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteReturnsIdReceiveItemsActionIdParams defines parameters for DeleteReturnsIdReceiveItemsActionId.
type DeleteReturnsIdReceiveItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdReceiveItemsActionIdParams defines parameters for PostReturnsIdReceiveItemsActionId.
type PostReturnsIdReceiveItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdReceiveConfirmParams defines parameters for PostReturnsIdReceiveConfirm.
type PostReturnsIdReceiveConfirmParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdRequestParams defines parameters for PostReturnsIdRequest.
type PostReturnsIdRequestParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdRequestItemsParams defines parameters for PostReturnsIdRequestItems.
type PostReturnsIdRequestItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteReturnsIdRequestItemsActionIdParams defines parameters for DeleteReturnsIdRequestItemsActionId.
type DeleteReturnsIdRequestItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdRequestItemsActionIdParams defines parameters for PostReturnsIdRequestItemsActionId.
type PostReturnsIdRequestItemsActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdShippingMethodParams defines parameters for PostReturnsIdShippingMethod.
type PostReturnsIdShippingMethodParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteReturnsIdShippingMethodActionIdParams defines parameters for DeleteReturnsIdShippingMethodActionId.
type DeleteReturnsIdShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostReturnsIdShippingMethodActionIdParams defines parameters for PostReturnsIdShippingMethodActionId.
type PostReturnsIdShippingMethodActionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetSalesChannelsParams defines parameters for GetSalesChannels.
type GetSalesChannelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the sales channel's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Name *struct {
		union json.RawMessage
	} `form:"name,omitempty" json:"name,omitempty"`

	// Description The sales channel's description.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// IsDisabled Filter by whether the sales channel is disabled.
	IsDisabled *bool `form:"is_disabled,omitempty" json:"is_disabled,omitempty"`

	// CreatedAt Filter by a sales channel's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                            `json:"$contains,omitempty"`
		Eq       *GetSalesChannelsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                             `json:"$nin,omitempty"`
		Not *GetSalesChannelsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a sales channel's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                            `json:"$contains,omitempty"`
		Eq       *GetSalesChannelsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                             `json:"$nin,omitempty"`
		Not *GetSalesChannelsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a sales channel's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                            `json:"$contains,omitempty"`
		Eq       *GetSalesChannelsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                             `json:"$nin,omitempty"`
		Not *GetSalesChannelsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	LocationId *struct {
		union json.RawMessage
	} `form:"location_id,omitempty" json:"location_id,omitempty"`
	PublishableKeyId *struct {
		union json.RawMessage
	} `form:"publishable_key_id,omitempty" json:"publishable_key_id,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetSalesChannelsParamsId0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsId0 = string

// GetSalesChannelsParamsId1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsId1 = []string

// GetSalesChannelsParamsName0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsName0 = string

// GetSalesChannelsParamsName1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsName1 = []string

// GetSalesChannelsParamsCreatedAtEq0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsCreatedAtEq0 = string

// GetSalesChannelsParamsCreatedAtEq1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsCreatedAtEq1 = []string

// GetSalesChannelsParams_CreatedAt_Eq defines parameters for GetSalesChannels.
type GetSalesChannelsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetSalesChannelsParamsCreatedAtNot0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsCreatedAtNot0 = string

// GetSalesChannelsParamsCreatedAtNot1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsCreatedAtNot1 = map[string]interface{}

// GetSalesChannelsParamsCreatedAtNot2 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsCreatedAtNot2 = []string

// GetSalesChannelsParams_CreatedAt_Not defines parameters for GetSalesChannels.
type GetSalesChannelsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetSalesChannelsParamsUpdatedAtEq0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsUpdatedAtEq0 = string

// GetSalesChannelsParamsUpdatedAtEq1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsUpdatedAtEq1 = []string

// GetSalesChannelsParams_UpdatedAt_Eq defines parameters for GetSalesChannels.
type GetSalesChannelsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetSalesChannelsParamsUpdatedAtNot0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsUpdatedAtNot0 = string

// GetSalesChannelsParamsUpdatedAtNot1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsUpdatedAtNot1 = map[string]interface{}

// GetSalesChannelsParamsUpdatedAtNot2 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsUpdatedAtNot2 = []string

// GetSalesChannelsParams_UpdatedAt_Not defines parameters for GetSalesChannels.
type GetSalesChannelsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetSalesChannelsParamsDeletedAtEq0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsDeletedAtEq0 = string

// GetSalesChannelsParamsDeletedAtEq1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsDeletedAtEq1 = []string

// GetSalesChannelsParams_DeletedAt_Eq defines parameters for GetSalesChannels.
type GetSalesChannelsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetSalesChannelsParamsDeletedAtNot0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsDeletedAtNot0 = string

// GetSalesChannelsParamsDeletedAtNot1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsDeletedAtNot1 = map[string]interface{}

// GetSalesChannelsParamsDeletedAtNot2 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsDeletedAtNot2 = []string

// GetSalesChannelsParams_DeletedAt_Not defines parameters for GetSalesChannels.
type GetSalesChannelsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetSalesChannelsParamsLocationId0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsLocationId0 = string

// GetSalesChannelsParamsLocationId1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsLocationId1 = []string

// GetSalesChannelsParamsPublishableKeyId0 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsPublishableKeyId0 = string

// GetSalesChannelsParamsPublishableKeyId1 defines parameters for GetSalesChannels.
type GetSalesChannelsParamsPublishableKeyId1 = []string

// PostSalesChannelsParams defines parameters for PostSalesChannels.
type PostSalesChannelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetSalesChannelsIdParams defines parameters for GetSalesChannelsId.
type GetSalesChannelsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostSalesChannelsIdParams defines parameters for PostSalesChannelsId.
type PostSalesChannelsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostSalesChannelsIdProductsJSONBody defines parameters for PostSalesChannelsIdProducts.
type PostSalesChannelsIdProductsJSONBody struct {
	// Add The products to add to the sales channel.
	Add *[]string `json:"add,omitempty"`

	// Remove The products to remove from the sales channel.
	Remove *[]string `json:"remove,omitempty"`
}

// PostSalesChannelsIdProductsParams defines parameters for PostSalesChannelsIdProducts.
type PostSalesChannelsIdProductsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetShippingOptionsParams defines parameters for GetShippingOptions.
type GetShippingOptionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Q Search term to filter the shipping option's searchable properties.
	Q             *string `form:"q,omitempty" json:"q,omitempty"`
	ServiceZoneId *struct {
		union json.RawMessage
	} `form:"service_zone_id,omitempty" json:"service_zone_id,omitempty"`
	ShippingProfileId *struct {
		union json.RawMessage
	} `form:"shipping_profile_id,omitempty" json:"shipping_profile_id,omitempty"`
	ProviderId *struct {
		union json.RawMessage
	} `form:"provider_id,omitempty" json:"provider_id,omitempty"`
	ShippingOptionTypeId *struct {
		union json.RawMessage
	} `form:"shipping_option_type_id,omitempty" json:"shipping_option_type_id,omitempty"`

	// CreatedAt Filter by a shipping option's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                              `json:"$contains,omitempty"`
		Eq       *GetShippingOptionsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                               `json:"$nin,omitempty"`
		Not *GetShippingOptionsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a shipping option's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                              `json:"$contains,omitempty"`
		Eq       *GetShippingOptionsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                               `json:"$nin,omitempty"`
		Not *GetShippingOptionsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a shipping option's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                              `json:"$contains,omitempty"`
		Eq       *GetShippingOptionsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                               `json:"$nin,omitempty"`
		Not *GetShippingOptionsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	StockLocationId *struct {
		union json.RawMessage
	} `form:"stock_location_id,omitempty" json:"stock_location_id,omitempty"`

	// IsReturn Filter by whether the shipping option is used for returns.
	IsReturn *bool `form:"is_return,omitempty" json:"is_return,omitempty"`

	// AdminOnly Filter by whether the shipping option is used by admin users only.
	AdminOnly *bool `form:"admin_only,omitempty" json:"admin_only,omitempty"`
}

// GetShippingOptionsParamsId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsId0 = string

// GetShippingOptionsParamsId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsId1 = []string

// GetShippingOptionsParamsServiceZoneId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsServiceZoneId0 = string

// GetShippingOptionsParamsServiceZoneId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsServiceZoneId1 = []string

// GetShippingOptionsParamsShippingProfileId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsShippingProfileId0 = string

// GetShippingOptionsParamsShippingProfileId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsShippingProfileId1 = []string

// GetShippingOptionsParamsProviderId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsProviderId0 = string

// GetShippingOptionsParamsProviderId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsProviderId1 = []string

// GetShippingOptionsParamsShippingOptionTypeId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsShippingOptionTypeId0 = string

// GetShippingOptionsParamsShippingOptionTypeId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsShippingOptionTypeId1 = []string

// GetShippingOptionsParamsCreatedAtEq0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsCreatedAtEq0 = string

// GetShippingOptionsParamsCreatedAtEq1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsCreatedAtEq1 = []string

// GetShippingOptionsParams_CreatedAt_Eq defines parameters for GetShippingOptions.
type GetShippingOptionsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetShippingOptionsParamsCreatedAtNot0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsCreatedAtNot0 = string

// GetShippingOptionsParamsCreatedAtNot1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsCreatedAtNot1 = map[string]interface{}

// GetShippingOptionsParamsCreatedAtNot2 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsCreatedAtNot2 = []string

// GetShippingOptionsParams_CreatedAt_Not defines parameters for GetShippingOptions.
type GetShippingOptionsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetShippingOptionsParamsUpdatedAtEq0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsUpdatedAtEq0 = string

// GetShippingOptionsParamsUpdatedAtEq1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsUpdatedAtEq1 = []string

// GetShippingOptionsParams_UpdatedAt_Eq defines parameters for GetShippingOptions.
type GetShippingOptionsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetShippingOptionsParamsUpdatedAtNot0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsUpdatedAtNot0 = string

// GetShippingOptionsParamsUpdatedAtNot1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsUpdatedAtNot1 = map[string]interface{}

// GetShippingOptionsParamsUpdatedAtNot2 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsUpdatedAtNot2 = []string

// GetShippingOptionsParams_UpdatedAt_Not defines parameters for GetShippingOptions.
type GetShippingOptionsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetShippingOptionsParamsDeletedAtEq0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsDeletedAtEq0 = string

// GetShippingOptionsParamsDeletedAtEq1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsDeletedAtEq1 = []string

// GetShippingOptionsParams_DeletedAt_Eq defines parameters for GetShippingOptions.
type GetShippingOptionsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetShippingOptionsParamsDeletedAtNot0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsDeletedAtNot0 = string

// GetShippingOptionsParamsDeletedAtNot1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsDeletedAtNot1 = map[string]interface{}

// GetShippingOptionsParamsDeletedAtNot2 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsDeletedAtNot2 = []string

// GetShippingOptionsParams_DeletedAt_Not defines parameters for GetShippingOptions.
type GetShippingOptionsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetShippingOptionsParamsStockLocationId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsStockLocationId0 = string

// GetShippingOptionsParamsStockLocationId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsStockLocationId1 = []string

// PostShippingOptionsParams defines parameters for PostShippingOptions.
type PostShippingOptionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetShippingOptionsIdParams defines parameters for GetShippingOptionsId.
type GetShippingOptionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data.
	//  * if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields.
	//  * without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostShippingOptionsIdJSONBody defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBody struct {
	// Data The shipping option's data that is useful for third-party providers.
	Data *map[string]interface{} `json:"data,omitempty"`

	// Name The shipping option's name.
	Name *string `json:"name,omitempty"`

	// PriceType The type of the shipping option's price. If `calculated`, its price is retrieved by the  associated fulfillment provider during checkout. If `flat`, its price is set in the `prices` property.
	PriceType *PostShippingOptionsIdJSONBodyPriceType `json:"price_type,omitempty"`

	// Prices The shipping option's prices. If the `price_type` is `calculated`, pass an empty array.
	Prices *[]PostShippingOptionsIdJSONBody_Prices_Item `json:"prices,omitempty"`

	// ProviderId The ID of the associated fulfillment provider that is used to process the option.
	ProviderId *string `json:"provider_id,omitempty"`

	// Rules The shipping option's rules.
	Rules *[]PostShippingOptionsIdJSONBody_Rules_Item `json:"rules,omitempty"`

	// ShippingProfileId The ID of the shipping profile this shipping option belongs to.
	ShippingProfileId *string `json:"shipping_profile_id,omitempty"`

	// Type The shipping option's type.
	Type *struct {
		// Code The type's code.
		Code string `json:"code"`

		// Description The type's description.
		Description string `json:"description"`

		// Label The type's label.
		Label string `json:"label"`
	} `json:"type,omitempty"`
}

// PostShippingOptionsIdParams defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostShippingOptionsIdJSONBodyPriceType defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBodyPriceType string

// PostShippingOptionsIdJSONBodyPrices0 defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBodyPrices0 struct {
	// Amount The price's amount.
	Amount *float32 `json:"amount,omitempty"`

	// CurrencyCode The price's currency code.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// Id The ID of an existing price.
	Id *string `json:"id,omitempty"`
}

// PostShippingOptionsIdJSONBodyPrices1 defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBodyPrices1 struct {
	// Amount The price's amount.
	Amount *float32 `json:"amount,omitempty"`

	// Id The ID of an existing price.
	Id *string `json:"id,omitempty"`

	// RegionId The ID of the associated region.
	RegionId *string `json:"region_id,omitempty"`
}

// PostShippingOptionsIdJSONBody_Prices_Item defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBody_Prices_Item struct {
	union json.RawMessage
}

// PostShippingOptionsIdJSONBodyRules0 defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBodyRules0 struct {
	// Attribute The name of a property or table that the rule applies to.
	Attribute string `json:"attribute"`

	// Operator The operator used to check whether a rule applies.
	Operator PostShippingOptionsIdJSONBodyRules0Operator `json:"operator"`
	Value    PostShippingOptionsIdJSONBody_Rules_0_Value `json:"value"`
}

// PostShippingOptionsIdJSONBodyRules1 defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBodyRules1 struct {
	// Attribute The name of a property or table that the rule applies to.
	Attribute string `json:"attribute"`

	// Id The rule's ID.
	Id string `json:"id"`

	// Operator The operator used to check whether a rule applies.
	Operator PostShippingOptionsIdJSONBodyRules1Operator `json:"operator"`
	Value    PostShippingOptionsIdJSONBody_Rules_1_Value `json:"value"`
}

// PostShippingOptionsIdJSONBody_Rules_Item defines parameters for PostShippingOptionsId.
type PostShippingOptionsIdJSONBody_Rules_Item struct {
	union json.RawMessage
}

// PostShippingOptionsIdRulesBatchJSONBody defines parameters for PostShippingOptionsIdRulesBatch.
type PostShippingOptionsIdRulesBatchJSONBody struct {
	// Create The shipping option rules to create.
	Create *[]AdminCreateShippingOptionRule `json:"create,omitempty"`

	// Delete The shipping option rules to delete.
	Delete *[]string `json:"delete,omitempty"`

	// Update The shipping option rules to update.
	Update *[]AdminUpdateShippingOptionRule `json:"update,omitempty"`
}

// PostShippingOptionsIdRulesBatchParams defines parameters for PostShippingOptionsIdRulesBatch.
type PostShippingOptionsIdRulesBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetShippingProfilesParams defines parameters for GetShippingProfiles.
type GetShippingProfilesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
	Id    *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Q Search term to filter the shipping profile's searchable properties.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Type Filter by a shipping profile's type.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Name Filter by a shipping profile's name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// CreatedAt Filter by a shipping profile's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                               `json:"$contains,omitempty"`
		Eq       *GetShippingProfilesParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                `json:"$nin,omitempty"`
		Not *GetShippingProfilesParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a shipping profile's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                               `json:"$contains,omitempty"`
		Eq       *GetShippingProfilesParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                `json:"$nin,omitempty"`
		Not *GetShippingProfilesParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a shipping profile's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                               `json:"$contains,omitempty"`
		Eq       *GetShippingProfilesParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                                `json:"$nin,omitempty"`
		Not *GetShippingProfilesParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetShippingProfilesParamsId0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsId0 = string

// GetShippingProfilesParamsId1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsId1 = []string

// GetShippingProfilesParamsCreatedAtEq0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsCreatedAtEq0 = string

// GetShippingProfilesParamsCreatedAtEq1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsCreatedAtEq1 = []string

// GetShippingProfilesParams_CreatedAt_Eq defines parameters for GetShippingProfiles.
type GetShippingProfilesParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetShippingProfilesParamsCreatedAtNot0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsCreatedAtNot0 = string

// GetShippingProfilesParamsCreatedAtNot1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsCreatedAtNot1 = map[string]interface{}

// GetShippingProfilesParamsCreatedAtNot2 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsCreatedAtNot2 = []string

// GetShippingProfilesParams_CreatedAt_Not defines parameters for GetShippingProfiles.
type GetShippingProfilesParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetShippingProfilesParamsUpdatedAtEq0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsUpdatedAtEq0 = string

// GetShippingProfilesParamsUpdatedAtEq1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsUpdatedAtEq1 = []string

// GetShippingProfilesParams_UpdatedAt_Eq defines parameters for GetShippingProfiles.
type GetShippingProfilesParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetShippingProfilesParamsUpdatedAtNot0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsUpdatedAtNot0 = string

// GetShippingProfilesParamsUpdatedAtNot1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsUpdatedAtNot1 = map[string]interface{}

// GetShippingProfilesParamsUpdatedAtNot2 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsUpdatedAtNot2 = []string

// GetShippingProfilesParams_UpdatedAt_Not defines parameters for GetShippingProfiles.
type GetShippingProfilesParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetShippingProfilesParamsDeletedAtEq0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsDeletedAtEq0 = string

// GetShippingProfilesParamsDeletedAtEq1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsDeletedAtEq1 = []string

// GetShippingProfilesParams_DeletedAt_Eq defines parameters for GetShippingProfiles.
type GetShippingProfilesParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetShippingProfilesParamsDeletedAtNot0 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsDeletedAtNot0 = string

// GetShippingProfilesParamsDeletedAtNot1 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsDeletedAtNot1 = map[string]interface{}

// GetShippingProfilesParamsDeletedAtNot2 defines parameters for GetShippingProfiles.
type GetShippingProfilesParamsDeletedAtNot2 = []string

// GetShippingProfilesParams_DeletedAt_Not defines parameters for GetShippingProfiles.
type GetShippingProfilesParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostShippingProfilesParams defines parameters for PostShippingProfiles.
type PostShippingProfilesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetShippingProfilesIdParams defines parameters for GetShippingProfilesId.
type GetShippingProfilesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostShippingProfilesIdJSONBody defines parameters for PostShippingProfilesId.
type PostShippingProfilesIdJSONBody struct {
	// Metadata The shipping profile's metadata.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The shipping profile's name.
	Name *string `json:"name,omitempty"`

	// Type The shipping profile's type.
	Type *string `json:"type,omitempty"`
}

// PostShippingProfilesIdParams defines parameters for PostShippingProfilesId.
type PostShippingProfilesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetStockLocationsParams defines parameters for GetStockLocations.
type GetStockLocationsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the stock location's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Name *struct {
		union json.RawMessage
	} `form:"name,omitempty" json:"name,omitempty"`
	AddressId *struct {
		union json.RawMessage
	} `form:"address_id,omitempty" json:"address_id,omitempty"`
	SalesChannelId *struct {
		union json.RawMessage
	} `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// CreatedAt Filter by a stock location's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                             `json:"$contains,omitempty"`
		Eq       *GetStockLocationsParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                              `json:"$nin,omitempty"`
		Not *GetStockLocationsParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a stock location's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                             `json:"$contains,omitempty"`
		Eq       *GetStockLocationsParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                              `json:"$nin,omitempty"`
		Not *GetStockLocationsParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a stock location's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                             `json:"$contains,omitempty"`
		Eq       *GetStockLocationsParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                              `json:"$nin,omitempty"`
		Not *GetStockLocationsParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetStockLocationsParamsId0 defines parameters for GetStockLocations.
type GetStockLocationsParamsId0 = string

// GetStockLocationsParamsId1 defines parameters for GetStockLocations.
type GetStockLocationsParamsId1 = []string

// GetStockLocationsParamsName0 defines parameters for GetStockLocations.
type GetStockLocationsParamsName0 = string

// GetStockLocationsParamsName1 defines parameters for GetStockLocations.
type GetStockLocationsParamsName1 = []string

// GetStockLocationsParamsAddressId0 defines parameters for GetStockLocations.
type GetStockLocationsParamsAddressId0 = string

// GetStockLocationsParamsAddressId1 defines parameters for GetStockLocations.
type GetStockLocationsParamsAddressId1 = []string

// GetStockLocationsParamsSalesChannelId0 defines parameters for GetStockLocations.
type GetStockLocationsParamsSalesChannelId0 = string

// GetStockLocationsParamsSalesChannelId1 defines parameters for GetStockLocations.
type GetStockLocationsParamsSalesChannelId1 = []string

// GetStockLocationsParamsCreatedAtEq0 defines parameters for GetStockLocations.
type GetStockLocationsParamsCreatedAtEq0 = string

// GetStockLocationsParamsCreatedAtEq1 defines parameters for GetStockLocations.
type GetStockLocationsParamsCreatedAtEq1 = []string

// GetStockLocationsParams_CreatedAt_Eq defines parameters for GetStockLocations.
type GetStockLocationsParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetStockLocationsParamsCreatedAtNot0 defines parameters for GetStockLocations.
type GetStockLocationsParamsCreatedAtNot0 = string

// GetStockLocationsParamsCreatedAtNot1 defines parameters for GetStockLocations.
type GetStockLocationsParamsCreatedAtNot1 = map[string]interface{}

// GetStockLocationsParamsCreatedAtNot2 defines parameters for GetStockLocations.
type GetStockLocationsParamsCreatedAtNot2 = []string

// GetStockLocationsParams_CreatedAt_Not defines parameters for GetStockLocations.
type GetStockLocationsParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetStockLocationsParamsUpdatedAtEq0 defines parameters for GetStockLocations.
type GetStockLocationsParamsUpdatedAtEq0 = string

// GetStockLocationsParamsUpdatedAtEq1 defines parameters for GetStockLocations.
type GetStockLocationsParamsUpdatedAtEq1 = []string

// GetStockLocationsParams_UpdatedAt_Eq defines parameters for GetStockLocations.
type GetStockLocationsParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetStockLocationsParamsUpdatedAtNot0 defines parameters for GetStockLocations.
type GetStockLocationsParamsUpdatedAtNot0 = string

// GetStockLocationsParamsUpdatedAtNot1 defines parameters for GetStockLocations.
type GetStockLocationsParamsUpdatedAtNot1 = map[string]interface{}

// GetStockLocationsParamsUpdatedAtNot2 defines parameters for GetStockLocations.
type GetStockLocationsParamsUpdatedAtNot2 = []string

// GetStockLocationsParams_UpdatedAt_Not defines parameters for GetStockLocations.
type GetStockLocationsParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetStockLocationsParamsDeletedAtEq0 defines parameters for GetStockLocations.
type GetStockLocationsParamsDeletedAtEq0 = string

// GetStockLocationsParamsDeletedAtEq1 defines parameters for GetStockLocations.
type GetStockLocationsParamsDeletedAtEq1 = []string

// GetStockLocationsParams_DeletedAt_Eq defines parameters for GetStockLocations.
type GetStockLocationsParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetStockLocationsParamsDeletedAtNot0 defines parameters for GetStockLocations.
type GetStockLocationsParamsDeletedAtNot0 = string

// GetStockLocationsParamsDeletedAtNot1 defines parameters for GetStockLocations.
type GetStockLocationsParamsDeletedAtNot1 = map[string]interface{}

// GetStockLocationsParamsDeletedAtNot2 defines parameters for GetStockLocations.
type GetStockLocationsParamsDeletedAtNot2 = []string

// GetStockLocationsParams_DeletedAt_Not defines parameters for GetStockLocations.
type GetStockLocationsParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostStockLocationsParams defines parameters for PostStockLocations.
type PostStockLocationsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetStockLocationsIdParams defines parameters for GetStockLocationsId.
type GetStockLocationsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStockLocationsIdParams defines parameters for PostStockLocationsId.
type PostStockLocationsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStockLocationsIdFulfillmentProvidersJSONBody defines parameters for PostStockLocationsIdFulfillmentProviders.
type PostStockLocationsIdFulfillmentProvidersJSONBody struct {
	// Add The fulfillment providers to add to the stock location.
	Add *[]string `json:"add,omitempty"`

	// Remove The fulfillment providers to remove from the stock location.
	Remove *[]string `json:"remove,omitempty"`
}

// PostStockLocationsIdFulfillmentProvidersParams defines parameters for PostStockLocationsIdFulfillmentProviders.
type PostStockLocationsIdFulfillmentProvidersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStockLocationsIdFulfillmentSetsJSONBody defines parameters for PostStockLocationsIdFulfillmentSets.
type PostStockLocationsIdFulfillmentSetsJSONBody struct {
	// Name The fulfillment set's name.
	Name string `json:"name"`

	// Type The fulfillment set's type.
	Type string `json:"type"`
}

// PostStockLocationsIdFulfillmentSetsParams defines parameters for PostStockLocationsIdFulfillmentSets.
type PostStockLocationsIdFulfillmentSetsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStockLocationsIdSalesChannelsJSONBody defines parameters for PostStockLocationsIdSalesChannels.
type PostStockLocationsIdSalesChannelsJSONBody struct {
	// Add The sales channels to add.
	Add *[]string `json:"add,omitempty"`

	// Remove The sales channels to remove.
	Remove *[]string `json:"remove,omitempty"`
}

// PostStockLocationsIdSalesChannelsParams defines parameters for PostStockLocationsIdSalesChannels.
type PostStockLocationsIdSalesChannelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetStoresParams defines parameters for GetStores.
type GetStoresParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter the store's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	Name *struct {
		union json.RawMessage
	} `form:"name,omitempty" json:"name,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetStoresParamsId0 defines parameters for GetStores.
type GetStoresParamsId0 = string

// GetStoresParamsId1 defines parameters for GetStores.
type GetStoresParamsId1 = []string

// GetStoresParamsName0 defines parameters for GetStores.
type GetStoresParamsName0 = string

// GetStoresParamsName1 defines parameters for GetStores.
type GetStoresParamsName1 = []string

// GetStoresIdParams defines parameters for GetStoresId.
type GetStoresIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStoresIdParams defines parameters for PostStoresId.
type PostStoresIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetTaxRatesParams defines parameters for GetTaxRates.
type GetTaxRatesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search terms to filter the tax rate's searchable properties.
	Q           *string `form:"q,omitempty" json:"q,omitempty"`
	TaxRegionId *struct {
		union json.RawMessage
	} `form:"tax_region_id,omitempty" json:"tax_region_id,omitempty"`

	// IsDefault Filter by whether the tax rate is a default in its tax region.
	IsDefault *GetTaxRatesParamsIsDefault `form:"is_default,omitempty" json:"is_default,omitempty"`

	// CreatedAt Filter by a tax rate's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetTaxRatesParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetTaxRatesParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a tax rate's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetTaxRatesParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetTaxRatesParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a tax rate's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                       `json:"$contains,omitempty"`
		Eq       *GetTaxRatesParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                        `json:"$nin,omitempty"`
		Not *GetTaxRatesParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`

	// ServiceZoneId Filter by a service zone's ID to retrieve its associated tax rates.
	ServiceZoneId *string `form:"service_zone_id,omitempty" json:"service_zone_id,omitempty"`

	// ShippingProfileId Filter by a shipping profile's ID to retrieve its associated tax rates.
	ShippingProfileId *string `form:"shipping_profile_id,omitempty" json:"shipping_profile_id,omitempty"`

	// ProviderId Filter by a fulfillment provider's ID to retrieve its associated tax rates.
	ProviderId *string `form:"provider_id,omitempty" json:"provider_id,omitempty"`

	// ShippingOptionTypeId Filter by a shipping option type's ID to retrieve its associated tax rates.
	ShippingOptionTypeId *string `form:"shipping_option_type_id,omitempty" json:"shipping_option_type_id,omitempty"`
}

// GetTaxRatesParamsTaxRegionId0 defines parameters for GetTaxRates.
type GetTaxRatesParamsTaxRegionId0 = string

// GetTaxRatesParamsTaxRegionId1 defines parameters for GetTaxRates.
type GetTaxRatesParamsTaxRegionId1 = []string

// GetTaxRatesParamsTaxRegionId2 defines parameters for GetTaxRates.
type GetTaxRatesParamsTaxRegionId2 struct {
	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string `json:"$contains,omitempty"`

	// Eq Filter by an exact match.
	Eq *string `json:"$eq,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array's items.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array's items.
	Nin *[]string `json:"$nin,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetTaxRatesParamsIsDefault defines parameters for GetTaxRates.
type GetTaxRatesParamsIsDefault string

// GetTaxRatesParamsCreatedAtEq0 defines parameters for GetTaxRates.
type GetTaxRatesParamsCreatedAtEq0 = string

// GetTaxRatesParamsCreatedAtEq1 defines parameters for GetTaxRates.
type GetTaxRatesParamsCreatedAtEq1 = []string

// GetTaxRatesParams_CreatedAt_Eq defines parameters for GetTaxRates.
type GetTaxRatesParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetTaxRatesParamsCreatedAtNot0 defines parameters for GetTaxRates.
type GetTaxRatesParamsCreatedAtNot0 = string

// GetTaxRatesParamsCreatedAtNot1 defines parameters for GetTaxRates.
type GetTaxRatesParamsCreatedAtNot1 = map[string]interface{}

// GetTaxRatesParamsCreatedAtNot2 defines parameters for GetTaxRates.
type GetTaxRatesParamsCreatedAtNot2 = []string

// GetTaxRatesParams_CreatedAt_Not defines parameters for GetTaxRates.
type GetTaxRatesParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetTaxRatesParamsUpdatedAtEq0 defines parameters for GetTaxRates.
type GetTaxRatesParamsUpdatedAtEq0 = string

// GetTaxRatesParamsUpdatedAtEq1 defines parameters for GetTaxRates.
type GetTaxRatesParamsUpdatedAtEq1 = []string

// GetTaxRatesParams_UpdatedAt_Eq defines parameters for GetTaxRates.
type GetTaxRatesParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetTaxRatesParamsUpdatedAtNot0 defines parameters for GetTaxRates.
type GetTaxRatesParamsUpdatedAtNot0 = string

// GetTaxRatesParamsUpdatedAtNot1 defines parameters for GetTaxRates.
type GetTaxRatesParamsUpdatedAtNot1 = map[string]interface{}

// GetTaxRatesParamsUpdatedAtNot2 defines parameters for GetTaxRates.
type GetTaxRatesParamsUpdatedAtNot2 = []string

// GetTaxRatesParams_UpdatedAt_Not defines parameters for GetTaxRates.
type GetTaxRatesParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetTaxRatesParamsDeletedAtEq0 defines parameters for GetTaxRates.
type GetTaxRatesParamsDeletedAtEq0 = string

// GetTaxRatesParamsDeletedAtEq1 defines parameters for GetTaxRates.
type GetTaxRatesParamsDeletedAtEq1 = []string

// GetTaxRatesParams_DeletedAt_Eq defines parameters for GetTaxRates.
type GetTaxRatesParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetTaxRatesParamsDeletedAtNot0 defines parameters for GetTaxRates.
type GetTaxRatesParamsDeletedAtNot0 = string

// GetTaxRatesParamsDeletedAtNot1 defines parameters for GetTaxRates.
type GetTaxRatesParamsDeletedAtNot1 = map[string]interface{}

// GetTaxRatesParamsDeletedAtNot2 defines parameters for GetTaxRates.
type GetTaxRatesParamsDeletedAtNot2 = []string

// GetTaxRatesParams_DeletedAt_Not defines parameters for GetTaxRates.
type GetTaxRatesParams_DeletedAt_Not struct {
	union json.RawMessage
}

// PostTaxRatesParams defines parameters for PostTaxRates.
type PostTaxRatesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetTaxRatesIdParams defines parameters for GetTaxRatesId.
type GetTaxRatesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostTaxRatesIdParams defines parameters for PostTaxRatesId.
type PostTaxRatesIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostTaxRatesIdRulesParams defines parameters for PostTaxRatesIdRules.
type PostTaxRatesIdRulesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteTaxRatesIdRulesRuleIdParams defines parameters for DeleteTaxRatesIdRulesRuleId.
type DeleteTaxRatesIdRulesRuleIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetTaxRegionsParams defines parameters for GetTaxRegions.
type GetTaxRegionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Search term to filter a tax region's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`
	CountryCode *struct {
		union json.RawMessage
	} `form:"country_code,omitempty" json:"country_code,omitempty"`
	ProvinceCode *struct {
		union json.RawMessage
	} `form:"province_code,omitempty" json:"province_code,omitempty"`
	ParentId *struct {
		union json.RawMessage
	} `form:"parent_id,omitempty" json:"parent_id,omitempty"`
	CreatedBy *struct {
		union json.RawMessage
	} `form:"created_by,omitempty" json:"created_by,omitempty"`

	// CreatedAt Filter by a tax region's creation date.
	CreatedAt *struct {
		union json.RawMessage
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a tax region's update date.
	UpdatedAt *struct {
		union json.RawMessage
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a tax region's deletion date.
	DeletedAt *struct {
		union json.RawMessage
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
	And *[]map[string]interface{} `form:"$and,omitempty" json:"$and,omitempty"`
	Or  *[]map[string]interface{} `form:"$or,omitempty" json:"$or,omitempty"`
}

// GetTaxRegionsParamsId0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsId0 = string

// GetTaxRegionsParamsId1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsId1 = []string

// GetTaxRegionsParamsCountryCode0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCountryCode0 = string

// GetTaxRegionsParamsCountryCode1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCountryCode1 = []string

// GetTaxRegionsParamsCountryCode2 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCountryCode2 struct {
	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string `json:"$contains,omitempty"`

	// Eq Filter by an exact match.
	Eq *string `json:"$eq,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array's items.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array's items.
	Nin *[]string `json:"$nin,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetTaxRegionsParamsProvinceCode0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsProvinceCode0 = string

// GetTaxRegionsParamsProvinceCode1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsProvinceCode1 = []string

// GetTaxRegionsParamsProvinceCode2 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsProvinceCode2 struct {
	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string `json:"$contains,omitempty"`

	// Eq Filter by an exact match.
	Eq *string `json:"$eq,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array's items.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array's items.
	Nin *[]string `json:"$nin,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetTaxRegionsParamsParentId0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsParentId0 = string

// GetTaxRegionsParamsParentId1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsParentId1 = []string

// GetTaxRegionsParamsParentId2 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsParentId2 struct {
	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string `json:"$contains,omitempty"`

	// Eq Filter by an exact match.
	Eq *string `json:"$eq,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array's items.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not matching this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array's items.
	Nin *[]string `json:"$nin,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetTaxRegionsParamsCreatedBy0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCreatedBy0 = string

// GetTaxRegionsParamsCreatedBy1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCreatedBy1 = []string

// GetTaxRegionsParamsCreatedAt0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCreatedAt0 = string

// GetTaxRegionsParamsCreatedAt1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsCreatedAt1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetTaxRegionsParams_CreatedAt_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetTaxRegionsParams_CreatedAt_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetTaxRegionsParamsUpdatedAt0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsUpdatedAt0 = string

// GetTaxRegionsParamsUpdatedAt1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsUpdatedAt1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetTaxRegionsParams_UpdatedAt_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetTaxRegionsParams_UpdatedAt_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// GetTaxRegionsParamsDeletedAt0 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsDeletedAt0 = string

// GetTaxRegionsParamsDeletedAt1 defines parameters for GetTaxRegions.
type GetTaxRegionsParamsDeletedAt1 struct {
	// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
	And *[]map[string]interface{} `json:"$and,omitempty"`

	// Contained Filter arrays that contain all values of this parameter.
	Contained *[]string `json:"$contained,omitempty"`

	// Contains Filter arrays that contain some of the values of this parameter.
	Contains *[]string                           `json:"$contains,omitempty"`
	Eq       *GetTaxRegionsParams_DeletedAt_1_Eq `json:"$eq,omitempty"`

	// Exists Filter by whether a value for this parameter exists (not `null`).
	Exists *bool `json:"$exists,omitempty"`

	// Fulltext Filter to apply on full-text properties.
	Fulltext *string `json:"$fulltext,omitempty"`

	// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
	Gt *string `json:"$gt,omitempty"`

	// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
	Gte *string `json:"$gte,omitempty"`

	// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
	Ilike *string `json:"$ilike,omitempty"`

	// In Filter by values in this array.
	In *[]string `json:"$in,omitempty"`

	// Like Apply a `like` filter. Useful for strings only.
	Like *string `json:"$like,omitempty"`

	// Lt Filter by values less than this parameter. Useful for numbers and dates only.
	Lt *string `json:"$lt,omitempty"`

	// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
	Lte *string `json:"$lte,omitempty"`

	// Ne Filter by values not equal to this parameter.
	Ne *string `json:"$ne,omitempty"`

	// Nin Filter by values not in this array.
	Nin *[]string                            `json:"$nin,omitempty"`
	Not *GetTaxRegionsParams_DeletedAt_1_Not `json:"$not,omitempty"`

	// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
	Or *[]map[string]interface{} `json:"$or,omitempty"`

	// Overlap Filter arrays that have overlapping values with this parameter.
	Overlap *[]string `json:"$overlap,omitempty"`

	// Re Apply a regex filter. Useful for strings only.
	Re *string `json:"$re,omitempty"`
}

// PostTaxRegionsParams defines parameters for PostTaxRegions.
type PostTaxRegionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetTaxRegionsIdParams defines parameters for GetTaxRegionsId.
type GetTaxRegionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostUploadsJSONBody defines parameters for PostUploads.
type PostUploadsJSONBody struct {
	union json.RawMessage
}

// PostUploadsJSONBody0 defines parameters for PostUploads.
type PostUploadsJSONBody0 struct {
	// Files The upload's files.
	Files []PostUploadsJSONBody_0_Files_Item `json:"files"`
}

// PostUploadsJSONBody1 defines parameters for PostUploads.
type PostUploadsJSONBody1 = []map[string]interface{}

// GetUploadsIdParams defines parameters for GetUploadsId.
type GetUploadsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q The search term to filter the user's searchable properties.
	Q  *string `form:"q,omitempty" json:"q,omitempty"`
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Email Filter by an email.
	Email *openapi_types.Email `form:"email,omitempty" json:"email,omitempty"`

	// FirstName Filter by a first name.
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty"`

	// LastName Filter by a last name.
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty"`

	// CreatedAt Filter by a user's creation date.
	CreatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                    `json:"$contains,omitempty"`
		Eq       *GetUsersParams_CreatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                     `json:"$nin,omitempty"`
		Not *GetUsersParams_CreatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a user's update date.
	UpdatedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                    `json:"$contains,omitempty"`
		Eq       *GetUsersParams_UpdatedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                     `json:"$nin,omitempty"`
		Not *GetUsersParams_UpdatedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a user's deletion date.
	DeletedAt *struct {
		// And Join query parameters with an AND condition. Each object's content is the same type as the expected query parameters.
		And *[]map[string]interface{} `json:"$and,omitempty"`

		// Contained Filter arrays that contain all values of this parameter.
		Contained *[]string `json:"$contained,omitempty"`

		// Contains Filter arrays that contain some of the values of this parameter.
		Contains *[]string                    `json:"$contains,omitempty"`
		Eq       *GetUsersParams_DeletedAt_Eq `json:"$eq,omitempty"`

		// Exists Filter by whether a value for this parameter exists (not `null`).
		Exists *bool `json:"$exists,omitempty"`

		// Fulltext Filter to apply on full-text properties.
		Fulltext *string `json:"$fulltext,omitempty"`

		// Gt Filter by values greater than this parameter. Useful for numbers and dates only.
		Gt *string `json:"$gt,omitempty"`

		// Gte Filter by values greater than or equal to this parameter. Useful for numbers and dates only.
		Gte *string `json:"$gte,omitempty"`

		// Ilike Apply a case-insensitive `like` filter. Useful for strings only.
		Ilike *string `json:"$ilike,omitempty"`

		// In Filter by values in this array.
		In *[]string `json:"$in,omitempty"`

		// Like Apply a `like` filter. Useful for strings only.
		Like *string `json:"$like,omitempty"`

		// Lt Filter by values less than this parameter. Useful for numbers and dates only.
		Lt *string `json:"$lt,omitempty"`

		// Lte Filter by values less than or equal to this parameter. Useful for numbers and dates only.
		Lte *string `json:"$lte,omitempty"`

		// Ne Filter by values not equal to this parameter.
		Ne *string `json:"$ne,omitempty"`

		// Nin Filter by values not in this array.
		Nin *[]string                     `json:"$nin,omitempty"`
		Not *GetUsersParams_DeletedAt_Not `json:"$not,omitempty"`

		// Or Join query parameters with an OR condition. Each object's content is the same type as the expected query parameters.
		Or *[]map[string]interface{} `json:"$or,omitempty"`

		// Overlap Filter arrays that have overlapping values with this parameter.
		Overlap *[]string `json:"$overlap,omitempty"`

		// Re Apply a regex filter. Useful for strings only.
		Re *string `json:"$re,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// GetUsersParamsId0 defines parameters for GetUsers.
type GetUsersParamsId0 = string

// GetUsersParamsId1 defines parameters for GetUsers.
type GetUsersParamsId1 = []string

// GetUsersParamsCreatedAtEq0 defines parameters for GetUsers.
type GetUsersParamsCreatedAtEq0 = string

// GetUsersParamsCreatedAtEq1 defines parameters for GetUsers.
type GetUsersParamsCreatedAtEq1 = []string

// GetUsersParams_CreatedAt_Eq defines parameters for GetUsers.
type GetUsersParams_CreatedAt_Eq struct {
	union json.RawMessage
}

// GetUsersParamsCreatedAtNot0 defines parameters for GetUsers.
type GetUsersParamsCreatedAtNot0 = string

// GetUsersParamsCreatedAtNot1 defines parameters for GetUsers.
type GetUsersParamsCreatedAtNot1 = map[string]interface{}

// GetUsersParamsCreatedAtNot2 defines parameters for GetUsers.
type GetUsersParamsCreatedAtNot2 = []string

// GetUsersParams_CreatedAt_Not defines parameters for GetUsers.
type GetUsersParams_CreatedAt_Not struct {
	union json.RawMessage
}

// GetUsersParamsUpdatedAtEq0 defines parameters for GetUsers.
type GetUsersParamsUpdatedAtEq0 = string

// GetUsersParamsUpdatedAtEq1 defines parameters for GetUsers.
type GetUsersParamsUpdatedAtEq1 = []string

// GetUsersParams_UpdatedAt_Eq defines parameters for GetUsers.
type GetUsersParams_UpdatedAt_Eq struct {
	union json.RawMessage
}

// GetUsersParamsUpdatedAtNot0 defines parameters for GetUsers.
type GetUsersParamsUpdatedAtNot0 = string

// GetUsersParamsUpdatedAtNot1 defines parameters for GetUsers.
type GetUsersParamsUpdatedAtNot1 = map[string]interface{}

// GetUsersParamsUpdatedAtNot2 defines parameters for GetUsers.
type GetUsersParamsUpdatedAtNot2 = []string

// GetUsersParams_UpdatedAt_Not defines parameters for GetUsers.
type GetUsersParams_UpdatedAt_Not struct {
	union json.RawMessage
}

// GetUsersParamsDeletedAtEq0 defines parameters for GetUsers.
type GetUsersParamsDeletedAtEq0 = string

// GetUsersParamsDeletedAtEq1 defines parameters for GetUsers.
type GetUsersParamsDeletedAtEq1 = []string

// GetUsersParams_DeletedAt_Eq defines parameters for GetUsers.
type GetUsersParams_DeletedAt_Eq struct {
	union json.RawMessage
}

// GetUsersParamsDeletedAtNot0 defines parameters for GetUsers.
type GetUsersParamsDeletedAtNot0 = string

// GetUsersParamsDeletedAtNot1 defines parameters for GetUsers.
type GetUsersParamsDeletedAtNot1 = map[string]interface{}

// GetUsersParamsDeletedAtNot2 defines parameters for GetUsers.
type GetUsersParamsDeletedAtNot2 = []string

// GetUsersParams_DeletedAt_Not defines parameters for GetUsers.
type GetUsersParams_DeletedAt_Not struct {
	union json.RawMessage
}

// GetUsersMeParams defines parameters for GetUsersMe.
type GetUsersMeParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetUsersIdParams defines parameters for GetUsersId.
type GetUsersIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostUsersIdParams defines parameters for PostUsersId.
type PostUsersIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetWorkflowsExecutionsParams defines parameters for GetWorkflowsExecutions.
type GetWorkflowsExecutionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of items to skip when retrieving a list.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of items returned in the list.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order         *string `form:"order,omitempty" json:"order,omitempty"`
	TransactionId *struct {
		union json.RawMessage
	} `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
	WorkflowId *struct {
		union json.RawMessage
	} `form:"workflow_id,omitempty" json:"workflow_id,omitempty"`
}

// GetWorkflowsExecutionsParamsTransactionId0 defines parameters for GetWorkflowsExecutions.
type GetWorkflowsExecutionsParamsTransactionId0 = string

// GetWorkflowsExecutionsParamsTransactionId1 defines parameters for GetWorkflowsExecutions.
type GetWorkflowsExecutionsParamsTransactionId1 = []string

// GetWorkflowsExecutionsParamsWorkflowId0 defines parameters for GetWorkflowsExecutions.
type GetWorkflowsExecutionsParamsWorkflowId0 = string

// GetWorkflowsExecutionsParamsWorkflowId1 defines parameters for GetWorkflowsExecutions.
type GetWorkflowsExecutionsParamsWorkflowId1 = []string

// GetWorkflowsExecutionsIdParams defines parameters for GetWorkflowsExecutionsId.
type GetWorkflowsExecutionsIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetWorkflowsExecutionsWorkflowIdTransactionIdParams defines parameters for GetWorkflowsExecutionsWorkflowIdTransactionId.
type GetWorkflowsExecutionsWorkflowIdTransactionIdParams struct {
	// Expand Comma-separated relations that should be expanded in the returned data.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned data. if a field is prefixed with `+` it will be added to the default fields, using `-` will remove it from the default fields. without prefix it will replace the entire default fields.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostActorTypeAuthProviderJSONBody defines parameters for PostActorTypeAuthProvider.
type PostActorTypeAuthProviderJSONBody = map[string]interface{}

// PostActorTypeAuthProviderRegisterJSONBody defines parameters for PostActorTypeAuthProviderRegister.
type PostActorTypeAuthProviderRegisterJSONBody = map[string]interface{}

// PostApiKeysJSONRequestBody defines body for PostApiKeys for application/json ContentType.
type PostApiKeysJSONRequestBody = AdminCreateApiKey

// PostApiKeysIdJSONRequestBody defines body for PostApiKeysId for application/json ContentType.
type PostApiKeysIdJSONRequestBody = AdminUpdateApiKey

// PostApiKeysIdRevokeJSONRequestBody defines body for PostApiKeysIdRevoke for application/json ContentType.
type PostApiKeysIdRevokeJSONRequestBody = AdminRevokeApiKey

// PostApiKeysIdSalesChannelsJSONRequestBody defines body for PostApiKeysIdSalesChannels for application/json ContentType.
type PostApiKeysIdSalesChannelsJSONRequestBody PostApiKeysIdSalesChannelsJSONBody

// PostCampaignsJSONRequestBody defines body for PostCampaigns for application/json ContentType.
type PostCampaignsJSONRequestBody PostCampaignsJSONBody

// PostCampaignsIdJSONRequestBody defines body for PostCampaignsId for application/json ContentType.
type PostCampaignsIdJSONRequestBody PostCampaignsIdJSONBody

// PostCampaignsIdPromotionsJSONRequestBody defines body for PostCampaignsIdPromotions for application/json ContentType.
type PostCampaignsIdPromotionsJSONRequestBody PostCampaignsIdPromotionsJSONBody

// PostClaimsJSONRequestBody defines body for PostClaims for application/json ContentType.
type PostClaimsJSONRequestBody = AdminPostOrderClaimsReqSchema

// PostClaimsIdCancelJSONRequestBody defines body for PostClaimsIdCancel for application/json ContentType.
type PostClaimsIdCancelJSONRequestBody = AdminPostCancelClaimReqSchema

// PostClaimsIdClaimItemsJSONRequestBody defines body for PostClaimsIdClaimItems for application/json ContentType.
type PostClaimsIdClaimItemsJSONRequestBody = AdminPostClaimItemsReqSchema

// PostClaimsIdClaimItemsActionIdJSONRequestBody defines body for PostClaimsIdClaimItemsActionId for application/json ContentType.
type PostClaimsIdClaimItemsActionIdJSONRequestBody = AdminPostClaimsItemsActionReqSchema

// PostClaimsIdInboundItemsJSONRequestBody defines body for PostClaimsIdInboundItems for application/json ContentType.
type PostClaimsIdInboundItemsJSONRequestBody = AdminPostReturnsRequestItemsReqSchema

// PostClaimsIdInboundItemsActionIdJSONRequestBody defines body for PostClaimsIdInboundItemsActionId for application/json ContentType.
type PostClaimsIdInboundItemsActionIdJSONRequestBody = AdminPostReturnsRequestItemsActionReqSchema

// PostClaimsIdInboundShippingMethodJSONRequestBody defines body for PostClaimsIdInboundShippingMethod for application/json ContentType.
type PostClaimsIdInboundShippingMethodJSONRequestBody = AdminPostReturnsShippingReqSchema

// PostClaimsIdInboundShippingMethodActionIdJSONRequestBody defines body for PostClaimsIdInboundShippingMethodActionId for application/json ContentType.
type PostClaimsIdInboundShippingMethodActionIdJSONRequestBody = AdminPostClaimsShippingActionReqSchema

// PostClaimsIdOutboundItemsJSONRequestBody defines body for PostClaimsIdOutboundItems for application/json ContentType.
type PostClaimsIdOutboundItemsJSONRequestBody = AdminPostClaimsAddItemsReqSchema

// PostClaimsIdOutboundItemsActionIdJSONRequestBody defines body for PostClaimsIdOutboundItemsActionId for application/json ContentType.
type PostClaimsIdOutboundItemsActionIdJSONRequestBody = AdminPostClaimsItemsActionReqSchema

// PostClaimsIdOutboundShippingMethodJSONRequestBody defines body for PostClaimsIdOutboundShippingMethod for application/json ContentType.
type PostClaimsIdOutboundShippingMethodJSONRequestBody = AdminPostClaimsShippingReqSchema

// PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody defines body for PostClaimsIdOutboundShippingMethodActionId for application/json ContentType.
type PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody = AdminPostClaimsShippingActionReqSchema

// PostCollectionsJSONRequestBody defines body for PostCollections for application/json ContentType.
type PostCollectionsJSONRequestBody = AdminCreateCollection

// PostCollectionsIdJSONRequestBody defines body for PostCollectionsId for application/json ContentType.
type PostCollectionsIdJSONRequestBody = AdminUpdateCollection

// PostCollectionsIdProductsJSONRequestBody defines body for PostCollectionsIdProducts for application/json ContentType.
type PostCollectionsIdProductsJSONRequestBody PostCollectionsIdProductsJSONBody

// PostCustomerGroupsJSONRequestBody defines body for PostCustomerGroups for application/json ContentType.
type PostCustomerGroupsJSONRequestBody = AdminCreateCustomerGroup

// PostCustomerGroupsIdJSONRequestBody defines body for PostCustomerGroupsId for application/json ContentType.
type PostCustomerGroupsIdJSONRequestBody = AdminUpdateCustomerGroup

// PostCustomerGroupsIdCustomersJSONRequestBody defines body for PostCustomerGroupsIdCustomers for application/json ContentType.
type PostCustomerGroupsIdCustomersJSONRequestBody PostCustomerGroupsIdCustomersJSONBody

// PostCustomersJSONRequestBody defines body for PostCustomers for application/json ContentType.
type PostCustomersJSONRequestBody PostCustomersJSONBody

// PostCustomersIdJSONRequestBody defines body for PostCustomersId for application/json ContentType.
type PostCustomersIdJSONRequestBody PostCustomersIdJSONBody

// PostCustomersIdAddressesJSONRequestBody defines body for PostCustomersIdAddresses for application/json ContentType.
type PostCustomersIdAddressesJSONRequestBody PostCustomersIdAddressesJSONBody

// PostCustomersIdAddressesAddressIdJSONRequestBody defines body for PostCustomersIdAddressesAddressId for application/json ContentType.
type PostCustomersIdAddressesAddressIdJSONRequestBody PostCustomersIdAddressesAddressIdJSONBody

// PostDraftOrdersJSONRequestBody defines body for PostDraftOrders for application/json ContentType.
type PostDraftOrdersJSONRequestBody PostDraftOrdersJSONBody

// PostExchangesJSONRequestBody defines body for PostExchanges for application/json ContentType.
type PostExchangesJSONRequestBody = AdminPostOrderExchangesReqSchema

// PostExchangesIdCancelJSONRequestBody defines body for PostExchangesIdCancel for application/json ContentType.
type PostExchangesIdCancelJSONRequestBody = AdminPostCancelExchangeReqSchema

// PostExchangesIdInboundItemsJSONRequestBody defines body for PostExchangesIdInboundItems for application/json ContentType.
type PostExchangesIdInboundItemsJSONRequestBody = AdminPostExchangesReturnRequestItemsReqSchema

// PostExchangesIdInboundItemsActionIdJSONRequestBody defines body for PostExchangesIdInboundItemsActionId for application/json ContentType.
type PostExchangesIdInboundItemsActionIdJSONRequestBody = AdminPostExchangesRequestItemsReturnActionReqSchema

// PostExchangesIdInboundShippingMethodJSONRequestBody defines body for PostExchangesIdInboundShippingMethod for application/json ContentType.
type PostExchangesIdInboundShippingMethodJSONRequestBody = AdminPostReturnsShippingReqSchema

// PostExchangesIdInboundShippingMethodActionIdJSONRequestBody defines body for PostExchangesIdInboundShippingMethodActionId for application/json ContentType.
type PostExchangesIdInboundShippingMethodActionIdJSONRequestBody = AdminPostExchangesShippingActionReqSchema

// PostExchangesIdOutboundItemsJSONRequestBody defines body for PostExchangesIdOutboundItems for application/json ContentType.
type PostExchangesIdOutboundItemsJSONRequestBody = AdminPostExchangesAddItemsReqSchema

// PostExchangesIdOutboundItemsActionIdJSONRequestBody defines body for PostExchangesIdOutboundItemsActionId for application/json ContentType.
type PostExchangesIdOutboundItemsActionIdJSONRequestBody = AdminPostExchangesItemsActionReqSchema

// PostExchangesIdOutboundShippingMethodJSONRequestBody defines body for PostExchangesIdOutboundShippingMethod for application/json ContentType.
type PostExchangesIdOutboundShippingMethodJSONRequestBody = AdminPostExchangesShippingReqSchema

// PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody defines body for PostExchangesIdOutboundShippingMethodActionId for application/json ContentType.
type PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody = AdminPostExchangesShippingActionReqSchema

// PostFulfillmentSetsIdServiceZonesJSONRequestBody defines body for PostFulfillmentSetsIdServiceZones for application/json ContentType.
type PostFulfillmentSetsIdServiceZonesJSONRequestBody PostFulfillmentSetsIdServiceZonesJSONBody

// PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody defines body for PostFulfillmentSetsIdServiceZonesZoneId for application/json ContentType.
type PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody PostFulfillmentSetsIdServiceZonesZoneIdJSONBody

// PostFulfillmentsJSONRequestBody defines body for PostFulfillments for application/json ContentType.
type PostFulfillmentsJSONRequestBody = AdminCreateFulfillment

// PostFulfillmentsIdShipmentJSONRequestBody defines body for PostFulfillmentsIdShipment for application/json ContentType.
type PostFulfillmentsIdShipmentJSONRequestBody = AdminCreateShipment

// PostInventoryItemsJSONRequestBody defines body for PostInventoryItems for application/json ContentType.
type PostInventoryItemsJSONRequestBody = AdminCreateInventoryItem

// PostInventoryItemsIdJSONRequestBody defines body for PostInventoryItemsId for application/json ContentType.
type PostInventoryItemsIdJSONRequestBody PostInventoryItemsIdJSONBody

// PostInventoryItemsIdLocationLevelsJSONRequestBody defines body for PostInventoryItemsIdLocationLevels for application/json ContentType.
type PostInventoryItemsIdLocationLevelsJSONRequestBody PostInventoryItemsIdLocationLevelsJSONBody

// PostInventoryItemsIdLocationLevelsBatchJSONRequestBody defines body for PostInventoryItemsIdLocationLevelsBatch for application/json ContentType.
type PostInventoryItemsIdLocationLevelsBatchJSONRequestBody PostInventoryItemsIdLocationLevelsBatchJSONBody

// PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody defines body for PostInventoryItemsIdLocationLevelsLocationId for application/json ContentType.
type PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody PostInventoryItemsIdLocationLevelsLocationIdJSONBody

// PostInvitesJSONRequestBody defines body for PostInvites for application/json ContentType.
type PostInvitesJSONRequestBody PostInvitesJSONBody

// PostInvitesAcceptJSONRequestBody defines body for PostInvitesAccept for application/json ContentType.
type PostInvitesAcceptJSONRequestBody PostInvitesAcceptJSONBody

// PostOrderEditsJSONRequestBody defines body for PostOrderEdits for application/json ContentType.
type PostOrderEditsJSONRequestBody = AdminPostOrderEditsReqSchema

// PostOrderEditsIdItemsJSONRequestBody defines body for PostOrderEditsIdItems for application/json ContentType.
type PostOrderEditsIdItemsJSONRequestBody = AdminPostOrderEditsAddItemsReqSchema

// PostOrderEditsIdItemsItemItemIdJSONRequestBody defines body for PostOrderEditsIdItemsItemItemId for application/json ContentType.
type PostOrderEditsIdItemsItemItemIdJSONRequestBody = AdminPostOrderEditsUpdateItemQuantityReqSchema

// PostOrderEditsIdItemsActionIdJSONRequestBody defines body for PostOrderEditsIdItemsActionId for application/json ContentType.
type PostOrderEditsIdItemsActionIdJSONRequestBody = AdminPostOrderEditsItemsActionReqSchema

// PostOrderEditsIdShippingMethodJSONRequestBody defines body for PostOrderEditsIdShippingMethod for application/json ContentType.
type PostOrderEditsIdShippingMethodJSONRequestBody = AdminPostOrderEditsShippingReqSchema

// PostOrderEditsIdShippingMethodActionIdJSONRequestBody defines body for PostOrderEditsIdShippingMethodActionId for application/json ContentType.
type PostOrderEditsIdShippingMethodActionIdJSONRequestBody = AdminPostOrderEditsShippingActionReqSchema

// PostOrdersIdCompleteJSONRequestBody defines body for PostOrdersIdComplete for application/json ContentType.
type PostOrdersIdCompleteJSONRequestBody PostOrdersIdCompleteJSONBody

// PostOrdersIdFulfillmentsJSONRequestBody defines body for PostOrdersIdFulfillments for application/json ContentType.
type PostOrdersIdFulfillmentsJSONRequestBody PostOrdersIdFulfillmentsJSONBody

// PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody defines body for PostOrdersIdFulfillmentsFulfillmentIdCancel for application/json ContentType.
type PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody PostOrdersIdFulfillmentsFulfillmentIdCancelJSONBody

// PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody defines body for PostOrdersIdFulfillmentsFulfillmentIdShipments for application/json ContentType.
type PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONBody

// PostPaymentCollectionsJSONRequestBody defines body for PostPaymentCollections for application/json ContentType.
type PostPaymentCollectionsJSONRequestBody PostPaymentCollectionsJSONBody

// PostPaymentCollectionsIdMarkAsPaidJSONRequestBody defines body for PostPaymentCollectionsIdMarkAsPaid for application/json ContentType.
type PostPaymentCollectionsIdMarkAsPaidJSONRequestBody PostPaymentCollectionsIdMarkAsPaidJSONBody

// PostPaymentsIdCaptureJSONRequestBody defines body for PostPaymentsIdCapture for application/json ContentType.
type PostPaymentsIdCaptureJSONRequestBody PostPaymentsIdCaptureJSONBody

// PostPaymentsIdRefundJSONRequestBody defines body for PostPaymentsIdRefund for application/json ContentType.
type PostPaymentsIdRefundJSONRequestBody PostPaymentsIdRefundJSONBody

// PostPriceListsJSONRequestBody defines body for PostPriceLists for application/json ContentType.
type PostPriceListsJSONRequestBody = AdminCreatePriceList

// PostPriceListsIdJSONRequestBody defines body for PostPriceListsId for application/json ContentType.
type PostPriceListsIdJSONRequestBody = AdminUpdatePriceList

// PostPriceListsIdPricesBatchJSONRequestBody defines body for PostPriceListsIdPricesBatch for application/json ContentType.
type PostPriceListsIdPricesBatchJSONRequestBody PostPriceListsIdPricesBatchJSONBody

// PostPriceListsIdProductsJSONRequestBody defines body for PostPriceListsIdProducts for application/json ContentType.
type PostPriceListsIdProductsJSONRequestBody = AdminLinkPriceListProducts

// PostPricePreferencesJSONRequestBody defines body for PostPricePreferences for application/json ContentType.
type PostPricePreferencesJSONRequestBody = AdminCreatePricePreference

// PostPricePreferencesIdJSONRequestBody defines body for PostPricePreferencesId for application/json ContentType.
type PostPricePreferencesIdJSONRequestBody = AdminUpdatePricePreference

// PostProductCategoriesJSONRequestBody defines body for PostProductCategories for application/json ContentType.
type PostProductCategoriesJSONRequestBody = AdminCreateProductCategory

// PostProductCategoriesIdJSONRequestBody defines body for PostProductCategoriesId for application/json ContentType.
type PostProductCategoriesIdJSONRequestBody PostProductCategoriesIdJSONBody

// PostProductCategoriesIdProductsJSONRequestBody defines body for PostProductCategoriesIdProducts for application/json ContentType.
type PostProductCategoriesIdProductsJSONRequestBody PostProductCategoriesIdProductsJSONBody

// PostProductTagsJSONRequestBody defines body for PostProductTags for application/json ContentType.
type PostProductTagsJSONRequestBody = AdminCreateProductTag

// PostProductTagsIdJSONRequestBody defines body for PostProductTagsId for application/json ContentType.
type PostProductTagsIdJSONRequestBody PostProductTagsIdJSONBody

// PostProductTypesJSONRequestBody defines body for PostProductTypes for application/json ContentType.
type PostProductTypesJSONRequestBody = AdminCreateProductType

// PostProductTypesIdJSONRequestBody defines body for PostProductTypesId for application/json ContentType.
type PostProductTypesIdJSONRequestBody PostProductTypesIdJSONBody

// PostProductsJSONRequestBody defines body for PostProducts for application/json ContentType.
type PostProductsJSONRequestBody PostProductsJSONBody

// PostProductsBatchJSONRequestBody defines body for PostProductsBatch for application/json ContentType.
type PostProductsBatchJSONRequestBody = AdminBatchProductRequest

// PostProductsImportJSONRequestBody defines body for PostProductsImport for application/json ContentType.
type PostProductsImportJSONRequestBody = AdminImportProductRequest

// PostProductsIdJSONRequestBody defines body for PostProductsId for application/json ContentType.
type PostProductsIdJSONRequestBody PostProductsIdJSONBody

// PostProductsIdOptionsJSONRequestBody defines body for PostProductsIdOptions for application/json ContentType.
type PostProductsIdOptionsJSONRequestBody PostProductsIdOptionsJSONBody

// PostProductsIdOptionsOptionIdJSONRequestBody defines body for PostProductsIdOptionsOptionId for application/json ContentType.
type PostProductsIdOptionsOptionIdJSONRequestBody PostProductsIdOptionsOptionIdJSONBody

// PostProductsIdVariantsJSONRequestBody defines body for PostProductsIdVariants for application/json ContentType.
type PostProductsIdVariantsJSONRequestBody PostProductsIdVariantsJSONBody

// PostProductsIdVariantsBatchJSONRequestBody defines body for PostProductsIdVariantsBatch for application/json ContentType.
type PostProductsIdVariantsBatchJSONRequestBody = AdminBatchProductVariantRequest

// PostProductsIdVariantsInventoryItemsBatchJSONRequestBody defines body for PostProductsIdVariantsInventoryItemsBatch for application/json ContentType.
type PostProductsIdVariantsInventoryItemsBatchJSONRequestBody PostProductsIdVariantsInventoryItemsBatchJSONBody

// PostProductsIdVariantsVariantIdJSONRequestBody defines body for PostProductsIdVariantsVariantId for application/json ContentType.
type PostProductsIdVariantsVariantIdJSONRequestBody PostProductsIdVariantsVariantIdJSONBody

// PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody defines body for PostProductsIdVariantsVariantIdInventoryItems for application/json ContentType.
type PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody = AdminCreateVariantInventoryItem

// PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody defines body for PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId for application/json ContentType.
type PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody = AdminUpdateVariantInventoryItem

// PostPromotionsJSONRequestBody defines body for PostPromotions for application/json ContentType.
type PostPromotionsJSONRequestBody PostPromotionsJSONBody

// PostPromotionsIdJSONRequestBody defines body for PostPromotionsId for application/json ContentType.
type PostPromotionsIdJSONRequestBody PostPromotionsIdJSONBody

// PostPromotionsIdBuyRulesBatchJSONRequestBody defines body for PostPromotionsIdBuyRulesBatch for application/json ContentType.
type PostPromotionsIdBuyRulesBatchJSONRequestBody PostPromotionsIdBuyRulesBatchJSONBody

// PostPromotionsIdRulesBatchJSONRequestBody defines body for PostPromotionsIdRulesBatch for application/json ContentType.
type PostPromotionsIdRulesBatchJSONRequestBody PostPromotionsIdRulesBatchJSONBody

// PostPromotionsIdTargetRulesBatchJSONRequestBody defines body for PostPromotionsIdTargetRulesBatch for application/json ContentType.
type PostPromotionsIdTargetRulesBatchJSONRequestBody PostPromotionsIdTargetRulesBatchJSONBody

// PostRefundReasonsJSONRequestBody defines body for PostRefundReasons for application/json ContentType.
type PostRefundReasonsJSONRequestBody = AdminCreateRefundReason

// PostRefundReasonsIdJSONRequestBody defines body for PostRefundReasonsId for application/json ContentType.
type PostRefundReasonsIdJSONRequestBody PostRefundReasonsIdJSONBody

// PostRegionsJSONRequestBody defines body for PostRegions for application/json ContentType.
type PostRegionsJSONRequestBody = AdminCreateRegion

// PostRegionsIdJSONRequestBody defines body for PostRegionsId for application/json ContentType.
type PostRegionsIdJSONRequestBody PostRegionsIdJSONBody

// PostReservationsJSONRequestBody defines body for PostReservations for application/json ContentType.
type PostReservationsJSONRequestBody = AdminCreateReservation

// PostReservationsIdJSONRequestBody defines body for PostReservationsId for application/json ContentType.
type PostReservationsIdJSONRequestBody PostReservationsIdJSONBody

// PostReturnReasonsJSONRequestBody defines body for PostReturnReasons for application/json ContentType.
type PostReturnReasonsJSONRequestBody = AdminCreateReturnReason

// PostReturnReasonsIdJSONRequestBody defines body for PostReturnReasonsId for application/json ContentType.
type PostReturnReasonsIdJSONRequestBody = AdminUpdateReturnReason

// PostReturnsJSONRequestBody defines body for PostReturns for application/json ContentType.
type PostReturnsJSONRequestBody = AdminPostReturnsReqSchema

// PostReturnsIdJSONRequestBody defines body for PostReturnsId for application/json ContentType.
type PostReturnsIdJSONRequestBody = AdminPostReturnsReturnReqSchema

// PostReturnsIdCancelJSONRequestBody defines body for PostReturnsIdCancel for application/json ContentType.
type PostReturnsIdCancelJSONRequestBody = AdminPostCancelReturnReqSchema

// PostReturnsIdDismissItemsJSONRequestBody defines body for PostReturnsIdDismissItems for application/json ContentType.
type PostReturnsIdDismissItemsJSONRequestBody = AdminPostReturnsReceiveItemsReqSchema

// PostReturnsIdDismissItemsActionIdJSONRequestBody defines body for PostReturnsIdDismissItemsActionId for application/json ContentType.
type PostReturnsIdDismissItemsActionIdJSONRequestBody = AdminPostReturnsDismissItemsActionReqSchema

// PostReturnsIdReceiveJSONRequestBody defines body for PostReturnsIdReceive for application/json ContentType.
type PostReturnsIdReceiveJSONRequestBody = AdminPostReceiveReturnsReqSchema

// PostReturnsIdReceiveItemsJSONRequestBody defines body for PostReturnsIdReceiveItems for application/json ContentType.
type PostReturnsIdReceiveItemsJSONRequestBody = AdminPostReturnsReceiveItemsReqSchema

// PostReturnsIdReceiveItemsActionIdJSONRequestBody defines body for PostReturnsIdReceiveItemsActionId for application/json ContentType.
type PostReturnsIdReceiveItemsActionIdJSONRequestBody = AdminPostReturnsReceiveItemsActionReqSchema

// PostReturnsIdReceiveConfirmJSONRequestBody defines body for PostReturnsIdReceiveConfirm for application/json ContentType.
type PostReturnsIdReceiveConfirmJSONRequestBody = AdminPostReturnsConfirmRequestReqSchema

// PostReturnsIdRequestJSONRequestBody defines body for PostReturnsIdRequest for application/json ContentType.
type PostReturnsIdRequestJSONRequestBody = AdminPostReturnsConfirmRequestReqSchema

// PostReturnsIdRequestItemsJSONRequestBody defines body for PostReturnsIdRequestItems for application/json ContentType.
type PostReturnsIdRequestItemsJSONRequestBody = AdminPostReturnsRequestItemsReqSchema

// PostReturnsIdRequestItemsActionIdJSONRequestBody defines body for PostReturnsIdRequestItemsActionId for application/json ContentType.
type PostReturnsIdRequestItemsActionIdJSONRequestBody = AdminPostReturnsRequestItemsActionReqSchema

// PostReturnsIdShippingMethodJSONRequestBody defines body for PostReturnsIdShippingMethod for application/json ContentType.
type PostReturnsIdShippingMethodJSONRequestBody = AdminPostReturnsShippingReqSchema

// PostReturnsIdShippingMethodActionIdJSONRequestBody defines body for PostReturnsIdShippingMethodActionId for application/json ContentType.
type PostReturnsIdShippingMethodActionIdJSONRequestBody = AdminPostReturnsShippingActionReqSchema

// PostSalesChannelsJSONRequestBody defines body for PostSalesChannels for application/json ContentType.
type PostSalesChannelsJSONRequestBody = AdminCreateSalesChannel

// PostSalesChannelsIdJSONRequestBody defines body for PostSalesChannelsId for application/json ContentType.
type PostSalesChannelsIdJSONRequestBody = AdminUpdateSalesChannel

// PostSalesChannelsIdProductsJSONRequestBody defines body for PostSalesChannelsIdProducts for application/json ContentType.
type PostSalesChannelsIdProductsJSONRequestBody PostSalesChannelsIdProductsJSONBody

// PostShippingOptionsJSONRequestBody defines body for PostShippingOptions for application/json ContentType.
type PostShippingOptionsJSONRequestBody = AdminCreateShippingOption

// PostShippingOptionsIdJSONRequestBody defines body for PostShippingOptionsId for application/json ContentType.
type PostShippingOptionsIdJSONRequestBody PostShippingOptionsIdJSONBody

// PostShippingOptionsIdRulesBatchJSONRequestBody defines body for PostShippingOptionsIdRulesBatch for application/json ContentType.
type PostShippingOptionsIdRulesBatchJSONRequestBody PostShippingOptionsIdRulesBatchJSONBody

// PostShippingProfilesJSONRequestBody defines body for PostShippingProfiles for application/json ContentType.
type PostShippingProfilesJSONRequestBody = AdminCreateShippingProfile

// PostShippingProfilesIdJSONRequestBody defines body for PostShippingProfilesId for application/json ContentType.
type PostShippingProfilesIdJSONRequestBody PostShippingProfilesIdJSONBody

// PostStockLocationsJSONRequestBody defines body for PostStockLocations for application/json ContentType.
type PostStockLocationsJSONRequestBody = AdminCreateStockLocation

// PostStockLocationsIdJSONRequestBody defines body for PostStockLocationsId for application/json ContentType.
type PostStockLocationsIdJSONRequestBody = AdminUpdateStockLocation

// PostStockLocationsIdFulfillmentProvidersJSONRequestBody defines body for PostStockLocationsIdFulfillmentProviders for application/json ContentType.
type PostStockLocationsIdFulfillmentProvidersJSONRequestBody PostStockLocationsIdFulfillmentProvidersJSONBody

// PostStockLocationsIdFulfillmentSetsJSONRequestBody defines body for PostStockLocationsIdFulfillmentSets for application/json ContentType.
type PostStockLocationsIdFulfillmentSetsJSONRequestBody PostStockLocationsIdFulfillmentSetsJSONBody

// PostStockLocationsIdSalesChannelsJSONRequestBody defines body for PostStockLocationsIdSalesChannels for application/json ContentType.
type PostStockLocationsIdSalesChannelsJSONRequestBody PostStockLocationsIdSalesChannelsJSONBody

// PostStoresIdJSONRequestBody defines body for PostStoresId for application/json ContentType.
type PostStoresIdJSONRequestBody = AdminUpdateStore

// PostTaxRatesJSONRequestBody defines body for PostTaxRates for application/json ContentType.
type PostTaxRatesJSONRequestBody = AdminCreateTaxRate

// PostTaxRatesIdJSONRequestBody defines body for PostTaxRatesId for application/json ContentType.
type PostTaxRatesIdJSONRequestBody = AdminUpdateTaxRate

// PostTaxRatesIdRulesJSONRequestBody defines body for PostTaxRatesIdRules for application/json ContentType.
type PostTaxRatesIdRulesJSONRequestBody = AdminCreateTaxRateRule

// PostTaxRegionsJSONRequestBody defines body for PostTaxRegions for application/json ContentType.
type PostTaxRegionsJSONRequestBody = AdminCreateTaxRegion

// PostUploadsJSONRequestBody defines body for PostUploads for application/json ContentType.
type PostUploadsJSONRequestBody PostUploadsJSONBody

// PostUsersIdJSONRequestBody defines body for PostUsersId for application/json ContentType.
type PostUsersIdJSONRequestBody = AdminUpdateUser

// PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody defines body for PostWorkflowsExecutionsWorkflowIdRun for application/json ContentType.
type PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody = AdminCreateWorkflowsRun

// PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody defines body for PostWorkflowsExecutionsWorkflowIdStepsFailure for application/json ContentType.
type PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody = AdminCreateWorkflowsAsyncResponse

// PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody defines body for PostWorkflowsExecutionsWorkflowIdStepsSuccess for application/json ContentType.
type PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody = AdminCreateWorkflowsAsyncResponse

// PostActorTypeAuthProviderJSONRequestBody defines body for PostActorTypeAuthProvider for application/json ContentType.
type PostActorTypeAuthProviderJSONRequestBody = PostActorTypeAuthProviderJSONBody

// PostActorTypeAuthProviderRegisterJSONRequestBody defines body for PostActorTypeAuthProviderRegister for application/json ContentType.
type PostActorTypeAuthProviderRegisterJSONRequestBody = PostActorTypeAuthProviderRegisterJSONBody

// AsAdminCreatePromotionRuleValues0 returns the union data inside the AdminCreatePromotionRule_Values as a AdminCreatePromotionRuleValues0
func (t AdminCreatePromotionRule_Values) AsAdminCreatePromotionRuleValues0() (AdminCreatePromotionRuleValues0, error) {
	var body AdminCreatePromotionRuleValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCreatePromotionRuleValues0 overwrites any union data inside the AdminCreatePromotionRule_Values as the provided AdminCreatePromotionRuleValues0
func (t *AdminCreatePromotionRule_Values) FromAdminCreatePromotionRuleValues0(v AdminCreatePromotionRuleValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCreatePromotionRuleValues0 performs a merge with any union data inside the AdminCreatePromotionRule_Values, using the provided AdminCreatePromotionRuleValues0
func (t *AdminCreatePromotionRule_Values) MergeAdminCreatePromotionRuleValues0(v AdminCreatePromotionRuleValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCreatePromotionRuleValues1 returns the union data inside the AdminCreatePromotionRule_Values as a AdminCreatePromotionRuleValues1
func (t AdminCreatePromotionRule_Values) AsAdminCreatePromotionRuleValues1() (AdminCreatePromotionRuleValues1, error) {
	var body AdminCreatePromotionRuleValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCreatePromotionRuleValues1 overwrites any union data inside the AdminCreatePromotionRule_Values as the provided AdminCreatePromotionRuleValues1
func (t *AdminCreatePromotionRule_Values) FromAdminCreatePromotionRuleValues1(v AdminCreatePromotionRuleValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCreatePromotionRuleValues1 performs a merge with any union data inside the AdminCreatePromotionRule_Values, using the provided AdminCreatePromotionRuleValues1
func (t *AdminCreatePromotionRule_Values) MergeAdminCreatePromotionRuleValues1(v AdminCreatePromotionRuleValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCreatePromotionRule_Values) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCreatePromotionRule_Values) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCreateShippingOptionRuleValue0 returns the union data inside the AdminCreateShippingOptionRule_Value as a AdminCreateShippingOptionRuleValue0
func (t AdminCreateShippingOptionRule_Value) AsAdminCreateShippingOptionRuleValue0() (AdminCreateShippingOptionRuleValue0, error) {
	var body AdminCreateShippingOptionRuleValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCreateShippingOptionRuleValue0 overwrites any union data inside the AdminCreateShippingOptionRule_Value as the provided AdminCreateShippingOptionRuleValue0
func (t *AdminCreateShippingOptionRule_Value) FromAdminCreateShippingOptionRuleValue0(v AdminCreateShippingOptionRuleValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCreateShippingOptionRuleValue0 performs a merge with any union data inside the AdminCreateShippingOptionRule_Value, using the provided AdminCreateShippingOptionRuleValue0
func (t *AdminCreateShippingOptionRule_Value) MergeAdminCreateShippingOptionRuleValue0(v AdminCreateShippingOptionRuleValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCreateShippingOptionRuleValue1 returns the union data inside the AdminCreateShippingOptionRule_Value as a AdminCreateShippingOptionRuleValue1
func (t AdminCreateShippingOptionRule_Value) AsAdminCreateShippingOptionRuleValue1() (AdminCreateShippingOptionRuleValue1, error) {
	var body AdminCreateShippingOptionRuleValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCreateShippingOptionRuleValue1 overwrites any union data inside the AdminCreateShippingOptionRule_Value as the provided AdminCreateShippingOptionRuleValue1
func (t *AdminCreateShippingOptionRule_Value) FromAdminCreateShippingOptionRuleValue1(v AdminCreateShippingOptionRuleValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCreateShippingOptionRuleValue1 performs a merge with any union data inside the AdminCreateShippingOptionRule_Value, using the provided AdminCreateShippingOptionRuleValue1
func (t *AdminCreateShippingOptionRule_Value) MergeAdminCreateShippingOptionRuleValue1(v AdminCreateShippingOptionRuleValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCreateShippingOptionRule_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCreateShippingOptionRule_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersCompanyName0 returns the union data inside the AdminCustomerInGroupFilters_CompanyName as a AdminCustomerInGroupFiltersCompanyName0
func (t AdminCustomerInGroupFilters_CompanyName) AsAdminCustomerInGroupFiltersCompanyName0() (AdminCustomerInGroupFiltersCompanyName0, error) {
	var body AdminCustomerInGroupFiltersCompanyName0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCompanyName0 overwrites any union data inside the AdminCustomerInGroupFilters_CompanyName as the provided AdminCustomerInGroupFiltersCompanyName0
func (t *AdminCustomerInGroupFilters_CompanyName) FromAdminCustomerInGroupFiltersCompanyName0(v AdminCustomerInGroupFiltersCompanyName0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCompanyName0 performs a merge with any union data inside the AdminCustomerInGroupFilters_CompanyName, using the provided AdminCustomerInGroupFiltersCompanyName0
func (t *AdminCustomerInGroupFilters_CompanyName) MergeAdminCustomerInGroupFiltersCompanyName0(v AdminCustomerInGroupFiltersCompanyName0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersCompanyName1 returns the union data inside the AdminCustomerInGroupFilters_CompanyName as a AdminCustomerInGroupFiltersCompanyName1
func (t AdminCustomerInGroupFilters_CompanyName) AsAdminCustomerInGroupFiltersCompanyName1() (AdminCustomerInGroupFiltersCompanyName1, error) {
	var body AdminCustomerInGroupFiltersCompanyName1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCompanyName1 overwrites any union data inside the AdminCustomerInGroupFilters_CompanyName as the provided AdminCustomerInGroupFiltersCompanyName1
func (t *AdminCustomerInGroupFilters_CompanyName) FromAdminCustomerInGroupFiltersCompanyName1(v AdminCustomerInGroupFiltersCompanyName1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCompanyName1 performs a merge with any union data inside the AdminCustomerInGroupFilters_CompanyName, using the provided AdminCustomerInGroupFiltersCompanyName1
func (t *AdminCustomerInGroupFilters_CompanyName) MergeAdminCustomerInGroupFiltersCompanyName1(v AdminCustomerInGroupFiltersCompanyName1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_CompanyName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_CompanyName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersCreatedAtEq0 returns the union data inside the AdminCustomerInGroupFilters_CreatedAt_Eq as a AdminCustomerInGroupFiltersCreatedAtEq0
func (t AdminCustomerInGroupFilters_CreatedAt_Eq) AsAdminCustomerInGroupFiltersCreatedAtEq0() (AdminCustomerInGroupFiltersCreatedAtEq0, error) {
	var body AdminCustomerInGroupFiltersCreatedAtEq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedAtEq0 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedAt_Eq as the provided AdminCustomerInGroupFiltersCreatedAtEq0
func (t *AdminCustomerInGroupFilters_CreatedAt_Eq) FromAdminCustomerInGroupFiltersCreatedAtEq0(v AdminCustomerInGroupFiltersCreatedAtEq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedAtEq0 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedAt_Eq, using the provided AdminCustomerInGroupFiltersCreatedAtEq0
func (t *AdminCustomerInGroupFilters_CreatedAt_Eq) MergeAdminCustomerInGroupFiltersCreatedAtEq0(v AdminCustomerInGroupFiltersCreatedAtEq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersCreatedAtEq1 returns the union data inside the AdminCustomerInGroupFilters_CreatedAt_Eq as a AdminCustomerInGroupFiltersCreatedAtEq1
func (t AdminCustomerInGroupFilters_CreatedAt_Eq) AsAdminCustomerInGroupFiltersCreatedAtEq1() (AdminCustomerInGroupFiltersCreatedAtEq1, error) {
	var body AdminCustomerInGroupFiltersCreatedAtEq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedAtEq1 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedAt_Eq as the provided AdminCustomerInGroupFiltersCreatedAtEq1
func (t *AdminCustomerInGroupFilters_CreatedAt_Eq) FromAdminCustomerInGroupFiltersCreatedAtEq1(v AdminCustomerInGroupFiltersCreatedAtEq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedAtEq1 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedAt_Eq, using the provided AdminCustomerInGroupFiltersCreatedAtEq1
func (t *AdminCustomerInGroupFilters_CreatedAt_Eq) MergeAdminCustomerInGroupFiltersCreatedAtEq1(v AdminCustomerInGroupFiltersCreatedAtEq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_CreatedAt_Eq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_CreatedAt_Eq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersCreatedAtNot0 returns the union data inside the AdminCustomerInGroupFilters_CreatedAt_Not as a AdminCustomerInGroupFiltersCreatedAtNot0
func (t AdminCustomerInGroupFilters_CreatedAt_Not) AsAdminCustomerInGroupFiltersCreatedAtNot0() (AdminCustomerInGroupFiltersCreatedAtNot0, error) {
	var body AdminCustomerInGroupFiltersCreatedAtNot0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedAtNot0 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedAt_Not as the provided AdminCustomerInGroupFiltersCreatedAtNot0
func (t *AdminCustomerInGroupFilters_CreatedAt_Not) FromAdminCustomerInGroupFiltersCreatedAtNot0(v AdminCustomerInGroupFiltersCreatedAtNot0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedAtNot0 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedAt_Not, using the provided AdminCustomerInGroupFiltersCreatedAtNot0
func (t *AdminCustomerInGroupFilters_CreatedAt_Not) MergeAdminCustomerInGroupFiltersCreatedAtNot0(v AdminCustomerInGroupFiltersCreatedAtNot0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersCreatedAtNot1 returns the union data inside the AdminCustomerInGroupFilters_CreatedAt_Not as a AdminCustomerInGroupFiltersCreatedAtNot1
func (t AdminCustomerInGroupFilters_CreatedAt_Not) AsAdminCustomerInGroupFiltersCreatedAtNot1() (AdminCustomerInGroupFiltersCreatedAtNot1, error) {
	var body AdminCustomerInGroupFiltersCreatedAtNot1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedAtNot1 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedAt_Not as the provided AdminCustomerInGroupFiltersCreatedAtNot1
func (t *AdminCustomerInGroupFilters_CreatedAt_Not) FromAdminCustomerInGroupFiltersCreatedAtNot1(v AdminCustomerInGroupFiltersCreatedAtNot1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedAtNot1 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedAt_Not, using the provided AdminCustomerInGroupFiltersCreatedAtNot1
func (t *AdminCustomerInGroupFilters_CreatedAt_Not) MergeAdminCustomerInGroupFiltersCreatedAtNot1(v AdminCustomerInGroupFiltersCreatedAtNot1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersCreatedAtNot2 returns the union data inside the AdminCustomerInGroupFilters_CreatedAt_Not as a AdminCustomerInGroupFiltersCreatedAtNot2
func (t AdminCustomerInGroupFilters_CreatedAt_Not) AsAdminCustomerInGroupFiltersCreatedAtNot2() (AdminCustomerInGroupFiltersCreatedAtNot2, error) {
	var body AdminCustomerInGroupFiltersCreatedAtNot2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedAtNot2 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedAt_Not as the provided AdminCustomerInGroupFiltersCreatedAtNot2
func (t *AdminCustomerInGroupFilters_CreatedAt_Not) FromAdminCustomerInGroupFiltersCreatedAtNot2(v AdminCustomerInGroupFiltersCreatedAtNot2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedAtNot2 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedAt_Not, using the provided AdminCustomerInGroupFiltersCreatedAtNot2
func (t *AdminCustomerInGroupFilters_CreatedAt_Not) MergeAdminCustomerInGroupFiltersCreatedAtNot2(v AdminCustomerInGroupFiltersCreatedAtNot2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_CreatedAt_Not) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_CreatedAt_Not) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersCreatedBy0 returns the union data inside the AdminCustomerInGroupFilters_CreatedBy as a AdminCustomerInGroupFiltersCreatedBy0
func (t AdminCustomerInGroupFilters_CreatedBy) AsAdminCustomerInGroupFiltersCreatedBy0() (AdminCustomerInGroupFiltersCreatedBy0, error) {
	var body AdminCustomerInGroupFiltersCreatedBy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedBy0 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedBy as the provided AdminCustomerInGroupFiltersCreatedBy0
func (t *AdminCustomerInGroupFilters_CreatedBy) FromAdminCustomerInGroupFiltersCreatedBy0(v AdminCustomerInGroupFiltersCreatedBy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedBy0 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedBy, using the provided AdminCustomerInGroupFiltersCreatedBy0
func (t *AdminCustomerInGroupFilters_CreatedBy) MergeAdminCustomerInGroupFiltersCreatedBy0(v AdminCustomerInGroupFiltersCreatedBy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersCreatedBy1 returns the union data inside the AdminCustomerInGroupFilters_CreatedBy as a AdminCustomerInGroupFiltersCreatedBy1
func (t AdminCustomerInGroupFilters_CreatedBy) AsAdminCustomerInGroupFiltersCreatedBy1() (AdminCustomerInGroupFiltersCreatedBy1, error) {
	var body AdminCustomerInGroupFiltersCreatedBy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersCreatedBy1 overwrites any union data inside the AdminCustomerInGroupFilters_CreatedBy as the provided AdminCustomerInGroupFiltersCreatedBy1
func (t *AdminCustomerInGroupFilters_CreatedBy) FromAdminCustomerInGroupFiltersCreatedBy1(v AdminCustomerInGroupFiltersCreatedBy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersCreatedBy1 performs a merge with any union data inside the AdminCustomerInGroupFilters_CreatedBy, using the provided AdminCustomerInGroupFiltersCreatedBy1
func (t *AdminCustomerInGroupFilters_CreatedBy) MergeAdminCustomerInGroupFiltersCreatedBy1(v AdminCustomerInGroupFiltersCreatedBy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_CreatedBy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_CreatedBy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersDefaultBillingAddressId0 returns the union data inside the AdminCustomerInGroupFilters_DefaultBillingAddressId as a AdminCustomerInGroupFiltersDefaultBillingAddressId0
func (t AdminCustomerInGroupFilters_DefaultBillingAddressId) AsAdminCustomerInGroupFiltersDefaultBillingAddressId0() (AdminCustomerInGroupFiltersDefaultBillingAddressId0, error) {
	var body AdminCustomerInGroupFiltersDefaultBillingAddressId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDefaultBillingAddressId0 overwrites any union data inside the AdminCustomerInGroupFilters_DefaultBillingAddressId as the provided AdminCustomerInGroupFiltersDefaultBillingAddressId0
func (t *AdminCustomerInGroupFilters_DefaultBillingAddressId) FromAdminCustomerInGroupFiltersDefaultBillingAddressId0(v AdminCustomerInGroupFiltersDefaultBillingAddressId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDefaultBillingAddressId0 performs a merge with any union data inside the AdminCustomerInGroupFilters_DefaultBillingAddressId, using the provided AdminCustomerInGroupFiltersDefaultBillingAddressId0
func (t *AdminCustomerInGroupFilters_DefaultBillingAddressId) MergeAdminCustomerInGroupFiltersDefaultBillingAddressId0(v AdminCustomerInGroupFiltersDefaultBillingAddressId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersDefaultBillingAddressId1 returns the union data inside the AdminCustomerInGroupFilters_DefaultBillingAddressId as a AdminCustomerInGroupFiltersDefaultBillingAddressId1
func (t AdminCustomerInGroupFilters_DefaultBillingAddressId) AsAdminCustomerInGroupFiltersDefaultBillingAddressId1() (AdminCustomerInGroupFiltersDefaultBillingAddressId1, error) {
	var body AdminCustomerInGroupFiltersDefaultBillingAddressId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDefaultBillingAddressId1 overwrites any union data inside the AdminCustomerInGroupFilters_DefaultBillingAddressId as the provided AdminCustomerInGroupFiltersDefaultBillingAddressId1
func (t *AdminCustomerInGroupFilters_DefaultBillingAddressId) FromAdminCustomerInGroupFiltersDefaultBillingAddressId1(v AdminCustomerInGroupFiltersDefaultBillingAddressId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDefaultBillingAddressId1 performs a merge with any union data inside the AdminCustomerInGroupFilters_DefaultBillingAddressId, using the provided AdminCustomerInGroupFiltersDefaultBillingAddressId1
func (t *AdminCustomerInGroupFilters_DefaultBillingAddressId) MergeAdminCustomerInGroupFiltersDefaultBillingAddressId1(v AdminCustomerInGroupFiltersDefaultBillingAddressId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_DefaultBillingAddressId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_DefaultBillingAddressId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersDefaultShippingAddressId0 returns the union data inside the AdminCustomerInGroupFilters_DefaultShippingAddressId as a AdminCustomerInGroupFiltersDefaultShippingAddressId0
func (t AdminCustomerInGroupFilters_DefaultShippingAddressId) AsAdminCustomerInGroupFiltersDefaultShippingAddressId0() (AdminCustomerInGroupFiltersDefaultShippingAddressId0, error) {
	var body AdminCustomerInGroupFiltersDefaultShippingAddressId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDefaultShippingAddressId0 overwrites any union data inside the AdminCustomerInGroupFilters_DefaultShippingAddressId as the provided AdminCustomerInGroupFiltersDefaultShippingAddressId0
func (t *AdminCustomerInGroupFilters_DefaultShippingAddressId) FromAdminCustomerInGroupFiltersDefaultShippingAddressId0(v AdminCustomerInGroupFiltersDefaultShippingAddressId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDefaultShippingAddressId0 performs a merge with any union data inside the AdminCustomerInGroupFilters_DefaultShippingAddressId, using the provided AdminCustomerInGroupFiltersDefaultShippingAddressId0
func (t *AdminCustomerInGroupFilters_DefaultShippingAddressId) MergeAdminCustomerInGroupFiltersDefaultShippingAddressId0(v AdminCustomerInGroupFiltersDefaultShippingAddressId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersDefaultShippingAddressId1 returns the union data inside the AdminCustomerInGroupFilters_DefaultShippingAddressId as a AdminCustomerInGroupFiltersDefaultShippingAddressId1
func (t AdminCustomerInGroupFilters_DefaultShippingAddressId) AsAdminCustomerInGroupFiltersDefaultShippingAddressId1() (AdminCustomerInGroupFiltersDefaultShippingAddressId1, error) {
	var body AdminCustomerInGroupFiltersDefaultShippingAddressId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDefaultShippingAddressId1 overwrites any union data inside the AdminCustomerInGroupFilters_DefaultShippingAddressId as the provided AdminCustomerInGroupFiltersDefaultShippingAddressId1
func (t *AdminCustomerInGroupFilters_DefaultShippingAddressId) FromAdminCustomerInGroupFiltersDefaultShippingAddressId1(v AdminCustomerInGroupFiltersDefaultShippingAddressId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDefaultShippingAddressId1 performs a merge with any union data inside the AdminCustomerInGroupFilters_DefaultShippingAddressId, using the provided AdminCustomerInGroupFiltersDefaultShippingAddressId1
func (t *AdminCustomerInGroupFilters_DefaultShippingAddressId) MergeAdminCustomerInGroupFiltersDefaultShippingAddressId1(v AdminCustomerInGroupFiltersDefaultShippingAddressId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_DefaultShippingAddressId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_DefaultShippingAddressId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersDeletedAtEq0 returns the union data inside the AdminCustomerInGroupFilters_DeletedAt_Eq as a AdminCustomerInGroupFiltersDeletedAtEq0
func (t AdminCustomerInGroupFilters_DeletedAt_Eq) AsAdminCustomerInGroupFiltersDeletedAtEq0() (AdminCustomerInGroupFiltersDeletedAtEq0, error) {
	var body AdminCustomerInGroupFiltersDeletedAtEq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDeletedAtEq0 overwrites any union data inside the AdminCustomerInGroupFilters_DeletedAt_Eq as the provided AdminCustomerInGroupFiltersDeletedAtEq0
func (t *AdminCustomerInGroupFilters_DeletedAt_Eq) FromAdminCustomerInGroupFiltersDeletedAtEq0(v AdminCustomerInGroupFiltersDeletedAtEq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDeletedAtEq0 performs a merge with any union data inside the AdminCustomerInGroupFilters_DeletedAt_Eq, using the provided AdminCustomerInGroupFiltersDeletedAtEq0
func (t *AdminCustomerInGroupFilters_DeletedAt_Eq) MergeAdminCustomerInGroupFiltersDeletedAtEq0(v AdminCustomerInGroupFiltersDeletedAtEq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersDeletedAtEq1 returns the union data inside the AdminCustomerInGroupFilters_DeletedAt_Eq as a AdminCustomerInGroupFiltersDeletedAtEq1
func (t AdminCustomerInGroupFilters_DeletedAt_Eq) AsAdminCustomerInGroupFiltersDeletedAtEq1() (AdminCustomerInGroupFiltersDeletedAtEq1, error) {
	var body AdminCustomerInGroupFiltersDeletedAtEq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDeletedAtEq1 overwrites any union data inside the AdminCustomerInGroupFilters_DeletedAt_Eq as the provided AdminCustomerInGroupFiltersDeletedAtEq1
func (t *AdminCustomerInGroupFilters_DeletedAt_Eq) FromAdminCustomerInGroupFiltersDeletedAtEq1(v AdminCustomerInGroupFiltersDeletedAtEq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDeletedAtEq1 performs a merge with any union data inside the AdminCustomerInGroupFilters_DeletedAt_Eq, using the provided AdminCustomerInGroupFiltersDeletedAtEq1
func (t *AdminCustomerInGroupFilters_DeletedAt_Eq) MergeAdminCustomerInGroupFiltersDeletedAtEq1(v AdminCustomerInGroupFiltersDeletedAtEq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_DeletedAt_Eq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_DeletedAt_Eq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersDeletedAtNot0 returns the union data inside the AdminCustomerInGroupFilters_DeletedAt_Not as a AdminCustomerInGroupFiltersDeletedAtNot0
func (t AdminCustomerInGroupFilters_DeletedAt_Not) AsAdminCustomerInGroupFiltersDeletedAtNot0() (AdminCustomerInGroupFiltersDeletedAtNot0, error) {
	var body AdminCustomerInGroupFiltersDeletedAtNot0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDeletedAtNot0 overwrites any union data inside the AdminCustomerInGroupFilters_DeletedAt_Not as the provided AdminCustomerInGroupFiltersDeletedAtNot0
func (t *AdminCustomerInGroupFilters_DeletedAt_Not) FromAdminCustomerInGroupFiltersDeletedAtNot0(v AdminCustomerInGroupFiltersDeletedAtNot0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDeletedAtNot0 performs a merge with any union data inside the AdminCustomerInGroupFilters_DeletedAt_Not, using the provided AdminCustomerInGroupFiltersDeletedAtNot0
func (t *AdminCustomerInGroupFilters_DeletedAt_Not) MergeAdminCustomerInGroupFiltersDeletedAtNot0(v AdminCustomerInGroupFiltersDeletedAtNot0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersDeletedAtNot1 returns the union data inside the AdminCustomerInGroupFilters_DeletedAt_Not as a AdminCustomerInGroupFiltersDeletedAtNot1
func (t AdminCustomerInGroupFilters_DeletedAt_Not) AsAdminCustomerInGroupFiltersDeletedAtNot1() (AdminCustomerInGroupFiltersDeletedAtNot1, error) {
	var body AdminCustomerInGroupFiltersDeletedAtNot1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDeletedAtNot1 overwrites any union data inside the AdminCustomerInGroupFilters_DeletedAt_Not as the provided AdminCustomerInGroupFiltersDeletedAtNot1
func (t *AdminCustomerInGroupFilters_DeletedAt_Not) FromAdminCustomerInGroupFiltersDeletedAtNot1(v AdminCustomerInGroupFiltersDeletedAtNot1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDeletedAtNot1 performs a merge with any union data inside the AdminCustomerInGroupFilters_DeletedAt_Not, using the provided AdminCustomerInGroupFiltersDeletedAtNot1
func (t *AdminCustomerInGroupFilters_DeletedAt_Not) MergeAdminCustomerInGroupFiltersDeletedAtNot1(v AdminCustomerInGroupFiltersDeletedAtNot1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersDeletedAtNot2 returns the union data inside the AdminCustomerInGroupFilters_DeletedAt_Not as a AdminCustomerInGroupFiltersDeletedAtNot2
func (t AdminCustomerInGroupFilters_DeletedAt_Not) AsAdminCustomerInGroupFiltersDeletedAtNot2() (AdminCustomerInGroupFiltersDeletedAtNot2, error) {
	var body AdminCustomerInGroupFiltersDeletedAtNot2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersDeletedAtNot2 overwrites any union data inside the AdminCustomerInGroupFilters_DeletedAt_Not as the provided AdminCustomerInGroupFiltersDeletedAtNot2
func (t *AdminCustomerInGroupFilters_DeletedAt_Not) FromAdminCustomerInGroupFiltersDeletedAtNot2(v AdminCustomerInGroupFiltersDeletedAtNot2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersDeletedAtNot2 performs a merge with any union data inside the AdminCustomerInGroupFilters_DeletedAt_Not, using the provided AdminCustomerInGroupFiltersDeletedAtNot2
func (t *AdminCustomerInGroupFilters_DeletedAt_Not) MergeAdminCustomerInGroupFiltersDeletedAtNot2(v AdminCustomerInGroupFiltersDeletedAtNot2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_DeletedAt_Not) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_DeletedAt_Not) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersEmail0 returns the union data inside the AdminCustomerInGroupFilters_Email as a AdminCustomerInGroupFiltersEmail0
func (t AdminCustomerInGroupFilters_Email) AsAdminCustomerInGroupFiltersEmail0() (AdminCustomerInGroupFiltersEmail0, error) {
	var body AdminCustomerInGroupFiltersEmail0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersEmail0 overwrites any union data inside the AdminCustomerInGroupFilters_Email as the provided AdminCustomerInGroupFiltersEmail0
func (t *AdminCustomerInGroupFilters_Email) FromAdminCustomerInGroupFiltersEmail0(v AdminCustomerInGroupFiltersEmail0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersEmail0 performs a merge with any union data inside the AdminCustomerInGroupFilters_Email, using the provided AdminCustomerInGroupFiltersEmail0
func (t *AdminCustomerInGroupFilters_Email) MergeAdminCustomerInGroupFiltersEmail0(v AdminCustomerInGroupFiltersEmail0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersEmail1 returns the union data inside the AdminCustomerInGroupFilters_Email as a AdminCustomerInGroupFiltersEmail1
func (t AdminCustomerInGroupFilters_Email) AsAdminCustomerInGroupFiltersEmail1() (AdminCustomerInGroupFiltersEmail1, error) {
	var body AdminCustomerInGroupFiltersEmail1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersEmail1 overwrites any union data inside the AdminCustomerInGroupFilters_Email as the provided AdminCustomerInGroupFiltersEmail1
func (t *AdminCustomerInGroupFilters_Email) FromAdminCustomerInGroupFiltersEmail1(v AdminCustomerInGroupFiltersEmail1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersEmail1 performs a merge with any union data inside the AdminCustomerInGroupFilters_Email, using the provided AdminCustomerInGroupFiltersEmail1
func (t *AdminCustomerInGroupFilters_Email) MergeAdminCustomerInGroupFiltersEmail1(v AdminCustomerInGroupFiltersEmail1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersEmail2 returns the union data inside the AdminCustomerInGroupFilters_Email as a AdminCustomerInGroupFiltersEmail2
func (t AdminCustomerInGroupFilters_Email) AsAdminCustomerInGroupFiltersEmail2() (AdminCustomerInGroupFiltersEmail2, error) {
	var body AdminCustomerInGroupFiltersEmail2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersEmail2 overwrites any union data inside the AdminCustomerInGroupFilters_Email as the provided AdminCustomerInGroupFiltersEmail2
func (t *AdminCustomerInGroupFilters_Email) FromAdminCustomerInGroupFiltersEmail2(v AdminCustomerInGroupFiltersEmail2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersEmail2 performs a merge with any union data inside the AdminCustomerInGroupFilters_Email, using the provided AdminCustomerInGroupFiltersEmail2
func (t *AdminCustomerInGroupFilters_Email) MergeAdminCustomerInGroupFiltersEmail2(v AdminCustomerInGroupFiltersEmail2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_Email) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_Email) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersFirstName0 returns the union data inside the AdminCustomerInGroupFilters_FirstName as a AdminCustomerInGroupFiltersFirstName0
func (t AdminCustomerInGroupFilters_FirstName) AsAdminCustomerInGroupFiltersFirstName0() (AdminCustomerInGroupFiltersFirstName0, error) {
	var body AdminCustomerInGroupFiltersFirstName0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersFirstName0 overwrites any union data inside the AdminCustomerInGroupFilters_FirstName as the provided AdminCustomerInGroupFiltersFirstName0
func (t *AdminCustomerInGroupFilters_FirstName) FromAdminCustomerInGroupFiltersFirstName0(v AdminCustomerInGroupFiltersFirstName0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersFirstName0 performs a merge with any union data inside the AdminCustomerInGroupFilters_FirstName, using the provided AdminCustomerInGroupFiltersFirstName0
func (t *AdminCustomerInGroupFilters_FirstName) MergeAdminCustomerInGroupFiltersFirstName0(v AdminCustomerInGroupFiltersFirstName0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersFirstName1 returns the union data inside the AdminCustomerInGroupFilters_FirstName as a AdminCustomerInGroupFiltersFirstName1
func (t AdminCustomerInGroupFilters_FirstName) AsAdminCustomerInGroupFiltersFirstName1() (AdminCustomerInGroupFiltersFirstName1, error) {
	var body AdminCustomerInGroupFiltersFirstName1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersFirstName1 overwrites any union data inside the AdminCustomerInGroupFilters_FirstName as the provided AdminCustomerInGroupFiltersFirstName1
func (t *AdminCustomerInGroupFilters_FirstName) FromAdminCustomerInGroupFiltersFirstName1(v AdminCustomerInGroupFiltersFirstName1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersFirstName1 performs a merge with any union data inside the AdminCustomerInGroupFilters_FirstName, using the provided AdminCustomerInGroupFiltersFirstName1
func (t *AdminCustomerInGroupFilters_FirstName) MergeAdminCustomerInGroupFiltersFirstName1(v AdminCustomerInGroupFiltersFirstName1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_FirstName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_FirstName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersId0 returns the union data inside the AdminCustomerInGroupFilters_Id as a AdminCustomerInGroupFiltersId0
func (t AdminCustomerInGroupFilters_Id) AsAdminCustomerInGroupFiltersId0() (AdminCustomerInGroupFiltersId0, error) {
	var body AdminCustomerInGroupFiltersId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersId0 overwrites any union data inside the AdminCustomerInGroupFilters_Id as the provided AdminCustomerInGroupFiltersId0
func (t *AdminCustomerInGroupFilters_Id) FromAdminCustomerInGroupFiltersId0(v AdminCustomerInGroupFiltersId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersId0 performs a merge with any union data inside the AdminCustomerInGroupFilters_Id, using the provided AdminCustomerInGroupFiltersId0
func (t *AdminCustomerInGroupFilters_Id) MergeAdminCustomerInGroupFiltersId0(v AdminCustomerInGroupFiltersId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersId1 returns the union data inside the AdminCustomerInGroupFilters_Id as a AdminCustomerInGroupFiltersId1
func (t AdminCustomerInGroupFilters_Id) AsAdminCustomerInGroupFiltersId1() (AdminCustomerInGroupFiltersId1, error) {
	var body AdminCustomerInGroupFiltersId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersId1 overwrites any union data inside the AdminCustomerInGroupFilters_Id as the provided AdminCustomerInGroupFiltersId1
func (t *AdminCustomerInGroupFilters_Id) FromAdminCustomerInGroupFiltersId1(v AdminCustomerInGroupFiltersId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersId1 performs a merge with any union data inside the AdminCustomerInGroupFilters_Id, using the provided AdminCustomerInGroupFiltersId1
func (t *AdminCustomerInGroupFilters_Id) MergeAdminCustomerInGroupFiltersId1(v AdminCustomerInGroupFiltersId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_Id) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_Id) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersLastName0 returns the union data inside the AdminCustomerInGroupFilters_LastName as a AdminCustomerInGroupFiltersLastName0
func (t AdminCustomerInGroupFilters_LastName) AsAdminCustomerInGroupFiltersLastName0() (AdminCustomerInGroupFiltersLastName0, error) {
	var body AdminCustomerInGroupFiltersLastName0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersLastName0 overwrites any union data inside the AdminCustomerInGroupFilters_LastName as the provided AdminCustomerInGroupFiltersLastName0
func (t *AdminCustomerInGroupFilters_LastName) FromAdminCustomerInGroupFiltersLastName0(v AdminCustomerInGroupFiltersLastName0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersLastName0 performs a merge with any union data inside the AdminCustomerInGroupFilters_LastName, using the provided AdminCustomerInGroupFiltersLastName0
func (t *AdminCustomerInGroupFilters_LastName) MergeAdminCustomerInGroupFiltersLastName0(v AdminCustomerInGroupFiltersLastName0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersLastName1 returns the union data inside the AdminCustomerInGroupFilters_LastName as a AdminCustomerInGroupFiltersLastName1
func (t AdminCustomerInGroupFilters_LastName) AsAdminCustomerInGroupFiltersLastName1() (AdminCustomerInGroupFiltersLastName1, error) {
	var body AdminCustomerInGroupFiltersLastName1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersLastName1 overwrites any union data inside the AdminCustomerInGroupFilters_LastName as the provided AdminCustomerInGroupFiltersLastName1
func (t *AdminCustomerInGroupFilters_LastName) FromAdminCustomerInGroupFiltersLastName1(v AdminCustomerInGroupFiltersLastName1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersLastName1 performs a merge with any union data inside the AdminCustomerInGroupFilters_LastName, using the provided AdminCustomerInGroupFiltersLastName1
func (t *AdminCustomerInGroupFilters_LastName) MergeAdminCustomerInGroupFiltersLastName1(v AdminCustomerInGroupFiltersLastName1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_LastName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_LastName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersUpdatedAtEq0 returns the union data inside the AdminCustomerInGroupFilters_UpdatedAt_Eq as a AdminCustomerInGroupFiltersUpdatedAtEq0
func (t AdminCustomerInGroupFilters_UpdatedAt_Eq) AsAdminCustomerInGroupFiltersUpdatedAtEq0() (AdminCustomerInGroupFiltersUpdatedAtEq0, error) {
	var body AdminCustomerInGroupFiltersUpdatedAtEq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersUpdatedAtEq0 overwrites any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Eq as the provided AdminCustomerInGroupFiltersUpdatedAtEq0
func (t *AdminCustomerInGroupFilters_UpdatedAt_Eq) FromAdminCustomerInGroupFiltersUpdatedAtEq0(v AdminCustomerInGroupFiltersUpdatedAtEq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersUpdatedAtEq0 performs a merge with any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Eq, using the provided AdminCustomerInGroupFiltersUpdatedAtEq0
func (t *AdminCustomerInGroupFilters_UpdatedAt_Eq) MergeAdminCustomerInGroupFiltersUpdatedAtEq0(v AdminCustomerInGroupFiltersUpdatedAtEq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersUpdatedAtEq1 returns the union data inside the AdminCustomerInGroupFilters_UpdatedAt_Eq as a AdminCustomerInGroupFiltersUpdatedAtEq1
func (t AdminCustomerInGroupFilters_UpdatedAt_Eq) AsAdminCustomerInGroupFiltersUpdatedAtEq1() (AdminCustomerInGroupFiltersUpdatedAtEq1, error) {
	var body AdminCustomerInGroupFiltersUpdatedAtEq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersUpdatedAtEq1 overwrites any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Eq as the provided AdminCustomerInGroupFiltersUpdatedAtEq1
func (t *AdminCustomerInGroupFilters_UpdatedAt_Eq) FromAdminCustomerInGroupFiltersUpdatedAtEq1(v AdminCustomerInGroupFiltersUpdatedAtEq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersUpdatedAtEq1 performs a merge with any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Eq, using the provided AdminCustomerInGroupFiltersUpdatedAtEq1
func (t *AdminCustomerInGroupFilters_UpdatedAt_Eq) MergeAdminCustomerInGroupFiltersUpdatedAtEq1(v AdminCustomerInGroupFiltersUpdatedAtEq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_UpdatedAt_Eq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_UpdatedAt_Eq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCustomerInGroupFiltersUpdatedAtNot0 returns the union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not as a AdminCustomerInGroupFiltersUpdatedAtNot0
func (t AdminCustomerInGroupFilters_UpdatedAt_Not) AsAdminCustomerInGroupFiltersUpdatedAtNot0() (AdminCustomerInGroupFiltersUpdatedAtNot0, error) {
	var body AdminCustomerInGroupFiltersUpdatedAtNot0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersUpdatedAtNot0 overwrites any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not as the provided AdminCustomerInGroupFiltersUpdatedAtNot0
func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) FromAdminCustomerInGroupFiltersUpdatedAtNot0(v AdminCustomerInGroupFiltersUpdatedAtNot0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersUpdatedAtNot0 performs a merge with any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not, using the provided AdminCustomerInGroupFiltersUpdatedAtNot0
func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) MergeAdminCustomerInGroupFiltersUpdatedAtNot0(v AdminCustomerInGroupFiltersUpdatedAtNot0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersUpdatedAtNot1 returns the union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not as a AdminCustomerInGroupFiltersUpdatedAtNot1
func (t AdminCustomerInGroupFilters_UpdatedAt_Not) AsAdminCustomerInGroupFiltersUpdatedAtNot1() (AdminCustomerInGroupFiltersUpdatedAtNot1, error) {
	var body AdminCustomerInGroupFiltersUpdatedAtNot1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersUpdatedAtNot1 overwrites any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not as the provided AdminCustomerInGroupFiltersUpdatedAtNot1
func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) FromAdminCustomerInGroupFiltersUpdatedAtNot1(v AdminCustomerInGroupFiltersUpdatedAtNot1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersUpdatedAtNot1 performs a merge with any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not, using the provided AdminCustomerInGroupFiltersUpdatedAtNot1
func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) MergeAdminCustomerInGroupFiltersUpdatedAtNot1(v AdminCustomerInGroupFiltersUpdatedAtNot1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminCustomerInGroupFiltersUpdatedAtNot2 returns the union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not as a AdminCustomerInGroupFiltersUpdatedAtNot2
func (t AdminCustomerInGroupFilters_UpdatedAt_Not) AsAdminCustomerInGroupFiltersUpdatedAtNot2() (AdminCustomerInGroupFiltersUpdatedAtNot2, error) {
	var body AdminCustomerInGroupFiltersUpdatedAtNot2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCustomerInGroupFiltersUpdatedAtNot2 overwrites any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not as the provided AdminCustomerInGroupFiltersUpdatedAtNot2
func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) FromAdminCustomerInGroupFiltersUpdatedAtNot2(v AdminCustomerInGroupFiltersUpdatedAtNot2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCustomerInGroupFiltersUpdatedAtNot2 performs a merge with any union data inside the AdminCustomerInGroupFilters_UpdatedAt_Not, using the provided AdminCustomerInGroupFiltersUpdatedAtNot2
func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) MergeAdminCustomerInGroupFiltersUpdatedAtNot2(v AdminCustomerInGroupFiltersUpdatedAtNot2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminCustomerInGroupFilters_UpdatedAt_Not) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminCustomerInGroupFilters_UpdatedAt_Not) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsDiscountTaxTotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_DiscountTaxTotal as a AdminOrderPreviewShippingMethodsDiscountTaxTotal0
func (t AdminOrderPreview_ShippingMethods_DiscountTaxTotal) AsAdminOrderPreviewShippingMethodsDiscountTaxTotal0() (AdminOrderPreviewShippingMethodsDiscountTaxTotal0, error) {
	var body AdminOrderPreviewShippingMethodsDiscountTaxTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsDiscountTaxTotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_DiscountTaxTotal as the provided AdminOrderPreviewShippingMethodsDiscountTaxTotal0
func (t *AdminOrderPreview_ShippingMethods_DiscountTaxTotal) FromAdminOrderPreviewShippingMethodsDiscountTaxTotal0(v AdminOrderPreviewShippingMethodsDiscountTaxTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsDiscountTaxTotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_DiscountTaxTotal, using the provided AdminOrderPreviewShippingMethodsDiscountTaxTotal0
func (t *AdminOrderPreview_ShippingMethods_DiscountTaxTotal) MergeAdminOrderPreviewShippingMethodsDiscountTaxTotal0(v AdminOrderPreviewShippingMethodsDiscountTaxTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsDiscountTaxTotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_DiscountTaxTotal as a AdminOrderPreviewShippingMethodsDiscountTaxTotal1
func (t AdminOrderPreview_ShippingMethods_DiscountTaxTotal) AsAdminOrderPreviewShippingMethodsDiscountTaxTotal1() (AdminOrderPreviewShippingMethodsDiscountTaxTotal1, error) {
	var body AdminOrderPreviewShippingMethodsDiscountTaxTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsDiscountTaxTotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_DiscountTaxTotal as the provided AdminOrderPreviewShippingMethodsDiscountTaxTotal1
func (t *AdminOrderPreview_ShippingMethods_DiscountTaxTotal) FromAdminOrderPreviewShippingMethodsDiscountTaxTotal1(v AdminOrderPreviewShippingMethodsDiscountTaxTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsDiscountTaxTotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_DiscountTaxTotal, using the provided AdminOrderPreviewShippingMethodsDiscountTaxTotal1
func (t *AdminOrderPreview_ShippingMethods_DiscountTaxTotal) MergeAdminOrderPreviewShippingMethodsDiscountTaxTotal1(v AdminOrderPreviewShippingMethodsDiscountTaxTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_DiscountTaxTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_DiscountTaxTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsDiscountTotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_DiscountTotal as a AdminOrderPreviewShippingMethodsDiscountTotal0
func (t AdminOrderPreview_ShippingMethods_DiscountTotal) AsAdminOrderPreviewShippingMethodsDiscountTotal0() (AdminOrderPreviewShippingMethodsDiscountTotal0, error) {
	var body AdminOrderPreviewShippingMethodsDiscountTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsDiscountTotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_DiscountTotal as the provided AdminOrderPreviewShippingMethodsDiscountTotal0
func (t *AdminOrderPreview_ShippingMethods_DiscountTotal) FromAdminOrderPreviewShippingMethodsDiscountTotal0(v AdminOrderPreviewShippingMethodsDiscountTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsDiscountTotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_DiscountTotal, using the provided AdminOrderPreviewShippingMethodsDiscountTotal0
func (t *AdminOrderPreview_ShippingMethods_DiscountTotal) MergeAdminOrderPreviewShippingMethodsDiscountTotal0(v AdminOrderPreviewShippingMethodsDiscountTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsDiscountTotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_DiscountTotal as a AdminOrderPreviewShippingMethodsDiscountTotal1
func (t AdminOrderPreview_ShippingMethods_DiscountTotal) AsAdminOrderPreviewShippingMethodsDiscountTotal1() (AdminOrderPreviewShippingMethodsDiscountTotal1, error) {
	var body AdminOrderPreviewShippingMethodsDiscountTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsDiscountTotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_DiscountTotal as the provided AdminOrderPreviewShippingMethodsDiscountTotal1
func (t *AdminOrderPreview_ShippingMethods_DiscountTotal) FromAdminOrderPreviewShippingMethodsDiscountTotal1(v AdminOrderPreviewShippingMethodsDiscountTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsDiscountTotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_DiscountTotal, using the provided AdminOrderPreviewShippingMethodsDiscountTotal1
func (t *AdminOrderPreview_ShippingMethods_DiscountTotal) MergeAdminOrderPreviewShippingMethodsDiscountTotal1(v AdminOrderPreviewShippingMethodsDiscountTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_DiscountTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_DiscountTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsOriginalSubtotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_OriginalSubtotal as a AdminOrderPreviewShippingMethodsOriginalSubtotal0
func (t AdminOrderPreview_ShippingMethods_OriginalSubtotal) AsAdminOrderPreviewShippingMethodsOriginalSubtotal0() (AdminOrderPreviewShippingMethodsOriginalSubtotal0, error) {
	var body AdminOrderPreviewShippingMethodsOriginalSubtotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsOriginalSubtotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_OriginalSubtotal as the provided AdminOrderPreviewShippingMethodsOriginalSubtotal0
func (t *AdminOrderPreview_ShippingMethods_OriginalSubtotal) FromAdminOrderPreviewShippingMethodsOriginalSubtotal0(v AdminOrderPreviewShippingMethodsOriginalSubtotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsOriginalSubtotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_OriginalSubtotal, using the provided AdminOrderPreviewShippingMethodsOriginalSubtotal0
func (t *AdminOrderPreview_ShippingMethods_OriginalSubtotal) MergeAdminOrderPreviewShippingMethodsOriginalSubtotal0(v AdminOrderPreviewShippingMethodsOriginalSubtotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsOriginalSubtotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_OriginalSubtotal as a AdminOrderPreviewShippingMethodsOriginalSubtotal1
func (t AdminOrderPreview_ShippingMethods_OriginalSubtotal) AsAdminOrderPreviewShippingMethodsOriginalSubtotal1() (AdminOrderPreviewShippingMethodsOriginalSubtotal1, error) {
	var body AdminOrderPreviewShippingMethodsOriginalSubtotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsOriginalSubtotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_OriginalSubtotal as the provided AdminOrderPreviewShippingMethodsOriginalSubtotal1
func (t *AdminOrderPreview_ShippingMethods_OriginalSubtotal) FromAdminOrderPreviewShippingMethodsOriginalSubtotal1(v AdminOrderPreviewShippingMethodsOriginalSubtotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsOriginalSubtotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_OriginalSubtotal, using the provided AdminOrderPreviewShippingMethodsOriginalSubtotal1
func (t *AdminOrderPreview_ShippingMethods_OriginalSubtotal) MergeAdminOrderPreviewShippingMethodsOriginalSubtotal1(v AdminOrderPreviewShippingMethodsOriginalSubtotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_OriginalSubtotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_OriginalSubtotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsOriginalTaxTotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_OriginalTaxTotal as a AdminOrderPreviewShippingMethodsOriginalTaxTotal0
func (t AdminOrderPreview_ShippingMethods_OriginalTaxTotal) AsAdminOrderPreviewShippingMethodsOriginalTaxTotal0() (AdminOrderPreviewShippingMethodsOriginalTaxTotal0, error) {
	var body AdminOrderPreviewShippingMethodsOriginalTaxTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsOriginalTaxTotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_OriginalTaxTotal as the provided AdminOrderPreviewShippingMethodsOriginalTaxTotal0
func (t *AdminOrderPreview_ShippingMethods_OriginalTaxTotal) FromAdminOrderPreviewShippingMethodsOriginalTaxTotal0(v AdminOrderPreviewShippingMethodsOriginalTaxTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsOriginalTaxTotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_OriginalTaxTotal, using the provided AdminOrderPreviewShippingMethodsOriginalTaxTotal0
func (t *AdminOrderPreview_ShippingMethods_OriginalTaxTotal) MergeAdminOrderPreviewShippingMethodsOriginalTaxTotal0(v AdminOrderPreviewShippingMethodsOriginalTaxTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsOriginalTaxTotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_OriginalTaxTotal as a AdminOrderPreviewShippingMethodsOriginalTaxTotal1
func (t AdminOrderPreview_ShippingMethods_OriginalTaxTotal) AsAdminOrderPreviewShippingMethodsOriginalTaxTotal1() (AdminOrderPreviewShippingMethodsOriginalTaxTotal1, error) {
	var body AdminOrderPreviewShippingMethodsOriginalTaxTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsOriginalTaxTotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_OriginalTaxTotal as the provided AdminOrderPreviewShippingMethodsOriginalTaxTotal1
func (t *AdminOrderPreview_ShippingMethods_OriginalTaxTotal) FromAdminOrderPreviewShippingMethodsOriginalTaxTotal1(v AdminOrderPreviewShippingMethodsOriginalTaxTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsOriginalTaxTotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_OriginalTaxTotal, using the provided AdminOrderPreviewShippingMethodsOriginalTaxTotal1
func (t *AdminOrderPreview_ShippingMethods_OriginalTaxTotal) MergeAdminOrderPreviewShippingMethodsOriginalTaxTotal1(v AdminOrderPreviewShippingMethodsOriginalTaxTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_OriginalTaxTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_OriginalTaxTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsOriginalTotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_OriginalTotal as a AdminOrderPreviewShippingMethodsOriginalTotal0
func (t AdminOrderPreview_ShippingMethods_OriginalTotal) AsAdminOrderPreviewShippingMethodsOriginalTotal0() (AdminOrderPreviewShippingMethodsOriginalTotal0, error) {
	var body AdminOrderPreviewShippingMethodsOriginalTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsOriginalTotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_OriginalTotal as the provided AdminOrderPreviewShippingMethodsOriginalTotal0
func (t *AdminOrderPreview_ShippingMethods_OriginalTotal) FromAdminOrderPreviewShippingMethodsOriginalTotal0(v AdminOrderPreviewShippingMethodsOriginalTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsOriginalTotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_OriginalTotal, using the provided AdminOrderPreviewShippingMethodsOriginalTotal0
func (t *AdminOrderPreview_ShippingMethods_OriginalTotal) MergeAdminOrderPreviewShippingMethodsOriginalTotal0(v AdminOrderPreviewShippingMethodsOriginalTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsOriginalTotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_OriginalTotal as a AdminOrderPreviewShippingMethodsOriginalTotal1
func (t AdminOrderPreview_ShippingMethods_OriginalTotal) AsAdminOrderPreviewShippingMethodsOriginalTotal1() (AdminOrderPreviewShippingMethodsOriginalTotal1, error) {
	var body AdminOrderPreviewShippingMethodsOriginalTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsOriginalTotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_OriginalTotal as the provided AdminOrderPreviewShippingMethodsOriginalTotal1
func (t *AdminOrderPreview_ShippingMethods_OriginalTotal) FromAdminOrderPreviewShippingMethodsOriginalTotal1(v AdminOrderPreviewShippingMethodsOriginalTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsOriginalTotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_OriginalTotal, using the provided AdminOrderPreviewShippingMethodsOriginalTotal1
func (t *AdminOrderPreview_ShippingMethods_OriginalTotal) MergeAdminOrderPreviewShippingMethodsOriginalTotal1(v AdminOrderPreviewShippingMethodsOriginalTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_OriginalTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_OriginalTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsSubtotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_Subtotal as a AdminOrderPreviewShippingMethodsSubtotal0
func (t AdminOrderPreview_ShippingMethods_Subtotal) AsAdminOrderPreviewShippingMethodsSubtotal0() (AdminOrderPreviewShippingMethodsSubtotal0, error) {
	var body AdminOrderPreviewShippingMethodsSubtotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsSubtotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_Subtotal as the provided AdminOrderPreviewShippingMethodsSubtotal0
func (t *AdminOrderPreview_ShippingMethods_Subtotal) FromAdminOrderPreviewShippingMethodsSubtotal0(v AdminOrderPreviewShippingMethodsSubtotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsSubtotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_Subtotal, using the provided AdminOrderPreviewShippingMethodsSubtotal0
func (t *AdminOrderPreview_ShippingMethods_Subtotal) MergeAdminOrderPreviewShippingMethodsSubtotal0(v AdminOrderPreviewShippingMethodsSubtotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsSubtotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_Subtotal as a AdminOrderPreviewShippingMethodsSubtotal1
func (t AdminOrderPreview_ShippingMethods_Subtotal) AsAdminOrderPreviewShippingMethodsSubtotal1() (AdminOrderPreviewShippingMethodsSubtotal1, error) {
	var body AdminOrderPreviewShippingMethodsSubtotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsSubtotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_Subtotal as the provided AdminOrderPreviewShippingMethodsSubtotal1
func (t *AdminOrderPreview_ShippingMethods_Subtotal) FromAdminOrderPreviewShippingMethodsSubtotal1(v AdminOrderPreviewShippingMethodsSubtotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsSubtotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_Subtotal, using the provided AdminOrderPreviewShippingMethodsSubtotal1
func (t *AdminOrderPreview_ShippingMethods_Subtotal) MergeAdminOrderPreviewShippingMethodsSubtotal1(v AdminOrderPreviewShippingMethodsSubtotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_Subtotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_Subtotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsTaxTotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_TaxTotal as a AdminOrderPreviewShippingMethodsTaxTotal0
func (t AdminOrderPreview_ShippingMethods_TaxTotal) AsAdminOrderPreviewShippingMethodsTaxTotal0() (AdminOrderPreviewShippingMethodsTaxTotal0, error) {
	var body AdminOrderPreviewShippingMethodsTaxTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsTaxTotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_TaxTotal as the provided AdminOrderPreviewShippingMethodsTaxTotal0
func (t *AdminOrderPreview_ShippingMethods_TaxTotal) FromAdminOrderPreviewShippingMethodsTaxTotal0(v AdminOrderPreviewShippingMethodsTaxTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsTaxTotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_TaxTotal, using the provided AdminOrderPreviewShippingMethodsTaxTotal0
func (t *AdminOrderPreview_ShippingMethods_TaxTotal) MergeAdminOrderPreviewShippingMethodsTaxTotal0(v AdminOrderPreviewShippingMethodsTaxTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsTaxTotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_TaxTotal as a AdminOrderPreviewShippingMethodsTaxTotal1
func (t AdminOrderPreview_ShippingMethods_TaxTotal) AsAdminOrderPreviewShippingMethodsTaxTotal1() (AdminOrderPreviewShippingMethodsTaxTotal1, error) {
	var body AdminOrderPreviewShippingMethodsTaxTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsTaxTotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_TaxTotal as the provided AdminOrderPreviewShippingMethodsTaxTotal1
func (t *AdminOrderPreview_ShippingMethods_TaxTotal) FromAdminOrderPreviewShippingMethodsTaxTotal1(v AdminOrderPreviewShippingMethodsTaxTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsTaxTotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_TaxTotal, using the provided AdminOrderPreviewShippingMethodsTaxTotal1
func (t *AdminOrderPreview_ShippingMethods_TaxTotal) MergeAdminOrderPreviewShippingMethodsTaxTotal1(v AdminOrderPreviewShippingMethodsTaxTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_TaxTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_TaxTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminOrderPreviewShippingMethodsTotal0 returns the union data inside the AdminOrderPreview_ShippingMethods_Total as a AdminOrderPreviewShippingMethodsTotal0
func (t AdminOrderPreview_ShippingMethods_Total) AsAdminOrderPreviewShippingMethodsTotal0() (AdminOrderPreviewShippingMethodsTotal0, error) {
	var body AdminOrderPreviewShippingMethodsTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsTotal0 overwrites any union data inside the AdminOrderPreview_ShippingMethods_Total as the provided AdminOrderPreviewShippingMethodsTotal0
func (t *AdminOrderPreview_ShippingMethods_Total) FromAdminOrderPreviewShippingMethodsTotal0(v AdminOrderPreviewShippingMethodsTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsTotal0 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_Total, using the provided AdminOrderPreviewShippingMethodsTotal0
func (t *AdminOrderPreview_ShippingMethods_Total) MergeAdminOrderPreviewShippingMethodsTotal0(v AdminOrderPreviewShippingMethodsTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminOrderPreviewShippingMethodsTotal1 returns the union data inside the AdminOrderPreview_ShippingMethods_Total as a AdminOrderPreviewShippingMethodsTotal1
func (t AdminOrderPreview_ShippingMethods_Total) AsAdminOrderPreviewShippingMethodsTotal1() (AdminOrderPreviewShippingMethodsTotal1, error) {
	var body AdminOrderPreviewShippingMethodsTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminOrderPreviewShippingMethodsTotal1 overwrites any union data inside the AdminOrderPreview_ShippingMethods_Total as the provided AdminOrderPreviewShippingMethodsTotal1
func (t *AdminOrderPreview_ShippingMethods_Total) FromAdminOrderPreviewShippingMethodsTotal1(v AdminOrderPreviewShippingMethodsTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminOrderPreviewShippingMethodsTotal1 performs a merge with any union data inside the AdminOrderPreview_ShippingMethods_Total, using the provided AdminOrderPreviewShippingMethodsTotal1
func (t *AdminOrderPreview_ShippingMethods_Total) MergeAdminOrderPreviewShippingMethodsTotal1(v AdminOrderPreviewShippingMethodsTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminOrderPreview_ShippingMethods_Total) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminOrderPreview_ShippingMethods_Total) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminProductVariantInventoryLink returns the union data inside the AdminProductVariantInventoryBatchResponse_Created as a AdminProductVariantInventoryLink
func (t AdminProductVariantInventoryBatchResponse_Created) AsAdminProductVariantInventoryLink() (AdminProductVariantInventoryLink, error) {
	var body AdminProductVariantInventoryLink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminProductVariantInventoryLink overwrites any union data inside the AdminProductVariantInventoryBatchResponse_Created as the provided AdminProductVariantInventoryLink
func (t *AdminProductVariantInventoryBatchResponse_Created) FromAdminProductVariantInventoryLink(v AdminProductVariantInventoryLink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminProductVariantInventoryLink performs a merge with any union data inside the AdminProductVariantInventoryBatchResponse_Created, using the provided AdminProductVariantInventoryLink
func (t *AdminProductVariantInventoryBatchResponse_Created) MergeAdminProductVariantInventoryLink(v AdminProductVariantInventoryLink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminProductVariantInventoryBatchResponseCreated1 returns the union data inside the AdminProductVariantInventoryBatchResponse_Created as a AdminProductVariantInventoryBatchResponseCreated1
func (t AdminProductVariantInventoryBatchResponse_Created) AsAdminProductVariantInventoryBatchResponseCreated1() (AdminProductVariantInventoryBatchResponseCreated1, error) {
	var body AdminProductVariantInventoryBatchResponseCreated1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminProductVariantInventoryBatchResponseCreated1 overwrites any union data inside the AdminProductVariantInventoryBatchResponse_Created as the provided AdminProductVariantInventoryBatchResponseCreated1
func (t *AdminProductVariantInventoryBatchResponse_Created) FromAdminProductVariantInventoryBatchResponseCreated1(v AdminProductVariantInventoryBatchResponseCreated1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminProductVariantInventoryBatchResponseCreated1 performs a merge with any union data inside the AdminProductVariantInventoryBatchResponse_Created, using the provided AdminProductVariantInventoryBatchResponseCreated1
func (t *AdminProductVariantInventoryBatchResponse_Created) MergeAdminProductVariantInventoryBatchResponseCreated1(v AdminProductVariantInventoryBatchResponseCreated1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminProductVariantInventoryBatchResponse_Created) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminProductVariantInventoryBatchResponse_Created) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminProductVariantInventoryLink returns the union data inside the AdminProductVariantInventoryBatchResponse_Deleted as a AdminProductVariantInventoryLink
func (t AdminProductVariantInventoryBatchResponse_Deleted) AsAdminProductVariantInventoryLink() (AdminProductVariantInventoryLink, error) {
	var body AdminProductVariantInventoryLink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminProductVariantInventoryLink overwrites any union data inside the AdminProductVariantInventoryBatchResponse_Deleted as the provided AdminProductVariantInventoryLink
func (t *AdminProductVariantInventoryBatchResponse_Deleted) FromAdminProductVariantInventoryLink(v AdminProductVariantInventoryLink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminProductVariantInventoryLink performs a merge with any union data inside the AdminProductVariantInventoryBatchResponse_Deleted, using the provided AdminProductVariantInventoryLink
func (t *AdminProductVariantInventoryBatchResponse_Deleted) MergeAdminProductVariantInventoryLink(v AdminProductVariantInventoryLink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminProductVariantInventoryBatchResponseDeleted1 returns the union data inside the AdminProductVariantInventoryBatchResponse_Deleted as a AdminProductVariantInventoryBatchResponseDeleted1
func (t AdminProductVariantInventoryBatchResponse_Deleted) AsAdminProductVariantInventoryBatchResponseDeleted1() (AdminProductVariantInventoryBatchResponseDeleted1, error) {
	var body AdminProductVariantInventoryBatchResponseDeleted1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminProductVariantInventoryBatchResponseDeleted1 overwrites any union data inside the AdminProductVariantInventoryBatchResponse_Deleted as the provided AdminProductVariantInventoryBatchResponseDeleted1
func (t *AdminProductVariantInventoryBatchResponse_Deleted) FromAdminProductVariantInventoryBatchResponseDeleted1(v AdminProductVariantInventoryBatchResponseDeleted1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminProductVariantInventoryBatchResponseDeleted1 performs a merge with any union data inside the AdminProductVariantInventoryBatchResponse_Deleted, using the provided AdminProductVariantInventoryBatchResponseDeleted1
func (t *AdminProductVariantInventoryBatchResponse_Deleted) MergeAdminProductVariantInventoryBatchResponseDeleted1(v AdminProductVariantInventoryBatchResponseDeleted1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminProductVariantInventoryBatchResponse_Deleted) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminProductVariantInventoryBatchResponse_Deleted) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminProductVariantInventoryLink returns the union data inside the AdminProductVariantInventoryBatchResponse_Updated as a AdminProductVariantInventoryLink
func (t AdminProductVariantInventoryBatchResponse_Updated) AsAdminProductVariantInventoryLink() (AdminProductVariantInventoryLink, error) {
	var body AdminProductVariantInventoryLink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminProductVariantInventoryLink overwrites any union data inside the AdminProductVariantInventoryBatchResponse_Updated as the provided AdminProductVariantInventoryLink
func (t *AdminProductVariantInventoryBatchResponse_Updated) FromAdminProductVariantInventoryLink(v AdminProductVariantInventoryLink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminProductVariantInventoryLink performs a merge with any union data inside the AdminProductVariantInventoryBatchResponse_Updated, using the provided AdminProductVariantInventoryLink
func (t *AdminProductVariantInventoryBatchResponse_Updated) MergeAdminProductVariantInventoryLink(v AdminProductVariantInventoryLink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminProductVariantInventoryBatchResponseUpdated1 returns the union data inside the AdminProductVariantInventoryBatchResponse_Updated as a AdminProductVariantInventoryBatchResponseUpdated1
func (t AdminProductVariantInventoryBatchResponse_Updated) AsAdminProductVariantInventoryBatchResponseUpdated1() (AdminProductVariantInventoryBatchResponseUpdated1, error) {
	var body AdminProductVariantInventoryBatchResponseUpdated1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminProductVariantInventoryBatchResponseUpdated1 overwrites any union data inside the AdminProductVariantInventoryBatchResponse_Updated as the provided AdminProductVariantInventoryBatchResponseUpdated1
func (t *AdminProductVariantInventoryBatchResponse_Updated) FromAdminProductVariantInventoryBatchResponseUpdated1(v AdminProductVariantInventoryBatchResponseUpdated1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminProductVariantInventoryBatchResponseUpdated1 performs a merge with any union data inside the AdminProductVariantInventoryBatchResponse_Updated, using the provided AdminProductVariantInventoryBatchResponseUpdated1
func (t *AdminProductVariantInventoryBatchResponse_Updated) MergeAdminProductVariantInventoryBatchResponseUpdated1(v AdminProductVariantInventoryBatchResponseUpdated1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminProductVariantInventoryBatchResponse_Updated) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminProductVariantInventoryBatchResponse_Updated) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminShippingOptionRuleValue0 returns the union data inside the AdminShippingOptionRule_Value as a AdminShippingOptionRuleValue0
func (t AdminShippingOptionRule_Value) AsAdminShippingOptionRuleValue0() (AdminShippingOptionRuleValue0, error) {
	var body AdminShippingOptionRuleValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminShippingOptionRuleValue0 overwrites any union data inside the AdminShippingOptionRule_Value as the provided AdminShippingOptionRuleValue0
func (t *AdminShippingOptionRule_Value) FromAdminShippingOptionRuleValue0(v AdminShippingOptionRuleValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminShippingOptionRuleValue0 performs a merge with any union data inside the AdminShippingOptionRule_Value, using the provided AdminShippingOptionRuleValue0
func (t *AdminShippingOptionRule_Value) MergeAdminShippingOptionRuleValue0(v AdminShippingOptionRuleValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminShippingOptionRuleValue1 returns the union data inside the AdminShippingOptionRule_Value as a AdminShippingOptionRuleValue1
func (t AdminShippingOptionRule_Value) AsAdminShippingOptionRuleValue1() (AdminShippingOptionRuleValue1, error) {
	var body AdminShippingOptionRuleValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminShippingOptionRuleValue1 overwrites any union data inside the AdminShippingOptionRule_Value as the provided AdminShippingOptionRuleValue1
func (t *AdminShippingOptionRule_Value) FromAdminShippingOptionRuleValue1(v AdminShippingOptionRuleValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminShippingOptionRuleValue1 performs a merge with any union data inside the AdminShippingOptionRule_Value, using the provided AdminShippingOptionRuleValue1
func (t *AdminShippingOptionRule_Value) MergeAdminShippingOptionRuleValue1(v AdminShippingOptionRuleValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminShippingOptionRule_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminShippingOptionRule_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminCreateProductVariant returns the union data inside the AdminUpdateProduct_Variants_Item as a AdminCreateProductVariant
func (t AdminUpdateProduct_Variants_Item) AsAdminCreateProductVariant() (AdminCreateProductVariant, error) {
	var body AdminCreateProductVariant
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminCreateProductVariant overwrites any union data inside the AdminUpdateProduct_Variants_Item as the provided AdminCreateProductVariant
func (t *AdminUpdateProduct_Variants_Item) FromAdminCreateProductVariant(v AdminCreateProductVariant) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminCreateProductVariant performs a merge with any union data inside the AdminUpdateProduct_Variants_Item, using the provided AdminCreateProductVariant
func (t *AdminUpdateProduct_Variants_Item) MergeAdminCreateProductVariant(v AdminCreateProductVariant) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminUpdateProductVariant returns the union data inside the AdminUpdateProduct_Variants_Item as a AdminUpdateProductVariant
func (t AdminUpdateProduct_Variants_Item) AsAdminUpdateProductVariant() (AdminUpdateProductVariant, error) {
	var body AdminUpdateProductVariant
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminUpdateProductVariant overwrites any union data inside the AdminUpdateProduct_Variants_Item as the provided AdminUpdateProductVariant
func (t *AdminUpdateProduct_Variants_Item) FromAdminUpdateProductVariant(v AdminUpdateProductVariant) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminUpdateProductVariant performs a merge with any union data inside the AdminUpdateProduct_Variants_Item, using the provided AdminUpdateProductVariant
func (t *AdminUpdateProduct_Variants_Item) MergeAdminUpdateProductVariant(v AdminUpdateProductVariant) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminUpdateProduct_Variants_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminUpdateProduct_Variants_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminUpdatePromotionRuleValues0 returns the union data inside the AdminUpdatePromotionRule_Values as a AdminUpdatePromotionRuleValues0
func (t AdminUpdatePromotionRule_Values) AsAdminUpdatePromotionRuleValues0() (AdminUpdatePromotionRuleValues0, error) {
	var body AdminUpdatePromotionRuleValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminUpdatePromotionRuleValues0 overwrites any union data inside the AdminUpdatePromotionRule_Values as the provided AdminUpdatePromotionRuleValues0
func (t *AdminUpdatePromotionRule_Values) FromAdminUpdatePromotionRuleValues0(v AdminUpdatePromotionRuleValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminUpdatePromotionRuleValues0 performs a merge with any union data inside the AdminUpdatePromotionRule_Values, using the provided AdminUpdatePromotionRuleValues0
func (t *AdminUpdatePromotionRule_Values) MergeAdminUpdatePromotionRuleValues0(v AdminUpdatePromotionRuleValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminUpdatePromotionRuleValues1 returns the union data inside the AdminUpdatePromotionRule_Values as a AdminUpdatePromotionRuleValues1
func (t AdminUpdatePromotionRule_Values) AsAdminUpdatePromotionRuleValues1() (AdminUpdatePromotionRuleValues1, error) {
	var body AdminUpdatePromotionRuleValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminUpdatePromotionRuleValues1 overwrites any union data inside the AdminUpdatePromotionRule_Values as the provided AdminUpdatePromotionRuleValues1
func (t *AdminUpdatePromotionRule_Values) FromAdminUpdatePromotionRuleValues1(v AdminUpdatePromotionRuleValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminUpdatePromotionRuleValues1 performs a merge with any union data inside the AdminUpdatePromotionRule_Values, using the provided AdminUpdatePromotionRuleValues1
func (t *AdminUpdatePromotionRule_Values) MergeAdminUpdatePromotionRuleValues1(v AdminUpdatePromotionRuleValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminUpdatePromotionRule_Values) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminUpdatePromotionRule_Values) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAdminUpdateShippingOptionRuleValue0 returns the union data inside the AdminUpdateShippingOptionRule_Value as a AdminUpdateShippingOptionRuleValue0
func (t AdminUpdateShippingOptionRule_Value) AsAdminUpdateShippingOptionRuleValue0() (AdminUpdateShippingOptionRuleValue0, error) {
	var body AdminUpdateShippingOptionRuleValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminUpdateShippingOptionRuleValue0 overwrites any union data inside the AdminUpdateShippingOptionRule_Value as the provided AdminUpdateShippingOptionRuleValue0
func (t *AdminUpdateShippingOptionRule_Value) FromAdminUpdateShippingOptionRuleValue0(v AdminUpdateShippingOptionRuleValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminUpdateShippingOptionRuleValue0 performs a merge with any union data inside the AdminUpdateShippingOptionRule_Value, using the provided AdminUpdateShippingOptionRuleValue0
func (t *AdminUpdateShippingOptionRule_Value) MergeAdminUpdateShippingOptionRuleValue0(v AdminUpdateShippingOptionRuleValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminUpdateShippingOptionRuleValue1 returns the union data inside the AdminUpdateShippingOptionRule_Value as a AdminUpdateShippingOptionRuleValue1
func (t AdminUpdateShippingOptionRule_Value) AsAdminUpdateShippingOptionRuleValue1() (AdminUpdateShippingOptionRuleValue1, error) {
	var body AdminUpdateShippingOptionRuleValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminUpdateShippingOptionRuleValue1 overwrites any union data inside the AdminUpdateShippingOptionRule_Value as the provided AdminUpdateShippingOptionRuleValue1
func (t *AdminUpdateShippingOptionRule_Value) FromAdminUpdateShippingOptionRuleValue1(v AdminUpdateShippingOptionRuleValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminUpdateShippingOptionRuleValue1 performs a merge with any union data inside the AdminUpdateShippingOptionRule_Value, using the provided AdminUpdateShippingOptionRuleValue1
func (t *AdminUpdateShippingOptionRule_Value) MergeAdminUpdateShippingOptionRuleValue1(v AdminUpdateShippingOptionRuleValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminUpdateShippingOptionRule_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminUpdateShippingOptionRule_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseClaimItemRawQuantityValue0 returns the union data inside the BaseClaimItem_RawQuantity_Value as a BaseClaimItemRawQuantityValue0
func (t BaseClaimItem_RawQuantity_Value) AsBaseClaimItemRawQuantityValue0() (BaseClaimItemRawQuantityValue0, error) {
	var body BaseClaimItemRawQuantityValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseClaimItemRawQuantityValue0 overwrites any union data inside the BaseClaimItem_RawQuantity_Value as the provided BaseClaimItemRawQuantityValue0
func (t *BaseClaimItem_RawQuantity_Value) FromBaseClaimItemRawQuantityValue0(v BaseClaimItemRawQuantityValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseClaimItemRawQuantityValue0 performs a merge with any union data inside the BaseClaimItem_RawQuantity_Value, using the provided BaseClaimItemRawQuantityValue0
func (t *BaseClaimItem_RawQuantity_Value) MergeBaseClaimItemRawQuantityValue0(v BaseClaimItemRawQuantityValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBaseClaimItemRawQuantityValue1 returns the union data inside the BaseClaimItem_RawQuantity_Value as a BaseClaimItemRawQuantityValue1
func (t BaseClaimItem_RawQuantity_Value) AsBaseClaimItemRawQuantityValue1() (BaseClaimItemRawQuantityValue1, error) {
	var body BaseClaimItemRawQuantityValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseClaimItemRawQuantityValue1 overwrites any union data inside the BaseClaimItem_RawQuantity_Value as the provided BaseClaimItemRawQuantityValue1
func (t *BaseClaimItem_RawQuantity_Value) FromBaseClaimItemRawQuantityValue1(v BaseClaimItemRawQuantityValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseClaimItemRawQuantityValue1 performs a merge with any union data inside the BaseClaimItem_RawQuantity_Value, using the provided BaseClaimItemRawQuantityValue1
func (t *BaseClaimItem_RawQuantity_Value) MergeBaseClaimItemRawQuantityValue1(v BaseClaimItemRawQuantityValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseClaimItem_RawQuantity_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BaseClaimItem_RawQuantity_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersCreatedAtEq0 returns the union data inside the CustomerGroupInCustomerFilters_CreatedAt_Eq as a CustomerGroupInCustomerFiltersCreatedAtEq0
func (t CustomerGroupInCustomerFilters_CreatedAt_Eq) AsCustomerGroupInCustomerFiltersCreatedAtEq0() (CustomerGroupInCustomerFiltersCreatedAtEq0, error) {
	var body CustomerGroupInCustomerFiltersCreatedAtEq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersCreatedAtEq0 overwrites any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Eq as the provided CustomerGroupInCustomerFiltersCreatedAtEq0
func (t *CustomerGroupInCustomerFilters_CreatedAt_Eq) FromCustomerGroupInCustomerFiltersCreatedAtEq0(v CustomerGroupInCustomerFiltersCreatedAtEq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersCreatedAtEq0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Eq, using the provided CustomerGroupInCustomerFiltersCreatedAtEq0
func (t *CustomerGroupInCustomerFilters_CreatedAt_Eq) MergeCustomerGroupInCustomerFiltersCreatedAtEq0(v CustomerGroupInCustomerFiltersCreatedAtEq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersCreatedAtEq1 returns the union data inside the CustomerGroupInCustomerFilters_CreatedAt_Eq as a CustomerGroupInCustomerFiltersCreatedAtEq1
func (t CustomerGroupInCustomerFilters_CreatedAt_Eq) AsCustomerGroupInCustomerFiltersCreatedAtEq1() (CustomerGroupInCustomerFiltersCreatedAtEq1, error) {
	var body CustomerGroupInCustomerFiltersCreatedAtEq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersCreatedAtEq1 overwrites any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Eq as the provided CustomerGroupInCustomerFiltersCreatedAtEq1
func (t *CustomerGroupInCustomerFilters_CreatedAt_Eq) FromCustomerGroupInCustomerFiltersCreatedAtEq1(v CustomerGroupInCustomerFiltersCreatedAtEq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersCreatedAtEq1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Eq, using the provided CustomerGroupInCustomerFiltersCreatedAtEq1
func (t *CustomerGroupInCustomerFilters_CreatedAt_Eq) MergeCustomerGroupInCustomerFiltersCreatedAtEq1(v CustomerGroupInCustomerFiltersCreatedAtEq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_CreatedAt_Eq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_CreatedAt_Eq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersCreatedAtNot0 returns the union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not as a CustomerGroupInCustomerFiltersCreatedAtNot0
func (t CustomerGroupInCustomerFilters_CreatedAt_Not) AsCustomerGroupInCustomerFiltersCreatedAtNot0() (CustomerGroupInCustomerFiltersCreatedAtNot0, error) {
	var body CustomerGroupInCustomerFiltersCreatedAtNot0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersCreatedAtNot0 overwrites any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not as the provided CustomerGroupInCustomerFiltersCreatedAtNot0
func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) FromCustomerGroupInCustomerFiltersCreatedAtNot0(v CustomerGroupInCustomerFiltersCreatedAtNot0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersCreatedAtNot0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not, using the provided CustomerGroupInCustomerFiltersCreatedAtNot0
func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) MergeCustomerGroupInCustomerFiltersCreatedAtNot0(v CustomerGroupInCustomerFiltersCreatedAtNot0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersCreatedAtNot1 returns the union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not as a CustomerGroupInCustomerFiltersCreatedAtNot1
func (t CustomerGroupInCustomerFilters_CreatedAt_Not) AsCustomerGroupInCustomerFiltersCreatedAtNot1() (CustomerGroupInCustomerFiltersCreatedAtNot1, error) {
	var body CustomerGroupInCustomerFiltersCreatedAtNot1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersCreatedAtNot1 overwrites any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not as the provided CustomerGroupInCustomerFiltersCreatedAtNot1
func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) FromCustomerGroupInCustomerFiltersCreatedAtNot1(v CustomerGroupInCustomerFiltersCreatedAtNot1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersCreatedAtNot1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not, using the provided CustomerGroupInCustomerFiltersCreatedAtNot1
func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) MergeCustomerGroupInCustomerFiltersCreatedAtNot1(v CustomerGroupInCustomerFiltersCreatedAtNot1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersCreatedAtNot2 returns the union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not as a CustomerGroupInCustomerFiltersCreatedAtNot2
func (t CustomerGroupInCustomerFilters_CreatedAt_Not) AsCustomerGroupInCustomerFiltersCreatedAtNot2() (CustomerGroupInCustomerFiltersCreatedAtNot2, error) {
	var body CustomerGroupInCustomerFiltersCreatedAtNot2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersCreatedAtNot2 overwrites any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not as the provided CustomerGroupInCustomerFiltersCreatedAtNot2
func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) FromCustomerGroupInCustomerFiltersCreatedAtNot2(v CustomerGroupInCustomerFiltersCreatedAtNot2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersCreatedAtNot2 performs a merge with any union data inside the CustomerGroupInCustomerFilters_CreatedAt_Not, using the provided CustomerGroupInCustomerFiltersCreatedAtNot2
func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) MergeCustomerGroupInCustomerFiltersCreatedAtNot2(v CustomerGroupInCustomerFiltersCreatedAtNot2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_CreatedAt_Not) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_CreatedAt_Not) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersDeletedAtEq0 returns the union data inside the CustomerGroupInCustomerFilters_DeletedAt_Eq as a CustomerGroupInCustomerFiltersDeletedAtEq0
func (t CustomerGroupInCustomerFilters_DeletedAt_Eq) AsCustomerGroupInCustomerFiltersDeletedAtEq0() (CustomerGroupInCustomerFiltersDeletedAtEq0, error) {
	var body CustomerGroupInCustomerFiltersDeletedAtEq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersDeletedAtEq0 overwrites any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Eq as the provided CustomerGroupInCustomerFiltersDeletedAtEq0
func (t *CustomerGroupInCustomerFilters_DeletedAt_Eq) FromCustomerGroupInCustomerFiltersDeletedAtEq0(v CustomerGroupInCustomerFiltersDeletedAtEq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersDeletedAtEq0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Eq, using the provided CustomerGroupInCustomerFiltersDeletedAtEq0
func (t *CustomerGroupInCustomerFilters_DeletedAt_Eq) MergeCustomerGroupInCustomerFiltersDeletedAtEq0(v CustomerGroupInCustomerFiltersDeletedAtEq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersDeletedAtEq1 returns the union data inside the CustomerGroupInCustomerFilters_DeletedAt_Eq as a CustomerGroupInCustomerFiltersDeletedAtEq1
func (t CustomerGroupInCustomerFilters_DeletedAt_Eq) AsCustomerGroupInCustomerFiltersDeletedAtEq1() (CustomerGroupInCustomerFiltersDeletedAtEq1, error) {
	var body CustomerGroupInCustomerFiltersDeletedAtEq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersDeletedAtEq1 overwrites any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Eq as the provided CustomerGroupInCustomerFiltersDeletedAtEq1
func (t *CustomerGroupInCustomerFilters_DeletedAt_Eq) FromCustomerGroupInCustomerFiltersDeletedAtEq1(v CustomerGroupInCustomerFiltersDeletedAtEq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersDeletedAtEq1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Eq, using the provided CustomerGroupInCustomerFiltersDeletedAtEq1
func (t *CustomerGroupInCustomerFilters_DeletedAt_Eq) MergeCustomerGroupInCustomerFiltersDeletedAtEq1(v CustomerGroupInCustomerFiltersDeletedAtEq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_DeletedAt_Eq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_DeletedAt_Eq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersDeletedAtNot0 returns the union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not as a CustomerGroupInCustomerFiltersDeletedAtNot0
func (t CustomerGroupInCustomerFilters_DeletedAt_Not) AsCustomerGroupInCustomerFiltersDeletedAtNot0() (CustomerGroupInCustomerFiltersDeletedAtNot0, error) {
	var body CustomerGroupInCustomerFiltersDeletedAtNot0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersDeletedAtNot0 overwrites any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not as the provided CustomerGroupInCustomerFiltersDeletedAtNot0
func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) FromCustomerGroupInCustomerFiltersDeletedAtNot0(v CustomerGroupInCustomerFiltersDeletedAtNot0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersDeletedAtNot0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not, using the provided CustomerGroupInCustomerFiltersDeletedAtNot0
func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) MergeCustomerGroupInCustomerFiltersDeletedAtNot0(v CustomerGroupInCustomerFiltersDeletedAtNot0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersDeletedAtNot1 returns the union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not as a CustomerGroupInCustomerFiltersDeletedAtNot1
func (t CustomerGroupInCustomerFilters_DeletedAt_Not) AsCustomerGroupInCustomerFiltersDeletedAtNot1() (CustomerGroupInCustomerFiltersDeletedAtNot1, error) {
	var body CustomerGroupInCustomerFiltersDeletedAtNot1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersDeletedAtNot1 overwrites any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not as the provided CustomerGroupInCustomerFiltersDeletedAtNot1
func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) FromCustomerGroupInCustomerFiltersDeletedAtNot1(v CustomerGroupInCustomerFiltersDeletedAtNot1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersDeletedAtNot1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not, using the provided CustomerGroupInCustomerFiltersDeletedAtNot1
func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) MergeCustomerGroupInCustomerFiltersDeletedAtNot1(v CustomerGroupInCustomerFiltersDeletedAtNot1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersDeletedAtNot2 returns the union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not as a CustomerGroupInCustomerFiltersDeletedAtNot2
func (t CustomerGroupInCustomerFilters_DeletedAt_Not) AsCustomerGroupInCustomerFiltersDeletedAtNot2() (CustomerGroupInCustomerFiltersDeletedAtNot2, error) {
	var body CustomerGroupInCustomerFiltersDeletedAtNot2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersDeletedAtNot2 overwrites any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not as the provided CustomerGroupInCustomerFiltersDeletedAtNot2
func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) FromCustomerGroupInCustomerFiltersDeletedAtNot2(v CustomerGroupInCustomerFiltersDeletedAtNot2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersDeletedAtNot2 performs a merge with any union data inside the CustomerGroupInCustomerFilters_DeletedAt_Not, using the provided CustomerGroupInCustomerFiltersDeletedAtNot2
func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) MergeCustomerGroupInCustomerFiltersDeletedAtNot2(v CustomerGroupInCustomerFiltersDeletedAtNot2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_DeletedAt_Not) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_DeletedAt_Not) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersId0 returns the union data inside the CustomerGroupInCustomerFilters_Id as a CustomerGroupInCustomerFiltersId0
func (t CustomerGroupInCustomerFilters_Id) AsCustomerGroupInCustomerFiltersId0() (CustomerGroupInCustomerFiltersId0, error) {
	var body CustomerGroupInCustomerFiltersId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersId0 overwrites any union data inside the CustomerGroupInCustomerFilters_Id as the provided CustomerGroupInCustomerFiltersId0
func (t *CustomerGroupInCustomerFilters_Id) FromCustomerGroupInCustomerFiltersId0(v CustomerGroupInCustomerFiltersId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersId0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_Id, using the provided CustomerGroupInCustomerFiltersId0
func (t *CustomerGroupInCustomerFilters_Id) MergeCustomerGroupInCustomerFiltersId0(v CustomerGroupInCustomerFiltersId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersId1 returns the union data inside the CustomerGroupInCustomerFilters_Id as a CustomerGroupInCustomerFiltersId1
func (t CustomerGroupInCustomerFilters_Id) AsCustomerGroupInCustomerFiltersId1() (CustomerGroupInCustomerFiltersId1, error) {
	var body CustomerGroupInCustomerFiltersId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersId1 overwrites any union data inside the CustomerGroupInCustomerFilters_Id as the provided CustomerGroupInCustomerFiltersId1
func (t *CustomerGroupInCustomerFilters_Id) FromCustomerGroupInCustomerFiltersId1(v CustomerGroupInCustomerFiltersId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersId1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_Id, using the provided CustomerGroupInCustomerFiltersId1
func (t *CustomerGroupInCustomerFilters_Id) MergeCustomerGroupInCustomerFiltersId1(v CustomerGroupInCustomerFiltersId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_Id) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_Id) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersName0 returns the union data inside the CustomerGroupInCustomerFilters_Name as a CustomerGroupInCustomerFiltersName0
func (t CustomerGroupInCustomerFilters_Name) AsCustomerGroupInCustomerFiltersName0() (CustomerGroupInCustomerFiltersName0, error) {
	var body CustomerGroupInCustomerFiltersName0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersName0 overwrites any union data inside the CustomerGroupInCustomerFilters_Name as the provided CustomerGroupInCustomerFiltersName0
func (t *CustomerGroupInCustomerFilters_Name) FromCustomerGroupInCustomerFiltersName0(v CustomerGroupInCustomerFiltersName0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersName0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_Name, using the provided CustomerGroupInCustomerFiltersName0
func (t *CustomerGroupInCustomerFilters_Name) MergeCustomerGroupInCustomerFiltersName0(v CustomerGroupInCustomerFiltersName0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersName1 returns the union data inside the CustomerGroupInCustomerFilters_Name as a CustomerGroupInCustomerFiltersName1
func (t CustomerGroupInCustomerFilters_Name) AsCustomerGroupInCustomerFiltersName1() (CustomerGroupInCustomerFiltersName1, error) {
	var body CustomerGroupInCustomerFiltersName1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersName1 overwrites any union data inside the CustomerGroupInCustomerFilters_Name as the provided CustomerGroupInCustomerFiltersName1
func (t *CustomerGroupInCustomerFilters_Name) FromCustomerGroupInCustomerFiltersName1(v CustomerGroupInCustomerFiltersName1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersName1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_Name, using the provided CustomerGroupInCustomerFiltersName1
func (t *CustomerGroupInCustomerFilters_Name) MergeCustomerGroupInCustomerFiltersName1(v CustomerGroupInCustomerFiltersName1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_Name) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_Name) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersUpdatedAtEq0 returns the union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Eq as a CustomerGroupInCustomerFiltersUpdatedAtEq0
func (t CustomerGroupInCustomerFilters_UpdatedAt_Eq) AsCustomerGroupInCustomerFiltersUpdatedAtEq0() (CustomerGroupInCustomerFiltersUpdatedAtEq0, error) {
	var body CustomerGroupInCustomerFiltersUpdatedAtEq0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersUpdatedAtEq0 overwrites any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Eq as the provided CustomerGroupInCustomerFiltersUpdatedAtEq0
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Eq) FromCustomerGroupInCustomerFiltersUpdatedAtEq0(v CustomerGroupInCustomerFiltersUpdatedAtEq0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersUpdatedAtEq0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Eq, using the provided CustomerGroupInCustomerFiltersUpdatedAtEq0
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Eq) MergeCustomerGroupInCustomerFiltersUpdatedAtEq0(v CustomerGroupInCustomerFiltersUpdatedAtEq0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersUpdatedAtEq1 returns the union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Eq as a CustomerGroupInCustomerFiltersUpdatedAtEq1
func (t CustomerGroupInCustomerFilters_UpdatedAt_Eq) AsCustomerGroupInCustomerFiltersUpdatedAtEq1() (CustomerGroupInCustomerFiltersUpdatedAtEq1, error) {
	var body CustomerGroupInCustomerFiltersUpdatedAtEq1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersUpdatedAtEq1 overwrites any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Eq as the provided CustomerGroupInCustomerFiltersUpdatedAtEq1
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Eq) FromCustomerGroupInCustomerFiltersUpdatedAtEq1(v CustomerGroupInCustomerFiltersUpdatedAtEq1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersUpdatedAtEq1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Eq, using the provided CustomerGroupInCustomerFiltersUpdatedAtEq1
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Eq) MergeCustomerGroupInCustomerFiltersUpdatedAtEq1(v CustomerGroupInCustomerFiltersUpdatedAtEq1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_UpdatedAt_Eq) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_UpdatedAt_Eq) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCustomerGroupInCustomerFiltersUpdatedAtNot0 returns the union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not as a CustomerGroupInCustomerFiltersUpdatedAtNot0
func (t CustomerGroupInCustomerFilters_UpdatedAt_Not) AsCustomerGroupInCustomerFiltersUpdatedAtNot0() (CustomerGroupInCustomerFiltersUpdatedAtNot0, error) {
	var body CustomerGroupInCustomerFiltersUpdatedAtNot0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersUpdatedAtNot0 overwrites any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not as the provided CustomerGroupInCustomerFiltersUpdatedAtNot0
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) FromCustomerGroupInCustomerFiltersUpdatedAtNot0(v CustomerGroupInCustomerFiltersUpdatedAtNot0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersUpdatedAtNot0 performs a merge with any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not, using the provided CustomerGroupInCustomerFiltersUpdatedAtNot0
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) MergeCustomerGroupInCustomerFiltersUpdatedAtNot0(v CustomerGroupInCustomerFiltersUpdatedAtNot0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersUpdatedAtNot1 returns the union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not as a CustomerGroupInCustomerFiltersUpdatedAtNot1
func (t CustomerGroupInCustomerFilters_UpdatedAt_Not) AsCustomerGroupInCustomerFiltersUpdatedAtNot1() (CustomerGroupInCustomerFiltersUpdatedAtNot1, error) {
	var body CustomerGroupInCustomerFiltersUpdatedAtNot1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersUpdatedAtNot1 overwrites any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not as the provided CustomerGroupInCustomerFiltersUpdatedAtNot1
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) FromCustomerGroupInCustomerFiltersUpdatedAtNot1(v CustomerGroupInCustomerFiltersUpdatedAtNot1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersUpdatedAtNot1 performs a merge with any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not, using the provided CustomerGroupInCustomerFiltersUpdatedAtNot1
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) MergeCustomerGroupInCustomerFiltersUpdatedAtNot1(v CustomerGroupInCustomerFiltersUpdatedAtNot1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomerGroupInCustomerFiltersUpdatedAtNot2 returns the union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not as a CustomerGroupInCustomerFiltersUpdatedAtNot2
func (t CustomerGroupInCustomerFilters_UpdatedAt_Not) AsCustomerGroupInCustomerFiltersUpdatedAtNot2() (CustomerGroupInCustomerFiltersUpdatedAtNot2, error) {
	var body CustomerGroupInCustomerFiltersUpdatedAtNot2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomerGroupInCustomerFiltersUpdatedAtNot2 overwrites any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not as the provided CustomerGroupInCustomerFiltersUpdatedAtNot2
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) FromCustomerGroupInCustomerFiltersUpdatedAtNot2(v CustomerGroupInCustomerFiltersUpdatedAtNot2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomerGroupInCustomerFiltersUpdatedAtNot2 performs a merge with any union data inside the CustomerGroupInCustomerFilters_UpdatedAt_Not, using the provided CustomerGroupInCustomerFiltersUpdatedAtNot2
func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) MergeCustomerGroupInCustomerFiltersUpdatedAtNot2(v CustomerGroupInCustomerFiltersUpdatedAtNot2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CustomerGroupInCustomerFilters_UpdatedAt_Not) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CustomerGroupInCustomerFilters_UpdatedAt_Not) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawCompareAtUnitPriceValue0 returns the union data inside the OrderLineItem_RawCompareAtUnitPrice_Value as a OrderLineItemRawCompareAtUnitPriceValue0
func (t OrderLineItem_RawCompareAtUnitPrice_Value) AsOrderLineItemRawCompareAtUnitPriceValue0() (OrderLineItemRawCompareAtUnitPriceValue0, error) {
	var body OrderLineItemRawCompareAtUnitPriceValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawCompareAtUnitPriceValue0 overwrites any union data inside the OrderLineItem_RawCompareAtUnitPrice_Value as the provided OrderLineItemRawCompareAtUnitPriceValue0
func (t *OrderLineItem_RawCompareAtUnitPrice_Value) FromOrderLineItemRawCompareAtUnitPriceValue0(v OrderLineItemRawCompareAtUnitPriceValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawCompareAtUnitPriceValue0 performs a merge with any union data inside the OrderLineItem_RawCompareAtUnitPrice_Value, using the provided OrderLineItemRawCompareAtUnitPriceValue0
func (t *OrderLineItem_RawCompareAtUnitPrice_Value) MergeOrderLineItemRawCompareAtUnitPriceValue0(v OrderLineItemRawCompareAtUnitPriceValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawCompareAtUnitPriceValue1 returns the union data inside the OrderLineItem_RawCompareAtUnitPrice_Value as a OrderLineItemRawCompareAtUnitPriceValue1
func (t OrderLineItem_RawCompareAtUnitPrice_Value) AsOrderLineItemRawCompareAtUnitPriceValue1() (OrderLineItemRawCompareAtUnitPriceValue1, error) {
	var body OrderLineItemRawCompareAtUnitPriceValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawCompareAtUnitPriceValue1 overwrites any union data inside the OrderLineItem_RawCompareAtUnitPrice_Value as the provided OrderLineItemRawCompareAtUnitPriceValue1
func (t *OrderLineItem_RawCompareAtUnitPrice_Value) FromOrderLineItemRawCompareAtUnitPriceValue1(v OrderLineItemRawCompareAtUnitPriceValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawCompareAtUnitPriceValue1 performs a merge with any union data inside the OrderLineItem_RawCompareAtUnitPrice_Value, using the provided OrderLineItemRawCompareAtUnitPriceValue1
func (t *OrderLineItem_RawCompareAtUnitPrice_Value) MergeOrderLineItemRawCompareAtUnitPriceValue1(v OrderLineItemRawCompareAtUnitPriceValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawCompareAtUnitPrice_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawCompareAtUnitPrice_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawDiscountTaxTotalValue0 returns the union data inside the OrderLineItem_RawDiscountTaxTotal_Value as a OrderLineItemRawDiscountTaxTotalValue0
func (t OrderLineItem_RawDiscountTaxTotal_Value) AsOrderLineItemRawDiscountTaxTotalValue0() (OrderLineItemRawDiscountTaxTotalValue0, error) {
	var body OrderLineItemRawDiscountTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawDiscountTaxTotalValue0 overwrites any union data inside the OrderLineItem_RawDiscountTaxTotal_Value as the provided OrderLineItemRawDiscountTaxTotalValue0
func (t *OrderLineItem_RawDiscountTaxTotal_Value) FromOrderLineItemRawDiscountTaxTotalValue0(v OrderLineItemRawDiscountTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawDiscountTaxTotalValue0 performs a merge with any union data inside the OrderLineItem_RawDiscountTaxTotal_Value, using the provided OrderLineItemRawDiscountTaxTotalValue0
func (t *OrderLineItem_RawDiscountTaxTotal_Value) MergeOrderLineItemRawDiscountTaxTotalValue0(v OrderLineItemRawDiscountTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawDiscountTaxTotalValue1 returns the union data inside the OrderLineItem_RawDiscountTaxTotal_Value as a OrderLineItemRawDiscountTaxTotalValue1
func (t OrderLineItem_RawDiscountTaxTotal_Value) AsOrderLineItemRawDiscountTaxTotalValue1() (OrderLineItemRawDiscountTaxTotalValue1, error) {
	var body OrderLineItemRawDiscountTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawDiscountTaxTotalValue1 overwrites any union data inside the OrderLineItem_RawDiscountTaxTotal_Value as the provided OrderLineItemRawDiscountTaxTotalValue1
func (t *OrderLineItem_RawDiscountTaxTotal_Value) FromOrderLineItemRawDiscountTaxTotalValue1(v OrderLineItemRawDiscountTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawDiscountTaxTotalValue1 performs a merge with any union data inside the OrderLineItem_RawDiscountTaxTotal_Value, using the provided OrderLineItemRawDiscountTaxTotalValue1
func (t *OrderLineItem_RawDiscountTaxTotal_Value) MergeOrderLineItemRawDiscountTaxTotalValue1(v OrderLineItemRawDiscountTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawDiscountTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawDiscountTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawDiscountTotalValue0 returns the union data inside the OrderLineItem_RawDiscountTotal_Value as a OrderLineItemRawDiscountTotalValue0
func (t OrderLineItem_RawDiscountTotal_Value) AsOrderLineItemRawDiscountTotalValue0() (OrderLineItemRawDiscountTotalValue0, error) {
	var body OrderLineItemRawDiscountTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawDiscountTotalValue0 overwrites any union data inside the OrderLineItem_RawDiscountTotal_Value as the provided OrderLineItemRawDiscountTotalValue0
func (t *OrderLineItem_RawDiscountTotal_Value) FromOrderLineItemRawDiscountTotalValue0(v OrderLineItemRawDiscountTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawDiscountTotalValue0 performs a merge with any union data inside the OrderLineItem_RawDiscountTotal_Value, using the provided OrderLineItemRawDiscountTotalValue0
func (t *OrderLineItem_RawDiscountTotal_Value) MergeOrderLineItemRawDiscountTotalValue0(v OrderLineItemRawDiscountTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawDiscountTotalValue1 returns the union data inside the OrderLineItem_RawDiscountTotal_Value as a OrderLineItemRawDiscountTotalValue1
func (t OrderLineItem_RawDiscountTotal_Value) AsOrderLineItemRawDiscountTotalValue1() (OrderLineItemRawDiscountTotalValue1, error) {
	var body OrderLineItemRawDiscountTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawDiscountTotalValue1 overwrites any union data inside the OrderLineItem_RawDiscountTotal_Value as the provided OrderLineItemRawDiscountTotalValue1
func (t *OrderLineItem_RawDiscountTotal_Value) FromOrderLineItemRawDiscountTotalValue1(v OrderLineItemRawDiscountTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawDiscountTotalValue1 performs a merge with any union data inside the OrderLineItem_RawDiscountTotal_Value, using the provided OrderLineItemRawDiscountTotalValue1
func (t *OrderLineItem_RawDiscountTotal_Value) MergeOrderLineItemRawDiscountTotalValue1(v OrderLineItemRawDiscountTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawDiscountTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawDiscountTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawItemSubtotalValue0 returns the union data inside the OrderLineItem_RawItemSubtotal_Value as a OrderLineItemRawItemSubtotalValue0
func (t OrderLineItem_RawItemSubtotal_Value) AsOrderLineItemRawItemSubtotalValue0() (OrderLineItemRawItemSubtotalValue0, error) {
	var body OrderLineItemRawItemSubtotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawItemSubtotalValue0 overwrites any union data inside the OrderLineItem_RawItemSubtotal_Value as the provided OrderLineItemRawItemSubtotalValue0
func (t *OrderLineItem_RawItemSubtotal_Value) FromOrderLineItemRawItemSubtotalValue0(v OrderLineItemRawItemSubtotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawItemSubtotalValue0 performs a merge with any union data inside the OrderLineItem_RawItemSubtotal_Value, using the provided OrderLineItemRawItemSubtotalValue0
func (t *OrderLineItem_RawItemSubtotal_Value) MergeOrderLineItemRawItemSubtotalValue0(v OrderLineItemRawItemSubtotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawItemSubtotalValue1 returns the union data inside the OrderLineItem_RawItemSubtotal_Value as a OrderLineItemRawItemSubtotalValue1
func (t OrderLineItem_RawItemSubtotal_Value) AsOrderLineItemRawItemSubtotalValue1() (OrderLineItemRawItemSubtotalValue1, error) {
	var body OrderLineItemRawItemSubtotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawItemSubtotalValue1 overwrites any union data inside the OrderLineItem_RawItemSubtotal_Value as the provided OrderLineItemRawItemSubtotalValue1
func (t *OrderLineItem_RawItemSubtotal_Value) FromOrderLineItemRawItemSubtotalValue1(v OrderLineItemRawItemSubtotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawItemSubtotalValue1 performs a merge with any union data inside the OrderLineItem_RawItemSubtotal_Value, using the provided OrderLineItemRawItemSubtotalValue1
func (t *OrderLineItem_RawItemSubtotal_Value) MergeOrderLineItemRawItemSubtotalValue1(v OrderLineItemRawItemSubtotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawItemSubtotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawItemSubtotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawItemTaxTotalValue0 returns the union data inside the OrderLineItem_RawItemTaxTotal_Value as a OrderLineItemRawItemTaxTotalValue0
func (t OrderLineItem_RawItemTaxTotal_Value) AsOrderLineItemRawItemTaxTotalValue0() (OrderLineItemRawItemTaxTotalValue0, error) {
	var body OrderLineItemRawItemTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawItemTaxTotalValue0 overwrites any union data inside the OrderLineItem_RawItemTaxTotal_Value as the provided OrderLineItemRawItemTaxTotalValue0
func (t *OrderLineItem_RawItemTaxTotal_Value) FromOrderLineItemRawItemTaxTotalValue0(v OrderLineItemRawItemTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawItemTaxTotalValue0 performs a merge with any union data inside the OrderLineItem_RawItemTaxTotal_Value, using the provided OrderLineItemRawItemTaxTotalValue0
func (t *OrderLineItem_RawItemTaxTotal_Value) MergeOrderLineItemRawItemTaxTotalValue0(v OrderLineItemRawItemTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawItemTaxTotalValue1 returns the union data inside the OrderLineItem_RawItemTaxTotal_Value as a OrderLineItemRawItemTaxTotalValue1
func (t OrderLineItem_RawItemTaxTotal_Value) AsOrderLineItemRawItemTaxTotalValue1() (OrderLineItemRawItemTaxTotalValue1, error) {
	var body OrderLineItemRawItemTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawItemTaxTotalValue1 overwrites any union data inside the OrderLineItem_RawItemTaxTotal_Value as the provided OrderLineItemRawItemTaxTotalValue1
func (t *OrderLineItem_RawItemTaxTotal_Value) FromOrderLineItemRawItemTaxTotalValue1(v OrderLineItemRawItemTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawItemTaxTotalValue1 performs a merge with any union data inside the OrderLineItem_RawItemTaxTotal_Value, using the provided OrderLineItemRawItemTaxTotalValue1
func (t *OrderLineItem_RawItemTaxTotal_Value) MergeOrderLineItemRawItemTaxTotalValue1(v OrderLineItemRawItemTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawItemTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawItemTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawItemTotalValue0 returns the union data inside the OrderLineItem_RawItemTotal_Value as a OrderLineItemRawItemTotalValue0
func (t OrderLineItem_RawItemTotal_Value) AsOrderLineItemRawItemTotalValue0() (OrderLineItemRawItemTotalValue0, error) {
	var body OrderLineItemRawItemTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawItemTotalValue0 overwrites any union data inside the OrderLineItem_RawItemTotal_Value as the provided OrderLineItemRawItemTotalValue0
func (t *OrderLineItem_RawItemTotal_Value) FromOrderLineItemRawItemTotalValue0(v OrderLineItemRawItemTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawItemTotalValue0 performs a merge with any union data inside the OrderLineItem_RawItemTotal_Value, using the provided OrderLineItemRawItemTotalValue0
func (t *OrderLineItem_RawItemTotal_Value) MergeOrderLineItemRawItemTotalValue0(v OrderLineItemRawItemTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawItemTotalValue1 returns the union data inside the OrderLineItem_RawItemTotal_Value as a OrderLineItemRawItemTotalValue1
func (t OrderLineItem_RawItemTotal_Value) AsOrderLineItemRawItemTotalValue1() (OrderLineItemRawItemTotalValue1, error) {
	var body OrderLineItemRawItemTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawItemTotalValue1 overwrites any union data inside the OrderLineItem_RawItemTotal_Value as the provided OrderLineItemRawItemTotalValue1
func (t *OrderLineItem_RawItemTotal_Value) FromOrderLineItemRawItemTotalValue1(v OrderLineItemRawItemTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawItemTotalValue1 performs a merge with any union data inside the OrderLineItem_RawItemTotal_Value, using the provided OrderLineItemRawItemTotalValue1
func (t *OrderLineItem_RawItemTotal_Value) MergeOrderLineItemRawItemTotalValue1(v OrderLineItemRawItemTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawItemTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawItemTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawOriginalSubtotalValue0 returns the union data inside the OrderLineItem_RawOriginalSubtotal_Value as a OrderLineItemRawOriginalSubtotalValue0
func (t OrderLineItem_RawOriginalSubtotal_Value) AsOrderLineItemRawOriginalSubtotalValue0() (OrderLineItemRawOriginalSubtotalValue0, error) {
	var body OrderLineItemRawOriginalSubtotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawOriginalSubtotalValue0 overwrites any union data inside the OrderLineItem_RawOriginalSubtotal_Value as the provided OrderLineItemRawOriginalSubtotalValue0
func (t *OrderLineItem_RawOriginalSubtotal_Value) FromOrderLineItemRawOriginalSubtotalValue0(v OrderLineItemRawOriginalSubtotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawOriginalSubtotalValue0 performs a merge with any union data inside the OrderLineItem_RawOriginalSubtotal_Value, using the provided OrderLineItemRawOriginalSubtotalValue0
func (t *OrderLineItem_RawOriginalSubtotal_Value) MergeOrderLineItemRawOriginalSubtotalValue0(v OrderLineItemRawOriginalSubtotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawOriginalSubtotalValue1 returns the union data inside the OrderLineItem_RawOriginalSubtotal_Value as a OrderLineItemRawOriginalSubtotalValue1
func (t OrderLineItem_RawOriginalSubtotal_Value) AsOrderLineItemRawOriginalSubtotalValue1() (OrderLineItemRawOriginalSubtotalValue1, error) {
	var body OrderLineItemRawOriginalSubtotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawOriginalSubtotalValue1 overwrites any union data inside the OrderLineItem_RawOriginalSubtotal_Value as the provided OrderLineItemRawOriginalSubtotalValue1
func (t *OrderLineItem_RawOriginalSubtotal_Value) FromOrderLineItemRawOriginalSubtotalValue1(v OrderLineItemRawOriginalSubtotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawOriginalSubtotalValue1 performs a merge with any union data inside the OrderLineItem_RawOriginalSubtotal_Value, using the provided OrderLineItemRawOriginalSubtotalValue1
func (t *OrderLineItem_RawOriginalSubtotal_Value) MergeOrderLineItemRawOriginalSubtotalValue1(v OrderLineItemRawOriginalSubtotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawOriginalSubtotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawOriginalSubtotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawOriginalTaxTotalValue0 returns the union data inside the OrderLineItem_RawOriginalTaxTotal_Value as a OrderLineItemRawOriginalTaxTotalValue0
func (t OrderLineItem_RawOriginalTaxTotal_Value) AsOrderLineItemRawOriginalTaxTotalValue0() (OrderLineItemRawOriginalTaxTotalValue0, error) {
	var body OrderLineItemRawOriginalTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawOriginalTaxTotalValue0 overwrites any union data inside the OrderLineItem_RawOriginalTaxTotal_Value as the provided OrderLineItemRawOriginalTaxTotalValue0
func (t *OrderLineItem_RawOriginalTaxTotal_Value) FromOrderLineItemRawOriginalTaxTotalValue0(v OrderLineItemRawOriginalTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawOriginalTaxTotalValue0 performs a merge with any union data inside the OrderLineItem_RawOriginalTaxTotal_Value, using the provided OrderLineItemRawOriginalTaxTotalValue0
func (t *OrderLineItem_RawOriginalTaxTotal_Value) MergeOrderLineItemRawOriginalTaxTotalValue0(v OrderLineItemRawOriginalTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawOriginalTaxTotalValue1 returns the union data inside the OrderLineItem_RawOriginalTaxTotal_Value as a OrderLineItemRawOriginalTaxTotalValue1
func (t OrderLineItem_RawOriginalTaxTotal_Value) AsOrderLineItemRawOriginalTaxTotalValue1() (OrderLineItemRawOriginalTaxTotalValue1, error) {
	var body OrderLineItemRawOriginalTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawOriginalTaxTotalValue1 overwrites any union data inside the OrderLineItem_RawOriginalTaxTotal_Value as the provided OrderLineItemRawOriginalTaxTotalValue1
func (t *OrderLineItem_RawOriginalTaxTotal_Value) FromOrderLineItemRawOriginalTaxTotalValue1(v OrderLineItemRawOriginalTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawOriginalTaxTotalValue1 performs a merge with any union data inside the OrderLineItem_RawOriginalTaxTotal_Value, using the provided OrderLineItemRawOriginalTaxTotalValue1
func (t *OrderLineItem_RawOriginalTaxTotal_Value) MergeOrderLineItemRawOriginalTaxTotalValue1(v OrderLineItemRawOriginalTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawOriginalTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawOriginalTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawOriginalTotalValue0 returns the union data inside the OrderLineItem_RawOriginalTotal_Value as a OrderLineItemRawOriginalTotalValue0
func (t OrderLineItem_RawOriginalTotal_Value) AsOrderLineItemRawOriginalTotalValue0() (OrderLineItemRawOriginalTotalValue0, error) {
	var body OrderLineItemRawOriginalTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawOriginalTotalValue0 overwrites any union data inside the OrderLineItem_RawOriginalTotal_Value as the provided OrderLineItemRawOriginalTotalValue0
func (t *OrderLineItem_RawOriginalTotal_Value) FromOrderLineItemRawOriginalTotalValue0(v OrderLineItemRawOriginalTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawOriginalTotalValue0 performs a merge with any union data inside the OrderLineItem_RawOriginalTotal_Value, using the provided OrderLineItemRawOriginalTotalValue0
func (t *OrderLineItem_RawOriginalTotal_Value) MergeOrderLineItemRawOriginalTotalValue0(v OrderLineItemRawOriginalTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawOriginalTotalValue1 returns the union data inside the OrderLineItem_RawOriginalTotal_Value as a OrderLineItemRawOriginalTotalValue1
func (t OrderLineItem_RawOriginalTotal_Value) AsOrderLineItemRawOriginalTotalValue1() (OrderLineItemRawOriginalTotalValue1, error) {
	var body OrderLineItemRawOriginalTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawOriginalTotalValue1 overwrites any union data inside the OrderLineItem_RawOriginalTotal_Value as the provided OrderLineItemRawOriginalTotalValue1
func (t *OrderLineItem_RawOriginalTotal_Value) FromOrderLineItemRawOriginalTotalValue1(v OrderLineItemRawOriginalTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawOriginalTotalValue1 performs a merge with any union data inside the OrderLineItem_RawOriginalTotal_Value, using the provided OrderLineItemRawOriginalTotalValue1
func (t *OrderLineItem_RawOriginalTotal_Value) MergeOrderLineItemRawOriginalTotalValue1(v OrderLineItemRawOriginalTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawOriginalTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawOriginalTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawQuantityValue0 returns the union data inside the OrderLineItem_RawQuantity_Value as a OrderLineItemRawQuantityValue0
func (t OrderLineItem_RawQuantity_Value) AsOrderLineItemRawQuantityValue0() (OrderLineItemRawQuantityValue0, error) {
	var body OrderLineItemRawQuantityValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawQuantityValue0 overwrites any union data inside the OrderLineItem_RawQuantity_Value as the provided OrderLineItemRawQuantityValue0
func (t *OrderLineItem_RawQuantity_Value) FromOrderLineItemRawQuantityValue0(v OrderLineItemRawQuantityValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawQuantityValue0 performs a merge with any union data inside the OrderLineItem_RawQuantity_Value, using the provided OrderLineItemRawQuantityValue0
func (t *OrderLineItem_RawQuantity_Value) MergeOrderLineItemRawQuantityValue0(v OrderLineItemRawQuantityValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawQuantityValue1 returns the union data inside the OrderLineItem_RawQuantity_Value as a OrderLineItemRawQuantityValue1
func (t OrderLineItem_RawQuantity_Value) AsOrderLineItemRawQuantityValue1() (OrderLineItemRawQuantityValue1, error) {
	var body OrderLineItemRawQuantityValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawQuantityValue1 overwrites any union data inside the OrderLineItem_RawQuantity_Value as the provided OrderLineItemRawQuantityValue1
func (t *OrderLineItem_RawQuantity_Value) FromOrderLineItemRawQuantityValue1(v OrderLineItemRawQuantityValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawQuantityValue1 performs a merge with any union data inside the OrderLineItem_RawQuantity_Value, using the provided OrderLineItemRawQuantityValue1
func (t *OrderLineItem_RawQuantity_Value) MergeOrderLineItemRawQuantityValue1(v OrderLineItemRawQuantityValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawQuantity_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawQuantity_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawRefundableTotalValue0 returns the union data inside the OrderLineItem_RawRefundableTotal_Value as a OrderLineItemRawRefundableTotalValue0
func (t OrderLineItem_RawRefundableTotal_Value) AsOrderLineItemRawRefundableTotalValue0() (OrderLineItemRawRefundableTotalValue0, error) {
	var body OrderLineItemRawRefundableTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawRefundableTotalValue0 overwrites any union data inside the OrderLineItem_RawRefundableTotal_Value as the provided OrderLineItemRawRefundableTotalValue0
func (t *OrderLineItem_RawRefundableTotal_Value) FromOrderLineItemRawRefundableTotalValue0(v OrderLineItemRawRefundableTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawRefundableTotalValue0 performs a merge with any union data inside the OrderLineItem_RawRefundableTotal_Value, using the provided OrderLineItemRawRefundableTotalValue0
func (t *OrderLineItem_RawRefundableTotal_Value) MergeOrderLineItemRawRefundableTotalValue0(v OrderLineItemRawRefundableTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawRefundableTotalValue1 returns the union data inside the OrderLineItem_RawRefundableTotal_Value as a OrderLineItemRawRefundableTotalValue1
func (t OrderLineItem_RawRefundableTotal_Value) AsOrderLineItemRawRefundableTotalValue1() (OrderLineItemRawRefundableTotalValue1, error) {
	var body OrderLineItemRawRefundableTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawRefundableTotalValue1 overwrites any union data inside the OrderLineItem_RawRefundableTotal_Value as the provided OrderLineItemRawRefundableTotalValue1
func (t *OrderLineItem_RawRefundableTotal_Value) FromOrderLineItemRawRefundableTotalValue1(v OrderLineItemRawRefundableTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawRefundableTotalValue1 performs a merge with any union data inside the OrderLineItem_RawRefundableTotal_Value, using the provided OrderLineItemRawRefundableTotalValue1
func (t *OrderLineItem_RawRefundableTotal_Value) MergeOrderLineItemRawRefundableTotalValue1(v OrderLineItemRawRefundableTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawRefundableTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawRefundableTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawRefundableTotalPerUnitValue0 returns the union data inside the OrderLineItem_RawRefundableTotalPerUnit_Value as a OrderLineItemRawRefundableTotalPerUnitValue0
func (t OrderLineItem_RawRefundableTotalPerUnit_Value) AsOrderLineItemRawRefundableTotalPerUnitValue0() (OrderLineItemRawRefundableTotalPerUnitValue0, error) {
	var body OrderLineItemRawRefundableTotalPerUnitValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawRefundableTotalPerUnitValue0 overwrites any union data inside the OrderLineItem_RawRefundableTotalPerUnit_Value as the provided OrderLineItemRawRefundableTotalPerUnitValue0
func (t *OrderLineItem_RawRefundableTotalPerUnit_Value) FromOrderLineItemRawRefundableTotalPerUnitValue0(v OrderLineItemRawRefundableTotalPerUnitValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawRefundableTotalPerUnitValue0 performs a merge with any union data inside the OrderLineItem_RawRefundableTotalPerUnit_Value, using the provided OrderLineItemRawRefundableTotalPerUnitValue0
func (t *OrderLineItem_RawRefundableTotalPerUnit_Value) MergeOrderLineItemRawRefundableTotalPerUnitValue0(v OrderLineItemRawRefundableTotalPerUnitValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawRefundableTotalPerUnitValue1 returns the union data inside the OrderLineItem_RawRefundableTotalPerUnit_Value as a OrderLineItemRawRefundableTotalPerUnitValue1
func (t OrderLineItem_RawRefundableTotalPerUnit_Value) AsOrderLineItemRawRefundableTotalPerUnitValue1() (OrderLineItemRawRefundableTotalPerUnitValue1, error) {
	var body OrderLineItemRawRefundableTotalPerUnitValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawRefundableTotalPerUnitValue1 overwrites any union data inside the OrderLineItem_RawRefundableTotalPerUnit_Value as the provided OrderLineItemRawRefundableTotalPerUnitValue1
func (t *OrderLineItem_RawRefundableTotalPerUnit_Value) FromOrderLineItemRawRefundableTotalPerUnitValue1(v OrderLineItemRawRefundableTotalPerUnitValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawRefundableTotalPerUnitValue1 performs a merge with any union data inside the OrderLineItem_RawRefundableTotalPerUnit_Value, using the provided OrderLineItemRawRefundableTotalPerUnitValue1
func (t *OrderLineItem_RawRefundableTotalPerUnit_Value) MergeOrderLineItemRawRefundableTotalPerUnitValue1(v OrderLineItemRawRefundableTotalPerUnitValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawRefundableTotalPerUnit_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawRefundableTotalPerUnit_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawSubtotalValue0 returns the union data inside the OrderLineItem_RawSubtotal_Value as a OrderLineItemRawSubtotalValue0
func (t OrderLineItem_RawSubtotal_Value) AsOrderLineItemRawSubtotalValue0() (OrderLineItemRawSubtotalValue0, error) {
	var body OrderLineItemRawSubtotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawSubtotalValue0 overwrites any union data inside the OrderLineItem_RawSubtotal_Value as the provided OrderLineItemRawSubtotalValue0
func (t *OrderLineItem_RawSubtotal_Value) FromOrderLineItemRawSubtotalValue0(v OrderLineItemRawSubtotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawSubtotalValue0 performs a merge with any union data inside the OrderLineItem_RawSubtotal_Value, using the provided OrderLineItemRawSubtotalValue0
func (t *OrderLineItem_RawSubtotal_Value) MergeOrderLineItemRawSubtotalValue0(v OrderLineItemRawSubtotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawSubtotalValue1 returns the union data inside the OrderLineItem_RawSubtotal_Value as a OrderLineItemRawSubtotalValue1
func (t OrderLineItem_RawSubtotal_Value) AsOrderLineItemRawSubtotalValue1() (OrderLineItemRawSubtotalValue1, error) {
	var body OrderLineItemRawSubtotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawSubtotalValue1 overwrites any union data inside the OrderLineItem_RawSubtotal_Value as the provided OrderLineItemRawSubtotalValue1
func (t *OrderLineItem_RawSubtotal_Value) FromOrderLineItemRawSubtotalValue1(v OrderLineItemRawSubtotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawSubtotalValue1 performs a merge with any union data inside the OrderLineItem_RawSubtotal_Value, using the provided OrderLineItemRawSubtotalValue1
func (t *OrderLineItem_RawSubtotal_Value) MergeOrderLineItemRawSubtotalValue1(v OrderLineItemRawSubtotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawSubtotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawSubtotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawTaxTotalValue0 returns the union data inside the OrderLineItem_RawTaxTotal_Value as a OrderLineItemRawTaxTotalValue0
func (t OrderLineItem_RawTaxTotal_Value) AsOrderLineItemRawTaxTotalValue0() (OrderLineItemRawTaxTotalValue0, error) {
	var body OrderLineItemRawTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawTaxTotalValue0 overwrites any union data inside the OrderLineItem_RawTaxTotal_Value as the provided OrderLineItemRawTaxTotalValue0
func (t *OrderLineItem_RawTaxTotal_Value) FromOrderLineItemRawTaxTotalValue0(v OrderLineItemRawTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawTaxTotalValue0 performs a merge with any union data inside the OrderLineItem_RawTaxTotal_Value, using the provided OrderLineItemRawTaxTotalValue0
func (t *OrderLineItem_RawTaxTotal_Value) MergeOrderLineItemRawTaxTotalValue0(v OrderLineItemRawTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawTaxTotalValue1 returns the union data inside the OrderLineItem_RawTaxTotal_Value as a OrderLineItemRawTaxTotalValue1
func (t OrderLineItem_RawTaxTotal_Value) AsOrderLineItemRawTaxTotalValue1() (OrderLineItemRawTaxTotalValue1, error) {
	var body OrderLineItemRawTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawTaxTotalValue1 overwrites any union data inside the OrderLineItem_RawTaxTotal_Value as the provided OrderLineItemRawTaxTotalValue1
func (t *OrderLineItem_RawTaxTotal_Value) FromOrderLineItemRawTaxTotalValue1(v OrderLineItemRawTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawTaxTotalValue1 performs a merge with any union data inside the OrderLineItem_RawTaxTotal_Value, using the provided OrderLineItemRawTaxTotalValue1
func (t *OrderLineItem_RawTaxTotal_Value) MergeOrderLineItemRawTaxTotalValue1(v OrderLineItemRawTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawTotalValue0 returns the union data inside the OrderLineItem_RawTotal_Value as a OrderLineItemRawTotalValue0
func (t OrderLineItem_RawTotal_Value) AsOrderLineItemRawTotalValue0() (OrderLineItemRawTotalValue0, error) {
	var body OrderLineItemRawTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawTotalValue0 overwrites any union data inside the OrderLineItem_RawTotal_Value as the provided OrderLineItemRawTotalValue0
func (t *OrderLineItem_RawTotal_Value) FromOrderLineItemRawTotalValue0(v OrderLineItemRawTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawTotalValue0 performs a merge with any union data inside the OrderLineItem_RawTotal_Value, using the provided OrderLineItemRawTotalValue0
func (t *OrderLineItem_RawTotal_Value) MergeOrderLineItemRawTotalValue0(v OrderLineItemRawTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawTotalValue1 returns the union data inside the OrderLineItem_RawTotal_Value as a OrderLineItemRawTotalValue1
func (t OrderLineItem_RawTotal_Value) AsOrderLineItemRawTotalValue1() (OrderLineItemRawTotalValue1, error) {
	var body OrderLineItemRawTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawTotalValue1 overwrites any union data inside the OrderLineItem_RawTotal_Value as the provided OrderLineItemRawTotalValue1
func (t *OrderLineItem_RawTotal_Value) FromOrderLineItemRawTotalValue1(v OrderLineItemRawTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawTotalValue1 performs a merge with any union data inside the OrderLineItem_RawTotal_Value, using the provided OrderLineItemRawTotalValue1
func (t *OrderLineItem_RawTotal_Value) MergeOrderLineItemRawTotalValue1(v OrderLineItemRawTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderLineItemRawUnitPriceValue0 returns the union data inside the OrderLineItem_RawUnitPrice_Value as a OrderLineItemRawUnitPriceValue0
func (t OrderLineItem_RawUnitPrice_Value) AsOrderLineItemRawUnitPriceValue0() (OrderLineItemRawUnitPriceValue0, error) {
	var body OrderLineItemRawUnitPriceValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawUnitPriceValue0 overwrites any union data inside the OrderLineItem_RawUnitPrice_Value as the provided OrderLineItemRawUnitPriceValue0
func (t *OrderLineItem_RawUnitPrice_Value) FromOrderLineItemRawUnitPriceValue0(v OrderLineItemRawUnitPriceValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawUnitPriceValue0 performs a merge with any union data inside the OrderLineItem_RawUnitPrice_Value, using the provided OrderLineItemRawUnitPriceValue0
func (t *OrderLineItem_RawUnitPrice_Value) MergeOrderLineItemRawUnitPriceValue0(v OrderLineItemRawUnitPriceValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderLineItemRawUnitPriceValue1 returns the union data inside the OrderLineItem_RawUnitPrice_Value as a OrderLineItemRawUnitPriceValue1
func (t OrderLineItem_RawUnitPrice_Value) AsOrderLineItemRawUnitPriceValue1() (OrderLineItemRawUnitPriceValue1, error) {
	var body OrderLineItemRawUnitPriceValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderLineItemRawUnitPriceValue1 overwrites any union data inside the OrderLineItem_RawUnitPrice_Value as the provided OrderLineItemRawUnitPriceValue1
func (t *OrderLineItem_RawUnitPrice_Value) FromOrderLineItemRawUnitPriceValue1(v OrderLineItemRawUnitPriceValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderLineItemRawUnitPriceValue1 performs a merge with any union data inside the OrderLineItem_RawUnitPrice_Value, using the provided OrderLineItemRawUnitPriceValue1
func (t *OrderLineItem_RawUnitPrice_Value) MergeOrderLineItemRawUnitPriceValue1(v OrderLineItemRawUnitPriceValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderLineItem_RawUnitPrice_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderLineItem_RawUnitPrice_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawAmountValue0 returns the union data inside the OrderShippingMethod_RawAmount_Value as a OrderShippingMethodRawAmountValue0
func (t OrderShippingMethod_RawAmount_Value) AsOrderShippingMethodRawAmountValue0() (OrderShippingMethodRawAmountValue0, error) {
	var body OrderShippingMethodRawAmountValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawAmountValue0 overwrites any union data inside the OrderShippingMethod_RawAmount_Value as the provided OrderShippingMethodRawAmountValue0
func (t *OrderShippingMethod_RawAmount_Value) FromOrderShippingMethodRawAmountValue0(v OrderShippingMethodRawAmountValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawAmountValue0 performs a merge with any union data inside the OrderShippingMethod_RawAmount_Value, using the provided OrderShippingMethodRawAmountValue0
func (t *OrderShippingMethod_RawAmount_Value) MergeOrderShippingMethodRawAmountValue0(v OrderShippingMethodRawAmountValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawAmountValue1 returns the union data inside the OrderShippingMethod_RawAmount_Value as a OrderShippingMethodRawAmountValue1
func (t OrderShippingMethod_RawAmount_Value) AsOrderShippingMethodRawAmountValue1() (OrderShippingMethodRawAmountValue1, error) {
	var body OrderShippingMethodRawAmountValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawAmountValue1 overwrites any union data inside the OrderShippingMethod_RawAmount_Value as the provided OrderShippingMethodRawAmountValue1
func (t *OrderShippingMethod_RawAmount_Value) FromOrderShippingMethodRawAmountValue1(v OrderShippingMethodRawAmountValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawAmountValue1 performs a merge with any union data inside the OrderShippingMethod_RawAmount_Value, using the provided OrderShippingMethodRawAmountValue1
func (t *OrderShippingMethod_RawAmount_Value) MergeOrderShippingMethodRawAmountValue1(v OrderShippingMethodRawAmountValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawAmount_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawAmount_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawDiscountTaxTotalValue0 returns the union data inside the OrderShippingMethod_RawDiscountTaxTotal_Value as a OrderShippingMethodRawDiscountTaxTotalValue0
func (t OrderShippingMethod_RawDiscountTaxTotal_Value) AsOrderShippingMethodRawDiscountTaxTotalValue0() (OrderShippingMethodRawDiscountTaxTotalValue0, error) {
	var body OrderShippingMethodRawDiscountTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawDiscountTaxTotalValue0 overwrites any union data inside the OrderShippingMethod_RawDiscountTaxTotal_Value as the provided OrderShippingMethodRawDiscountTaxTotalValue0
func (t *OrderShippingMethod_RawDiscountTaxTotal_Value) FromOrderShippingMethodRawDiscountTaxTotalValue0(v OrderShippingMethodRawDiscountTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawDiscountTaxTotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawDiscountTaxTotal_Value, using the provided OrderShippingMethodRawDiscountTaxTotalValue0
func (t *OrderShippingMethod_RawDiscountTaxTotal_Value) MergeOrderShippingMethodRawDiscountTaxTotalValue0(v OrderShippingMethodRawDiscountTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawDiscountTaxTotalValue1 returns the union data inside the OrderShippingMethod_RawDiscountTaxTotal_Value as a OrderShippingMethodRawDiscountTaxTotalValue1
func (t OrderShippingMethod_RawDiscountTaxTotal_Value) AsOrderShippingMethodRawDiscountTaxTotalValue1() (OrderShippingMethodRawDiscountTaxTotalValue1, error) {
	var body OrderShippingMethodRawDiscountTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawDiscountTaxTotalValue1 overwrites any union data inside the OrderShippingMethod_RawDiscountTaxTotal_Value as the provided OrderShippingMethodRawDiscountTaxTotalValue1
func (t *OrderShippingMethod_RawDiscountTaxTotal_Value) FromOrderShippingMethodRawDiscountTaxTotalValue1(v OrderShippingMethodRawDiscountTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawDiscountTaxTotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawDiscountTaxTotal_Value, using the provided OrderShippingMethodRawDiscountTaxTotalValue1
func (t *OrderShippingMethod_RawDiscountTaxTotal_Value) MergeOrderShippingMethodRawDiscountTaxTotalValue1(v OrderShippingMethodRawDiscountTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawDiscountTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawDiscountTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawDiscountTotalValue0 returns the union data inside the OrderShippingMethod_RawDiscountTotal_Value as a OrderShippingMethodRawDiscountTotalValue0
func (t OrderShippingMethod_RawDiscountTotal_Value) AsOrderShippingMethodRawDiscountTotalValue0() (OrderShippingMethodRawDiscountTotalValue0, error) {
	var body OrderShippingMethodRawDiscountTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawDiscountTotalValue0 overwrites any union data inside the OrderShippingMethod_RawDiscountTotal_Value as the provided OrderShippingMethodRawDiscountTotalValue0
func (t *OrderShippingMethod_RawDiscountTotal_Value) FromOrderShippingMethodRawDiscountTotalValue0(v OrderShippingMethodRawDiscountTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawDiscountTotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawDiscountTotal_Value, using the provided OrderShippingMethodRawDiscountTotalValue0
func (t *OrderShippingMethod_RawDiscountTotal_Value) MergeOrderShippingMethodRawDiscountTotalValue0(v OrderShippingMethodRawDiscountTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawDiscountTotalValue1 returns the union data inside the OrderShippingMethod_RawDiscountTotal_Value as a OrderShippingMethodRawDiscountTotalValue1
func (t OrderShippingMethod_RawDiscountTotal_Value) AsOrderShippingMethodRawDiscountTotalValue1() (OrderShippingMethodRawDiscountTotalValue1, error) {
	var body OrderShippingMethodRawDiscountTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawDiscountTotalValue1 overwrites any union data inside the OrderShippingMethod_RawDiscountTotal_Value as the provided OrderShippingMethodRawDiscountTotalValue1
func (t *OrderShippingMethod_RawDiscountTotal_Value) FromOrderShippingMethodRawDiscountTotalValue1(v OrderShippingMethodRawDiscountTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawDiscountTotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawDiscountTotal_Value, using the provided OrderShippingMethodRawDiscountTotalValue1
func (t *OrderShippingMethod_RawDiscountTotal_Value) MergeOrderShippingMethodRawDiscountTotalValue1(v OrderShippingMethodRawDiscountTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawDiscountTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawDiscountTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawOriginalSubtotalValue0 returns the union data inside the OrderShippingMethod_RawOriginalSubtotal_Value as a OrderShippingMethodRawOriginalSubtotalValue0
func (t OrderShippingMethod_RawOriginalSubtotal_Value) AsOrderShippingMethodRawOriginalSubtotalValue0() (OrderShippingMethodRawOriginalSubtotalValue0, error) {
	var body OrderShippingMethodRawOriginalSubtotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawOriginalSubtotalValue0 overwrites any union data inside the OrderShippingMethod_RawOriginalSubtotal_Value as the provided OrderShippingMethodRawOriginalSubtotalValue0
func (t *OrderShippingMethod_RawOriginalSubtotal_Value) FromOrderShippingMethodRawOriginalSubtotalValue0(v OrderShippingMethodRawOriginalSubtotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawOriginalSubtotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawOriginalSubtotal_Value, using the provided OrderShippingMethodRawOriginalSubtotalValue0
func (t *OrderShippingMethod_RawOriginalSubtotal_Value) MergeOrderShippingMethodRawOriginalSubtotalValue0(v OrderShippingMethodRawOriginalSubtotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawOriginalSubtotalValue1 returns the union data inside the OrderShippingMethod_RawOriginalSubtotal_Value as a OrderShippingMethodRawOriginalSubtotalValue1
func (t OrderShippingMethod_RawOriginalSubtotal_Value) AsOrderShippingMethodRawOriginalSubtotalValue1() (OrderShippingMethodRawOriginalSubtotalValue1, error) {
	var body OrderShippingMethodRawOriginalSubtotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawOriginalSubtotalValue1 overwrites any union data inside the OrderShippingMethod_RawOriginalSubtotal_Value as the provided OrderShippingMethodRawOriginalSubtotalValue1
func (t *OrderShippingMethod_RawOriginalSubtotal_Value) FromOrderShippingMethodRawOriginalSubtotalValue1(v OrderShippingMethodRawOriginalSubtotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawOriginalSubtotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawOriginalSubtotal_Value, using the provided OrderShippingMethodRawOriginalSubtotalValue1
func (t *OrderShippingMethod_RawOriginalSubtotal_Value) MergeOrderShippingMethodRawOriginalSubtotalValue1(v OrderShippingMethodRawOriginalSubtotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawOriginalSubtotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawOriginalSubtotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawOriginalTaxTotalValue0 returns the union data inside the OrderShippingMethod_RawOriginalTaxTotal_Value as a OrderShippingMethodRawOriginalTaxTotalValue0
func (t OrderShippingMethod_RawOriginalTaxTotal_Value) AsOrderShippingMethodRawOriginalTaxTotalValue0() (OrderShippingMethodRawOriginalTaxTotalValue0, error) {
	var body OrderShippingMethodRawOriginalTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawOriginalTaxTotalValue0 overwrites any union data inside the OrderShippingMethod_RawOriginalTaxTotal_Value as the provided OrderShippingMethodRawOriginalTaxTotalValue0
func (t *OrderShippingMethod_RawOriginalTaxTotal_Value) FromOrderShippingMethodRawOriginalTaxTotalValue0(v OrderShippingMethodRawOriginalTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawOriginalTaxTotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawOriginalTaxTotal_Value, using the provided OrderShippingMethodRawOriginalTaxTotalValue0
func (t *OrderShippingMethod_RawOriginalTaxTotal_Value) MergeOrderShippingMethodRawOriginalTaxTotalValue0(v OrderShippingMethodRawOriginalTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawOriginalTaxTotalValue1 returns the union data inside the OrderShippingMethod_RawOriginalTaxTotal_Value as a OrderShippingMethodRawOriginalTaxTotalValue1
func (t OrderShippingMethod_RawOriginalTaxTotal_Value) AsOrderShippingMethodRawOriginalTaxTotalValue1() (OrderShippingMethodRawOriginalTaxTotalValue1, error) {
	var body OrderShippingMethodRawOriginalTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawOriginalTaxTotalValue1 overwrites any union data inside the OrderShippingMethod_RawOriginalTaxTotal_Value as the provided OrderShippingMethodRawOriginalTaxTotalValue1
func (t *OrderShippingMethod_RawOriginalTaxTotal_Value) FromOrderShippingMethodRawOriginalTaxTotalValue1(v OrderShippingMethodRawOriginalTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawOriginalTaxTotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawOriginalTaxTotal_Value, using the provided OrderShippingMethodRawOriginalTaxTotalValue1
func (t *OrderShippingMethod_RawOriginalTaxTotal_Value) MergeOrderShippingMethodRawOriginalTaxTotalValue1(v OrderShippingMethodRawOriginalTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawOriginalTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawOriginalTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawOriginalTotalValue0 returns the union data inside the OrderShippingMethod_RawOriginalTotal_Value as a OrderShippingMethodRawOriginalTotalValue0
func (t OrderShippingMethod_RawOriginalTotal_Value) AsOrderShippingMethodRawOriginalTotalValue0() (OrderShippingMethodRawOriginalTotalValue0, error) {
	var body OrderShippingMethodRawOriginalTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawOriginalTotalValue0 overwrites any union data inside the OrderShippingMethod_RawOriginalTotal_Value as the provided OrderShippingMethodRawOriginalTotalValue0
func (t *OrderShippingMethod_RawOriginalTotal_Value) FromOrderShippingMethodRawOriginalTotalValue0(v OrderShippingMethodRawOriginalTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawOriginalTotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawOriginalTotal_Value, using the provided OrderShippingMethodRawOriginalTotalValue0
func (t *OrderShippingMethod_RawOriginalTotal_Value) MergeOrderShippingMethodRawOriginalTotalValue0(v OrderShippingMethodRawOriginalTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawOriginalTotalValue1 returns the union data inside the OrderShippingMethod_RawOriginalTotal_Value as a OrderShippingMethodRawOriginalTotalValue1
func (t OrderShippingMethod_RawOriginalTotal_Value) AsOrderShippingMethodRawOriginalTotalValue1() (OrderShippingMethodRawOriginalTotalValue1, error) {
	var body OrderShippingMethodRawOriginalTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawOriginalTotalValue1 overwrites any union data inside the OrderShippingMethod_RawOriginalTotal_Value as the provided OrderShippingMethodRawOriginalTotalValue1
func (t *OrderShippingMethod_RawOriginalTotal_Value) FromOrderShippingMethodRawOriginalTotalValue1(v OrderShippingMethodRawOriginalTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawOriginalTotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawOriginalTotal_Value, using the provided OrderShippingMethodRawOriginalTotalValue1
func (t *OrderShippingMethod_RawOriginalTotal_Value) MergeOrderShippingMethodRawOriginalTotalValue1(v OrderShippingMethodRawOriginalTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawOriginalTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawOriginalTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawSubtotalValue0 returns the union data inside the OrderShippingMethod_RawSubtotal_Value as a OrderShippingMethodRawSubtotalValue0
func (t OrderShippingMethod_RawSubtotal_Value) AsOrderShippingMethodRawSubtotalValue0() (OrderShippingMethodRawSubtotalValue0, error) {
	var body OrderShippingMethodRawSubtotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawSubtotalValue0 overwrites any union data inside the OrderShippingMethod_RawSubtotal_Value as the provided OrderShippingMethodRawSubtotalValue0
func (t *OrderShippingMethod_RawSubtotal_Value) FromOrderShippingMethodRawSubtotalValue0(v OrderShippingMethodRawSubtotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawSubtotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawSubtotal_Value, using the provided OrderShippingMethodRawSubtotalValue0
func (t *OrderShippingMethod_RawSubtotal_Value) MergeOrderShippingMethodRawSubtotalValue0(v OrderShippingMethodRawSubtotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawSubtotalValue1 returns the union data inside the OrderShippingMethod_RawSubtotal_Value as a OrderShippingMethodRawSubtotalValue1
func (t OrderShippingMethod_RawSubtotal_Value) AsOrderShippingMethodRawSubtotalValue1() (OrderShippingMethodRawSubtotalValue1, error) {
	var body OrderShippingMethodRawSubtotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawSubtotalValue1 overwrites any union data inside the OrderShippingMethod_RawSubtotal_Value as the provided OrderShippingMethodRawSubtotalValue1
func (t *OrderShippingMethod_RawSubtotal_Value) FromOrderShippingMethodRawSubtotalValue1(v OrderShippingMethodRawSubtotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawSubtotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawSubtotal_Value, using the provided OrderShippingMethodRawSubtotalValue1
func (t *OrderShippingMethod_RawSubtotal_Value) MergeOrderShippingMethodRawSubtotalValue1(v OrderShippingMethodRawSubtotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawSubtotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawSubtotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawTaxTotalValue0 returns the union data inside the OrderShippingMethod_RawTaxTotal_Value as a OrderShippingMethodRawTaxTotalValue0
func (t OrderShippingMethod_RawTaxTotal_Value) AsOrderShippingMethodRawTaxTotalValue0() (OrderShippingMethodRawTaxTotalValue0, error) {
	var body OrderShippingMethodRawTaxTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawTaxTotalValue0 overwrites any union data inside the OrderShippingMethod_RawTaxTotal_Value as the provided OrderShippingMethodRawTaxTotalValue0
func (t *OrderShippingMethod_RawTaxTotal_Value) FromOrderShippingMethodRawTaxTotalValue0(v OrderShippingMethodRawTaxTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawTaxTotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawTaxTotal_Value, using the provided OrderShippingMethodRawTaxTotalValue0
func (t *OrderShippingMethod_RawTaxTotal_Value) MergeOrderShippingMethodRawTaxTotalValue0(v OrderShippingMethodRawTaxTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawTaxTotalValue1 returns the union data inside the OrderShippingMethod_RawTaxTotal_Value as a OrderShippingMethodRawTaxTotalValue1
func (t OrderShippingMethod_RawTaxTotal_Value) AsOrderShippingMethodRawTaxTotalValue1() (OrderShippingMethodRawTaxTotalValue1, error) {
	var body OrderShippingMethodRawTaxTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawTaxTotalValue1 overwrites any union data inside the OrderShippingMethod_RawTaxTotal_Value as the provided OrderShippingMethodRawTaxTotalValue1
func (t *OrderShippingMethod_RawTaxTotal_Value) FromOrderShippingMethodRawTaxTotalValue1(v OrderShippingMethodRawTaxTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawTaxTotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawTaxTotal_Value, using the provided OrderShippingMethodRawTaxTotalValue1
func (t *OrderShippingMethod_RawTaxTotal_Value) MergeOrderShippingMethodRawTaxTotalValue1(v OrderShippingMethodRawTaxTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawTaxTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawTaxTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderShippingMethodRawTotalValue0 returns the union data inside the OrderShippingMethod_RawTotal_Value as a OrderShippingMethodRawTotalValue0
func (t OrderShippingMethod_RawTotal_Value) AsOrderShippingMethodRawTotalValue0() (OrderShippingMethodRawTotalValue0, error) {
	var body OrderShippingMethodRawTotalValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawTotalValue0 overwrites any union data inside the OrderShippingMethod_RawTotal_Value as the provided OrderShippingMethodRawTotalValue0
func (t *OrderShippingMethod_RawTotal_Value) FromOrderShippingMethodRawTotalValue0(v OrderShippingMethodRawTotalValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawTotalValue0 performs a merge with any union data inside the OrderShippingMethod_RawTotal_Value, using the provided OrderShippingMethodRawTotalValue0
func (t *OrderShippingMethod_RawTotal_Value) MergeOrderShippingMethodRawTotalValue0(v OrderShippingMethodRawTotalValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsOrderShippingMethodRawTotalValue1 returns the union data inside the OrderShippingMethod_RawTotal_Value as a OrderShippingMethodRawTotalValue1
func (t OrderShippingMethod_RawTotal_Value) AsOrderShippingMethodRawTotalValue1() (OrderShippingMethodRawTotalValue1, error) {
	var body OrderShippingMethodRawTotalValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderShippingMethodRawTotalValue1 overwrites any union data inside the OrderShippingMethod_RawTotal_Value as the provided OrderShippingMethodRawTotalValue1
func (t *OrderShippingMethod_RawTotal_Value) FromOrderShippingMethodRawTotalValue1(v OrderShippingMethodRawTotalValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderShippingMethodRawTotalValue1 performs a merge with any union data inside the OrderShippingMethod_RawTotal_Value, using the provided OrderShippingMethodRawTotalValue1
func (t *OrderShippingMethod_RawTotal_Value) MergeOrderShippingMethodRawTotalValue1(v OrderShippingMethodRawTotalValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OrderShippingMethod_RawTotal_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderShippingMethod_RawTotal_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAddress returns the union data inside the UpdateCartData_BillingAddress as a CreateAddress
func (t UpdateCartData_BillingAddress) AsCreateAddress() (CreateAddress, error) {
	var body CreateAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAddress overwrites any union data inside the UpdateCartData_BillingAddress as the provided CreateAddress
func (t *UpdateCartData_BillingAddress) FromCreateAddress(v CreateAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAddress performs a merge with any union data inside the UpdateCartData_BillingAddress, using the provided CreateAddress
func (t *UpdateCartData_BillingAddress) MergeCreateAddress(v CreateAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateAddress returns the union data inside the UpdateCartData_BillingAddress as a UpdateAddress
func (t UpdateCartData_BillingAddress) AsUpdateAddress() (UpdateAddress, error) {
	var body UpdateAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateAddress overwrites any union data inside the UpdateCartData_BillingAddress as the provided UpdateAddress
func (t *UpdateCartData_BillingAddress) FromUpdateAddress(v UpdateAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateAddress performs a merge with any union data inside the UpdateCartData_BillingAddress, using the provided UpdateAddress
func (t *UpdateCartData_BillingAddress) MergeUpdateAddress(v UpdateAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateCartData_BillingAddress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateCartData_BillingAddress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAddress returns the union data inside the UpdateCartData_ShippingAddress as a CreateAddress
func (t UpdateCartData_ShippingAddress) AsCreateAddress() (CreateAddress, error) {
	var body CreateAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAddress overwrites any union data inside the UpdateCartData_ShippingAddress as the provided CreateAddress
func (t *UpdateCartData_ShippingAddress) FromCreateAddress(v CreateAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAddress performs a merge with any union data inside the UpdateCartData_ShippingAddress, using the provided CreateAddress
func (t *UpdateCartData_ShippingAddress) MergeCreateAddress(v CreateAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateAddress returns the union data inside the UpdateCartData_ShippingAddress as a UpdateAddress
func (t UpdateCartData_ShippingAddress) AsUpdateAddress() (UpdateAddress, error) {
	var body UpdateAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateAddress overwrites any union data inside the UpdateCartData_ShippingAddress as the provided UpdateAddress
func (t *UpdateCartData_ShippingAddress) FromUpdateAddress(v UpdateAddress) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateAddress performs a merge with any union data inside the UpdateCartData_ShippingAddress, using the provided UpdateAddress
func (t *UpdateCartData_ShippingAddress) MergeUpdateAddress(v UpdateAddress) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateCartData_ShippingAddress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateCartData_ShippingAddress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApiKeys request
	GetApiKeys(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiKeysWithBody request with any body
	PostApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiKeys(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKeysId request
	DeleteApiKeysId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiKeysId request
	GetApiKeysId(ctx context.Context, id string, params *GetApiKeysIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiKeysIdWithBody request with any body
	PostApiKeysIdWithBody(ctx context.Context, id string, params *PostApiKeysIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiKeysId(ctx context.Context, id string, params *PostApiKeysIdParams, body PostApiKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiKeysIdRevokeWithBody request with any body
	PostApiKeysIdRevokeWithBody(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiKeysIdRevoke(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, body PostApiKeysIdRevokeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiKeysIdSalesChannelsWithBody request with any body
	PostApiKeysIdSalesChannelsWithBody(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApiKeysIdSalesChannels(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, body PostApiKeysIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaigns request
	GetCampaigns(ctx context.Context, params *GetCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCampaignsWithBody request with any body
	PostCampaignsWithBody(ctx context.Context, params *PostCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCampaigns(ctx context.Context, params *PostCampaignsParams, body PostCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCampaignsId request
	DeleteCampaignsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsId request
	GetCampaignsId(ctx context.Context, id string, params *GetCampaignsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCampaignsIdWithBody request with any body
	PostCampaignsIdWithBody(ctx context.Context, id string, params *PostCampaignsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCampaignsId(ctx context.Context, id string, params *PostCampaignsIdParams, body PostCampaignsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCampaignsIdPromotionsWithBody request with any body
	PostCampaignsIdPromotionsWithBody(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCampaignsIdPromotions(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, body PostCampaignsIdPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClaims request
	GetClaims(ctx context.Context, params *GetClaimsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsWithBody request with any body
	PostClaimsWithBody(ctx context.Context, params *PostClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaims(ctx context.Context, params *PostClaimsParams, body PostClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClaimsId request
	GetClaimsId(ctx context.Context, id string, params *GetClaimsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdCancelWithBody request with any body
	PostClaimsIdCancelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdCancel(ctx context.Context, id string, body PostClaimsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdClaimItemsWithBody request with any body
	PostClaimsIdClaimItemsWithBody(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdClaimItems(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, body PostClaimsIdClaimItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClaimsIdClaimItemsActionId request
	DeleteClaimsIdClaimItemsActionId(ctx context.Context, id string, actionId string, params *DeleteClaimsIdClaimItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdClaimItemsActionIdWithBody request with any body
	PostClaimsIdClaimItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdClaimItemsActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, body PostClaimsIdClaimItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdInboundItemsWithBody request with any body
	PostClaimsIdInboundItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdInboundItems(ctx context.Context, id string, body PostClaimsIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClaimsIdInboundItemsActionId request
	DeleteClaimsIdInboundItemsActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdInboundItemsActionIdWithBody request with any body
	PostClaimsIdInboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdInboundItemsActionId(ctx context.Context, id string, actionId string, body PostClaimsIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdInboundShippingMethodWithBody request with any body
	PostClaimsIdInboundShippingMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdInboundShippingMethod(ctx context.Context, id string, body PostClaimsIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClaimsIdInboundShippingMethodActionId request
	DeleteClaimsIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdInboundShippingMethodActionIdWithBody request with any body
	PostClaimsIdInboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, body PostClaimsIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdOutboundItemsWithBody request with any body
	PostClaimsIdOutboundItemsWithBody(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdOutboundItems(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, body PostClaimsIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClaimsIdOutboundItemsActionId request
	DeleteClaimsIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdOutboundItemsActionIdWithBody request with any body
	PostClaimsIdOutboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, body PostClaimsIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdOutboundShippingMethodWithBody request with any body
	PostClaimsIdOutboundShippingMethodWithBody(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdOutboundShippingMethod(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, body PostClaimsIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClaimsIdOutboundShippingMethodActionId request
	DeleteClaimsIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdOutboundShippingMethodActionIdWithBody request with any body
	PostClaimsIdOutboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostClaimsIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, body PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClaimsIdRequest request
	DeleteClaimsIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClaimsIdRequest request
	PostClaimsIdRequest(ctx context.Context, id string, params *PostClaimsIdRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollections request
	GetCollections(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollectionsWithBody request with any body
	PostCollectionsWithBody(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollections(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollectionsId request
	DeleteCollectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionsId request
	GetCollectionsId(ctx context.Context, id string, params *GetCollectionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollectionsIdWithBody request with any body
	PostCollectionsIdWithBody(ctx context.Context, id string, params *PostCollectionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollectionsId(ctx context.Context, id string, params *PostCollectionsIdParams, body PostCollectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollectionsIdProductsWithBody request with any body
	PostCollectionsIdProductsWithBody(ctx context.Context, id string, params *PostCollectionsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollectionsIdProducts(ctx context.Context, id string, params *PostCollectionsIdProductsParams, body PostCollectionsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencies request
	GetCurrencies(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrenciesCode request
	GetCurrenciesCode(ctx context.Context, code string, params *GetCurrenciesCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerGroups request
	GetCustomerGroups(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerGroupsWithBody request with any body
	PostCustomerGroupsWithBody(ctx context.Context, params *PostCustomerGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerGroups(ctx context.Context, params *PostCustomerGroupsParams, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomerGroupsId request
	DeleteCustomerGroupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerGroupsId request
	GetCustomerGroupsId(ctx context.Context, id string, params *GetCustomerGroupsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerGroupsIdWithBody request with any body
	PostCustomerGroupsIdWithBody(ctx context.Context, id string, params *PostCustomerGroupsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerGroupsId(ctx context.Context, id string, params *PostCustomerGroupsIdParams, body PostCustomerGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerGroupsIdCustomersWithBody request with any body
	PostCustomerGroupsIdCustomersWithBody(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerGroupsIdCustomers(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, body PostCustomerGroupsIdCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomers request
	GetCustomers(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersWithBody request with any body
	PostCustomersWithBody(ctx context.Context, params *PostCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomers(ctx context.Context, params *PostCustomersParams, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomersId request
	DeleteCustomersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomersId request
	GetCustomersId(ctx context.Context, id string, params *GetCustomersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersIdWithBody request with any body
	PostCustomersIdWithBody(ctx context.Context, id string, params *PostCustomersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomersId(ctx context.Context, id string, params *PostCustomersIdParams, body PostCustomersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomersIdAddresses request
	GetCustomersIdAddresses(ctx context.Context, id string, params *GetCustomersIdAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersIdAddressesWithBody request with any body
	PostCustomersIdAddressesWithBody(ctx context.Context, id string, params *PostCustomersIdAddressesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomersIdAddresses(ctx context.Context, id string, params *PostCustomersIdAddressesParams, body PostCustomersIdAddressesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomersIdAddressesAddressId request
	DeleteCustomersIdAddressesAddressId(ctx context.Context, id string, addressId string, params *DeleteCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomersIdAddressesAddressId request
	GetCustomersIdAddressesAddressId(ctx context.Context, id string, addressId string, params *GetCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersIdAddressesAddressIdWithBody request with any body
	PostCustomersIdAddressesAddressIdWithBody(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomersIdAddressesAddressId(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, body PostCustomersIdAddressesAddressIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDraftOrders request
	GetDraftOrders(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDraftOrdersWithBody request with any body
	PostDraftOrdersWithBody(ctx context.Context, params *PostDraftOrdersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDraftOrders(ctx context.Context, params *PostDraftOrdersParams, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDraftOrdersId request
	GetDraftOrdersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchanges request
	GetExchanges(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesWithBody request with any body
	PostExchangesWithBody(ctx context.Context, params *PostExchangesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchanges(ctx context.Context, params *PostExchangesParams, body PostExchangesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExchangesId request
	GetExchangesId(ctx context.Context, id string, params *GetExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdCancelWithBody request with any body
	PostExchangesIdCancelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdCancel(ctx context.Context, id string, body PostExchangesIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdInboundItemsWithBody request with any body
	PostExchangesIdInboundItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdInboundItems(ctx context.Context, id string, body PostExchangesIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExchangesIdInboundItemsActionId request
	DeleteExchangesIdInboundItemsActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdInboundItemsActionIdWithBody request with any body
	PostExchangesIdInboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdInboundItemsActionId(ctx context.Context, id string, actionId string, body PostExchangesIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdInboundShippingMethodWithBody request with any body
	PostExchangesIdInboundShippingMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdInboundShippingMethod(ctx context.Context, id string, body PostExchangesIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExchangesIdInboundShippingMethodActionId request
	DeleteExchangesIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdInboundShippingMethodActionIdWithBody request with any body
	PostExchangesIdInboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, body PostExchangesIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdOutboundItemsWithBody request with any body
	PostExchangesIdOutboundItemsWithBody(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdOutboundItems(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, body PostExchangesIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExchangesIdOutboundItemsActionId request
	DeleteExchangesIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdOutboundItemsActionIdWithBody request with any body
	PostExchangesIdOutboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, body PostExchangesIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdOutboundShippingMethodWithBody request with any body
	PostExchangesIdOutboundShippingMethodWithBody(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdOutboundShippingMethod(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, body PostExchangesIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExchangesIdOutboundShippingMethodActionId request
	DeleteExchangesIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdOutboundShippingMethodActionIdWithBody request with any body
	PostExchangesIdOutboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExchangesIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, body PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExchangesIdRequest request
	DeleteExchangesIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExchangesIdRequest request
	PostExchangesIdRequest(ctx context.Context, id string, params *PostExchangesIdRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFulfillmentProviders request
	GetFulfillmentProviders(ctx context.Context, params *GetFulfillmentProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFulfillmentSetsId request
	DeleteFulfillmentSetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFulfillmentSetsIdServiceZonesWithBody request with any body
	PostFulfillmentSetsIdServiceZonesWithBody(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFulfillmentSetsIdServiceZones(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, body PostFulfillmentSetsIdServiceZonesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFulfillmentSetsIdServiceZonesZoneId request
	DeleteFulfillmentSetsIdServiceZonesZoneId(ctx context.Context, id string, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFulfillmentSetsIdServiceZonesZoneId request
	GetFulfillmentSetsIdServiceZonesZoneId(ctx context.Context, id string, zoneId string, params *GetFulfillmentSetsIdServiceZonesZoneIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFulfillmentSetsIdServiceZonesZoneIdWithBody request with any body
	PostFulfillmentSetsIdServiceZonesZoneIdWithBody(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFulfillmentSetsIdServiceZonesZoneId(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, body PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFulfillmentsWithBody request with any body
	PostFulfillmentsWithBody(ctx context.Context, params *PostFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFulfillments(ctx context.Context, params *PostFulfillmentsParams, body PostFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFulfillmentsIdCancel request
	PostFulfillmentsIdCancel(ctx context.Context, id string, params *PostFulfillmentsIdCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFulfillmentsIdShipmentWithBody request with any body
	PostFulfillmentsIdShipmentWithBody(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFulfillmentsIdShipment(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, body PostFulfillmentsIdShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItems request
	GetInventoryItems(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsWithBody request with any body
	PostInventoryItemsWithBody(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItems(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInventoryItemsId request
	DeleteInventoryItemsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItemsId request
	GetInventoryItemsId(ctx context.Context, id string, params *GetInventoryItemsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsIdWithBody request with any body
	PostInventoryItemsIdWithBody(ctx context.Context, id string, params *PostInventoryItemsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsId(ctx context.Context, id string, params *PostInventoryItemsIdParams, body PostInventoryItemsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItemsIdLocationLevels request
	GetInventoryItemsIdLocationLevels(ctx context.Context, id string, params *GetInventoryItemsIdLocationLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsIdLocationLevelsWithBody request with any body
	PostInventoryItemsIdLocationLevelsWithBody(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsIdLocationLevels(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, body PostInventoryItemsIdLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsIdLocationLevelsBatchWithBody request with any body
	PostInventoryItemsIdLocationLevelsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsIdLocationLevelsBatch(ctx context.Context, id string, body PostInventoryItemsIdLocationLevelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInventoryItemsIdLocationLevelsLocationId request
	DeleteInventoryItemsIdLocationLevelsLocationId(ctx context.Context, id string, locationId string, params *DeleteInventoryItemsIdLocationLevelsLocationIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsIdLocationLevelsLocationIdWithBody request with any body
	PostInventoryItemsIdLocationLevelsLocationIdWithBody(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsIdLocationLevelsLocationId(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, body PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvites request
	GetInvites(ctx context.Context, params *GetInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInvitesWithBody request with any body
	PostInvitesWithBody(ctx context.Context, params *PostInvitesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInvites(ctx context.Context, params *PostInvitesParams, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInvitesAcceptWithBody request with any body
	PostInvitesAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInvitesAccept(ctx context.Context, body PostInvitesAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvitesId request
	DeleteInvitesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvitesId request
	GetInvitesId(ctx context.Context, id string, params *GetInvitesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInvitesIdResend request
	PostInvitesIdResend(ctx context.Context, id string, params *PostInvitesIdResendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotifications request
	GetNotifications(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationsId request
	GetNotificationsId(ctx context.Context, id string, params *GetNotificationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsWithBody request with any body
	PostOrderEditsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEdits(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderEditsId request
	DeleteOrderEditsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdConfirm request
	PostOrderEditsIdConfirm(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdItemsWithBody request with any body
	PostOrderEditsIdItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsIdItems(ctx context.Context, id string, body PostOrderEditsIdItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdItemsItemItemIdWithBody request with any body
	PostOrderEditsIdItemsItemItemIdWithBody(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsIdItemsItemItemId(ctx context.Context, id string, itemId string, body PostOrderEditsIdItemsItemItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderEditsIdItemsActionId request
	DeleteOrderEditsIdItemsActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdItemsActionIdWithBody request with any body
	PostOrderEditsIdItemsActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsIdItemsActionId(ctx context.Context, id string, actionId string, body PostOrderEditsIdItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdRequest request
	PostOrderEditsIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdShippingMethodWithBody request with any body
	PostOrderEditsIdShippingMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsIdShippingMethod(ctx context.Context, id string, body PostOrderEditsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderEditsIdShippingMethodActionId request
	DeleteOrderEditsIdShippingMethodActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsIdShippingMethodActionIdWithBody request with any body
	PostOrderEditsIdShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsIdShippingMethodActionId(ctx context.Context, id string, actionId string, body PostOrderEditsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrdersId request
	GetOrdersId(ctx context.Context, id string, params *GetOrdersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersId request
	PostOrdersId(ctx context.Context, id string, params *PostOrdersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdArchive request
	PostOrdersIdArchive(ctx context.Context, id string, params *PostOrdersIdArchiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdCancel request
	PostOrdersIdCancel(ctx context.Context, id string, params *PostOrdersIdCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrdersIdChanges request
	GetOrdersIdChanges(ctx context.Context, id string, params *GetOrdersIdChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdCompleteWithBody request with any body
	PostOrdersIdCompleteWithBody(ctx context.Context, id string, params *PostOrdersIdCompleteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersIdComplete(ctx context.Context, id string, params *PostOrdersIdCompleteParams, body PostOrdersIdCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdFulfillmentsWithBody request with any body
	PostOrdersIdFulfillmentsWithBody(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersIdFulfillments(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, body PostOrdersIdFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdFulfillmentsFulfillmentIdCancelWithBody request with any body
	PostOrdersIdFulfillmentsFulfillmentIdCancelWithBody(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersIdFulfillmentsFulfillmentIdCancel(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, body PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered request
	PostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBody request with any body
	PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBody(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersIdFulfillmentsFulfillmentIdShipments(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, body PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrdersIdPreview request
	GetOrdersIdPreview(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentCollectionsWithBody request with any body
	PostPaymentCollectionsWithBody(ctx context.Context, params *PostPaymentCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPaymentCollections(ctx context.Context, params *PostPaymentCollectionsParams, body PostPaymentCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentCollectionsId request
	DeletePaymentCollectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentCollectionsIdMarkAsPaidWithBody request with any body
	PostPaymentCollectionsIdMarkAsPaidWithBody(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPaymentCollectionsIdMarkAsPaid(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, body PostPaymentCollectionsIdMarkAsPaidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayments request
	GetPayments(ctx context.Context, params *GetPaymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentsPaymentProviders request
	GetPaymentsPaymentProviders(ctx context.Context, params *GetPaymentsPaymentProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentsId request
	GetPaymentsId(ctx context.Context, id string, params *GetPaymentsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentsIdCaptureWithBody request with any body
	PostPaymentsIdCaptureWithBody(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPaymentsIdCapture(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, body PostPaymentsIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentsIdRefundWithBody request with any body
	PostPaymentsIdRefundWithBody(ctx context.Context, id string, params *PostPaymentsIdRefundParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPaymentsIdRefund(ctx context.Context, id string, params *PostPaymentsIdRefundParams, body PostPaymentsIdRefundJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPriceLists request
	GetPriceLists(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsWithBody request with any body
	PostPriceListsWithBody(ctx context.Context, params *PostPriceListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceLists(ctx context.Context, params *PostPriceListsParams, body PostPriceListsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePriceListsId request
	DeletePriceListsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPriceListsId request
	GetPriceListsId(ctx context.Context, id string, params *GetPriceListsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsIdWithBody request with any body
	PostPriceListsIdWithBody(ctx context.Context, id string, params *PostPriceListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceListsId(ctx context.Context, id string, params *PostPriceListsIdParams, body PostPriceListsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsIdPricesBatchWithBody request with any body
	PostPriceListsIdPricesBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceListsIdPricesBatch(ctx context.Context, id string, body PostPriceListsIdPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsIdProductsWithBody request with any body
	PostPriceListsIdProductsWithBody(ctx context.Context, id string, params *PostPriceListsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceListsIdProducts(ctx context.Context, id string, params *PostPriceListsIdProductsParams, body PostPriceListsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricePreferences request
	GetPricePreferences(ctx context.Context, params *GetPricePreferencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPricePreferencesWithBody request with any body
	PostPricePreferencesWithBody(ctx context.Context, params *PostPricePreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPricePreferences(ctx context.Context, params *PostPricePreferencesParams, body PostPricePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePricePreferencesId request
	DeletePricePreferencesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricePreferencesId request
	GetPricePreferencesId(ctx context.Context, id string, params *GetPricePreferencesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPricePreferencesIdWithBody request with any body
	PostPricePreferencesIdWithBody(ctx context.Context, id string, params *PostPricePreferencesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPricePreferencesId(ctx context.Context, id string, params *PostPricePreferencesIdParams, body PostPricePreferencesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductCategories request
	GetProductCategories(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductCategoriesWithBody request with any body
	PostProductCategoriesWithBody(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductCategories(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductCategoriesId request
	DeleteProductCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductCategoriesId request
	GetProductCategoriesId(ctx context.Context, id string, params *GetProductCategoriesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductCategoriesIdWithBody request with any body
	PostProductCategoriesIdWithBody(ctx context.Context, id string, params *PostProductCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductCategoriesId(ctx context.Context, id string, params *PostProductCategoriesIdParams, body PostProductCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductCategoriesIdProductsWithBody request with any body
	PostProductCategoriesIdProductsWithBody(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductCategoriesIdProducts(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, body PostProductCategoriesIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductTags request
	GetProductTags(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductTagsWithBody request with any body
	PostProductTagsWithBody(ctx context.Context, params *PostProductTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductTags(ctx context.Context, params *PostProductTagsParams, body PostProductTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductTagsId request
	DeleteProductTagsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductTagsId request
	GetProductTagsId(ctx context.Context, id string, params *GetProductTagsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductTagsIdWithBody request with any body
	PostProductTagsIdWithBody(ctx context.Context, id string, params *PostProductTagsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductTagsId(ctx context.Context, id string, params *PostProductTagsIdParams, body PostProductTagsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductTypes request
	GetProductTypes(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductTypesWithBody request with any body
	PostProductTypesWithBody(ctx context.Context, params *PostProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductTypes(ctx context.Context, params *PostProductTypesParams, body PostProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductTypesId request
	DeleteProductTypesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductTypesId request
	GetProductTypesId(ctx context.Context, id string, params *GetProductTypesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductTypesIdWithBody request with any body
	PostProductTypesIdWithBody(ctx context.Context, id string, params *PostProductTypesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductTypesId(ctx context.Context, id string, params *PostProductTypesIdParams, body PostProductTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductVariants request
	GetProductVariants(ctx context.Context, params *GetProductVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducts request
	GetProducts(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsWithBody request with any body
	PostProductsWithBody(ctx context.Context, params *PostProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProducts(ctx context.Context, params *PostProductsParams, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsBatchWithBody request with any body
	PostProductsBatchWithBody(ctx context.Context, params *PostProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsBatch(ctx context.Context, params *PostProductsBatchParams, body PostProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsExport request
	PostProductsExport(ctx context.Context, params *PostProductsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsImportWithBody request with any body
	PostProductsImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsImport(ctx context.Context, body PostProductsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsImportTransactionIdConfirm request
	PostProductsImportTransactionIdConfirm(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsId request
	DeleteProductsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsId request
	GetProductsId(ctx context.Context, id string, params *GetProductsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdWithBody request with any body
	PostProductsIdWithBody(ctx context.Context, id string, params *PostProductsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsId(ctx context.Context, id string, params *PostProductsIdParams, body PostProductsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsIdOptions request
	GetProductsIdOptions(ctx context.Context, id string, params *GetProductsIdOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdOptionsWithBody request with any body
	PostProductsIdOptionsWithBody(ctx context.Context, id string, params *PostProductsIdOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdOptions(ctx context.Context, id string, params *PostProductsIdOptionsParams, body PostProductsIdOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsIdOptionsOptionId request
	DeleteProductsIdOptionsOptionId(ctx context.Context, id string, optionId string, params *DeleteProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsIdOptionsOptionId request
	GetProductsIdOptionsOptionId(ctx context.Context, id string, optionId string, params *GetProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdOptionsOptionIdWithBody request with any body
	PostProductsIdOptionsOptionIdWithBody(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdOptionsOptionId(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, body PostProductsIdOptionsOptionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsIdVariants request
	GetProductsIdVariants(ctx context.Context, id string, params *GetProductsIdVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdVariantsWithBody request with any body
	PostProductsIdVariantsWithBody(ctx context.Context, id string, params *PostProductsIdVariantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdVariants(ctx context.Context, id string, params *PostProductsIdVariantsParams, body PostProductsIdVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdVariantsBatchWithBody request with any body
	PostProductsIdVariantsBatchWithBody(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdVariantsBatch(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, body PostProductsIdVariantsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdVariantsInventoryItemsBatchWithBody request with any body
	PostProductsIdVariantsInventoryItemsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdVariantsInventoryItemsBatch(ctx context.Context, id string, body PostProductsIdVariantsInventoryItemsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsIdVariantsVariantId request
	DeleteProductsIdVariantsVariantId(ctx context.Context, id string, variantId string, params *DeleteProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsIdVariantsVariantId request
	GetProductsIdVariantsVariantId(ctx context.Context, id string, variantId string, params *GetProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdVariantsVariantIdWithBody request with any body
	PostProductsIdVariantsVariantIdWithBody(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdVariantsVariantId(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, body PostProductsIdVariantsVariantIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdVariantsVariantIdInventoryItemsWithBody request with any body
	PostProductsIdVariantsVariantIdInventoryItemsWithBody(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdVariantsVariantIdInventoryItems(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, body PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId request
	DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId(ctx context.Context, id string, variantId string, inventoryItemId string, params *DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBody request with any body
	PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBody(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, body PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotions request
	GetPromotions(ctx context.Context, params *GetPromotionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPromotionsWithBody request with any body
	PostPromotionsWithBody(ctx context.Context, params *PostPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPromotions(ctx context.Context, params *PostPromotionsParams, body PostPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotionsRuleAttributeOptionsRuleType request
	GetPromotionsRuleAttributeOptionsRuleType(ctx context.Context, ruleType GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType, params *GetPromotionsRuleAttributeOptionsRuleTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId request
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId(ctx context.Context, ruleType GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType, ruleAttributeId string, params *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePromotionsId request
	DeletePromotionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotionsId request
	GetPromotionsId(ctx context.Context, id string, params *GetPromotionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPromotionsIdWithBody request with any body
	PostPromotionsIdWithBody(ctx context.Context, id string, params *PostPromotionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPromotionsId(ctx context.Context, id string, params *PostPromotionsIdParams, body PostPromotionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPromotionsIdBuyRulesBatchWithBody request with any body
	PostPromotionsIdBuyRulesBatchWithBody(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPromotionsIdBuyRulesBatch(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, body PostPromotionsIdBuyRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPromotionsIdRulesBatchWithBody request with any body
	PostPromotionsIdRulesBatchWithBody(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPromotionsIdRulesBatch(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, body PostPromotionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPromotionsIdTargetRulesBatchWithBody request with any body
	PostPromotionsIdTargetRulesBatchWithBody(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPromotionsIdTargetRulesBatch(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, body PostPromotionsIdTargetRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotionsIdRuleType request
	GetPromotionsIdRuleType(ctx context.Context, id string, ruleType GetPromotionsIdRuleTypeParamsRuleType, params *GetPromotionsIdRuleTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRefundReasons request
	GetRefundReasons(ctx context.Context, params *GetRefundReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRefundReasonsWithBody request with any body
	PostRefundReasonsWithBody(ctx context.Context, params *PostRefundReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRefundReasons(ctx context.Context, params *PostRefundReasonsParams, body PostRefundReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRefundReasonsId request
	DeleteRefundReasonsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRefundReasonsId request
	GetRefundReasonsId(ctx context.Context, id string, params *GetRefundReasonsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRefundReasonsIdWithBody request with any body
	PostRefundReasonsIdWithBody(ctx context.Context, id string, params *PostRefundReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRefundReasonsId(ctx context.Context, id string, params *PostRefundReasonsIdParams, body PostRefundReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegions request
	GetRegions(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsWithBody request with any body
	PostRegionsWithBody(ctx context.Context, params *PostRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegions(ctx context.Context, params *PostRegionsParams, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRegionsId request
	DeleteRegionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegionsId request
	GetRegionsId(ctx context.Context, id string, params *GetRegionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsIdWithBody request with any body
	PostRegionsIdWithBody(ctx context.Context, id string, params *PostRegionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegionsId(ctx context.Context, id string, params *PostRegionsIdParams, body PostRegionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservations request
	GetReservations(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservationsWithBody request with any body
	PostReservationsWithBody(ctx context.Context, params *PostReservationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReservations(ctx context.Context, params *PostReservationsParams, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservationsId request
	DeleteReservationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservationsId request
	GetReservationsId(ctx context.Context, id string, params *GetReservationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservationsIdWithBody request with any body
	PostReservationsIdWithBody(ctx context.Context, id string, params *PostReservationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReservationsId(ctx context.Context, id string, params *PostReservationsIdParams, body PostReservationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturnReasons request
	GetReturnReasons(ctx context.Context, params *GetReturnReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnReasonsWithBody request with any body
	PostReturnReasonsWithBody(ctx context.Context, params *PostReturnReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnReasons(ctx context.Context, params *PostReturnReasonsParams, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnReasonsId request
	DeleteReturnReasonsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturnReasonsId request
	GetReturnReasonsId(ctx context.Context, id string, params *GetReturnReasonsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnReasonsIdWithBody request with any body
	PostReturnReasonsIdWithBody(ctx context.Context, id string, params *PostReturnReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnReasonsId(ctx context.Context, id string, params *PostReturnReasonsIdParams, body PostReturnReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturns request
	GetReturns(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsWithBody request with any body
	PostReturnsWithBody(ctx context.Context, params *PostReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturns(ctx context.Context, params *PostReturnsParams, body PostReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturnsId request
	GetReturnsId(ctx context.Context, id string, params *GetReturnsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdWithBody request with any body
	PostReturnsIdWithBody(ctx context.Context, id string, params *PostReturnsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsId(ctx context.Context, id string, params *PostReturnsIdParams, body PostReturnsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdCancelWithBody request with any body
	PostReturnsIdCancelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdCancel(ctx context.Context, id string, body PostReturnsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdDismissItemsWithBody request with any body
	PostReturnsIdDismissItemsWithBody(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdDismissItems(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, body PostReturnsIdDismissItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnsIdDismissItemsActionId request
	DeleteReturnsIdDismissItemsActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdDismissItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdDismissItemsActionIdWithBody request with any body
	PostReturnsIdDismissItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdDismissItemsActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, body PostReturnsIdDismissItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnsIdReceive request
	DeleteReturnsIdReceive(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdReceiveWithBody request with any body
	PostReturnsIdReceiveWithBody(ctx context.Context, id string, params *PostReturnsIdReceiveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdReceive(ctx context.Context, id string, params *PostReturnsIdReceiveParams, body PostReturnsIdReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdReceiveItemsWithBody request with any body
	PostReturnsIdReceiveItemsWithBody(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdReceiveItems(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, body PostReturnsIdReceiveItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnsIdReceiveItemsActionId request
	DeleteReturnsIdReceiveItemsActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdReceiveItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdReceiveItemsActionIdWithBody request with any body
	PostReturnsIdReceiveItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdReceiveItemsActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, body PostReturnsIdReceiveItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdReceiveConfirmWithBody request with any body
	PostReturnsIdReceiveConfirmWithBody(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdReceiveConfirm(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, body PostReturnsIdReceiveConfirmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnsIdRequest request
	DeleteReturnsIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdRequestWithBody request with any body
	PostReturnsIdRequestWithBody(ctx context.Context, id string, params *PostReturnsIdRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdRequest(ctx context.Context, id string, params *PostReturnsIdRequestParams, body PostReturnsIdRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdRequestItemsWithBody request with any body
	PostReturnsIdRequestItemsWithBody(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdRequestItems(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, body PostReturnsIdRequestItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnsIdRequestItemsActionId request
	DeleteReturnsIdRequestItemsActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdRequestItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdRequestItemsActionIdWithBody request with any body
	PostReturnsIdRequestItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdRequestItemsActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, body PostReturnsIdRequestItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdShippingMethodWithBody request with any body
	PostReturnsIdShippingMethodWithBody(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdShippingMethod(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, body PostReturnsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnsIdShippingMethodActionId request
	DeleteReturnsIdShippingMethodActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsIdShippingMethodActionIdWithBody request with any body
	PostReturnsIdShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsIdShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, body PostReturnsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSalesChannels request
	GetSalesChannels(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsWithBody request with any body
	PostSalesChannelsWithBody(ctx context.Context, params *PostSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannels(ctx context.Context, params *PostSalesChannelsParams, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSalesChannelsId request
	DeleteSalesChannelsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSalesChannelsId request
	GetSalesChannelsId(ctx context.Context, id string, params *GetSalesChannelsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsIdWithBody request with any body
	PostSalesChannelsIdWithBody(ctx context.Context, id string, params *PostSalesChannelsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannelsId(ctx context.Context, id string, params *PostSalesChannelsIdParams, body PostSalesChannelsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsIdProductsWithBody request with any body
	PostSalesChannelsIdProductsWithBody(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannelsIdProducts(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, body PostSalesChannelsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingOptions request
	GetShippingOptions(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingOptionsWithBody request with any body
	PostShippingOptionsWithBody(ctx context.Context, params *PostShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingOptions(ctx context.Context, params *PostShippingOptionsParams, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShippingOptionsId request
	DeleteShippingOptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingOptionsId request
	GetShippingOptionsId(ctx context.Context, id string, params *GetShippingOptionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingOptionsIdWithBody request with any body
	PostShippingOptionsIdWithBody(ctx context.Context, id string, params *PostShippingOptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingOptionsId(ctx context.Context, id string, params *PostShippingOptionsIdParams, body PostShippingOptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingOptionsIdRulesBatchWithBody request with any body
	PostShippingOptionsIdRulesBatchWithBody(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingOptionsIdRulesBatch(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, body PostShippingOptionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingProfiles request
	GetShippingProfiles(ctx context.Context, params *GetShippingProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingProfilesWithBody request with any body
	PostShippingProfilesWithBody(ctx context.Context, params *PostShippingProfilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingProfiles(ctx context.Context, params *PostShippingProfilesParams, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShippingProfilesId request
	DeleteShippingProfilesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingProfilesId request
	GetShippingProfilesId(ctx context.Context, id string, params *GetShippingProfilesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingProfilesIdWithBody request with any body
	PostShippingProfilesIdWithBody(ctx context.Context, id string, params *PostShippingProfilesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingProfilesId(ctx context.Context, id string, params *PostShippingProfilesIdParams, body PostShippingProfilesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStockLocations request
	GetStockLocations(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsWithBody request with any body
	PostStockLocationsWithBody(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocations(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStockLocationsId request
	DeleteStockLocationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStockLocationsId request
	GetStockLocationsId(ctx context.Context, id string, params *GetStockLocationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsIdWithBody request with any body
	PostStockLocationsIdWithBody(ctx context.Context, id string, params *PostStockLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocationsId(ctx context.Context, id string, params *PostStockLocationsIdParams, body PostStockLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsIdFulfillmentProvidersWithBody request with any body
	PostStockLocationsIdFulfillmentProvidersWithBody(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocationsIdFulfillmentProviders(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, body PostStockLocationsIdFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsIdFulfillmentSetsWithBody request with any body
	PostStockLocationsIdFulfillmentSetsWithBody(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocationsIdFulfillmentSets(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, body PostStockLocationsIdFulfillmentSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsIdSalesChannelsWithBody request with any body
	PostStockLocationsIdSalesChannelsWithBody(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocationsIdSalesChannels(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, body PostStockLocationsIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStores request
	GetStores(ctx context.Context, params *GetStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoresId request
	GetStoresId(ctx context.Context, id string, params *GetStoresIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStoresIdWithBody request with any body
	PostStoresIdWithBody(ctx context.Context, id string, params *PostStoresIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStoresId(ctx context.Context, id string, params *PostStoresIdParams, body PostStoresIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxRates request
	GetTaxRates(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesWithBody request with any body
	PostTaxRatesWithBody(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRates(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRatesId request
	DeleteTaxRatesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxRatesId request
	GetTaxRatesId(ctx context.Context, id string, params *GetTaxRatesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesIdWithBody request with any body
	PostTaxRatesIdWithBody(ctx context.Context, id string, params *PostTaxRatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRatesId(ctx context.Context, id string, params *PostTaxRatesIdParams, body PostTaxRatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesIdRulesWithBody request with any body
	PostTaxRatesIdRulesWithBody(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRatesIdRules(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, body PostTaxRatesIdRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRatesIdRulesRuleId request
	DeleteTaxRatesIdRulesRuleId(ctx context.Context, id string, ruleId string, params *DeleteTaxRatesIdRulesRuleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxRegions request
	GetTaxRegions(ctx context.Context, params *GetTaxRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRegionsWithBody request with any body
	PostTaxRegionsWithBody(ctx context.Context, params *PostTaxRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRegions(ctx context.Context, params *PostTaxRegionsParams, body PostTaxRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRegionsId request
	DeleteTaxRegionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxRegionsId request
	GetTaxRegionsId(ctx context.Context, id string, params *GetTaxRegionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUploadsWithBody request with any body
	PostUploadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUploads(ctx context.Context, body PostUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUploadsId request
	DeleteUploadsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUploadsId request
	GetUploadsId(ctx context.Context, id string, params *GetUploadsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersMe request
	GetUsersMe(ctx context.Context, params *GetUsersMeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersId request
	DeleteUsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersId request
	GetUsersId(ctx context.Context, id string, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersIdWithBody request with any body
	PostUsersIdWithBody(ctx context.Context, id string, params *PostUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersId(ctx context.Context, id string, params *PostUsersIdParams, body PostUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowsExecutions request
	GetWorkflowsExecutions(ctx context.Context, params *GetWorkflowsExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowsExecutionsId request
	GetWorkflowsExecutionsId(ctx context.Context, id string, params *GetWorkflowsExecutionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkflowsExecutionsWorkflowIdRunWithBody request with any body
	PostWorkflowsExecutionsWorkflowIdRunWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkflowsExecutionsWorkflowIdRun(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkflowsExecutionsWorkflowIdStepsFailureWithBody request with any body
	PostWorkflowsExecutionsWorkflowIdStepsFailureWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkflowsExecutionsWorkflowIdStepsFailure(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBody request with any body
	PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowsExecutionsWorkflowIdSubscribe request
	GetWorkflowsExecutionsWorkflowIdSubscribe(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowsExecutionsWorkflowIdTransactionId request
	GetWorkflowsExecutionsWorkflowIdTransactionId(ctx context.Context, workflowId string, transactionId string, params *GetWorkflowsExecutionsWorkflowIdTransactionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe request
	GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx context.Context, workflowId string, transactionId string, stepId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSession request
	DeleteSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSession request
	PostSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAdminAuthTokenRefresh request
	PostAdminAuthTokenRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostActorTypeAuthProviderWithBody request with any body
	PostActorTypeAuthProviderWithBody(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostActorTypeAuthProvider(ctx context.Context, authProvider string, body PostActorTypeAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostActorTypeAuthProviderCallback request
	PostActorTypeAuthProviderCallback(ctx context.Context, authProvider string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostActorTypeAuthProviderRegisterWithBody request with any body
	PostActorTypeAuthProviderRegisterWithBody(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostActorTypeAuthProviderRegister(ctx context.Context, authProvider string, body PostActorTypeAuthProviderRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApiKeys(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeys(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKeysId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeysIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiKeysId(ctx context.Context, id string, params *GetApiKeysIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiKeysIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysIdWithBody(ctx context.Context, id string, params *PostApiKeysIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysId(ctx context.Context, id string, params *PostApiKeysIdParams, body PostApiKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysIdRevokeWithBody(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysIdRevokeRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysIdRevoke(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, body PostApiKeysIdRevokeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysIdRevokeRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysIdSalesChannelsWithBody(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysIdSalesChannelsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiKeysIdSalesChannels(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, body PostApiKeysIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiKeysIdSalesChannelsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaigns(ctx context.Context, params *GetCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCampaignsWithBody(ctx context.Context, params *PostCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCampaignsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCampaigns(ctx context.Context, params *PostCampaignsParams, body PostCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCampaignsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCampaignsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCampaignsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsId(ctx context.Context, id string, params *GetCampaignsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCampaignsIdWithBody(ctx context.Context, id string, params *PostCampaignsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCampaignsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCampaignsId(ctx context.Context, id string, params *PostCampaignsIdParams, body PostCampaignsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCampaignsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCampaignsIdPromotionsWithBody(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCampaignsIdPromotionsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCampaignsIdPromotions(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, body PostCampaignsIdPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCampaignsIdPromotionsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClaims(ctx context.Context, params *GetClaimsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClaimsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsWithBody(ctx context.Context, params *PostClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaims(ctx context.Context, params *PostClaimsParams, body PostClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClaimsId(ctx context.Context, id string, params *GetClaimsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClaimsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdCancelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdCancelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdCancel(ctx context.Context, id string, body PostClaimsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdCancelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdClaimItemsWithBody(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdClaimItemsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdClaimItems(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, body PostClaimsIdClaimItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdClaimItemsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClaimsIdClaimItemsActionId(ctx context.Context, id string, actionId string, params *DeleteClaimsIdClaimItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClaimsIdClaimItemsActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdClaimItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdClaimItemsActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdClaimItemsActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, body PostClaimsIdClaimItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdClaimItemsActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundItemsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundItems(ctx context.Context, id string, body PostClaimsIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundItemsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClaimsIdInboundItemsActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClaimsIdInboundItemsActionIdRequest(c.Server, id, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundItemsActionIdRequestWithBody(c.Server, id, actionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundItemsActionId(ctx context.Context, id string, actionId string, body PostClaimsIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundItemsActionIdRequest(c.Server, id, actionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundShippingMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundShippingMethodRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundShippingMethod(ctx context.Context, id string, body PostClaimsIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundShippingMethodRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClaimsIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClaimsIdInboundShippingMethodActionIdRequest(c.Server, id, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundShippingMethodActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, body PostClaimsIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdInboundShippingMethodActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundItemsWithBody(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundItemsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundItems(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, body PostClaimsIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundItemsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClaimsIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClaimsIdOutboundItemsActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundItemsActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, body PostClaimsIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundItemsActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundShippingMethodWithBody(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundShippingMethodRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundShippingMethod(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, body PostClaimsIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundShippingMethodRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClaimsIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClaimsIdOutboundShippingMethodActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundShippingMethodActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, body PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdOutboundShippingMethodActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClaimsIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClaimsIdRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClaimsIdRequest(ctx context.Context, id string, params *PostClaimsIdRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClaimsIdRequestRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollections(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsWithBody(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollections(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionsId(ctx context.Context, id string, params *GetCollectionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsIdWithBody(ctx context.Context, id string, params *PostCollectionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsId(ctx context.Context, id string, params *PostCollectionsIdParams, body PostCollectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsIdProductsWithBody(ctx context.Context, id string, params *PostCollectionsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsIdProductsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsIdProducts(ctx context.Context, id string, params *PostCollectionsIdProductsParams, body PostCollectionsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsIdProductsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencies(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrenciesCode(ctx context.Context, code string, params *GetCurrenciesCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrenciesCodeRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerGroups(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsWithBody(ctx context.Context, params *PostCustomerGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroups(ctx context.Context, params *PostCustomerGroupsParams, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomerGroupsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerGroupsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerGroupsId(ctx context.Context, id string, params *GetCustomerGroupsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerGroupsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsIdWithBody(ctx context.Context, id string, params *PostCustomerGroupsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsId(ctx context.Context, id string, params *PostCustomerGroupsIdParams, body PostCustomerGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsIdCustomersWithBody(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsIdCustomersRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsIdCustomers(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, body PostCustomerGroupsIdCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsIdCustomersRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomers(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersWithBody(ctx context.Context, params *PostCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomers(ctx context.Context, params *PostCustomersParams, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomersId(ctx context.Context, id string, params *GetCustomersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdWithBody(ctx context.Context, id string, params *PostCustomersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersId(ctx context.Context, id string, params *PostCustomersIdParams, body PostCustomersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomersIdAddresses(ctx context.Context, id string, params *GetCustomersIdAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomersIdAddressesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdAddressesWithBody(ctx context.Context, id string, params *PostCustomersIdAddressesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersIdAddressesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdAddresses(ctx context.Context, id string, params *PostCustomersIdAddressesParams, body PostCustomersIdAddressesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersIdAddressesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomersIdAddressesAddressId(ctx context.Context, id string, addressId string, params *DeleteCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomersIdAddressesAddressIdRequest(c.Server, id, addressId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomersIdAddressesAddressId(ctx context.Context, id string, addressId string, params *GetCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomersIdAddressesAddressIdRequest(c.Server, id, addressId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdAddressesAddressIdWithBody(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersIdAddressesAddressIdRequestWithBody(c.Server, id, addressId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdAddressesAddressId(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, body PostCustomersIdAddressesAddressIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersIdAddressesAddressIdRequest(c.Server, id, addressId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDraftOrders(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDraftOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersWithBody(ctx context.Context, params *PostDraftOrdersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrders(ctx context.Context, params *PostDraftOrdersParams, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDraftOrdersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDraftOrdersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchanges(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesWithBody(ctx context.Context, params *PostExchangesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchanges(ctx context.Context, params *PostExchangesParams, body PostExchangesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExchangesId(ctx context.Context, id string, params *GetExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExchangesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdCancelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdCancelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdCancel(ctx context.Context, id string, body PostExchangesIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdCancelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundItemsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundItems(ctx context.Context, id string, body PostExchangesIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundItemsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExchangesIdInboundItemsActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExchangesIdInboundItemsActionIdRequest(c.Server, id, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundItemsActionIdRequestWithBody(c.Server, id, actionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundItemsActionId(ctx context.Context, id string, actionId string, body PostExchangesIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundItemsActionIdRequest(c.Server, id, actionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundShippingMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundShippingMethodRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundShippingMethod(ctx context.Context, id string, body PostExchangesIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundShippingMethodRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExchangesIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExchangesIdInboundShippingMethodActionIdRequest(c.Server, id, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundShippingMethodActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdInboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, body PostExchangesIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdInboundShippingMethodActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundItemsWithBody(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundItemsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundItems(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, body PostExchangesIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundItemsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExchangesIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExchangesIdOutboundItemsActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundItemsActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundItemsActionId(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, body PostExchangesIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundItemsActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundShippingMethodWithBody(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundShippingMethodRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundShippingMethod(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, body PostExchangesIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundShippingMethodRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExchangesIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExchangesIdOutboundShippingMethodActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundShippingMethodActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdOutboundShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, body PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdOutboundShippingMethodActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExchangesIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExchangesIdRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExchangesIdRequest(ctx context.Context, id string, params *PostExchangesIdRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExchangesIdRequestRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFulfillmentProviders(ctx context.Context, params *GetFulfillmentProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFulfillmentProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFulfillmentSetsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFulfillmentSetsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentSetsIdServiceZonesWithBody(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentSetsIdServiceZonesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentSetsIdServiceZones(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, body PostFulfillmentSetsIdServiceZonesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentSetsIdServiceZonesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFulfillmentSetsIdServiceZonesZoneId(ctx context.Context, id string, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFulfillmentSetsIdServiceZonesZoneIdRequest(c.Server, id, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFulfillmentSetsIdServiceZonesZoneId(ctx context.Context, id string, zoneId string, params *GetFulfillmentSetsIdServiceZonesZoneIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFulfillmentSetsIdServiceZonesZoneIdRequest(c.Server, id, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentSetsIdServiceZonesZoneIdWithBody(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentSetsIdServiceZonesZoneIdRequestWithBody(c.Server, id, zoneId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentSetsIdServiceZonesZoneId(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, body PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentSetsIdServiceZonesZoneIdRequest(c.Server, id, zoneId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentsWithBody(ctx context.Context, params *PostFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillments(ctx context.Context, params *PostFulfillmentsParams, body PostFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentsIdCancel(ctx context.Context, id string, params *PostFulfillmentsIdCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentsIdCancelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentsIdShipmentWithBody(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentsIdShipmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFulfillmentsIdShipment(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, body PostFulfillmentsIdShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFulfillmentsIdShipmentRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItems(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsWithBody(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItems(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInventoryItemsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInventoryItemsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItemsId(ctx context.Context, id string, params *GetInventoryItemsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdWithBody(ctx context.Context, id string, params *PostInventoryItemsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsId(ctx context.Context, id string, params *PostInventoryItemsIdParams, body PostInventoryItemsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItemsIdLocationLevels(ctx context.Context, id string, params *GetInventoryItemsIdLocationLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemsIdLocationLevelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdLocationLevelsWithBody(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdLocationLevelsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdLocationLevels(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, body PostInventoryItemsIdLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdLocationLevelsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdLocationLevelsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdLocationLevelsBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdLocationLevelsBatch(ctx context.Context, id string, body PostInventoryItemsIdLocationLevelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdLocationLevelsBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInventoryItemsIdLocationLevelsLocationId(ctx context.Context, id string, locationId string, params *DeleteInventoryItemsIdLocationLevelsLocationIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInventoryItemsIdLocationLevelsLocationIdRequest(c.Server, id, locationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdLocationLevelsLocationIdWithBody(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdLocationLevelsLocationIdRequestWithBody(c.Server, id, locationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsIdLocationLevelsLocationId(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, body PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsIdLocationLevelsLocationIdRequest(c.Server, id, locationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvites(ctx context.Context, params *GetInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesWithBody(ctx context.Context, params *PostInvitesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvites(ctx context.Context, params *PostInvitesParams, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesAcceptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesAccept(ctx context.Context, body PostInvitesAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesAcceptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvitesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInvitesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvitesId(ctx context.Context, id string, params *GetInvitesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvitesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesIdResend(ctx context.Context, id string, params *PostInvitesIdResendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesIdResendRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotifications(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationsId(ctx context.Context, id string, params *GetNotificationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEdits(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderEditsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderEditsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdConfirm(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdConfirmRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdItemsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdItems(ctx context.Context, id string, body PostOrderEditsIdItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdItemsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdItemsItemItemIdWithBody(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdItemsItemItemIdRequestWithBody(c.Server, id, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdItemsItemItemId(ctx context.Context, id string, itemId string, body PostOrderEditsIdItemsItemItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdItemsItemItemIdRequest(c.Server, id, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderEditsIdItemsActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderEditsIdItemsActionIdRequest(c.Server, id, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdItemsActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdItemsActionIdRequestWithBody(c.Server, id, actionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdItemsActionId(ctx context.Context, id string, actionId string, body PostOrderEditsIdItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdItemsActionIdRequest(c.Server, id, actionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdShippingMethodWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdShippingMethodRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdShippingMethod(ctx context.Context, id string, body PostOrderEditsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdShippingMethodRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderEditsIdShippingMethodActionId(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderEditsIdShippingMethodActionIdRequest(c.Server, id, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdShippingMethodActionIdRequestWithBody(c.Server, id, actionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsIdShippingMethodActionId(ctx context.Context, id string, actionId string, body PostOrderEditsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsIdShippingMethodActionIdRequest(c.Server, id, actionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrdersId(ctx context.Context, id string, params *GetOrdersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersId(ctx context.Context, id string, params *PostOrdersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdArchive(ctx context.Context, id string, params *PostOrdersIdArchiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdArchiveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdCancel(ctx context.Context, id string, params *PostOrdersIdCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdCancelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrdersIdChanges(ctx context.Context, id string, params *GetOrdersIdChangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersIdChangesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdCompleteWithBody(ctx context.Context, id string, params *PostOrdersIdCompleteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdCompleteRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdComplete(ctx context.Context, id string, params *PostOrdersIdCompleteParams, body PostOrdersIdCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdCompleteRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillmentsWithBody(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillments(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, body PostOrdersIdFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillmentsFulfillmentIdCancelWithBody(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequestWithBody(c.Server, id, fulfillmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillmentsFulfillmentIdCancel(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, body PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequest(c.Server, id, fulfillmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredRequest(c.Server, id, fulfillmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBody(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequestWithBody(c.Server, id, fulfillmentId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersIdFulfillmentsFulfillmentIdShipments(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, body PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequest(c.Server, id, fulfillmentId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrdersIdPreview(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersIdPreviewRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollectionsWithBody(ctx context.Context, params *PostPaymentCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollections(ctx context.Context, params *PostPaymentCollectionsParams, body PostPaymentCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentCollectionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentCollectionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollectionsIdMarkAsPaidWithBody(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsIdMarkAsPaidRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollectionsIdMarkAsPaid(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, body PostPaymentCollectionsIdMarkAsPaidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsIdMarkAsPaidRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayments(ctx context.Context, params *GetPaymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentsPaymentProviders(ctx context.Context, params *GetPaymentsPaymentProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentsPaymentProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentsId(ctx context.Context, id string, params *GetPaymentsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsIdCaptureWithBody(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsIdCaptureRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsIdCapture(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, body PostPaymentsIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsIdCaptureRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsIdRefundWithBody(ctx context.Context, id string, params *PostPaymentsIdRefundParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsIdRefundRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsIdRefund(ctx context.Context, id string, params *PostPaymentsIdRefundParams, body PostPaymentsIdRefundJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsIdRefundRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPriceLists(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPriceListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsWithBody(ctx context.Context, params *PostPriceListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceLists(ctx context.Context, params *PostPriceListsParams, body PostPriceListsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPriceListsId(ctx context.Context, id string, params *GetPriceListsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPriceListsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsIdWithBody(ctx context.Context, id string, params *PostPriceListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsId(ctx context.Context, id string, params *PostPriceListsIdParams, body PostPriceListsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsIdPricesBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsIdPricesBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsIdPricesBatch(ctx context.Context, id string, body PostPriceListsIdPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsIdPricesBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsIdProductsWithBody(ctx context.Context, id string, params *PostPriceListsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsIdProductsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsIdProducts(ctx context.Context, id string, params *PostPriceListsIdProductsParams, body PostPriceListsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsIdProductsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricePreferences(ctx context.Context, params *GetPricePreferencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricePreferencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPricePreferencesWithBody(ctx context.Context, params *PostPricePreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPricePreferencesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPricePreferences(ctx context.Context, params *PostPricePreferencesParams, body PostPricePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPricePreferencesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePricePreferencesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePricePreferencesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricePreferencesId(ctx context.Context, id string, params *GetPricePreferencesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricePreferencesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPricePreferencesIdWithBody(ctx context.Context, id string, params *PostPricePreferencesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPricePreferencesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPricePreferencesId(ctx context.Context, id string, params *PostPricePreferencesIdParams, body PostPricePreferencesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPricePreferencesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductCategories(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesWithBody(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategories(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductCategoriesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductCategoriesId(ctx context.Context, id string, params *GetProductCategoriesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductCategoriesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesIdWithBody(ctx context.Context, id string, params *PostProductCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesId(ctx context.Context, id string, params *PostProductCategoriesIdParams, body PostProductCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesIdProductsWithBody(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesIdProductsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesIdProducts(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, body PostProductCategoriesIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesIdProductsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductTags(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTagsWithBody(ctx context.Context, params *PostProductTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTagsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTags(ctx context.Context, params *PostProductTagsParams, body PostProductTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTagsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductTagsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductTagsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductTagsId(ctx context.Context, id string, params *GetProductTagsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductTagsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTagsIdWithBody(ctx context.Context, id string, params *PostProductTagsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTagsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTagsId(ctx context.Context, id string, params *PostProductTagsIdParams, body PostProductTagsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTagsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductTypes(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTypesWithBody(ctx context.Context, params *PostProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTypesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTypes(ctx context.Context, params *PostProductTypesParams, body PostProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTypesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductTypesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductTypesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductTypesId(ctx context.Context, id string, params *GetProductTypesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductTypesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTypesIdWithBody(ctx context.Context, id string, params *PostProductTypesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTypesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductTypesId(ctx context.Context, id string, params *PostProductTypesIdParams, body PostProductTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductTypesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductVariants(ctx context.Context, params *GetProductVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductVariantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducts(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsWithBody(ctx context.Context, params *PostProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProducts(ctx context.Context, params *PostProductsParams, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsBatchWithBody(ctx context.Context, params *PostProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsBatchRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsBatch(ctx context.Context, params *PostProductsBatchParams, body PostProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsBatchRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsExport(ctx context.Context, params *PostProductsExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsImport(ctx context.Context, body PostProductsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsImportTransactionIdConfirm(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsImportTransactionIdConfirmRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsId(ctx context.Context, id string, params *GetProductsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdWithBody(ctx context.Context, id string, params *PostProductsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsId(ctx context.Context, id string, params *PostProductsIdParams, body PostProductsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsIdOptions(ctx context.Context, id string, params *GetProductsIdOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsIdOptionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdOptionsWithBody(ctx context.Context, id string, params *PostProductsIdOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdOptionsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdOptions(ctx context.Context, id string, params *PostProductsIdOptionsParams, body PostProductsIdOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdOptionsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsIdOptionsOptionId(ctx context.Context, id string, optionId string, params *DeleteProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsIdOptionsOptionIdRequest(c.Server, id, optionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsIdOptionsOptionId(ctx context.Context, id string, optionId string, params *GetProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsIdOptionsOptionIdRequest(c.Server, id, optionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdOptionsOptionIdWithBody(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdOptionsOptionIdRequestWithBody(c.Server, id, optionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdOptionsOptionId(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, body PostProductsIdOptionsOptionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdOptionsOptionIdRequest(c.Server, id, optionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsIdVariants(ctx context.Context, id string, params *GetProductsIdVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsIdVariantsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsWithBody(ctx context.Context, id string, params *PostProductsIdVariantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariants(ctx context.Context, id string, params *PostProductsIdVariantsParams, body PostProductsIdVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsBatchWithBody(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsBatch(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, body PostProductsIdVariantsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsInventoryItemsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsInventoryItemsBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsInventoryItemsBatch(ctx context.Context, id string, body PostProductsIdVariantsInventoryItemsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsInventoryItemsBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsIdVariantsVariantId(ctx context.Context, id string, variantId string, params *DeleteProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsIdVariantsVariantIdRequest(c.Server, id, variantId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsIdVariantsVariantId(ctx context.Context, id string, variantId string, params *GetProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsIdVariantsVariantIdRequest(c.Server, id, variantId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsVariantIdWithBody(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsVariantIdRequestWithBody(c.Server, id, variantId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsVariantId(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, body PostProductsIdVariantsVariantIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsVariantIdRequest(c.Server, id, variantId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsVariantIdInventoryItemsWithBody(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsVariantIdInventoryItemsRequestWithBody(c.Server, id, variantId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsVariantIdInventoryItems(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, body PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsVariantIdInventoryItemsRequest(c.Server, id, variantId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId(ctx context.Context, id string, variantId string, inventoryItemId string, params *DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequest(c.Server, id, variantId, inventoryItemId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBody(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequestWithBody(c.Server, id, variantId, inventoryItemId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, body PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequest(c.Server, id, variantId, inventoryItemId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotions(ctx context.Context, params *GetPromotionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsWithBody(ctx context.Context, params *PostPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotions(ctx context.Context, params *PostPromotionsParams, body PostPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotionsRuleAttributeOptionsRuleType(ctx context.Context, ruleType GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType, params *GetPromotionsRuleAttributeOptionsRuleTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionsRuleAttributeOptionsRuleTypeRequest(c.Server, ruleType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId(ctx context.Context, ruleType GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType, ruleAttributeId string, params *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdRequest(c.Server, ruleType, ruleAttributeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePromotionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePromotionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotionsId(ctx context.Context, id string, params *GetPromotionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdWithBody(ctx context.Context, id string, params *PostPromotionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsId(ctx context.Context, id string, params *PostPromotionsIdParams, body PostPromotionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdBuyRulesBatchWithBody(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdBuyRulesBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdBuyRulesBatch(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, body PostPromotionsIdBuyRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdBuyRulesBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdRulesBatchWithBody(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdRulesBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdRulesBatch(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, body PostPromotionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdRulesBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdTargetRulesBatchWithBody(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdTargetRulesBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPromotionsIdTargetRulesBatch(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, body PostPromotionsIdTargetRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPromotionsIdTargetRulesBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotionsIdRuleType(ctx context.Context, id string, ruleType GetPromotionsIdRuleTypeParamsRuleType, params *GetPromotionsIdRuleTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionsIdRuleTypeRequest(c.Server, id, ruleType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRefundReasons(ctx context.Context, params *GetRefundReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRefundReasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRefundReasonsWithBody(ctx context.Context, params *PostRefundReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRefundReasonsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRefundReasons(ctx context.Context, params *PostRefundReasonsParams, body PostRefundReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRefundReasonsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRefundReasonsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRefundReasonsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRefundReasonsId(ctx context.Context, id string, params *GetRefundReasonsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRefundReasonsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRefundReasonsIdWithBody(ctx context.Context, id string, params *PostRefundReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRefundReasonsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRefundReasonsId(ctx context.Context, id string, params *PostRefundReasonsIdParams, body PostRefundReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRefundReasonsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegions(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsWithBody(ctx context.Context, params *PostRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegions(ctx context.Context, params *PostRegionsParams, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRegionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRegionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegionsId(ctx context.Context, id string, params *GetRegionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsIdWithBody(ctx context.Context, id string, params *PostRegionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsId(ctx context.Context, id string, params *PostRegionsIdParams, body PostRegionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservations(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservationsWithBody(ctx context.Context, params *PostReservationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservations(ctx context.Context, params *PostReservationsParams, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservationsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservationsId(ctx context.Context, id string, params *GetReservationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservationsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservationsIdWithBody(ctx context.Context, id string, params *PostReservationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservationsId(ctx context.Context, id string, params *PostReservationsIdParams, body PostReservationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturnReasons(ctx context.Context, params *GetReturnReasonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnReasonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasonsWithBody(ctx context.Context, params *PostReturnReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasons(ctx context.Context, params *PostReturnReasonsParams, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnReasonsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnReasonsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturnReasonsId(ctx context.Context, id string, params *GetReturnReasonsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnReasonsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasonsIdWithBody(ctx context.Context, id string, params *PostReturnReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasonsId(ctx context.Context, id string, params *PostReturnReasonsIdParams, body PostReturnReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturns(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsWithBody(ctx context.Context, params *PostReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturns(ctx context.Context, params *PostReturnsParams, body PostReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturnsId(ctx context.Context, id string, params *GetReturnsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdWithBody(ctx context.Context, id string, params *PostReturnsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsId(ctx context.Context, id string, params *PostReturnsIdParams, body PostReturnsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdCancelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdCancelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdCancel(ctx context.Context, id string, body PostReturnsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdCancelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdDismissItemsWithBody(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdDismissItemsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdDismissItems(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, body PostReturnsIdDismissItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdDismissItemsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnsIdDismissItemsActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdDismissItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnsIdDismissItemsActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdDismissItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdDismissItemsActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdDismissItemsActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, body PostReturnsIdDismissItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdDismissItemsActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnsIdReceive(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnsIdReceiveRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveWithBody(ctx context.Context, id string, params *PostReturnsIdReceiveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceive(ctx context.Context, id string, params *PostReturnsIdReceiveParams, body PostReturnsIdReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveItemsWithBody(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveItemsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveItems(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, body PostReturnsIdReceiveItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveItemsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnsIdReceiveItemsActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdReceiveItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnsIdReceiveItemsActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveItemsActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveItemsActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, body PostReturnsIdReceiveItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveItemsActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveConfirmWithBody(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveConfirmRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdReceiveConfirm(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, body PostReturnsIdReceiveConfirmJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdReceiveConfirmRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnsIdRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnsIdRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdRequestWithBody(ctx context.Context, id string, params *PostReturnsIdRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdRequest(ctx context.Context, id string, params *PostReturnsIdRequestParams, body PostReturnsIdRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdRequestItemsWithBody(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestItemsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdRequestItems(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, body PostReturnsIdRequestItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestItemsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnsIdRequestItemsActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdRequestItemsActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnsIdRequestItemsActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdRequestItemsActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestItemsActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdRequestItemsActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, body PostReturnsIdRequestItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdRequestItemsActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdShippingMethodWithBody(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdShippingMethodRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdShippingMethod(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, body PostReturnsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdShippingMethodRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnsIdShippingMethodActionId(ctx context.Context, id string, actionId string, params *DeleteReturnsIdShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnsIdShippingMethodActionIdRequest(c.Server, id, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdShippingMethodActionIdWithBody(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdShippingMethodActionIdRequestWithBody(c.Server, id, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsIdShippingMethodActionId(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, body PostReturnsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsIdShippingMethodActionIdRequest(c.Server, id, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSalesChannels(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSalesChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsWithBody(ctx context.Context, params *PostSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannels(ctx context.Context, params *PostSalesChannelsParams, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSalesChannelsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSalesChannelsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSalesChannelsId(ctx context.Context, id string, params *GetSalesChannelsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSalesChannelsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsIdWithBody(ctx context.Context, id string, params *PostSalesChannelsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsId(ctx context.Context, id string, params *PostSalesChannelsIdParams, body PostSalesChannelsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsIdProductsWithBody(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsIdProductsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsIdProducts(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, body PostSalesChannelsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsIdProductsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingOptions(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsWithBody(ctx context.Context, params *PostShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptions(ctx context.Context, params *PostShippingOptionsParams, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShippingOptionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShippingOptionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingOptionsId(ctx context.Context, id string, params *GetShippingOptionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingOptionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsIdWithBody(ctx context.Context, id string, params *PostShippingOptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsId(ctx context.Context, id string, params *PostShippingOptionsIdParams, body PostShippingOptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsIdRulesBatchWithBody(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsIdRulesBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsIdRulesBatch(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, body PostShippingOptionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsIdRulesBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingProfiles(ctx context.Context, params *GetShippingProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfilesWithBody(ctx context.Context, params *PostShippingProfilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfiles(ctx context.Context, params *PostShippingProfilesParams, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShippingProfilesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShippingProfilesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingProfilesId(ctx context.Context, id string, params *GetShippingProfilesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingProfilesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfilesIdWithBody(ctx context.Context, id string, params *PostShippingProfilesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfilesId(ctx context.Context, id string, params *PostShippingProfilesIdParams, body PostShippingProfilesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStockLocations(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStockLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsWithBody(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocations(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStockLocationsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStockLocationsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStockLocationsId(ctx context.Context, id string, params *GetStockLocationsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStockLocationsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdWithBody(ctx context.Context, id string, params *PostStockLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsId(ctx context.Context, id string, params *PostStockLocationsIdParams, body PostStockLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdFulfillmentProvidersWithBody(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdFulfillmentProvidersRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdFulfillmentProviders(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, body PostStockLocationsIdFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdFulfillmentProvidersRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdFulfillmentSetsWithBody(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdFulfillmentSetsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdFulfillmentSets(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, body PostStockLocationsIdFulfillmentSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdFulfillmentSetsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdSalesChannelsWithBody(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdSalesChannelsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsIdSalesChannels(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, body PostStockLocationsIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsIdSalesChannelsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStores(ctx context.Context, params *GetStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoresId(ctx context.Context, id string, params *GetStoresIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoresIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStoresIdWithBody(ctx context.Context, id string, params *PostStoresIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStoresIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStoresId(ctx context.Context, id string, params *PostStoresIdParams, body PostStoresIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStoresIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxRates(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxRatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesWithBody(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRates(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxRatesId(ctx context.Context, id string, params *GetTaxRatesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxRatesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesIdWithBody(ctx context.Context, id string, params *PostTaxRatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesId(ctx context.Context, id string, params *PostTaxRatesIdParams, body PostTaxRatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesIdRulesWithBody(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesIdRulesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesIdRules(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, body PostTaxRatesIdRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesIdRulesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesIdRulesRuleId(ctx context.Context, id string, ruleId string, params *DeleteTaxRatesIdRulesRuleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesIdRulesRuleIdRequest(c.Server, id, ruleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxRegions(ctx context.Context, params *GetTaxRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRegionsWithBody(ctx context.Context, params *PostTaxRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRegionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRegions(ctx context.Context, params *PostTaxRegionsParams, body PostTaxRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRegionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRegionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRegionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxRegionsId(ctx context.Context, id string, params *GetTaxRegionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxRegionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploads(ctx context.Context, body PostUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUploadsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUploadsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUploadsId(ctx context.Context, id string, params *GetUploadsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUploadsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersMe(ctx context.Context, params *GetUsersMeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersMeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersId(ctx context.Context, id string, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersIdWithBody(ctx context.Context, id string, params *PostUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersId(ctx context.Context, id string, params *PostUsersIdParams, body PostUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowsExecutions(ctx context.Context, params *GetWorkflowsExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowsExecutionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowsExecutionsId(ctx context.Context, id string, params *GetWorkflowsExecutionsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowsExecutionsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkflowsExecutionsWorkflowIdRunWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkflowsExecutionsWorkflowIdRunRequestWithBody(c.Server, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkflowsExecutionsWorkflowIdRun(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkflowsExecutionsWorkflowIdRunRequest(c.Server, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkflowsExecutionsWorkflowIdStepsFailureWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequestWithBody(c.Server, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkflowsExecutionsWorkflowIdStepsFailure(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequest(c.Server, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequestWithBody(c.Server, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequest(c.Server, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowsExecutionsWorkflowIdSubscribe(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowsExecutionsWorkflowIdSubscribeRequest(c.Server, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowsExecutionsWorkflowIdTransactionId(ctx context.Context, workflowId string, transactionId string, params *GetWorkflowsExecutionsWorkflowIdTransactionIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowsExecutionsWorkflowIdTransactionIdRequest(c.Server, workflowId, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx context.Context, workflowId string, transactionId string, stepId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRequest(c.Server, workflowId, transactionId, stepId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAdminAuthTokenRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAdminAuthTokenRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActorTypeAuthProviderWithBody(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActorTypeAuthProviderRequestWithBody(c.Server, authProvider, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActorTypeAuthProvider(ctx context.Context, authProvider string, body PostActorTypeAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActorTypeAuthProviderRequest(c.Server, authProvider, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActorTypeAuthProviderCallback(ctx context.Context, authProvider string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActorTypeAuthProviderCallbackRequest(c.Server, authProvider)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActorTypeAuthProviderRegisterWithBody(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActorTypeAuthProviderRegisterRequestWithBody(c.Server, authProvider, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActorTypeAuthProviderRegister(ctx context.Context, authProvider string, body PostActorTypeAuthProviderRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActorTypeAuthProviderRegisterRequest(c.Server, authProvider, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetApiKeysRequest generates requests for GetApiKeys
func NewGetApiKeysRequest(server string, params *GetApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevokedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revoked_at", runtime.ParamLocationQuery, *params.RevokedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiKeysRequest calls the generic PostApiKeys builder with application/json body
func NewPostApiKeysRequest(server string, body PostApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewPostApiKeysRequestWithBody generates requests for PostApiKeys with any type of body
func NewPostApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeysIdRequest generates requests for DeleteApiKeysId
func NewDeleteApiKeysIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiKeysIdRequest generates requests for GetApiKeysId
func NewGetApiKeysIdRequest(server string, id string, params *GetApiKeysIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApiKeysIdRequest calls the generic PostApiKeysId builder with application/json body
func NewPostApiKeysIdRequest(server string, id string, params *PostApiKeysIdParams, body PostApiKeysIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiKeysIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostApiKeysIdRequestWithBody generates requests for PostApiKeysId with any type of body
func NewPostApiKeysIdRequestWithBody(server string, id string, params *PostApiKeysIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostApiKeysIdRevokeRequest calls the generic PostApiKeysIdRevoke builder with application/json body
func NewPostApiKeysIdRevokeRequest(server string, id string, params *PostApiKeysIdRevokeParams, body PostApiKeysIdRevokeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiKeysIdRevokeRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostApiKeysIdRevokeRequestWithBody generates requests for PostApiKeysIdRevoke with any type of body
func NewPostApiKeysIdRevokeRequestWithBody(server string, id string, params *PostApiKeysIdRevokeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys/%s/revoke", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostApiKeysIdSalesChannelsRequest calls the generic PostApiKeysIdSalesChannels builder with application/json body
func NewPostApiKeysIdSalesChannelsRequest(server string, id string, params *PostApiKeysIdSalesChannelsParams, body PostApiKeysIdSalesChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApiKeysIdSalesChannelsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostApiKeysIdSalesChannelsRequestWithBody generates requests for PostApiKeysIdSalesChannels with any type of body
func NewPostApiKeysIdSalesChannelsRequestWithBody(server string, id string, params *PostApiKeysIdSalesChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/api-keys/%s/sales-channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCampaignsRequest generates requests for GetCampaigns
func NewGetCampaignsRequest(server string, params *GetCampaignsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCampaignsRequest calls the generic PostCampaigns builder with application/json body
func NewPostCampaignsRequest(server string, params *PostCampaignsParams, body PostCampaignsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCampaignsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCampaignsRequestWithBody generates requests for PostCampaigns with any type of body
func NewPostCampaignsRequestWithBody(server string, params *PostCampaignsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCampaignsIdRequest generates requests for DeleteCampaignsId
func NewDeleteCampaignsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdRequest generates requests for GetCampaignsId
func NewGetCampaignsIdRequest(server string, id string, params *GetCampaignsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCampaignsIdRequest calls the generic PostCampaignsId builder with application/json body
func NewPostCampaignsIdRequest(server string, id string, params *PostCampaignsIdParams, body PostCampaignsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCampaignsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCampaignsIdRequestWithBody generates requests for PostCampaignsId with any type of body
func NewPostCampaignsIdRequestWithBody(server string, id string, params *PostCampaignsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCampaignsIdPromotionsRequest calls the generic PostCampaignsIdPromotions builder with application/json body
func NewPostCampaignsIdPromotionsRequest(server string, id string, params *PostCampaignsIdPromotionsParams, body PostCampaignsIdPromotionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCampaignsIdPromotionsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCampaignsIdPromotionsRequestWithBody generates requests for PostCampaignsIdPromotions with any type of body
func NewPostCampaignsIdPromotionsRequestWithBody(server string, id string, params *PostCampaignsIdPromotionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/campaigns/%s/promotions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClaimsRequest generates requests for GetClaims
func NewGetClaimsRequest(server string, params *GetClaimsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsRequest calls the generic PostClaims builder with application/json body
func NewPostClaimsRequest(server string, params *PostClaimsParams, body PostClaimsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostClaimsRequestWithBody generates requests for PostClaims with any type of body
func NewPostClaimsRequestWithBody(server string, params *PostClaimsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClaimsIdRequest generates requests for GetClaimsId
func NewGetClaimsIdRequest(server string, id string, params *GetClaimsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdCancelRequest calls the generic PostClaimsIdCancel builder with application/json body
func NewPostClaimsIdCancelRequest(server string, id string, body PostClaimsIdCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdCancelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostClaimsIdCancelRequestWithBody generates requests for PostClaimsIdCancel with any type of body
func NewPostClaimsIdCancelRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClaimsIdClaimItemsRequest calls the generic PostClaimsIdClaimItems builder with application/json body
func NewPostClaimsIdClaimItemsRequest(server string, id string, params *PostClaimsIdClaimItemsParams, body PostClaimsIdClaimItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdClaimItemsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostClaimsIdClaimItemsRequestWithBody generates requests for PostClaimsIdClaimItems with any type of body
func NewPostClaimsIdClaimItemsRequestWithBody(server string, id string, params *PostClaimsIdClaimItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/claim-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClaimsIdClaimItemsActionIdRequest generates requests for DeleteClaimsIdClaimItemsActionId
func NewDeleteClaimsIdClaimItemsActionIdRequest(server string, id string, actionId string, params *DeleteClaimsIdClaimItemsActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/claim-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdClaimItemsActionIdRequest calls the generic PostClaimsIdClaimItemsActionId builder with application/json body
func NewPostClaimsIdClaimItemsActionIdRequest(server string, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, body PostClaimsIdClaimItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdClaimItemsActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostClaimsIdClaimItemsActionIdRequestWithBody generates requests for PostClaimsIdClaimItemsActionId with any type of body
func NewPostClaimsIdClaimItemsActionIdRequestWithBody(server string, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/claim-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClaimsIdInboundItemsRequest calls the generic PostClaimsIdInboundItems builder with application/json body
func NewPostClaimsIdInboundItemsRequest(server string, id string, body PostClaimsIdInboundItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdInboundItemsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostClaimsIdInboundItemsRequestWithBody generates requests for PostClaimsIdInboundItems with any type of body
func NewPostClaimsIdInboundItemsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/inbound/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClaimsIdInboundItemsActionIdRequest generates requests for DeleteClaimsIdInboundItemsActionId
func NewDeleteClaimsIdInboundItemsActionIdRequest(server string, id string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/inbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdInboundItemsActionIdRequest calls the generic PostClaimsIdInboundItemsActionId builder with application/json body
func NewPostClaimsIdInboundItemsActionIdRequest(server string, id string, actionId string, body PostClaimsIdInboundItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdInboundItemsActionIdRequestWithBody(server, id, actionId, "application/json", bodyReader)
}

// NewPostClaimsIdInboundItemsActionIdRequestWithBody generates requests for PostClaimsIdInboundItemsActionId with any type of body
func NewPostClaimsIdInboundItemsActionIdRequestWithBody(server string, id string, actionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/inbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClaimsIdInboundShippingMethodRequest calls the generic PostClaimsIdInboundShippingMethod builder with application/json body
func NewPostClaimsIdInboundShippingMethodRequest(server string, id string, body PostClaimsIdInboundShippingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdInboundShippingMethodRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostClaimsIdInboundShippingMethodRequestWithBody generates requests for PostClaimsIdInboundShippingMethod with any type of body
func NewPostClaimsIdInboundShippingMethodRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/inbound/shipping-method", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClaimsIdInboundShippingMethodActionIdRequest generates requests for DeleteClaimsIdInboundShippingMethodActionId
func NewDeleteClaimsIdInboundShippingMethodActionIdRequest(server string, id string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/inbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdInboundShippingMethodActionIdRequest calls the generic PostClaimsIdInboundShippingMethodActionId builder with application/json body
func NewPostClaimsIdInboundShippingMethodActionIdRequest(server string, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, body PostClaimsIdInboundShippingMethodActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdInboundShippingMethodActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostClaimsIdInboundShippingMethodActionIdRequestWithBody generates requests for PostClaimsIdInboundShippingMethodActionId with any type of body
func NewPostClaimsIdInboundShippingMethodActionIdRequestWithBody(server string, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/inbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClaimsIdOutboundItemsRequest calls the generic PostClaimsIdOutboundItems builder with application/json body
func NewPostClaimsIdOutboundItemsRequest(server string, id string, params *PostClaimsIdOutboundItemsParams, body PostClaimsIdOutboundItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdOutboundItemsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostClaimsIdOutboundItemsRequestWithBody generates requests for PostClaimsIdOutboundItems with any type of body
func NewPostClaimsIdOutboundItemsRequestWithBody(server string, id string, params *PostClaimsIdOutboundItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/outbound/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClaimsIdOutboundItemsActionIdRequest generates requests for DeleteClaimsIdOutboundItemsActionId
func NewDeleteClaimsIdOutboundItemsActionIdRequest(server string, id string, actionId string, params *DeleteClaimsIdOutboundItemsActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/outbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdOutboundItemsActionIdRequest calls the generic PostClaimsIdOutboundItemsActionId builder with application/json body
func NewPostClaimsIdOutboundItemsActionIdRequest(server string, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, body PostClaimsIdOutboundItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdOutboundItemsActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostClaimsIdOutboundItemsActionIdRequestWithBody generates requests for PostClaimsIdOutboundItemsActionId with any type of body
func NewPostClaimsIdOutboundItemsActionIdRequestWithBody(server string, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/outbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostClaimsIdOutboundShippingMethodRequest calls the generic PostClaimsIdOutboundShippingMethod builder with application/json body
func NewPostClaimsIdOutboundShippingMethodRequest(server string, id string, params *PostClaimsIdOutboundShippingMethodParams, body PostClaimsIdOutboundShippingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdOutboundShippingMethodRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostClaimsIdOutboundShippingMethodRequestWithBody generates requests for PostClaimsIdOutboundShippingMethod with any type of body
func NewPostClaimsIdOutboundShippingMethodRequestWithBody(server string, id string, params *PostClaimsIdOutboundShippingMethodParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/outbound/shipping-method", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClaimsIdOutboundShippingMethodActionIdRequest generates requests for DeleteClaimsIdOutboundShippingMethodActionId
func NewDeleteClaimsIdOutboundShippingMethodActionIdRequest(server string, id string, actionId string, params *DeleteClaimsIdOutboundShippingMethodActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/outbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdOutboundShippingMethodActionIdRequest calls the generic PostClaimsIdOutboundShippingMethodActionId builder with application/json body
func NewPostClaimsIdOutboundShippingMethodActionIdRequest(server string, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, body PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClaimsIdOutboundShippingMethodActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostClaimsIdOutboundShippingMethodActionIdRequestWithBody generates requests for PostClaimsIdOutboundShippingMethodActionId with any type of body
func NewPostClaimsIdOutboundShippingMethodActionIdRequestWithBody(server string, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/outbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClaimsIdRequestRequest generates requests for DeleteClaimsIdRequest
func NewDeleteClaimsIdRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClaimsIdRequestRequest generates requests for PostClaimsIdRequest
func NewPostClaimsIdRequestRequest(server string, id string, params *PostClaimsIdRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/claims/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionsRequest generates requests for GetCollections
func NewGetCollectionsRequest(server string, params *GetCollectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCollectionsRequest calls the generic PostCollections builder with application/json body
func NewPostCollectionsRequest(server string, params *PostCollectionsParams, body PostCollectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCollectionsRequestWithBody generates requests for PostCollections with any type of body
func NewPostCollectionsRequestWithBody(server string, params *PostCollectionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionsIdRequest generates requests for DeleteCollectionsId
func NewDeleteCollectionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionsIdRequest generates requests for GetCollectionsId
func NewGetCollectionsIdRequest(server string, id string, params *GetCollectionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCollectionsIdRequest calls the generic PostCollectionsId builder with application/json body
func NewPostCollectionsIdRequest(server string, id string, params *PostCollectionsIdParams, body PostCollectionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCollectionsIdRequestWithBody generates requests for PostCollectionsId with any type of body
func NewPostCollectionsIdRequestWithBody(server string, id string, params *PostCollectionsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCollectionsIdProductsRequest calls the generic PostCollectionsIdProducts builder with application/json body
func NewPostCollectionsIdProductsRequest(server string, id string, params *PostCollectionsIdProductsParams, body PostCollectionsIdProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionsIdProductsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCollectionsIdProductsRequestWithBody generates requests for PostCollectionsIdProducts with any type of body
func NewPostCollectionsIdProductsRequestWithBody(server string, id string, params *PostCollectionsIdProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrenciesRequest generates requests for GetCurrencies
func NewGetCurrenciesRequest(server string, params *GetCurrenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrenciesCodeRequest generates requests for GetCurrenciesCode
func NewGetCurrenciesCodeRequest(server string, code string, params *GetCurrenciesCodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerGroupsRequest generates requests for GetCustomerGroups
func NewGetCustomerGroupsRequest(server string, params *GetCustomerGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Customers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customers", runtime.ParamLocationQuery, *params.Customers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomerGroupsRequest calls the generic PostCustomerGroups builder with application/json body
func NewPostCustomerGroupsRequest(server string, params *PostCustomerGroupsParams, body PostCustomerGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCustomerGroupsRequestWithBody generates requests for PostCustomerGroups with any type of body
func NewPostCustomerGroupsRequestWithBody(server string, params *PostCustomerGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerGroupsIdRequest generates requests for DeleteCustomerGroupsId
func NewDeleteCustomerGroupsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerGroupsIdRequest generates requests for GetCustomerGroupsId
func NewGetCustomerGroupsIdRequest(server string, id string, params *GetCustomerGroupsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomerGroupsIdRequest calls the generic PostCustomerGroupsId builder with application/json body
func NewPostCustomerGroupsIdRequest(server string, id string, params *PostCustomerGroupsIdParams, body PostCustomerGroupsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerGroupsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCustomerGroupsIdRequestWithBody generates requests for PostCustomerGroupsId with any type of body
func NewPostCustomerGroupsIdRequestWithBody(server string, id string, params *PostCustomerGroupsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCustomerGroupsIdCustomersRequest calls the generic PostCustomerGroupsIdCustomers builder with application/json body
func NewPostCustomerGroupsIdCustomersRequest(server string, id string, params *PostCustomerGroupsIdCustomersParams, body PostCustomerGroupsIdCustomersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerGroupsIdCustomersRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCustomerGroupsIdCustomersRequestWithBody generates requests for PostCustomerGroupsIdCustomers with any type of body
func NewPostCustomerGroupsIdCustomersRequestWithBody(server string, id string, params *PostCustomerGroupsIdCustomersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s/customers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomersRequest generates requests for GetCustomers
func NewGetCustomersRequest(server string, params *GetCustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompanyName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company_name", runtime.ParamLocationQuery, *params.CompanyName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_account", runtime.ParamLocationQuery, *params.HasAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersRequest calls the generic PostCustomers builder with application/json body
func NewPostCustomersRequest(server string, params *PostCustomersParams, body PostCustomersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCustomersRequestWithBody generates requests for PostCustomers with any type of body
func NewPostCustomersRequestWithBody(server string, params *PostCustomersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomersIdRequest generates requests for DeleteCustomersId
func NewDeleteCustomersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomersIdRequest generates requests for GetCustomersId
func NewGetCustomersIdRequest(server string, id string, params *GetCustomersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersIdRequest calls the generic PostCustomersId builder with application/json body
func NewPostCustomersIdRequest(server string, id string, params *PostCustomersIdParams, body PostCustomersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCustomersIdRequestWithBody generates requests for PostCustomersId with any type of body
func NewPostCustomersIdRequestWithBody(server string, id string, params *PostCustomersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomersIdAddressesRequest generates requests for GetCustomersIdAddresses
func NewGetCustomersIdAddressesRequest(server string, id string, params *GetCustomersIdAddressesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s/addresses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Company != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "company", runtime.ParamLocationQuery, *params.Company); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.City != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "city", runtime.ParamLocationQuery, *params.City); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CountryCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country_code", runtime.ParamLocationQuery, *params.CountryCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Province != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "province", runtime.ParamLocationQuery, *params.Province); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PostalCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "postal_code", runtime.ParamLocationQuery, *params.PostalCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersIdAddressesRequest calls the generic PostCustomersIdAddresses builder with application/json body
func NewPostCustomersIdAddressesRequest(server string, id string, params *PostCustomersIdAddressesParams, body PostCustomersIdAddressesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersIdAddressesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCustomersIdAddressesRequestWithBody generates requests for PostCustomersIdAddresses with any type of body
func NewPostCustomersIdAddressesRequestWithBody(server string, id string, params *PostCustomersIdAddressesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s/addresses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomersIdAddressesAddressIdRequest generates requests for DeleteCustomersIdAddressesAddressId
func NewDeleteCustomersIdAddressesAddressIdRequest(server string, id string, addressId string, params *DeleteCustomersIdAddressesAddressIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address_id", runtime.ParamLocationPath, addressId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s/addresses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomersIdAddressesAddressIdRequest generates requests for GetCustomersIdAddressesAddressId
func NewGetCustomersIdAddressesAddressIdRequest(server string, id string, addressId string, params *GetCustomersIdAddressesAddressIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address_id", runtime.ParamLocationPath, addressId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s/addresses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersIdAddressesAddressIdRequest calls the generic PostCustomersIdAddressesAddressId builder with application/json body
func NewPostCustomersIdAddressesAddressIdRequest(server string, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, body PostCustomersIdAddressesAddressIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersIdAddressesAddressIdRequestWithBody(server, id, addressId, params, "application/json", bodyReader)
}

// NewPostCustomersIdAddressesAddressIdRequestWithBody generates requests for PostCustomersIdAddressesAddressId with any type of body
func NewPostCustomersIdAddressesAddressIdRequestWithBody(server string, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "address_id", runtime.ParamLocationPath, addressId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s/addresses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDraftOrdersRequest generates requests for GetDraftOrders
func NewGetDraftOrdersRequest(server string, params *GetDraftOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FulfillmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fulfillment_status", runtime.ParamLocationQuery, *params.FulfillmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_status", runtime.ParamLocationQuery, *params.PaymentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDraftOrdersRequest calls the generic PostDraftOrders builder with application/json body
func NewPostDraftOrdersRequest(server string, params *PostDraftOrdersParams, body PostDraftOrdersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDraftOrdersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostDraftOrdersRequestWithBody generates requests for PostDraftOrders with any type of body
func NewPostDraftOrdersRequestWithBody(server string, params *PostDraftOrdersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDraftOrdersIdRequest generates requests for GetDraftOrdersId
func NewGetDraftOrdersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExchangesRequest generates requests for GetExchanges
func NewGetExchangesRequest(server string, params *GetExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesRequest calls the generic PostExchanges builder with application/json body
func NewPostExchangesRequest(server string, params *PostExchangesParams, body PostExchangesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostExchangesRequestWithBody generates requests for PostExchanges with any type of body
func NewPostExchangesRequestWithBody(server string, params *PostExchangesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExchangesIdRequest generates requests for GetExchangesId
func NewGetExchangesIdRequest(server string, id string, params *GetExchangesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesIdCancelRequest calls the generic PostExchangesIdCancel builder with application/json body
func NewPostExchangesIdCancelRequest(server string, id string, body PostExchangesIdCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdCancelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostExchangesIdCancelRequestWithBody generates requests for PostExchangesIdCancel with any type of body
func NewPostExchangesIdCancelRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostExchangesIdInboundItemsRequest calls the generic PostExchangesIdInboundItems builder with application/json body
func NewPostExchangesIdInboundItemsRequest(server string, id string, body PostExchangesIdInboundItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdInboundItemsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostExchangesIdInboundItemsRequestWithBody generates requests for PostExchangesIdInboundItems with any type of body
func NewPostExchangesIdInboundItemsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/inbound/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExchangesIdInboundItemsActionIdRequest generates requests for DeleteExchangesIdInboundItemsActionId
func NewDeleteExchangesIdInboundItemsActionIdRequest(server string, id string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/inbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesIdInboundItemsActionIdRequest calls the generic PostExchangesIdInboundItemsActionId builder with application/json body
func NewPostExchangesIdInboundItemsActionIdRequest(server string, id string, actionId string, body PostExchangesIdInboundItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdInboundItemsActionIdRequestWithBody(server, id, actionId, "application/json", bodyReader)
}

// NewPostExchangesIdInboundItemsActionIdRequestWithBody generates requests for PostExchangesIdInboundItemsActionId with any type of body
func NewPostExchangesIdInboundItemsActionIdRequestWithBody(server string, id string, actionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/inbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostExchangesIdInboundShippingMethodRequest calls the generic PostExchangesIdInboundShippingMethod builder with application/json body
func NewPostExchangesIdInboundShippingMethodRequest(server string, id string, body PostExchangesIdInboundShippingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdInboundShippingMethodRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostExchangesIdInboundShippingMethodRequestWithBody generates requests for PostExchangesIdInboundShippingMethod with any type of body
func NewPostExchangesIdInboundShippingMethodRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/inbound/shipping-method", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExchangesIdInboundShippingMethodActionIdRequest generates requests for DeleteExchangesIdInboundShippingMethodActionId
func NewDeleteExchangesIdInboundShippingMethodActionIdRequest(server string, id string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/inbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesIdInboundShippingMethodActionIdRequest calls the generic PostExchangesIdInboundShippingMethodActionId builder with application/json body
func NewPostExchangesIdInboundShippingMethodActionIdRequest(server string, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, body PostExchangesIdInboundShippingMethodActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdInboundShippingMethodActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostExchangesIdInboundShippingMethodActionIdRequestWithBody generates requests for PostExchangesIdInboundShippingMethodActionId with any type of body
func NewPostExchangesIdInboundShippingMethodActionIdRequestWithBody(server string, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/inbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostExchangesIdOutboundItemsRequest calls the generic PostExchangesIdOutboundItems builder with application/json body
func NewPostExchangesIdOutboundItemsRequest(server string, id string, params *PostExchangesIdOutboundItemsParams, body PostExchangesIdOutboundItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdOutboundItemsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostExchangesIdOutboundItemsRequestWithBody generates requests for PostExchangesIdOutboundItems with any type of body
func NewPostExchangesIdOutboundItemsRequestWithBody(server string, id string, params *PostExchangesIdOutboundItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/outbound/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExchangesIdOutboundItemsActionIdRequest generates requests for DeleteExchangesIdOutboundItemsActionId
func NewDeleteExchangesIdOutboundItemsActionIdRequest(server string, id string, actionId string, params *DeleteExchangesIdOutboundItemsActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/outbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesIdOutboundItemsActionIdRequest calls the generic PostExchangesIdOutboundItemsActionId builder with application/json body
func NewPostExchangesIdOutboundItemsActionIdRequest(server string, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, body PostExchangesIdOutboundItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdOutboundItemsActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostExchangesIdOutboundItemsActionIdRequestWithBody generates requests for PostExchangesIdOutboundItemsActionId with any type of body
func NewPostExchangesIdOutboundItemsActionIdRequestWithBody(server string, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/outbound/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostExchangesIdOutboundShippingMethodRequest calls the generic PostExchangesIdOutboundShippingMethod builder with application/json body
func NewPostExchangesIdOutboundShippingMethodRequest(server string, id string, params *PostExchangesIdOutboundShippingMethodParams, body PostExchangesIdOutboundShippingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdOutboundShippingMethodRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostExchangesIdOutboundShippingMethodRequestWithBody generates requests for PostExchangesIdOutboundShippingMethod with any type of body
func NewPostExchangesIdOutboundShippingMethodRequestWithBody(server string, id string, params *PostExchangesIdOutboundShippingMethodParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/outbound/shipping-method", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExchangesIdOutboundShippingMethodActionIdRequest generates requests for DeleteExchangesIdOutboundShippingMethodActionId
func NewDeleteExchangesIdOutboundShippingMethodActionIdRequest(server string, id string, actionId string, params *DeleteExchangesIdOutboundShippingMethodActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/outbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesIdOutboundShippingMethodActionIdRequest calls the generic PostExchangesIdOutboundShippingMethodActionId builder with application/json body
func NewPostExchangesIdOutboundShippingMethodActionIdRequest(server string, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, body PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExchangesIdOutboundShippingMethodActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostExchangesIdOutboundShippingMethodActionIdRequestWithBody generates requests for PostExchangesIdOutboundShippingMethodActionId with any type of body
func NewPostExchangesIdOutboundShippingMethodActionIdRequestWithBody(server string, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/outbound/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteExchangesIdRequestRequest generates requests for DeleteExchangesIdRequest
func NewDeleteExchangesIdRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExchangesIdRequestRequest generates requests for PostExchangesIdRequest
func NewPostExchangesIdRequestRequest(server string, id string, params *PostExchangesIdRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/exchanges/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFulfillmentProvidersRequest generates requests for GetFulfillmentProviders
func NewGetFulfillmentProvidersRequest(server string, params *GetFulfillmentProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillment-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_enabled", runtime.ParamLocationQuery, *params.IsEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StockLocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stock_location_id", runtime.ParamLocationQuery, *params.StockLocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFulfillmentSetsIdRequest generates requests for DeleteFulfillmentSetsId
func NewDeleteFulfillmentSetsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillment-sets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFulfillmentSetsIdServiceZonesRequest calls the generic PostFulfillmentSetsIdServiceZones builder with application/json body
func NewPostFulfillmentSetsIdServiceZonesRequest(server string, id string, params *PostFulfillmentSetsIdServiceZonesParams, body PostFulfillmentSetsIdServiceZonesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFulfillmentSetsIdServiceZonesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostFulfillmentSetsIdServiceZonesRequestWithBody generates requests for PostFulfillmentSetsIdServiceZones with any type of body
func NewPostFulfillmentSetsIdServiceZonesRequestWithBody(server string, id string, params *PostFulfillmentSetsIdServiceZonesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillment-sets/%s/service-zones", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFulfillmentSetsIdServiceZonesZoneIdRequest generates requests for DeleteFulfillmentSetsIdServiceZonesZoneId
func NewDeleteFulfillmentSetsIdServiceZonesZoneIdRequest(server string, id string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zone_id", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillment-sets/%s/service-zones/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFulfillmentSetsIdServiceZonesZoneIdRequest generates requests for GetFulfillmentSetsIdServiceZonesZoneId
func NewGetFulfillmentSetsIdServiceZonesZoneIdRequest(server string, id string, zoneId string, params *GetFulfillmentSetsIdServiceZonesZoneIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zone_id", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillment-sets/%s/service-zones/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFulfillmentSetsIdServiceZonesZoneIdRequest calls the generic PostFulfillmentSetsIdServiceZonesZoneId builder with application/json body
func NewPostFulfillmentSetsIdServiceZonesZoneIdRequest(server string, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, body PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFulfillmentSetsIdServiceZonesZoneIdRequestWithBody(server, id, zoneId, params, "application/json", bodyReader)
}

// NewPostFulfillmentSetsIdServiceZonesZoneIdRequestWithBody generates requests for PostFulfillmentSetsIdServiceZonesZoneId with any type of body
func NewPostFulfillmentSetsIdServiceZonesZoneIdRequestWithBody(server string, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zone_id", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillment-sets/%s/service-zones/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFulfillmentsRequest calls the generic PostFulfillments builder with application/json body
func NewPostFulfillmentsRequest(server string, params *PostFulfillmentsParams, body PostFulfillmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFulfillmentsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFulfillmentsRequestWithBody generates requests for PostFulfillments with any type of body
func NewPostFulfillmentsRequestWithBody(server string, params *PostFulfillmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFulfillmentsIdCancelRequest generates requests for PostFulfillmentsIdCancel
func NewPostFulfillmentsIdCancelRequest(server string, id string, params *PostFulfillmentsIdCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillments/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFulfillmentsIdShipmentRequest calls the generic PostFulfillmentsIdShipment builder with application/json body
func NewPostFulfillmentsIdShipmentRequest(server string, id string, params *PostFulfillmentsIdShipmentParams, body PostFulfillmentsIdShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFulfillmentsIdShipmentRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostFulfillmentsIdShipmentRequestWithBody generates requests for PostFulfillmentsIdShipment with any type of body
func NewPostFulfillmentsIdShipmentRequestWithBody(server string, id string, params *PostFulfillmentsIdShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/fulfillments/%s/shipment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInventoryItemsRequest generates requests for GetInventoryItems
func NewGetInventoryItemsRequest(server string, params *GetInventoryItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sku", runtime.ParamLocationQuery, *params.Sku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin_country", runtime.ParamLocationQuery, *params.OriginCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MidCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mid_code", runtime.ParamLocationQuery, *params.MidCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HsCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hs_code", runtime.ParamLocationQuery, *params.HsCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Material != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "material", runtime.ParamLocationQuery, *params.Material); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequiresShipping != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requires_shipping", runtime.ParamLocationQuery, *params.RequiresShipping); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Weight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "weight", runtime.ParamLocationQuery, *params.Weight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Length != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "length", runtime.ParamLocationQuery, *params.Length); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationLevels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_levels", runtime.ParamLocationQuery, *params.LocationLevels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsRequest calls the generic PostInventoryItems builder with application/json body
func NewPostInventoryItemsRequest(server string, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostInventoryItemsRequestWithBody generates requests for PostInventoryItems with any type of body
func NewPostInventoryItemsRequestWithBody(server string, params *PostInventoryItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInventoryItemsIdRequest generates requests for DeleteInventoryItemsId
func NewDeleteInventoryItemsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInventoryItemsIdRequest generates requests for GetInventoryItemsId
func NewGetInventoryItemsIdRequest(server string, id string, params *GetInventoryItemsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsIdRequest calls the generic PostInventoryItemsId builder with application/json body
func NewPostInventoryItemsIdRequest(server string, id string, params *PostInventoryItemsIdParams, body PostInventoryItemsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostInventoryItemsIdRequestWithBody generates requests for PostInventoryItemsId with any type of body
func NewPostInventoryItemsIdRequestWithBody(server string, id string, params *PostInventoryItemsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInventoryItemsIdLocationLevelsRequest generates requests for GetInventoryItemsIdLocationLevels
func NewGetInventoryItemsIdLocationLevelsRequest(server string, id string, params *GetInventoryItemsIdLocationLevelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsIdLocationLevelsRequest calls the generic PostInventoryItemsIdLocationLevels builder with application/json body
func NewPostInventoryItemsIdLocationLevelsRequest(server string, id string, params *PostInventoryItemsIdLocationLevelsParams, body PostInventoryItemsIdLocationLevelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsIdLocationLevelsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostInventoryItemsIdLocationLevelsRequestWithBody generates requests for PostInventoryItemsIdLocationLevels with any type of body
func NewPostInventoryItemsIdLocationLevelsRequestWithBody(server string, id string, params *PostInventoryItemsIdLocationLevelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInventoryItemsIdLocationLevelsBatchRequest calls the generic PostInventoryItemsIdLocationLevelsBatch builder with application/json body
func NewPostInventoryItemsIdLocationLevelsBatchRequest(server string, id string, body PostInventoryItemsIdLocationLevelsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsIdLocationLevelsBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostInventoryItemsIdLocationLevelsBatchRequestWithBody generates requests for PostInventoryItemsIdLocationLevelsBatch with any type of body
func NewPostInventoryItemsIdLocationLevelsBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInventoryItemsIdLocationLevelsLocationIdRequest generates requests for DeleteInventoryItemsIdLocationLevelsLocationId
func NewDeleteInventoryItemsIdLocationLevelsLocationIdRequest(server string, id string, locationId string, params *DeleteInventoryItemsIdLocationLevelsLocationIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "location_id", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsIdLocationLevelsLocationIdRequest calls the generic PostInventoryItemsIdLocationLevelsLocationId builder with application/json body
func NewPostInventoryItemsIdLocationLevelsLocationIdRequest(server string, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, body PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsIdLocationLevelsLocationIdRequestWithBody(server, id, locationId, params, "application/json", bodyReader)
}

// NewPostInventoryItemsIdLocationLevelsLocationIdRequestWithBody generates requests for PostInventoryItemsIdLocationLevelsLocationId with any type of body
func NewPostInventoryItemsIdLocationLevelsLocationIdRequestWithBody(server string, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "location_id", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInvitesRequest generates requests for GetInvites
func NewGetInvitesRequest(server string, params *GetInvitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInvitesRequest calls the generic PostInvites builder with application/json body
func NewPostInvitesRequest(server string, params *PostInvitesParams, body PostInvitesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInvitesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostInvitesRequestWithBody generates requests for PostInvites with any type of body
func NewPostInvitesRequestWithBody(server string, params *PostInvitesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInvitesAcceptRequest calls the generic PostInvitesAccept builder with application/json body
func NewPostInvitesAcceptRequest(server string, body PostInvitesAcceptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInvitesAcceptRequestWithBody(server, "application/json", bodyReader)
}

// NewPostInvitesAcceptRequestWithBody generates requests for PostInvitesAccept with any type of body
func NewPostInvitesAcceptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/accept")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInvitesIdRequest generates requests for DeleteInvitesId
func NewDeleteInvitesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvitesIdRequest generates requests for GetInvitesId
func NewGetInvitesIdRequest(server string, id string, params *GetInvitesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInvitesIdResendRequest generates requests for PostInvitesIdResend
func NewPostInvitesIdResendRequest(server string, id string, params *PostInvitesIdResendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/%s/resend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationsRequest generates requests for GetNotifications
func NewGetNotificationsRequest(server string, params *GetNotificationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Channel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, *params.Channel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationsIdRequest generates requests for GetNotificationsId
func NewGetNotificationsIdRequest(server string, id string, params *GetNotificationsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsRequest calls the generic PostOrderEdits builder with application/json body
func NewPostOrderEditsRequest(server string, body PostOrderEditsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostOrderEditsRequestWithBody generates requests for PostOrderEdits with any type of body
func NewPostOrderEditsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrderEditsIdRequest generates requests for DeleteOrderEditsId
func NewDeleteOrderEditsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsIdConfirmRequest generates requests for PostOrderEditsIdConfirm
func NewPostOrderEditsIdConfirmRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsIdItemsRequest calls the generic PostOrderEditsIdItems builder with application/json body
func NewPostOrderEditsIdItemsRequest(server string, id string, body PostOrderEditsIdItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsIdItemsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostOrderEditsIdItemsRequestWithBody generates requests for PostOrderEditsIdItems with any type of body
func NewPostOrderEditsIdItemsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrderEditsIdItemsItemItemIdRequest calls the generic PostOrderEditsIdItemsItemItemId builder with application/json body
func NewPostOrderEditsIdItemsItemItemIdRequest(server string, id string, itemId string, body PostOrderEditsIdItemsItemItemIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsIdItemsItemItemIdRequestWithBody(server, id, itemId, "application/json", bodyReader)
}

// NewPostOrderEditsIdItemsItemItemIdRequestWithBody generates requests for PostOrderEditsIdItemsItemItemId with any type of body
func NewPostOrderEditsIdItemsItemItemIdRequestWithBody(server string, id string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "item_id", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items/item/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrderEditsIdItemsActionIdRequest generates requests for DeleteOrderEditsIdItemsActionId
func NewDeleteOrderEditsIdItemsActionIdRequest(server string, id string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsIdItemsActionIdRequest calls the generic PostOrderEditsIdItemsActionId builder with application/json body
func NewPostOrderEditsIdItemsActionIdRequest(server string, id string, actionId string, body PostOrderEditsIdItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsIdItemsActionIdRequestWithBody(server, id, actionId, "application/json", bodyReader)
}

// NewPostOrderEditsIdItemsActionIdRequestWithBody generates requests for PostOrderEditsIdItemsActionId with any type of body
func NewPostOrderEditsIdItemsActionIdRequestWithBody(server string, id string, actionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrderEditsIdRequestRequest generates requests for PostOrderEditsIdRequest
func NewPostOrderEditsIdRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsIdShippingMethodRequest calls the generic PostOrderEditsIdShippingMethod builder with application/json body
func NewPostOrderEditsIdShippingMethodRequest(server string, id string, body PostOrderEditsIdShippingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsIdShippingMethodRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostOrderEditsIdShippingMethodRequestWithBody generates requests for PostOrderEditsIdShippingMethod with any type of body
func NewPostOrderEditsIdShippingMethodRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/shipping-method", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrderEditsIdShippingMethodActionIdRequest generates requests for DeleteOrderEditsIdShippingMethodActionId
func NewDeleteOrderEditsIdShippingMethodActionIdRequest(server string, id string, actionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsIdShippingMethodActionIdRequest calls the generic PostOrderEditsIdShippingMethodActionId builder with application/json body
func NewPostOrderEditsIdShippingMethodActionIdRequest(server string, id string, actionId string, body PostOrderEditsIdShippingMethodActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsIdShippingMethodActionIdRequestWithBody(server, id, actionId, "application/json", bodyReader)
}

// NewPostOrderEditsIdShippingMethodActionIdRequestWithBody generates requests for PostOrderEditsIdShippingMethodActionId with any type of body
func NewPostOrderEditsIdShippingMethodActionIdRequestWithBody(server string, id string, actionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FulfillmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fulfillment_status", runtime.ParamLocationQuery, *params.FulfillmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_status", runtime.ParamLocationQuery, *params.PaymentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrdersIdRequest generates requests for GetOrdersId
func NewGetOrdersIdRequest(server string, id string, params *GetOrdersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersIdRequest generates requests for PostOrdersId
func NewPostOrdersIdRequest(server string, id string, params *PostOrdersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersIdArchiveRequest generates requests for PostOrdersIdArchive
func NewPostOrdersIdArchiveRequest(server string, id string, params *PostOrdersIdArchiveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersIdCancelRequest generates requests for PostOrdersIdCancel
func NewPostOrdersIdCancelRequest(server string, id string, params *PostOrdersIdCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrdersIdChangesRequest generates requests for GetOrdersIdChanges
func NewGetOrdersIdChangesRequest(server string, id string, params *GetOrdersIdChangesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/changes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersIdCompleteRequest calls the generic PostOrdersIdComplete builder with application/json body
func NewPostOrdersIdCompleteRequest(server string, id string, params *PostOrdersIdCompleteParams, body PostOrdersIdCompleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersIdCompleteRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersIdCompleteRequestWithBody generates requests for PostOrdersIdComplete with any type of body
func NewPostOrdersIdCompleteRequestWithBody(server string, id string, params *PostOrdersIdCompleteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersIdFulfillmentsRequest calls the generic PostOrdersIdFulfillments builder with application/json body
func NewPostOrdersIdFulfillmentsRequest(server string, id string, params *PostOrdersIdFulfillmentsParams, body PostOrdersIdFulfillmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersIdFulfillmentsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersIdFulfillmentsRequestWithBody generates requests for PostOrdersIdFulfillments with any type of body
func NewPostOrdersIdFulfillmentsRequestWithBody(server string, id string, params *PostOrdersIdFulfillmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/fulfillments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequest calls the generic PostOrdersIdFulfillmentsFulfillmentIdCancel builder with application/json body
func NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequest(server string, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, body PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequestWithBody(server, id, fulfillmentId, params, "application/json", bodyReader)
}

// NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequestWithBody generates requests for PostOrdersIdFulfillmentsFulfillmentIdCancel with any type of body
func NewPostOrdersIdFulfillmentsFulfillmentIdCancelRequestWithBody(server string, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, fulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/fulfillments/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredRequest generates requests for PostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered
func NewPostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredRequest(server string, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, fulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/fulfillments/%s/mark-as-delivered", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequest calls the generic PostOrdersIdFulfillmentsFulfillmentIdShipments builder with application/json body
func NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequest(server string, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, body PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequestWithBody(server, id, fulfillmentId, params, "application/json", bodyReader)
}

// NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequestWithBody generates requests for PostOrdersIdFulfillmentsFulfillmentIdShipments with any type of body
func NewPostOrdersIdFulfillmentsFulfillmentIdShipmentsRequestWithBody(server string, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, fulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/fulfillments/%s/shipments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrdersIdPreviewRequest generates requests for GetOrdersIdPreview
func NewGetOrdersIdPreviewRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPaymentCollectionsRequest calls the generic PostPaymentCollections builder with application/json body
func NewPostPaymentCollectionsRequest(server string, params *PostPaymentCollectionsParams, body PostPaymentCollectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPaymentCollectionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPaymentCollectionsRequestWithBody generates requests for PostPaymentCollections with any type of body
func NewPostPaymentCollectionsRequestWithBody(server string, params *PostPaymentCollectionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentCollectionsIdRequest generates requests for DeletePaymentCollectionsId
func NewDeletePaymentCollectionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPaymentCollectionsIdMarkAsPaidRequest calls the generic PostPaymentCollectionsIdMarkAsPaid builder with application/json body
func NewPostPaymentCollectionsIdMarkAsPaidRequest(server string, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, body PostPaymentCollectionsIdMarkAsPaidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPaymentCollectionsIdMarkAsPaidRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPaymentCollectionsIdMarkAsPaidRequestWithBody generates requests for PostPaymentCollectionsIdMarkAsPaid with any type of body
func NewPostPaymentCollectionsIdMarkAsPaidRequestWithBody(server string, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections/%s/mark-as-paid", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentsRequest generates requests for GetPayments
func NewGetPaymentsRequest(server string, params *GetPaymentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentSessionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_session_id", runtime.ParamLocationQuery, *params.PaymentSessionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentsPaymentProvidersRequest generates requests for GetPaymentsPaymentProviders
func NewGetPaymentsPaymentProvidersRequest(server string, params *GetPaymentsPaymentProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/payment-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_enabled", runtime.ParamLocationQuery, *params.IsEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentsIdRequest generates requests for GetPaymentsId
func NewGetPaymentsIdRequest(server string, id string, params *GetPaymentsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPaymentsIdCaptureRequest calls the generic PostPaymentsIdCapture builder with application/json body
func NewPostPaymentsIdCaptureRequest(server string, id string, params *PostPaymentsIdCaptureParams, body PostPaymentsIdCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPaymentsIdCaptureRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPaymentsIdCaptureRequestWithBody generates requests for PostPaymentsIdCapture with any type of body
func NewPostPaymentsIdCaptureRequestWithBody(server string, id string, params *PostPaymentsIdCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPaymentsIdRefundRequest calls the generic PostPaymentsIdRefund builder with application/json body
func NewPostPaymentsIdRefundRequest(server string, id string, params *PostPaymentsIdRefundParams, body PostPaymentsIdRefundJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPaymentsIdRefundRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPaymentsIdRefundRequestWithBody generates requests for PostPaymentsIdRefund with any type of body
func NewPostPaymentsIdRefundRequestWithBody(server string, id string, params *PostPaymentsIdRefundParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPriceListsRequest generates requests for GetPriceLists
func NewGetPriceListsRequest(server string, params *GetPriceListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartsAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starts_at", runtime.ParamLocationQuery, *params.StartsAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndsAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ends_at", runtime.ParamLocationQuery, *params.EndsAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RulesCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rules_count", runtime.ParamLocationQuery, *params.RulesCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPriceListsRequest calls the generic PostPriceLists builder with application/json body
func NewPostPriceListsRequest(server string, params *PostPriceListsParams, body PostPriceListsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPriceListsRequestWithBody generates requests for PostPriceLists with any type of body
func NewPostPriceListsRequestWithBody(server string, params *PostPriceListsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePriceListsIdRequest generates requests for DeletePriceListsId
func NewDeletePriceListsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPriceListsIdRequest generates requests for GetPriceListsId
func NewGetPriceListsIdRequest(server string, id string, params *GetPriceListsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPriceListsIdRequest calls the generic PostPriceListsId builder with application/json body
func NewPostPriceListsIdRequest(server string, id string, params *PostPriceListsIdParams, body PostPriceListsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPriceListsIdRequestWithBody generates requests for PostPriceListsId with any type of body
func NewPostPriceListsIdRequestWithBody(server string, id string, params *PostPriceListsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPriceListsIdPricesBatchRequest calls the generic PostPriceListsIdPricesBatch builder with application/json body
func NewPostPriceListsIdPricesBatchRequest(server string, id string, body PostPriceListsIdPricesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsIdPricesBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPriceListsIdPricesBatchRequestWithBody generates requests for PostPriceListsIdPricesBatch with any type of body
func NewPostPriceListsIdPricesBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/prices/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPriceListsIdProductsRequest calls the generic PostPriceListsIdProducts builder with application/json body
func NewPostPriceListsIdProductsRequest(server string, id string, params *PostPriceListsIdProductsParams, body PostPriceListsIdProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsIdProductsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPriceListsIdProductsRequestWithBody generates requests for PostPriceListsIdProducts with any type of body
func NewPostPriceListsIdProductsRequestWithBody(server string, id string, params *PostPriceListsIdProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPricePreferencesRequest generates requests for GetPricePreferences
func NewGetPricePreferencesRequest(server string, params *GetPricePreferencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Attribute != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "attribute", runtime.ParamLocationQuery, *params.Attribute); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPricePreferencesRequest calls the generic PostPricePreferences builder with application/json body
func NewPostPricePreferencesRequest(server string, params *PostPricePreferencesParams, body PostPricePreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPricePreferencesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPricePreferencesRequestWithBody generates requests for PostPricePreferences with any type of body
func NewPostPricePreferencesRequestWithBody(server string, params *PostPricePreferencesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-preferences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePricePreferencesIdRequest generates requests for DeletePricePreferencesId
func NewDeletePricePreferencesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-preferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPricePreferencesIdRequest generates requests for GetPricePreferencesId
func NewGetPricePreferencesIdRequest(server string, id string, params *GetPricePreferencesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-preferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPricePreferencesIdRequest calls the generic PostPricePreferencesId builder with application/json body
func NewPostPricePreferencesIdRequest(server string, id string, params *PostPricePreferencesIdParams, body PostPricePreferencesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPricePreferencesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPricePreferencesIdRequestWithBody generates requests for PostPricePreferencesId with any type of body
func NewPostPricePreferencesIdRequestWithBody(server string, id string, params *PostPricePreferencesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-preferences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductCategoriesRequest generates requests for GetProductCategories
func NewGetProductCategoriesRequest(server string, params *GetProductCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentCategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_category_id", runtime.ParamLocationQuery, *params.ParentCategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAncestorsTree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_ancestors_tree", runtime.ParamLocationQuery, *params.IncludeAncestorsTree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDescendantsTree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_descendants_tree", runtime.ParamLocationQuery, *params.IncludeDescendantsTree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsInternal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_internal", runtime.ParamLocationQuery, *params.IsInternal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_active", runtime.ParamLocationQuery, *params.IsActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductCategoriesRequest calls the generic PostProductCategories builder with application/json body
func NewPostProductCategoriesRequest(server string, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductCategoriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProductCategoriesRequestWithBody generates requests for PostProductCategories with any type of body
func NewPostProductCategoriesRequestWithBody(server string, params *PostProductCategoriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductCategoriesIdRequest generates requests for DeleteProductCategoriesId
func NewDeleteProductCategoriesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductCategoriesIdRequest generates requests for GetProductCategoriesId
func NewGetProductCategoriesIdRequest(server string, id string, params *GetProductCategoriesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeAncestorsTree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_ancestors_tree", runtime.ParamLocationQuery, *params.IncludeAncestorsTree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDescendantsTree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_descendants_tree", runtime.ParamLocationQuery, *params.IncludeDescendantsTree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductCategoriesIdRequest calls the generic PostProductCategoriesId builder with application/json body
func NewPostProductCategoriesIdRequest(server string, id string, params *PostProductCategoriesIdParams, body PostProductCategoriesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductCategoriesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductCategoriesIdRequestWithBody generates requests for PostProductCategoriesId with any type of body
func NewPostProductCategoriesIdRequestWithBody(server string, id string, params *PostProductCategoriesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductCategoriesIdProductsRequest calls the generic PostProductCategoriesIdProducts builder with application/json body
func NewPostProductCategoriesIdProductsRequest(server string, id string, params *PostProductCategoriesIdProductsParams, body PostProductCategoriesIdProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductCategoriesIdProductsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductCategoriesIdProductsRequestWithBody generates requests for PostProductCategoriesIdProducts with any type of body
func NewPostProductCategoriesIdProductsRequestWithBody(server string, id string, params *PostProductCategoriesIdProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductTagsRequest generates requests for GetProductTags
func NewGetProductTagsRequest(server string, params *GetProductTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductTagsRequest calls the generic PostProductTags builder with application/json body
func NewPostProductTagsRequest(server string, params *PostProductTagsParams, body PostProductTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductTagsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProductTagsRequestWithBody generates requests for PostProductTags with any type of body
func NewPostProductTagsRequestWithBody(server string, params *PostProductTagsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductTagsIdRequest generates requests for DeleteProductTagsId
func NewDeleteProductTagsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductTagsIdRequest generates requests for GetProductTagsId
func NewGetProductTagsIdRequest(server string, id string, params *GetProductTagsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductTagsIdRequest calls the generic PostProductTagsId builder with application/json body
func NewPostProductTagsIdRequest(server string, id string, params *PostProductTagsIdParams, body PostProductTagsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductTagsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductTagsIdRequestWithBody generates requests for PostProductTagsId with any type of body
func NewPostProductTagsIdRequestWithBody(server string, id string, params *PostProductTagsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductTypesRequest generates requests for GetProductTypes
func NewGetProductTypesRequest(server string, params *GetProductTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductTypesRequest calls the generic PostProductTypes builder with application/json body
func NewPostProductTypesRequest(server string, params *PostProductTypesParams, body PostProductTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductTypesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProductTypesRequestWithBody generates requests for PostProductTypes with any type of body
func NewPostProductTypesRequestWithBody(server string, params *PostProductTypesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductTypesIdRequest generates requests for DeleteProductTypesId
func NewDeleteProductTypesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductTypesIdRequest generates requests for GetProductTypesId
func NewGetProductTypesIdRequest(server string, id string, params *GetProductTypesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductTypesIdRequest calls the generic PostProductTypesId builder with application/json body
func NewPostProductTypesIdRequest(server string, id string, params *PostProductTypesIdParams, body PostProductTypesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductTypesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductTypesIdRequestWithBody generates requests for PostProductTypesId with any type of body
func NewPostProductTypesIdRequestWithBody(server string, id string, params *PostProductTypesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductVariantsRequest generates requests for GetProductVariants
func NewGetProductVariantsRequest(server string, params *GetProductVariantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-variants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ManageInventory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "manage_inventory", runtime.ParamLocationQuery, *params.ManageInventory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowBackorder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_backorder", runtime.ParamLocationQuery, *params.AllowBackorder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsRequest generates requests for GetProducts
func NewGetProductsRequest(server string, params *GetProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_list_id", runtime.ParamLocationQuery, *params.PriceListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGiftcard != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_giftcard", runtime.ParamLocationQuery, *params.IsGiftcard); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type_id", runtime.ParamLocationQuery, *params.TypeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category_id", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collection_id", runtime.ParamLocationQuery, *params.CollectionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Variants != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "variants", runtime.ParamLocationQuery, *params.Variants); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsRequest calls the generic PostProducts builder with application/json body
func NewPostProductsRequest(server string, params *PostProductsParams, body PostProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProductsRequestWithBody generates requests for PostProducts with any type of body
func NewPostProductsRequestWithBody(server string, params *PostProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsBatchRequest calls the generic PostProductsBatch builder with application/json body
func NewPostProductsBatchRequest(server string, params *PostProductsBatchParams, body PostProductsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsBatchRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProductsBatchRequestWithBody generates requests for PostProductsBatch with any type of body
func NewPostProductsBatchRequestWithBody(server string, params *PostProductsBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsExportRequest generates requests for PostProductsExport
func NewPostProductsExportRequest(server string, params *PostProductsExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsImportRequest calls the generic PostProductsImport builder with application/json body
func NewPostProductsImportRequest(server string, body PostProductsImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsImportRequestWithBody(server, "application/json", bodyReader)
}

// NewPostProductsImportRequestWithBody generates requests for PostProductsImport with any type of body
func NewPostProductsImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsImportTransactionIdConfirmRequest generates requests for PostProductsImportTransactionIdConfirm
func NewPostProductsImportTransactionIdConfirmRequest(server string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/import/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductsIdRequest generates requests for DeleteProductsId
func NewDeleteProductsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsIdRequest generates requests for GetProductsId
func NewGetProductsIdRequest(server string, id string, params *GetProductsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsIdRequest calls the generic PostProductsId builder with application/json body
func NewPostProductsIdRequest(server string, id string, params *PostProductsIdParams, body PostProductsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductsIdRequestWithBody generates requests for PostProductsId with any type of body
func NewPostProductsIdRequestWithBody(server string, id string, params *PostProductsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsIdOptionsRequest generates requests for GetProductsIdOptions
func NewGetProductsIdOptionsRequest(server string, id string, params *GetProductsIdOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsIdOptionsRequest calls the generic PostProductsIdOptions builder with application/json body
func NewPostProductsIdOptionsRequest(server string, id string, params *PostProductsIdOptionsParams, body PostProductsIdOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdOptionsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductsIdOptionsRequestWithBody generates requests for PostProductsIdOptions with any type of body
func NewPostProductsIdOptionsRequestWithBody(server string, id string, params *PostProductsIdOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsIdOptionsOptionIdRequest generates requests for DeleteProductsIdOptionsOptionId
func NewDeleteProductsIdOptionsOptionIdRequest(server string, id string, optionId string, params *DeleteProductsIdOptionsOptionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "option_id", runtime.ParamLocationPath, optionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsIdOptionsOptionIdRequest generates requests for GetProductsIdOptionsOptionId
func NewGetProductsIdOptionsOptionIdRequest(server string, id string, optionId string, params *GetProductsIdOptionsOptionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "option_id", runtime.ParamLocationPath, optionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsIdOptionsOptionIdRequest calls the generic PostProductsIdOptionsOptionId builder with application/json body
func NewPostProductsIdOptionsOptionIdRequest(server string, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, body PostProductsIdOptionsOptionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdOptionsOptionIdRequestWithBody(server, id, optionId, params, "application/json", bodyReader)
}

// NewPostProductsIdOptionsOptionIdRequestWithBody generates requests for PostProductsIdOptionsOptionId with any type of body
func NewPostProductsIdOptionsOptionIdRequestWithBody(server string, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "option_id", runtime.ParamLocationPath, optionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsIdVariantsRequest generates requests for GetProductsIdVariants
func NewGetProductsIdVariantsRequest(server string, id string, params *GetProductsIdVariantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ManageInventory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "manage_inventory", runtime.ParamLocationQuery, *params.ManageInventory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowBackorder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_backorder", runtime.ParamLocationQuery, *params.AllowBackorder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsIdVariantsRequest calls the generic PostProductsIdVariants builder with application/json body
func NewPostProductsIdVariantsRequest(server string, id string, params *PostProductsIdVariantsParams, body PostProductsIdVariantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdVariantsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductsIdVariantsRequestWithBody generates requests for PostProductsIdVariants with any type of body
func NewPostProductsIdVariantsRequestWithBody(server string, id string, params *PostProductsIdVariantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsIdVariantsBatchRequest calls the generic PostProductsIdVariantsBatch builder with application/json body
func NewPostProductsIdVariantsBatchRequest(server string, id string, params *PostProductsIdVariantsBatchParams, body PostProductsIdVariantsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdVariantsBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductsIdVariantsBatchRequestWithBody generates requests for PostProductsIdVariantsBatch with any type of body
func NewPostProductsIdVariantsBatchRequestWithBody(server string, id string, params *PostProductsIdVariantsBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsIdVariantsInventoryItemsBatchRequest calls the generic PostProductsIdVariantsInventoryItemsBatch builder with application/json body
func NewPostProductsIdVariantsInventoryItemsBatchRequest(server string, id string, body PostProductsIdVariantsInventoryItemsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdVariantsInventoryItemsBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProductsIdVariantsInventoryItemsBatchRequestWithBody generates requests for PostProductsIdVariantsInventoryItemsBatch with any type of body
func NewPostProductsIdVariantsInventoryItemsBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/inventory-items/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsIdVariantsVariantIdRequest generates requests for DeleteProductsIdVariantsVariantId
func NewDeleteProductsIdVariantsVariantIdRequest(server string, id string, variantId string, params *DeleteProductsIdVariantsVariantIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsIdVariantsVariantIdRequest generates requests for GetProductsIdVariantsVariantId
func NewGetProductsIdVariantsVariantIdRequest(server string, id string, variantId string, params *GetProductsIdVariantsVariantIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsIdVariantsVariantIdRequest calls the generic PostProductsIdVariantsVariantId builder with application/json body
func NewPostProductsIdVariantsVariantIdRequest(server string, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, body PostProductsIdVariantsVariantIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdVariantsVariantIdRequestWithBody(server, id, variantId, params, "application/json", bodyReader)
}

// NewPostProductsIdVariantsVariantIdRequestWithBody generates requests for PostProductsIdVariantsVariantId with any type of body
func NewPostProductsIdVariantsVariantIdRequestWithBody(server string, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsIdVariantsVariantIdInventoryItemsRequest calls the generic PostProductsIdVariantsVariantIdInventoryItems builder with application/json body
func NewPostProductsIdVariantsVariantIdInventoryItemsRequest(server string, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, body PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdVariantsVariantIdInventoryItemsRequestWithBody(server, id, variantId, params, "application/json", bodyReader)
}

// NewPostProductsIdVariantsVariantIdInventoryItemsRequestWithBody generates requests for PostProductsIdVariantsVariantIdInventoryItems with any type of body
func NewPostProductsIdVariantsVariantIdInventoryItemsRequestWithBody(server string, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s/inventory-items", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequest generates requests for DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId
func NewDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequest(server string, id string, variantId string, inventoryItemId string, params *DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "inventory_item_id", runtime.ParamLocationPath, inventoryItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s/inventory-items/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequest calls the generic PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId builder with application/json body
func NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequest(server string, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, body PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequestWithBody(server, id, variantId, inventoryItemId, params, "application/json", bodyReader)
}

// NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequestWithBody generates requests for PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId with any type of body
func NewPostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdRequestWithBody(server string, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "inventory_item_id", runtime.ParamLocationPath, inventoryItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s/inventory-items/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPromotionsRequest generates requests for GetPromotions
func NewGetPromotionsRequest(server string, params *GetPromotionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaign_id", runtime.ParamLocationQuery, *params.CampaignId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ApplicationMethod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "application_method", runtime.ParamLocationQuery, *params.ApplicationMethod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPromotionsRequest calls the generic PostPromotions builder with application/json body
func NewPostPromotionsRequest(server string, params *PostPromotionsParams, body PostPromotionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPromotionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostPromotionsRequestWithBody generates requests for PostPromotions with any type of body
func NewPostPromotionsRequestWithBody(server string, params *PostPromotionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPromotionsRuleAttributeOptionsRuleTypeRequest generates requests for GetPromotionsRuleAttributeOptionsRuleType
func NewGetPromotionsRuleAttributeOptionsRuleTypeRequest(server string, ruleType GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType, params *GetPromotionsRuleAttributeOptionsRuleTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_type", runtime.ParamLocationPath, ruleType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/rule-attribute-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PromotionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "promotion_type", runtime.ParamLocationQuery, *params.PromotionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ApplicationMethodType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "application_method_type", runtime.ParamLocationQuery, *params.ApplicationMethodType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdRequest generates requests for GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId
func NewGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdRequest(server string, ruleType GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType, ruleAttributeId string, params *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rule_type", runtime.ParamLocationPath, ruleType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "rule_attribute_id", runtime.ParamLocationPath, ruleAttributeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/rule-value-options/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PromotionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "promotion_type", runtime.ParamLocationQuery, *params.PromotionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ApplicationMethodType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "application_method_type", runtime.ParamLocationQuery, *params.ApplicationMethodType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePromotionsIdRequest generates requests for DeletePromotionsId
func NewDeletePromotionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPromotionsIdRequest generates requests for GetPromotionsId
func NewGetPromotionsIdRequest(server string, id string, params *GetPromotionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPromotionsIdRequest calls the generic PostPromotionsId builder with application/json body
func NewPostPromotionsIdRequest(server string, id string, params *PostPromotionsIdParams, body PostPromotionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPromotionsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPromotionsIdRequestWithBody generates requests for PostPromotionsId with any type of body
func NewPostPromotionsIdRequestWithBody(server string, id string, params *PostPromotionsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPromotionsIdBuyRulesBatchRequest calls the generic PostPromotionsIdBuyRulesBatch builder with application/json body
func NewPostPromotionsIdBuyRulesBatchRequest(server string, id string, params *PostPromotionsIdBuyRulesBatchParams, body PostPromotionsIdBuyRulesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPromotionsIdBuyRulesBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPromotionsIdBuyRulesBatchRequestWithBody generates requests for PostPromotionsIdBuyRulesBatch with any type of body
func NewPostPromotionsIdBuyRulesBatchRequestWithBody(server string, id string, params *PostPromotionsIdBuyRulesBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s/buy-rules/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPromotionsIdRulesBatchRequest calls the generic PostPromotionsIdRulesBatch builder with application/json body
func NewPostPromotionsIdRulesBatchRequest(server string, id string, params *PostPromotionsIdRulesBatchParams, body PostPromotionsIdRulesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPromotionsIdRulesBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPromotionsIdRulesBatchRequestWithBody generates requests for PostPromotionsIdRulesBatch with any type of body
func NewPostPromotionsIdRulesBatchRequestWithBody(server string, id string, params *PostPromotionsIdRulesBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s/rules/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPromotionsIdTargetRulesBatchRequest calls the generic PostPromotionsIdTargetRulesBatch builder with application/json body
func NewPostPromotionsIdTargetRulesBatchRequest(server string, id string, params *PostPromotionsIdTargetRulesBatchParams, body PostPromotionsIdTargetRulesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPromotionsIdTargetRulesBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostPromotionsIdTargetRulesBatchRequestWithBody generates requests for PostPromotionsIdTargetRulesBatch with any type of body
func NewPostPromotionsIdTargetRulesBatchRequestWithBody(server string, id string, params *PostPromotionsIdTargetRulesBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s/target-rules/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPromotionsIdRuleTypeRequest generates requests for GetPromotionsIdRuleType
func NewGetPromotionsIdRuleTypeRequest(server string, id string, ruleType GetPromotionsIdRuleTypeParamsRuleType, params *GetPromotionsIdRuleTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "rule_type", runtime.ParamLocationPath, ruleType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/promotions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRefundReasonsRequest generates requests for GetRefundReasons
func NewGetRefundReasonsRequest(server string, params *GetRefundReasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/refund-reasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRefundReasonsRequest calls the generic PostRefundReasons builder with application/json body
func NewPostRefundReasonsRequest(server string, params *PostRefundReasonsParams, body PostRefundReasonsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRefundReasonsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostRefundReasonsRequestWithBody generates requests for PostRefundReasons with any type of body
func NewPostRefundReasonsRequestWithBody(server string, params *PostRefundReasonsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/refund-reasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRefundReasonsIdRequest generates requests for DeleteRefundReasonsId
func NewDeleteRefundReasonsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/refund-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRefundReasonsIdRequest generates requests for GetRefundReasonsId
func NewGetRefundReasonsIdRequest(server string, id string, params *GetRefundReasonsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/refund-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRefundReasonsIdRequest calls the generic PostRefundReasonsId builder with application/json body
func NewPostRefundReasonsIdRequest(server string, id string, params *PostRefundReasonsIdParams, body PostRefundReasonsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRefundReasonsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostRefundReasonsIdRequestWithBody generates requests for PostRefundReasonsId with any type of body
func NewPostRefundReasonsIdRequestWithBody(server string, id string, params *PostRefundReasonsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/refund-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRegionsRequest generates requests for GetRegions
func NewGetRegionsRequest(server string, params *GetRegionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrencyCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "currency_code", runtime.ParamLocationQuery, *params.CurrencyCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegionsRequest calls the generic PostRegions builder with application/json body
func NewPostRegionsRequest(server string, params *PostRegionsParams, body PostRegionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostRegionsRequestWithBody generates requests for PostRegions with any type of body
func NewPostRegionsRequestWithBody(server string, params *PostRegionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRegionsIdRequest generates requests for DeleteRegionsId
func NewDeleteRegionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegionsIdRequest generates requests for GetRegionsId
func NewGetRegionsIdRequest(server string, id string, params *GetRegionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegionsIdRequest calls the generic PostRegionsId builder with application/json body
func NewPostRegionsIdRequest(server string, id string, params *PostRegionsIdParams, body PostRegionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostRegionsIdRequestWithBody generates requests for PostRegionsId with any type of body
func NewPostRegionsIdRequestWithBody(server string, id string, params *PostRegionsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReservationsRequest generates requests for GetReservations
func NewGetReservationsRequest(server string, params *GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InventoryItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inventory_item_id", runtime.ParamLocationQuery, *params.InventoryItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LineItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "line_item_id", runtime.ParamLocationQuery, *params.LineItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservationsRequest calls the generic PostReservations builder with application/json body
func NewPostReservationsRequest(server string, params *PostReservationsParams, body PostReservationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostReservationsRequestWithBody generates requests for PostReservations with any type of body
func NewPostReservationsRequestWithBody(server string, params *PostReservationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReservationsIdRequest generates requests for DeleteReservationsId
func NewDeleteReservationsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservationsIdRequest generates requests for GetReservationsId
func NewGetReservationsIdRequest(server string, id string, params *GetReservationsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservationsIdRequest calls the generic PostReservationsId builder with application/json body
func NewPostReservationsIdRequest(server string, id string, params *PostReservationsIdParams, body PostReservationsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservationsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReservationsIdRequestWithBody generates requests for PostReservationsId with any type of body
func NewPostReservationsIdRequestWithBody(server string, id string, params *PostReservationsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReturnReasonsRequest generates requests for GetReturnReasons
func NewGetReturnReasonsRequest(server string, params *GetReturnReasonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Label != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentReturnReasonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_return_reason_id", runtime.ParamLocationQuery, *params.ParentReturnReasonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnReasonsRequest calls the generic PostReturnReasons builder with application/json body
func NewPostReturnReasonsRequest(server string, params *PostReturnReasonsParams, body PostReturnReasonsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnReasonsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostReturnReasonsRequestWithBody generates requests for PostReturnReasons with any type of body
func NewPostReturnReasonsRequestWithBody(server string, params *PostReturnReasonsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnReasonsIdRequest generates requests for DeleteReturnReasonsId
func NewDeleteReturnReasonsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReturnReasonsIdRequest generates requests for GetReturnReasonsId
func NewGetReturnReasonsIdRequest(server string, id string, params *GetReturnReasonsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnReasonsIdRequest calls the generic PostReturnReasonsId builder with application/json body
func NewPostReturnReasonsIdRequest(server string, id string, params *PostReturnReasonsIdParams, body PostReturnReasonsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnReasonsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnReasonsIdRequestWithBody generates requests for PostReturnReasonsId with any type of body
func NewPostReturnReasonsIdRequestWithBody(server string, id string, params *PostReturnReasonsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReturnsRequest generates requests for GetReturns
func NewGetReturnsRequest(server string, params *GetReturnsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FulfillmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fulfillment_status", runtime.ParamLocationQuery, *params.FulfillmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payment_status", runtime.ParamLocationQuery, *params.PaymentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsRequest calls the generic PostReturns builder with application/json body
func NewPostReturnsRequest(server string, params *PostReturnsParams, body PostReturnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostReturnsRequestWithBody generates requests for PostReturns with any type of body
func NewPostReturnsRequestWithBody(server string, params *PostReturnsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReturnsIdRequest generates requests for GetReturnsId
func NewGetReturnsIdRequest(server string, id string, params *GetReturnsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdRequest calls the generic PostReturnsId builder with application/json body
func NewPostReturnsIdRequest(server string, id string, params *PostReturnsIdParams, body PostReturnsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdRequestWithBody generates requests for PostReturnsId with any type of body
func NewPostReturnsIdRequestWithBody(server string, id string, params *PostReturnsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostReturnsIdCancelRequest calls the generic PostReturnsIdCancel builder with application/json body
func NewPostReturnsIdCancelRequest(server string, id string, body PostReturnsIdCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdCancelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostReturnsIdCancelRequestWithBody generates requests for PostReturnsIdCancel with any type of body
func NewPostReturnsIdCancelRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostReturnsIdDismissItemsRequest calls the generic PostReturnsIdDismissItems builder with application/json body
func NewPostReturnsIdDismissItemsRequest(server string, id string, params *PostReturnsIdDismissItemsParams, body PostReturnsIdDismissItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdDismissItemsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdDismissItemsRequestWithBody generates requests for PostReturnsIdDismissItems with any type of body
func NewPostReturnsIdDismissItemsRequestWithBody(server string, id string, params *PostReturnsIdDismissItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/dismiss-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnsIdDismissItemsActionIdRequest generates requests for DeleteReturnsIdDismissItemsActionId
func NewDeleteReturnsIdDismissItemsActionIdRequest(server string, id string, actionId string, params *DeleteReturnsIdDismissItemsActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/dismiss-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdDismissItemsActionIdRequest calls the generic PostReturnsIdDismissItemsActionId builder with application/json body
func NewPostReturnsIdDismissItemsActionIdRequest(server string, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, body PostReturnsIdDismissItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdDismissItemsActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostReturnsIdDismissItemsActionIdRequestWithBody generates requests for PostReturnsIdDismissItemsActionId with any type of body
func NewPostReturnsIdDismissItemsActionIdRequestWithBody(server string, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/dismiss-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnsIdReceiveRequest generates requests for DeleteReturnsIdReceive
func NewDeleteReturnsIdReceiveRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdReceiveRequest calls the generic PostReturnsIdReceive builder with application/json body
func NewPostReturnsIdReceiveRequest(server string, id string, params *PostReturnsIdReceiveParams, body PostReturnsIdReceiveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdReceiveRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdReceiveRequestWithBody generates requests for PostReturnsIdReceive with any type of body
func NewPostReturnsIdReceiveRequestWithBody(server string, id string, params *PostReturnsIdReceiveParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostReturnsIdReceiveItemsRequest calls the generic PostReturnsIdReceiveItems builder with application/json body
func NewPostReturnsIdReceiveItemsRequest(server string, id string, params *PostReturnsIdReceiveItemsParams, body PostReturnsIdReceiveItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdReceiveItemsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdReceiveItemsRequestWithBody generates requests for PostReturnsIdReceiveItems with any type of body
func NewPostReturnsIdReceiveItemsRequestWithBody(server string, id string, params *PostReturnsIdReceiveItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnsIdReceiveItemsActionIdRequest generates requests for DeleteReturnsIdReceiveItemsActionId
func NewDeleteReturnsIdReceiveItemsActionIdRequest(server string, id string, actionId string, params *DeleteReturnsIdReceiveItemsActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdReceiveItemsActionIdRequest calls the generic PostReturnsIdReceiveItemsActionId builder with application/json body
func NewPostReturnsIdReceiveItemsActionIdRequest(server string, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, body PostReturnsIdReceiveItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdReceiveItemsActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostReturnsIdReceiveItemsActionIdRequestWithBody generates requests for PostReturnsIdReceiveItemsActionId with any type of body
func NewPostReturnsIdReceiveItemsActionIdRequestWithBody(server string, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostReturnsIdReceiveConfirmRequest calls the generic PostReturnsIdReceiveConfirm builder with application/json body
func NewPostReturnsIdReceiveConfirmRequest(server string, id string, params *PostReturnsIdReceiveConfirmParams, body PostReturnsIdReceiveConfirmJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdReceiveConfirmRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdReceiveConfirmRequestWithBody generates requests for PostReturnsIdReceiveConfirm with any type of body
func NewPostReturnsIdReceiveConfirmRequestWithBody(server string, id string, params *PostReturnsIdReceiveConfirmParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnsIdRequestRequest generates requests for DeleteReturnsIdRequest
func NewDeleteReturnsIdRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdRequestRequest calls the generic PostReturnsIdRequest builder with application/json body
func NewPostReturnsIdRequestRequest(server string, id string, params *PostReturnsIdRequestParams, body PostReturnsIdRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdRequestRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdRequestRequestWithBody generates requests for PostReturnsIdRequest with any type of body
func NewPostReturnsIdRequestRequestWithBody(server string, id string, params *PostReturnsIdRequestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostReturnsIdRequestItemsRequest calls the generic PostReturnsIdRequestItems builder with application/json body
func NewPostReturnsIdRequestItemsRequest(server string, id string, params *PostReturnsIdRequestItemsParams, body PostReturnsIdRequestItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdRequestItemsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdRequestItemsRequestWithBody generates requests for PostReturnsIdRequestItems with any type of body
func NewPostReturnsIdRequestItemsRequestWithBody(server string, id string, params *PostReturnsIdRequestItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/request-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnsIdRequestItemsActionIdRequest generates requests for DeleteReturnsIdRequestItemsActionId
func NewDeleteReturnsIdRequestItemsActionIdRequest(server string, id string, actionId string, params *DeleteReturnsIdRequestItemsActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/request-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdRequestItemsActionIdRequest calls the generic PostReturnsIdRequestItemsActionId builder with application/json body
func NewPostReturnsIdRequestItemsActionIdRequest(server string, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, body PostReturnsIdRequestItemsActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdRequestItemsActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostReturnsIdRequestItemsActionIdRequestWithBody generates requests for PostReturnsIdRequestItemsActionId with any type of body
func NewPostReturnsIdRequestItemsActionIdRequestWithBody(server string, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/request-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostReturnsIdShippingMethodRequest calls the generic PostReturnsIdShippingMethod builder with application/json body
func NewPostReturnsIdShippingMethodRequest(server string, id string, params *PostReturnsIdShippingMethodParams, body PostReturnsIdShippingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdShippingMethodRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostReturnsIdShippingMethodRequestWithBody generates requests for PostReturnsIdShippingMethod with any type of body
func NewPostReturnsIdShippingMethodRequestWithBody(server string, id string, params *PostReturnsIdShippingMethodParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/shipping-method", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnsIdShippingMethodActionIdRequest generates requests for DeleteReturnsIdShippingMethodActionId
func NewDeleteReturnsIdShippingMethodActionIdRequest(server string, id string, actionId string, params *DeleteReturnsIdShippingMethodActionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsIdShippingMethodActionIdRequest calls the generic PostReturnsIdShippingMethodActionId builder with application/json body
func NewPostReturnsIdShippingMethodActionIdRequest(server string, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, body PostReturnsIdShippingMethodActionIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsIdShippingMethodActionIdRequestWithBody(server, id, actionId, params, "application/json", bodyReader)
}

// NewPostReturnsIdShippingMethodActionIdRequestWithBody generates requests for PostReturnsIdShippingMethodActionId with any type of body
func NewPostReturnsIdShippingMethodActionIdRequestWithBody(server string, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action_id", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/shipping-method/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSalesChannelsRequest generates requests for GetSalesChannels
func NewGetSalesChannelsRequest(server string, params *GetSalesChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_disabled", runtime.ParamLocationQuery, *params.IsDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishableKeyId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publishable_key_id", runtime.ParamLocationQuery, *params.PublishableKeyId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSalesChannelsRequest calls the generic PostSalesChannels builder with application/json body
func NewPostSalesChannelsRequest(server string, params *PostSalesChannelsParams, body PostSalesChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostSalesChannelsRequestWithBody generates requests for PostSalesChannels with any type of body
func NewPostSalesChannelsRequestWithBody(server string, params *PostSalesChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSalesChannelsIdRequest generates requests for DeleteSalesChannelsId
func NewDeleteSalesChannelsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSalesChannelsIdRequest generates requests for GetSalesChannelsId
func NewGetSalesChannelsIdRequest(server string, id string, params *GetSalesChannelsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSalesChannelsIdRequest calls the generic PostSalesChannelsId builder with application/json body
func NewPostSalesChannelsIdRequest(server string, id string, params *PostSalesChannelsIdParams, body PostSalesChannelsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostSalesChannelsIdRequestWithBody generates requests for PostSalesChannelsId with any type of body
func NewPostSalesChannelsIdRequestWithBody(server string, id string, params *PostSalesChannelsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSalesChannelsIdProductsRequest calls the generic PostSalesChannelsIdProducts builder with application/json body
func NewPostSalesChannelsIdProductsRequest(server string, id string, params *PostSalesChannelsIdProductsParams, body PostSalesChannelsIdProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsIdProductsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostSalesChannelsIdProductsRequestWithBody generates requests for PostSalesChannelsIdProducts with any type of body
func NewPostSalesChannelsIdProductsRequestWithBody(server string, id string, params *PostSalesChannelsIdProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShippingOptionsRequest generates requests for GetShippingOptions
func NewGetShippingOptionsRequest(server string, params *GetShippingOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServiceZoneId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_zone_id", runtime.ParamLocationQuery, *params.ServiceZoneId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShippingProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipping_profile_id", runtime.ParamLocationQuery, *params.ShippingProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProviderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider_id", runtime.ParamLocationQuery, *params.ProviderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShippingOptionTypeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipping_option_type_id", runtime.ParamLocationQuery, *params.ShippingOptionTypeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StockLocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stock_location_id", runtime.ParamLocationQuery, *params.StockLocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsReturn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_return", runtime.ParamLocationQuery, *params.IsReturn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "admin_only", runtime.ParamLocationQuery, *params.AdminOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingOptionsRequest calls the generic PostShippingOptions builder with application/json body
func NewPostShippingOptionsRequest(server string, params *PostShippingOptionsParams, body PostShippingOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingOptionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostShippingOptionsRequestWithBody generates requests for PostShippingOptions with any type of body
func NewPostShippingOptionsRequestWithBody(server string, params *PostShippingOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShippingOptionsIdRequest generates requests for DeleteShippingOptionsId
func NewDeleteShippingOptionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShippingOptionsIdRequest generates requests for GetShippingOptionsId
func NewGetShippingOptionsIdRequest(server string, id string, params *GetShippingOptionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingOptionsIdRequest calls the generic PostShippingOptionsId builder with application/json body
func NewPostShippingOptionsIdRequest(server string, id string, params *PostShippingOptionsIdParams, body PostShippingOptionsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingOptionsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostShippingOptionsIdRequestWithBody generates requests for PostShippingOptionsId with any type of body
func NewPostShippingOptionsIdRequestWithBody(server string, id string, params *PostShippingOptionsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostShippingOptionsIdRulesBatchRequest calls the generic PostShippingOptionsIdRulesBatch builder with application/json body
func NewPostShippingOptionsIdRulesBatchRequest(server string, id string, params *PostShippingOptionsIdRulesBatchParams, body PostShippingOptionsIdRulesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingOptionsIdRulesBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostShippingOptionsIdRulesBatchRequestWithBody generates requests for PostShippingOptionsIdRulesBatch with any type of body
func NewPostShippingOptionsIdRulesBatchRequestWithBody(server string, id string, params *PostShippingOptionsIdRulesBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s/rules/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShippingProfilesRequest generates requests for GetShippingProfiles
func NewGetShippingProfilesRequest(server string, params *GetShippingProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingProfilesRequest calls the generic PostShippingProfiles builder with application/json body
func NewPostShippingProfilesRequest(server string, params *PostShippingProfilesParams, body PostShippingProfilesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingProfilesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostShippingProfilesRequestWithBody generates requests for PostShippingProfiles with any type of body
func NewPostShippingProfilesRequestWithBody(server string, params *PostShippingProfilesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShippingProfilesIdRequest generates requests for DeleteShippingProfilesId
func NewDeleteShippingProfilesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShippingProfilesIdRequest generates requests for GetShippingProfilesId
func NewGetShippingProfilesIdRequest(server string, id string, params *GetShippingProfilesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingProfilesIdRequest calls the generic PostShippingProfilesId builder with application/json body
func NewPostShippingProfilesIdRequest(server string, id string, params *PostShippingProfilesIdParams, body PostShippingProfilesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingProfilesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostShippingProfilesIdRequestWithBody generates requests for PostShippingProfilesId with any type of body
func NewPostShippingProfilesIdRequestWithBody(server string, id string, params *PostShippingProfilesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStockLocationsRequest generates requests for GetStockLocations
func NewGetStockLocationsRequest(server string, params *GetStockLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddressId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address_id", runtime.ParamLocationQuery, *params.AddressId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStockLocationsRequest calls the generic PostStockLocations builder with application/json body
func NewPostStockLocationsRequest(server string, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostStockLocationsRequestWithBody generates requests for PostStockLocations with any type of body
func NewPostStockLocationsRequestWithBody(server string, params *PostStockLocationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStockLocationsIdRequest generates requests for DeleteStockLocationsId
func NewDeleteStockLocationsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStockLocationsIdRequest generates requests for GetStockLocationsId
func NewGetStockLocationsIdRequest(server string, id string, params *GetStockLocationsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStockLocationsIdRequest calls the generic PostStockLocationsId builder with application/json body
func NewPostStockLocationsIdRequest(server string, id string, params *PostStockLocationsIdParams, body PostStockLocationsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostStockLocationsIdRequestWithBody generates requests for PostStockLocationsId with any type of body
func NewPostStockLocationsIdRequestWithBody(server string, id string, params *PostStockLocationsIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStockLocationsIdFulfillmentProvidersRequest calls the generic PostStockLocationsIdFulfillmentProviders builder with application/json body
func NewPostStockLocationsIdFulfillmentProvidersRequest(server string, id string, params *PostStockLocationsIdFulfillmentProvidersParams, body PostStockLocationsIdFulfillmentProvidersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsIdFulfillmentProvidersRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostStockLocationsIdFulfillmentProvidersRequestWithBody generates requests for PostStockLocationsIdFulfillmentProviders with any type of body
func NewPostStockLocationsIdFulfillmentProvidersRequestWithBody(server string, id string, params *PostStockLocationsIdFulfillmentProvidersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s/fulfillment-providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStockLocationsIdFulfillmentSetsRequest calls the generic PostStockLocationsIdFulfillmentSets builder with application/json body
func NewPostStockLocationsIdFulfillmentSetsRequest(server string, id string, params *PostStockLocationsIdFulfillmentSetsParams, body PostStockLocationsIdFulfillmentSetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsIdFulfillmentSetsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostStockLocationsIdFulfillmentSetsRequestWithBody generates requests for PostStockLocationsIdFulfillmentSets with any type of body
func NewPostStockLocationsIdFulfillmentSetsRequestWithBody(server string, id string, params *PostStockLocationsIdFulfillmentSetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s/fulfillment-sets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStockLocationsIdSalesChannelsRequest calls the generic PostStockLocationsIdSalesChannels builder with application/json body
func NewPostStockLocationsIdSalesChannelsRequest(server string, id string, params *PostStockLocationsIdSalesChannelsParams, body PostStockLocationsIdSalesChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsIdSalesChannelsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostStockLocationsIdSalesChannelsRequestWithBody generates requests for PostStockLocationsIdSalesChannels with any type of body
func NewPostStockLocationsIdSalesChannelsRequestWithBody(server string, id string, params *PostStockLocationsIdSalesChannelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s/sales-channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStoresRequest generates requests for GetStores
func NewGetStoresRequest(server string, params *GetStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoresIdRequest generates requests for GetStoresId
func NewGetStoresIdRequest(server string, id string, params *GetStoresIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStoresIdRequest calls the generic PostStoresId builder with application/json body
func NewPostStoresIdRequest(server string, id string, params *PostStoresIdParams, body PostStoresIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStoresIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostStoresIdRequestWithBody generates requests for PostStoresId with any type of body
func NewPostStoresIdRequestWithBody(server string, id string, params *PostStoresIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTaxRatesRequest generates requests for GetTaxRates
func NewGetTaxRatesRequest(server string, params *GetTaxRatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxRegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_region_id", runtime.ParamLocationQuery, *params.TaxRegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDefault != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_default", runtime.ParamLocationQuery, *params.IsDefault); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServiceZoneId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service_zone_id", runtime.ParamLocationQuery, *params.ServiceZoneId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShippingProfileId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipping_profile_id", runtime.ParamLocationQuery, *params.ShippingProfileId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProviderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider_id", runtime.ParamLocationQuery, *params.ProviderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShippingOptionTypeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shipping_option_type_id", runtime.ParamLocationQuery, *params.ShippingOptionTypeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTaxRatesRequest calls the generic PostTaxRates builder with application/json body
func NewPostTaxRatesRequest(server string, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostTaxRatesRequestWithBody generates requests for PostTaxRates with any type of body
func NewPostTaxRatesRequestWithBody(server string, params *PostTaxRatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRatesIdRequest generates requests for DeleteTaxRatesId
func NewDeleteTaxRatesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxRatesIdRequest generates requests for GetTaxRatesId
func NewGetTaxRatesIdRequest(server string, id string, params *GetTaxRatesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTaxRatesIdRequest calls the generic PostTaxRatesId builder with application/json body
func NewPostTaxRatesIdRequest(server string, id string, params *PostTaxRatesIdParams, body PostTaxRatesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTaxRatesIdRequestWithBody generates requests for PostTaxRatesId with any type of body
func NewPostTaxRatesIdRequestWithBody(server string, id string, params *PostTaxRatesIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTaxRatesIdRulesRequest calls the generic PostTaxRatesIdRules builder with application/json body
func NewPostTaxRatesIdRulesRequest(server string, id string, params *PostTaxRatesIdRulesParams, body PostTaxRatesIdRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesIdRulesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTaxRatesIdRulesRequestWithBody generates requests for PostTaxRatesIdRules with any type of body
func NewPostTaxRatesIdRulesRequestWithBody(server string, id string, params *PostTaxRatesIdRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRatesIdRulesRuleIdRequest generates requests for DeleteTaxRatesIdRulesRuleId
func NewDeleteTaxRatesIdRulesRuleIdRequest(server string, id string, ruleId string, params *DeleteTaxRatesIdRulesRuleIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "rule_id", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxRegionsRequest generates requests for GetTaxRegions
func NewGetTaxRegionsRequest(server string, params *GetTaxRegionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CountryCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "country_code", runtime.ParamLocationQuery, *params.CountryCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProvinceCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "province_code", runtime.ParamLocationQuery, *params.ProvinceCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_id", runtime.ParamLocationQuery, *params.ParentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.And != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$and", runtime.ParamLocationQuery, *params.And); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Or != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "$or", runtime.ParamLocationQuery, *params.Or); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTaxRegionsRequest calls the generic PostTaxRegions builder with application/json body
func NewPostTaxRegionsRequest(server string, params *PostTaxRegionsParams, body PostTaxRegionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRegionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostTaxRegionsRequestWithBody generates requests for PostTaxRegions with any type of body
func NewPostTaxRegionsRequestWithBody(server string, params *PostTaxRegionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRegionsIdRequest generates requests for DeleteTaxRegionsId
func NewDeleteTaxRegionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxRegionsIdRequest generates requests for GetTaxRegionsId
func NewGetTaxRegionsIdRequest(server string, id string, params *GetTaxRegionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUploadsRequest calls the generic PostUploads builder with application/json body
func NewPostUploadsRequest(server string, body PostUploadsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUploadsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUploadsRequestWithBody generates requests for PostUploads with any type of body
func NewPostUploadsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUploadsIdRequest generates requests for DeleteUploadsId
func NewDeleteUploadsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUploadsIdRequest generates requests for GetUploadsId
func NewGetUploadsIdRequest(server string, id string, params *GetUploadsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersMeRequest generates requests for GetUsersMe
func NewGetUsersMeRequest(server string, params *GetUsersMeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUsersIdRequest generates requests for DeleteUsersId
func NewDeleteUsersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdRequest generates requests for GetUsersId
func NewGetUsersIdRequest(server string, id string, params *GetUsersIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersIdRequest calls the generic PostUsersId builder with application/json body
func NewPostUsersIdRequest(server string, id string, params *PostUsersIdParams, body PostUsersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostUsersIdRequestWithBody generates requests for PostUsersId with any type of body
func NewPostUsersIdRequestWithBody(server string, id string, params *PostUsersIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkflowsExecutionsRequest generates requests for GetWorkflowsExecutions
func NewGetWorkflowsExecutionsRequest(server string, params *GetWorkflowsExecutionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflow_id", runtime.ParamLocationQuery, *params.WorkflowId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkflowsExecutionsIdRequest generates requests for GetWorkflowsExecutionsId
func NewGetWorkflowsExecutionsIdRequest(server string, id string, params *GetWorkflowsExecutionsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWorkflowsExecutionsWorkflowIdRunRequest calls the generic PostWorkflowsExecutionsWorkflowIdRun builder with application/json body
func NewPostWorkflowsExecutionsWorkflowIdRunRequest(server string, workflowId string, body PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkflowsExecutionsWorkflowIdRunRequestWithBody(server, workflowId, "application/json", bodyReader)
}

// NewPostWorkflowsExecutionsWorkflowIdRunRequestWithBody generates requests for PostWorkflowsExecutionsWorkflowIdRun with any type of body
func NewPostWorkflowsExecutionsWorkflowIdRunRequestWithBody(server string, workflowId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s/run", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequest calls the generic PostWorkflowsExecutionsWorkflowIdStepsFailure builder with application/json body
func NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequest(server string, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequestWithBody(server, workflowId, "application/json", bodyReader)
}

// NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequestWithBody generates requests for PostWorkflowsExecutionsWorkflowIdStepsFailure with any type of body
func NewPostWorkflowsExecutionsWorkflowIdStepsFailureRequestWithBody(server string, workflowId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s/steps/failure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequest calls the generic PostWorkflowsExecutionsWorkflowIdStepsSuccess builder with application/json body
func NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequest(server string, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequestWithBody(server, workflowId, "application/json", bodyReader)
}

// NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequestWithBody generates requests for PostWorkflowsExecutionsWorkflowIdStepsSuccess with any type of body
func NewPostWorkflowsExecutionsWorkflowIdStepsSuccessRequestWithBody(server string, workflowId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s/steps/success", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkflowsExecutionsWorkflowIdSubscribeRequest generates requests for GetWorkflowsExecutionsWorkflowIdSubscribe
func NewGetWorkflowsExecutionsWorkflowIdSubscribeRequest(server string, workflowId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s/subscribe", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkflowsExecutionsWorkflowIdTransactionIdRequest generates requests for GetWorkflowsExecutionsWorkflowIdTransactionId
func NewGetWorkflowsExecutionsWorkflowIdTransactionIdRequest(server string, workflowId string, transactionId string, params *GetWorkflowsExecutionsWorkflowIdTransactionIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRequest generates requests for GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe
func NewGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeRequest(server string, workflowId string, transactionId string, stepId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "step_id", runtime.ParamLocationPath, stepId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/workflows-executions/%s/%s/%s/subscribe", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSessionRequest generates requests for DeleteSession
func NewDeleteSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSessionRequest generates requests for PostSession
func NewPostSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAdminAuthTokenRefreshRequest generates requests for PostAdminAuthTokenRefresh
func NewPostAdminAuthTokenRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostActorTypeAuthProviderRequest calls the generic PostActorTypeAuthProvider builder with application/json body
func NewPostActorTypeAuthProviderRequest(server string, authProvider string, body PostActorTypeAuthProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostActorTypeAuthProviderRequestWithBody(server, authProvider, "application/json", bodyReader)
}

// NewPostActorTypeAuthProviderRequestWithBody generates requests for PostActorTypeAuthProvider with any type of body
func NewPostActorTypeAuthProviderRequestWithBody(server string, authProvider string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "auth_provider", runtime.ParamLocationPath, authProvider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostActorTypeAuthProviderCallbackRequest generates requests for PostActorTypeAuthProviderCallback
func NewPostActorTypeAuthProviderCallbackRequest(server string, authProvider string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "auth_provider", runtime.ParamLocationPath, authProvider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/user/%s/callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostActorTypeAuthProviderRegisterRequest calls the generic PostActorTypeAuthProviderRegister builder with application/json body
func NewPostActorTypeAuthProviderRegisterRequest(server string, authProvider string, body PostActorTypeAuthProviderRegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostActorTypeAuthProviderRegisterRequestWithBody(server, authProvider, "application/json", bodyReader)
}

// NewPostActorTypeAuthProviderRegisterRequestWithBody generates requests for PostActorTypeAuthProviderRegister with any type of body
func NewPostActorTypeAuthProviderRegisterRequestWithBody(server string, authProvider string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "auth_provider", runtime.ParamLocationPath, authProvider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/user/%s/register", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetApiKeysWithResponse request
	GetApiKeysWithResponse(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error)

	// PostApiKeysWithBodyWithResponse request with any body
	PostApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error)

	PostApiKeysWithResponse(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error)

	// DeleteApiKeysIdWithResponse request
	DeleteApiKeysIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteApiKeysIdResponse, error)

	// GetApiKeysIdWithResponse request
	GetApiKeysIdWithResponse(ctx context.Context, id string, params *GetApiKeysIdParams, reqEditors ...RequestEditorFn) (*GetApiKeysIdResponse, error)

	// PostApiKeysIdWithBodyWithResponse request with any body
	PostApiKeysIdWithBodyWithResponse(ctx context.Context, id string, params *PostApiKeysIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysIdResponse, error)

	PostApiKeysIdWithResponse(ctx context.Context, id string, params *PostApiKeysIdParams, body PostApiKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysIdResponse, error)

	// PostApiKeysIdRevokeWithBodyWithResponse request with any body
	PostApiKeysIdRevokeWithBodyWithResponse(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysIdRevokeResponse, error)

	PostApiKeysIdRevokeWithResponse(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, body PostApiKeysIdRevokeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysIdRevokeResponse, error)

	// PostApiKeysIdSalesChannelsWithBodyWithResponse request with any body
	PostApiKeysIdSalesChannelsWithBodyWithResponse(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysIdSalesChannelsResponse, error)

	PostApiKeysIdSalesChannelsWithResponse(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, body PostApiKeysIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysIdSalesChannelsResponse, error)

	// GetCampaignsWithResponse request
	GetCampaignsWithResponse(ctx context.Context, params *GetCampaignsParams, reqEditors ...RequestEditorFn) (*GetCampaignsResponse, error)

	// PostCampaignsWithBodyWithResponse request with any body
	PostCampaignsWithBodyWithResponse(ctx context.Context, params *PostCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCampaignsResponse, error)

	PostCampaignsWithResponse(ctx context.Context, params *PostCampaignsParams, body PostCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCampaignsResponse, error)

	// DeleteCampaignsIdWithResponse request
	DeleteCampaignsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCampaignsIdResponse, error)

	// GetCampaignsIdWithResponse request
	GetCampaignsIdWithResponse(ctx context.Context, id string, params *GetCampaignsIdParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdResponse, error)

	// PostCampaignsIdWithBodyWithResponse request with any body
	PostCampaignsIdWithBodyWithResponse(ctx context.Context, id string, params *PostCampaignsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCampaignsIdResponse, error)

	PostCampaignsIdWithResponse(ctx context.Context, id string, params *PostCampaignsIdParams, body PostCampaignsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCampaignsIdResponse, error)

	// PostCampaignsIdPromotionsWithBodyWithResponse request with any body
	PostCampaignsIdPromotionsWithBodyWithResponse(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCampaignsIdPromotionsResponse, error)

	PostCampaignsIdPromotionsWithResponse(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, body PostCampaignsIdPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCampaignsIdPromotionsResponse, error)

	// GetClaimsWithResponse request
	GetClaimsWithResponse(ctx context.Context, params *GetClaimsParams, reqEditors ...RequestEditorFn) (*GetClaimsResponse, error)

	// PostClaimsWithBodyWithResponse request with any body
	PostClaimsWithBodyWithResponse(ctx context.Context, params *PostClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsResponse, error)

	PostClaimsWithResponse(ctx context.Context, params *PostClaimsParams, body PostClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsResponse, error)

	// GetClaimsIdWithResponse request
	GetClaimsIdWithResponse(ctx context.Context, id string, params *GetClaimsIdParams, reqEditors ...RequestEditorFn) (*GetClaimsIdResponse, error)

	// PostClaimsIdCancelWithBodyWithResponse request with any body
	PostClaimsIdCancelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdCancelResponse, error)

	PostClaimsIdCancelWithResponse(ctx context.Context, id string, body PostClaimsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdCancelResponse, error)

	// PostClaimsIdClaimItemsWithBodyWithResponse request with any body
	PostClaimsIdClaimItemsWithBodyWithResponse(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsResponse, error)

	PostClaimsIdClaimItemsWithResponse(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, body PostClaimsIdClaimItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsResponse, error)

	// DeleteClaimsIdClaimItemsActionIdWithResponse request
	DeleteClaimsIdClaimItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteClaimsIdClaimItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteClaimsIdClaimItemsActionIdResponse, error)

	// PostClaimsIdClaimItemsActionIdWithBodyWithResponse request with any body
	PostClaimsIdClaimItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsActionIdResponse, error)

	PostClaimsIdClaimItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, body PostClaimsIdClaimItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsActionIdResponse, error)

	// PostClaimsIdInboundItemsWithBodyWithResponse request with any body
	PostClaimsIdInboundItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsResponse, error)

	PostClaimsIdInboundItemsWithResponse(ctx context.Context, id string, body PostClaimsIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsResponse, error)

	// DeleteClaimsIdInboundItemsActionIdWithResponse request
	DeleteClaimsIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteClaimsIdInboundItemsActionIdResponse, error)

	// PostClaimsIdInboundItemsActionIdWithBodyWithResponse request with any body
	PostClaimsIdInboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsActionIdResponse, error)

	PostClaimsIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, body PostClaimsIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsActionIdResponse, error)

	// PostClaimsIdInboundShippingMethodWithBodyWithResponse request with any body
	PostClaimsIdInboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodResponse, error)

	PostClaimsIdInboundShippingMethodWithResponse(ctx context.Context, id string, body PostClaimsIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodResponse, error)

	// DeleteClaimsIdInboundShippingMethodActionIdWithResponse request
	DeleteClaimsIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteClaimsIdInboundShippingMethodActionIdResponse, error)

	// PostClaimsIdInboundShippingMethodActionIdWithBodyWithResponse request with any body
	PostClaimsIdInboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodActionIdResponse, error)

	PostClaimsIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, body PostClaimsIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodActionIdResponse, error)

	// PostClaimsIdOutboundItemsWithBodyWithResponse request with any body
	PostClaimsIdOutboundItemsWithBodyWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsResponse, error)

	PostClaimsIdOutboundItemsWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, body PostClaimsIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsResponse, error)

	// DeleteClaimsIdOutboundItemsActionIdWithResponse request
	DeleteClaimsIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteClaimsIdOutboundItemsActionIdResponse, error)

	// PostClaimsIdOutboundItemsActionIdWithBodyWithResponse request with any body
	PostClaimsIdOutboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsActionIdResponse, error)

	PostClaimsIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, body PostClaimsIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsActionIdResponse, error)

	// PostClaimsIdOutboundShippingMethodWithBodyWithResponse request with any body
	PostClaimsIdOutboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodResponse, error)

	PostClaimsIdOutboundShippingMethodWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, body PostClaimsIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodResponse, error)

	// DeleteClaimsIdOutboundShippingMethodActionIdWithResponse request
	DeleteClaimsIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*DeleteClaimsIdOutboundShippingMethodActionIdResponse, error)

	// PostClaimsIdOutboundShippingMethodActionIdWithBodyWithResponse request with any body
	PostClaimsIdOutboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodActionIdResponse, error)

	PostClaimsIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, body PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodActionIdResponse, error)

	// DeleteClaimsIdRequestWithResponse request
	DeleteClaimsIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClaimsIdRequestResponse, error)

	// PostClaimsIdRequestWithResponse request
	PostClaimsIdRequestWithResponse(ctx context.Context, id string, params *PostClaimsIdRequestParams, reqEditors ...RequestEditorFn) (*PostClaimsIdRequestResponse, error)

	// GetCollectionsWithResponse request
	GetCollectionsWithResponse(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*GetCollectionsResponse, error)

	// PostCollectionsWithBodyWithResponse request with any body
	PostCollectionsWithBodyWithResponse(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error)

	PostCollectionsWithResponse(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error)

	// DeleteCollectionsIdWithResponse request
	DeleteCollectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCollectionsIdResponse, error)

	// GetCollectionsIdWithResponse request
	GetCollectionsIdWithResponse(ctx context.Context, id string, params *GetCollectionsIdParams, reqEditors ...RequestEditorFn) (*GetCollectionsIdResponse, error)

	// PostCollectionsIdWithBodyWithResponse request with any body
	PostCollectionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostCollectionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsIdResponse, error)

	PostCollectionsIdWithResponse(ctx context.Context, id string, params *PostCollectionsIdParams, body PostCollectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsIdResponse, error)

	// PostCollectionsIdProductsWithBodyWithResponse request with any body
	PostCollectionsIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostCollectionsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsIdProductsResponse, error)

	PostCollectionsIdProductsWithResponse(ctx context.Context, id string, params *PostCollectionsIdProductsParams, body PostCollectionsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsIdProductsResponse, error)

	// GetCurrenciesWithResponse request
	GetCurrenciesWithResponse(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*GetCurrenciesResponse, error)

	// GetCurrenciesCodeWithResponse request
	GetCurrenciesCodeWithResponse(ctx context.Context, code string, params *GetCurrenciesCodeParams, reqEditors ...RequestEditorFn) (*GetCurrenciesCodeResponse, error)

	// GetCustomerGroupsWithResponse request
	GetCustomerGroupsWithResponse(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsResponse, error)

	// PostCustomerGroupsWithBodyWithResponse request with any body
	PostCustomerGroupsWithBodyWithResponse(ctx context.Context, params *PostCustomerGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error)

	PostCustomerGroupsWithResponse(ctx context.Context, params *PostCustomerGroupsParams, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error)

	// DeleteCustomerGroupsIdWithResponse request
	DeleteCustomerGroupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsIdResponse, error)

	// GetCustomerGroupsIdWithResponse request
	GetCustomerGroupsIdWithResponse(ctx context.Context, id string, params *GetCustomerGroupsIdParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsIdResponse, error)

	// PostCustomerGroupsIdWithBodyWithResponse request with any body
	PostCustomerGroupsIdWithBodyWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdResponse, error)

	PostCustomerGroupsIdWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdParams, body PostCustomerGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdResponse, error)

	// PostCustomerGroupsIdCustomersWithBodyWithResponse request with any body
	PostCustomerGroupsIdCustomersWithBodyWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdCustomersResponse, error)

	PostCustomerGroupsIdCustomersWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, body PostCustomerGroupsIdCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdCustomersResponse, error)

	// GetCustomersWithResponse request
	GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*GetCustomersResponse, error)

	// PostCustomersWithBodyWithResponse request with any body
	PostCustomersWithBodyWithResponse(ctx context.Context, params *PostCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error)

	PostCustomersWithResponse(ctx context.Context, params *PostCustomersParams, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error)

	// DeleteCustomersIdWithResponse request
	DeleteCustomersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCustomersIdResponse, error)

	// GetCustomersIdWithResponse request
	GetCustomersIdWithResponse(ctx context.Context, id string, params *GetCustomersIdParams, reqEditors ...RequestEditorFn) (*GetCustomersIdResponse, error)

	// PostCustomersIdWithBodyWithResponse request with any body
	PostCustomersIdWithBodyWithResponse(ctx context.Context, id string, params *PostCustomersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersIdResponse, error)

	PostCustomersIdWithResponse(ctx context.Context, id string, params *PostCustomersIdParams, body PostCustomersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersIdResponse, error)

	// GetCustomersIdAddressesWithResponse request
	GetCustomersIdAddressesWithResponse(ctx context.Context, id string, params *GetCustomersIdAddressesParams, reqEditors ...RequestEditorFn) (*GetCustomersIdAddressesResponse, error)

	// PostCustomersIdAddressesWithBodyWithResponse request with any body
	PostCustomersIdAddressesWithBodyWithResponse(ctx context.Context, id string, params *PostCustomersIdAddressesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesResponse, error)

	PostCustomersIdAddressesWithResponse(ctx context.Context, id string, params *PostCustomersIdAddressesParams, body PostCustomersIdAddressesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesResponse, error)

	// DeleteCustomersIdAddressesAddressIdWithResponse request
	DeleteCustomersIdAddressesAddressIdWithResponse(ctx context.Context, id string, addressId string, params *DeleteCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*DeleteCustomersIdAddressesAddressIdResponse, error)

	// GetCustomersIdAddressesAddressIdWithResponse request
	GetCustomersIdAddressesAddressIdWithResponse(ctx context.Context, id string, addressId string, params *GetCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*GetCustomersIdAddressesAddressIdResponse, error)

	// PostCustomersIdAddressesAddressIdWithBodyWithResponse request with any body
	PostCustomersIdAddressesAddressIdWithBodyWithResponse(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesAddressIdResponse, error)

	PostCustomersIdAddressesAddressIdWithResponse(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, body PostCustomersIdAddressesAddressIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesAddressIdResponse, error)

	// GetDraftOrdersWithResponse request
	GetDraftOrdersWithResponse(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*GetDraftOrdersResponse, error)

	// PostDraftOrdersWithBodyWithResponse request with any body
	PostDraftOrdersWithBodyWithResponse(ctx context.Context, params *PostDraftOrdersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error)

	PostDraftOrdersWithResponse(ctx context.Context, params *PostDraftOrdersParams, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error)

	// GetDraftOrdersIdWithResponse request
	GetDraftOrdersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDraftOrdersIdResponse, error)

	// GetExchangesWithResponse request
	GetExchangesWithResponse(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*GetExchangesResponse, error)

	// PostExchangesWithBodyWithResponse request with any body
	PostExchangesWithBodyWithResponse(ctx context.Context, params *PostExchangesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesResponse, error)

	PostExchangesWithResponse(ctx context.Context, params *PostExchangesParams, body PostExchangesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesResponse, error)

	// GetExchangesIdWithResponse request
	GetExchangesIdWithResponse(ctx context.Context, id string, params *GetExchangesIdParams, reqEditors ...RequestEditorFn) (*GetExchangesIdResponse, error)

	// PostExchangesIdCancelWithBodyWithResponse request with any body
	PostExchangesIdCancelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdCancelResponse, error)

	PostExchangesIdCancelWithResponse(ctx context.Context, id string, body PostExchangesIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdCancelResponse, error)

	// PostExchangesIdInboundItemsWithBodyWithResponse request with any body
	PostExchangesIdInboundItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsResponse, error)

	PostExchangesIdInboundItemsWithResponse(ctx context.Context, id string, body PostExchangesIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsResponse, error)

	// DeleteExchangesIdInboundItemsActionIdWithResponse request
	DeleteExchangesIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteExchangesIdInboundItemsActionIdResponse, error)

	// PostExchangesIdInboundItemsActionIdWithBodyWithResponse request with any body
	PostExchangesIdInboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsActionIdResponse, error)

	PostExchangesIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, body PostExchangesIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsActionIdResponse, error)

	// PostExchangesIdInboundShippingMethodWithBodyWithResponse request with any body
	PostExchangesIdInboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodResponse, error)

	PostExchangesIdInboundShippingMethodWithResponse(ctx context.Context, id string, body PostExchangesIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodResponse, error)

	// DeleteExchangesIdInboundShippingMethodActionIdWithResponse request
	DeleteExchangesIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteExchangesIdInboundShippingMethodActionIdResponse, error)

	// PostExchangesIdInboundShippingMethodActionIdWithBodyWithResponse request with any body
	PostExchangesIdInboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodActionIdResponse, error)

	PostExchangesIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, body PostExchangesIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodActionIdResponse, error)

	// PostExchangesIdOutboundItemsWithBodyWithResponse request with any body
	PostExchangesIdOutboundItemsWithBodyWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsResponse, error)

	PostExchangesIdOutboundItemsWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, body PostExchangesIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsResponse, error)

	// DeleteExchangesIdOutboundItemsActionIdWithResponse request
	DeleteExchangesIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteExchangesIdOutboundItemsActionIdResponse, error)

	// PostExchangesIdOutboundItemsActionIdWithBodyWithResponse request with any body
	PostExchangesIdOutboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsActionIdResponse, error)

	PostExchangesIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, body PostExchangesIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsActionIdResponse, error)

	// PostExchangesIdOutboundShippingMethodWithBodyWithResponse request with any body
	PostExchangesIdOutboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodResponse, error)

	PostExchangesIdOutboundShippingMethodWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, body PostExchangesIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodResponse, error)

	// DeleteExchangesIdOutboundShippingMethodActionIdWithResponse request
	DeleteExchangesIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*DeleteExchangesIdOutboundShippingMethodActionIdResponse, error)

	// PostExchangesIdOutboundShippingMethodActionIdWithBodyWithResponse request with any body
	PostExchangesIdOutboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodActionIdResponse, error)

	PostExchangesIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, body PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodActionIdResponse, error)

	// DeleteExchangesIdRequestWithResponse request
	DeleteExchangesIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteExchangesIdRequestResponse, error)

	// PostExchangesIdRequestWithResponse request
	PostExchangesIdRequestWithResponse(ctx context.Context, id string, params *PostExchangesIdRequestParams, reqEditors ...RequestEditorFn) (*PostExchangesIdRequestResponse, error)

	// GetFulfillmentProvidersWithResponse request
	GetFulfillmentProvidersWithResponse(ctx context.Context, params *GetFulfillmentProvidersParams, reqEditors ...RequestEditorFn) (*GetFulfillmentProvidersResponse, error)

	// DeleteFulfillmentSetsIdWithResponse request
	DeleteFulfillmentSetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteFulfillmentSetsIdResponse, error)

	// PostFulfillmentSetsIdServiceZonesWithBodyWithResponse request with any body
	PostFulfillmentSetsIdServiceZonesWithBodyWithResponse(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesResponse, error)

	PostFulfillmentSetsIdServiceZonesWithResponse(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, body PostFulfillmentSetsIdServiceZonesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesResponse, error)

	// DeleteFulfillmentSetsIdServiceZonesZoneIdWithResponse request
	DeleteFulfillmentSetsIdServiceZonesZoneIdWithResponse(ctx context.Context, id string, zoneId string, reqEditors ...RequestEditorFn) (*DeleteFulfillmentSetsIdServiceZonesZoneIdResponse, error)

	// GetFulfillmentSetsIdServiceZonesZoneIdWithResponse request
	GetFulfillmentSetsIdServiceZonesZoneIdWithResponse(ctx context.Context, id string, zoneId string, params *GetFulfillmentSetsIdServiceZonesZoneIdParams, reqEditors ...RequestEditorFn) (*GetFulfillmentSetsIdServiceZonesZoneIdResponse, error)

	// PostFulfillmentSetsIdServiceZonesZoneIdWithBodyWithResponse request with any body
	PostFulfillmentSetsIdServiceZonesZoneIdWithBodyWithResponse(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesZoneIdResponse, error)

	PostFulfillmentSetsIdServiceZonesZoneIdWithResponse(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, body PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesZoneIdResponse, error)

	// PostFulfillmentsWithBodyWithResponse request with any body
	PostFulfillmentsWithBodyWithResponse(ctx context.Context, params *PostFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentsResponse, error)

	PostFulfillmentsWithResponse(ctx context.Context, params *PostFulfillmentsParams, body PostFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentsResponse, error)

	// PostFulfillmentsIdCancelWithResponse request
	PostFulfillmentsIdCancelWithResponse(ctx context.Context, id string, params *PostFulfillmentsIdCancelParams, reqEditors ...RequestEditorFn) (*PostFulfillmentsIdCancelResponse, error)

	// PostFulfillmentsIdShipmentWithBodyWithResponse request with any body
	PostFulfillmentsIdShipmentWithBodyWithResponse(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentsIdShipmentResponse, error)

	PostFulfillmentsIdShipmentWithResponse(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, body PostFulfillmentsIdShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentsIdShipmentResponse, error)

	// GetInventoryItemsWithResponse request
	GetInventoryItemsWithResponse(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsResponse, error)

	// PostInventoryItemsWithBodyWithResponse request with any body
	PostInventoryItemsWithBodyWithResponse(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error)

	PostInventoryItemsWithResponse(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error)

	// DeleteInventoryItemsIdWithResponse request
	DeleteInventoryItemsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsIdResponse, error)

	// GetInventoryItemsIdWithResponse request
	GetInventoryItemsIdWithResponse(ctx context.Context, id string, params *GetInventoryItemsIdParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsIdResponse, error)

	// PostInventoryItemsIdWithBodyWithResponse request with any body
	PostInventoryItemsIdWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdResponse, error)

	PostInventoryItemsIdWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdParams, body PostInventoryItemsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdResponse, error)

	// GetInventoryItemsIdLocationLevelsWithResponse request
	GetInventoryItemsIdLocationLevelsWithResponse(ctx context.Context, id string, params *GetInventoryItemsIdLocationLevelsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsIdLocationLevelsResponse, error)

	// PostInventoryItemsIdLocationLevelsWithBodyWithResponse request with any body
	PostInventoryItemsIdLocationLevelsWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsResponse, error)

	PostInventoryItemsIdLocationLevelsWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, body PostInventoryItemsIdLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsResponse, error)

	// PostInventoryItemsIdLocationLevelsBatchWithBodyWithResponse request with any body
	PostInventoryItemsIdLocationLevelsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsBatchResponse, error)

	PostInventoryItemsIdLocationLevelsBatchWithResponse(ctx context.Context, id string, body PostInventoryItemsIdLocationLevelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsBatchResponse, error)

	// DeleteInventoryItemsIdLocationLevelsLocationIdWithResponse request
	DeleteInventoryItemsIdLocationLevelsLocationIdWithResponse(ctx context.Context, id string, locationId string, params *DeleteInventoryItemsIdLocationLevelsLocationIdParams, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsIdLocationLevelsLocationIdResponse, error)

	// PostInventoryItemsIdLocationLevelsLocationIdWithBodyWithResponse request with any body
	PostInventoryItemsIdLocationLevelsLocationIdWithBodyWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsLocationIdResponse, error)

	PostInventoryItemsIdLocationLevelsLocationIdWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, body PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsLocationIdResponse, error)

	// GetInvitesWithResponse request
	GetInvitesWithResponse(ctx context.Context, params *GetInvitesParams, reqEditors ...RequestEditorFn) (*GetInvitesResponse, error)

	// PostInvitesWithBodyWithResponse request with any body
	PostInvitesWithBodyWithResponse(ctx context.Context, params *PostInvitesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error)

	PostInvitesWithResponse(ctx context.Context, params *PostInvitesParams, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error)

	// PostInvitesAcceptWithBodyWithResponse request with any body
	PostInvitesAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesAcceptResponse, error)

	PostInvitesAcceptWithResponse(ctx context.Context, body PostInvitesAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesAcceptResponse, error)

	// DeleteInvitesIdWithResponse request
	DeleteInvitesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInvitesIdResponse, error)

	// GetInvitesIdWithResponse request
	GetInvitesIdWithResponse(ctx context.Context, id string, params *GetInvitesIdParams, reqEditors ...RequestEditorFn) (*GetInvitesIdResponse, error)

	// PostInvitesIdResendWithResponse request
	PostInvitesIdResendWithResponse(ctx context.Context, id string, params *PostInvitesIdResendParams, reqEditors ...RequestEditorFn) (*PostInvitesIdResendResponse, error)

	// GetNotificationsWithResponse request
	GetNotificationsWithResponse(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error)

	// GetNotificationsIdWithResponse request
	GetNotificationsIdWithResponse(ctx context.Context, id string, params *GetNotificationsIdParams, reqEditors ...RequestEditorFn) (*GetNotificationsIdResponse, error)

	// PostOrderEditsWithBodyWithResponse request with any body
	PostOrderEditsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error)

	PostOrderEditsWithResponse(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error)

	// DeleteOrderEditsIdWithResponse request
	DeleteOrderEditsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsIdResponse, error)

	// PostOrderEditsIdConfirmWithResponse request
	PostOrderEditsIdConfirmWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsIdConfirmResponse, error)

	// PostOrderEditsIdItemsWithBodyWithResponse request with any body
	PostOrderEditsIdItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsResponse, error)

	PostOrderEditsIdItemsWithResponse(ctx context.Context, id string, body PostOrderEditsIdItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsResponse, error)

	// PostOrderEditsIdItemsItemItemIdWithBodyWithResponse request with any body
	PostOrderEditsIdItemsItemItemIdWithBodyWithResponse(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsItemItemIdResponse, error)

	PostOrderEditsIdItemsItemItemIdWithResponse(ctx context.Context, id string, itemId string, body PostOrderEditsIdItemsItemItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsItemItemIdResponse, error)

	// DeleteOrderEditsIdItemsActionIdWithResponse request
	DeleteOrderEditsIdItemsActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsIdItemsActionIdResponse, error)

	// PostOrderEditsIdItemsActionIdWithBodyWithResponse request with any body
	PostOrderEditsIdItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsActionIdResponse, error)

	PostOrderEditsIdItemsActionIdWithResponse(ctx context.Context, id string, actionId string, body PostOrderEditsIdItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsActionIdResponse, error)

	// PostOrderEditsIdRequestWithResponse request
	PostOrderEditsIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsIdRequestResponse, error)

	// PostOrderEditsIdShippingMethodWithBodyWithResponse request with any body
	PostOrderEditsIdShippingMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodResponse, error)

	PostOrderEditsIdShippingMethodWithResponse(ctx context.Context, id string, body PostOrderEditsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodResponse, error)

	// DeleteOrderEditsIdShippingMethodActionIdWithResponse request
	DeleteOrderEditsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsIdShippingMethodActionIdResponse, error)

	// PostOrderEditsIdShippingMethodActionIdWithBodyWithResponse request with any body
	PostOrderEditsIdShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodActionIdResponse, error)

	PostOrderEditsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, body PostOrderEditsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodActionIdResponse, error)

	// GetOrdersWithResponse request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error)

	// GetOrdersIdWithResponse request
	GetOrdersIdWithResponse(ctx context.Context, id string, params *GetOrdersIdParams, reqEditors ...RequestEditorFn) (*GetOrdersIdResponse, error)

	// PostOrdersIdWithResponse request
	PostOrdersIdWithResponse(ctx context.Context, id string, params *PostOrdersIdParams, reqEditors ...RequestEditorFn) (*PostOrdersIdResponse, error)

	// PostOrdersIdArchiveWithResponse request
	PostOrdersIdArchiveWithResponse(ctx context.Context, id string, params *PostOrdersIdArchiveParams, reqEditors ...RequestEditorFn) (*PostOrdersIdArchiveResponse, error)

	// PostOrdersIdCancelWithResponse request
	PostOrdersIdCancelWithResponse(ctx context.Context, id string, params *PostOrdersIdCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersIdCancelResponse, error)

	// GetOrdersIdChangesWithResponse request
	GetOrdersIdChangesWithResponse(ctx context.Context, id string, params *GetOrdersIdChangesParams, reqEditors ...RequestEditorFn) (*GetOrdersIdChangesResponse, error)

	// PostOrdersIdCompleteWithBodyWithResponse request with any body
	PostOrdersIdCompleteWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersIdCompleteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdCompleteResponse, error)

	PostOrdersIdCompleteWithResponse(ctx context.Context, id string, params *PostOrdersIdCompleteParams, body PostOrdersIdCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdCompleteResponse, error)

	// PostOrdersIdFulfillmentsWithBodyWithResponse request with any body
	PostOrdersIdFulfillmentsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsResponse, error)

	PostOrdersIdFulfillmentsWithResponse(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, body PostOrdersIdFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsResponse, error)

	// PostOrdersIdFulfillmentsFulfillmentIdCancelWithBodyWithResponse request with any body
	PostOrdersIdFulfillmentsFulfillmentIdCancelWithBodyWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdCancelResponse, error)

	PostOrdersIdFulfillmentsFulfillmentIdCancelWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, body PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdCancelResponse, error)

	// PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredWithResponse request
	PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse, error)

	// PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBodyWithResponse request with any body
	PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBodyWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse, error)

	PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, body PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse, error)

	// GetOrdersIdPreviewWithResponse request
	GetOrdersIdPreviewWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetOrdersIdPreviewResponse, error)

	// PostPaymentCollectionsWithBodyWithResponse request with any body
	PostPaymentCollectionsWithBodyWithResponse(ctx context.Context, params *PostPaymentCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsResponse, error)

	PostPaymentCollectionsWithResponse(ctx context.Context, params *PostPaymentCollectionsParams, body PostPaymentCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsResponse, error)

	// DeletePaymentCollectionsIdWithResponse request
	DeletePaymentCollectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePaymentCollectionsIdResponse, error)

	// PostPaymentCollectionsIdMarkAsPaidWithBodyWithResponse request with any body
	PostPaymentCollectionsIdMarkAsPaidWithBodyWithResponse(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsIdMarkAsPaidResponse, error)

	PostPaymentCollectionsIdMarkAsPaidWithResponse(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, body PostPaymentCollectionsIdMarkAsPaidJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsIdMarkAsPaidResponse, error)

	// GetPaymentsWithResponse request
	GetPaymentsWithResponse(ctx context.Context, params *GetPaymentsParams, reqEditors ...RequestEditorFn) (*GetPaymentsResponse, error)

	// GetPaymentsPaymentProvidersWithResponse request
	GetPaymentsPaymentProvidersWithResponse(ctx context.Context, params *GetPaymentsPaymentProvidersParams, reqEditors ...RequestEditorFn) (*GetPaymentsPaymentProvidersResponse, error)

	// GetPaymentsIdWithResponse request
	GetPaymentsIdWithResponse(ctx context.Context, id string, params *GetPaymentsIdParams, reqEditors ...RequestEditorFn) (*GetPaymentsIdResponse, error)

	// PostPaymentsIdCaptureWithBodyWithResponse request with any body
	PostPaymentsIdCaptureWithBodyWithResponse(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentsIdCaptureResponse, error)

	PostPaymentsIdCaptureWithResponse(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, body PostPaymentsIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentsIdCaptureResponse, error)

	// PostPaymentsIdRefundWithBodyWithResponse request with any body
	PostPaymentsIdRefundWithBodyWithResponse(ctx context.Context, id string, params *PostPaymentsIdRefundParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentsIdRefundResponse, error)

	PostPaymentsIdRefundWithResponse(ctx context.Context, id string, params *PostPaymentsIdRefundParams, body PostPaymentsIdRefundJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentsIdRefundResponse, error)

	// GetPriceListsWithResponse request
	GetPriceListsWithResponse(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*GetPriceListsResponse, error)

	// PostPriceListsWithBodyWithResponse request with any body
	PostPriceListsWithBodyWithResponse(ctx context.Context, params *PostPriceListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsResponse, error)

	PostPriceListsWithResponse(ctx context.Context, params *PostPriceListsParams, body PostPriceListsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsResponse, error)

	// DeletePriceListsIdWithResponse request
	DeletePriceListsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePriceListsIdResponse, error)

	// GetPriceListsIdWithResponse request
	GetPriceListsIdWithResponse(ctx context.Context, id string, params *GetPriceListsIdParams, reqEditors ...RequestEditorFn) (*GetPriceListsIdResponse, error)

	// PostPriceListsIdWithBodyWithResponse request with any body
	PostPriceListsIdWithBodyWithResponse(ctx context.Context, id string, params *PostPriceListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsIdResponse, error)

	PostPriceListsIdWithResponse(ctx context.Context, id string, params *PostPriceListsIdParams, body PostPriceListsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsIdResponse, error)

	// PostPriceListsIdPricesBatchWithBodyWithResponse request with any body
	PostPriceListsIdPricesBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsIdPricesBatchResponse, error)

	PostPriceListsIdPricesBatchWithResponse(ctx context.Context, id string, body PostPriceListsIdPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsIdPricesBatchResponse, error)

	// PostPriceListsIdProductsWithBodyWithResponse request with any body
	PostPriceListsIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostPriceListsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsIdProductsResponse, error)

	PostPriceListsIdProductsWithResponse(ctx context.Context, id string, params *PostPriceListsIdProductsParams, body PostPriceListsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsIdProductsResponse, error)

	// GetPricePreferencesWithResponse request
	GetPricePreferencesWithResponse(ctx context.Context, params *GetPricePreferencesParams, reqEditors ...RequestEditorFn) (*GetPricePreferencesResponse, error)

	// PostPricePreferencesWithBodyWithResponse request with any body
	PostPricePreferencesWithBodyWithResponse(ctx context.Context, params *PostPricePreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPricePreferencesResponse, error)

	PostPricePreferencesWithResponse(ctx context.Context, params *PostPricePreferencesParams, body PostPricePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPricePreferencesResponse, error)

	// DeletePricePreferencesIdWithResponse request
	DeletePricePreferencesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePricePreferencesIdResponse, error)

	// GetPricePreferencesIdWithResponse request
	GetPricePreferencesIdWithResponse(ctx context.Context, id string, params *GetPricePreferencesIdParams, reqEditors ...RequestEditorFn) (*GetPricePreferencesIdResponse, error)

	// PostPricePreferencesIdWithBodyWithResponse request with any body
	PostPricePreferencesIdWithBodyWithResponse(ctx context.Context, id string, params *PostPricePreferencesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPricePreferencesIdResponse, error)

	PostPricePreferencesIdWithResponse(ctx context.Context, id string, params *PostPricePreferencesIdParams, body PostPricePreferencesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPricePreferencesIdResponse, error)

	// GetProductCategoriesWithResponse request
	GetProductCategoriesWithResponse(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesResponse, error)

	// PostProductCategoriesWithBodyWithResponse request with any body
	PostProductCategoriesWithBodyWithResponse(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error)

	PostProductCategoriesWithResponse(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error)

	// DeleteProductCategoriesIdWithResponse request
	DeleteProductCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesIdResponse, error)

	// GetProductCategoriesIdWithResponse request
	GetProductCategoriesIdWithResponse(ctx context.Context, id string, params *GetProductCategoriesIdParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesIdResponse, error)

	// PostProductCategoriesIdWithBodyWithResponse request with any body
	PostProductCategoriesIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdResponse, error)

	PostProductCategoriesIdWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdParams, body PostProductCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdResponse, error)

	// PostProductCategoriesIdProductsWithBodyWithResponse request with any body
	PostProductCategoriesIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdProductsResponse, error)

	PostProductCategoriesIdProductsWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, body PostProductCategoriesIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdProductsResponse, error)

	// GetProductTagsWithResponse request
	GetProductTagsWithResponse(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*GetProductTagsResponse, error)

	// PostProductTagsWithBodyWithResponse request with any body
	PostProductTagsWithBodyWithResponse(ctx context.Context, params *PostProductTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTagsResponse, error)

	PostProductTagsWithResponse(ctx context.Context, params *PostProductTagsParams, body PostProductTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTagsResponse, error)

	// DeleteProductTagsIdWithResponse request
	DeleteProductTagsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductTagsIdResponse, error)

	// GetProductTagsIdWithResponse request
	GetProductTagsIdWithResponse(ctx context.Context, id string, params *GetProductTagsIdParams, reqEditors ...RequestEditorFn) (*GetProductTagsIdResponse, error)

	// PostProductTagsIdWithBodyWithResponse request with any body
	PostProductTagsIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductTagsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTagsIdResponse, error)

	PostProductTagsIdWithResponse(ctx context.Context, id string, params *PostProductTagsIdParams, body PostProductTagsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTagsIdResponse, error)

	// GetProductTypesWithResponse request
	GetProductTypesWithResponse(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*GetProductTypesResponse, error)

	// PostProductTypesWithBodyWithResponse request with any body
	PostProductTypesWithBodyWithResponse(ctx context.Context, params *PostProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTypesResponse, error)

	PostProductTypesWithResponse(ctx context.Context, params *PostProductTypesParams, body PostProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTypesResponse, error)

	// DeleteProductTypesIdWithResponse request
	DeleteProductTypesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductTypesIdResponse, error)

	// GetProductTypesIdWithResponse request
	GetProductTypesIdWithResponse(ctx context.Context, id string, params *GetProductTypesIdParams, reqEditors ...RequestEditorFn) (*GetProductTypesIdResponse, error)

	// PostProductTypesIdWithBodyWithResponse request with any body
	PostProductTypesIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductTypesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTypesIdResponse, error)

	PostProductTypesIdWithResponse(ctx context.Context, id string, params *PostProductTypesIdParams, body PostProductTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTypesIdResponse, error)

	// GetProductVariantsWithResponse request
	GetProductVariantsWithResponse(ctx context.Context, params *GetProductVariantsParams, reqEditors ...RequestEditorFn) (*GetProductVariantsResponse, error)

	// GetProductsWithResponse request
	GetProductsWithResponse(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*GetProductsResponse, error)

	// PostProductsWithBodyWithResponse request with any body
	PostProductsWithBodyWithResponse(ctx context.Context, params *PostProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsResponse, error)

	PostProductsWithResponse(ctx context.Context, params *PostProductsParams, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsResponse, error)

	// PostProductsBatchWithBodyWithResponse request with any body
	PostProductsBatchWithBodyWithResponse(ctx context.Context, params *PostProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsBatchResponse, error)

	PostProductsBatchWithResponse(ctx context.Context, params *PostProductsBatchParams, body PostProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsBatchResponse, error)

	// PostProductsExportWithResponse request
	PostProductsExportWithResponse(ctx context.Context, params *PostProductsExportParams, reqEditors ...RequestEditorFn) (*PostProductsExportResponse, error)

	// PostProductsImportWithBodyWithResponse request with any body
	PostProductsImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsImportResponse, error)

	PostProductsImportWithResponse(ctx context.Context, body PostProductsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsImportResponse, error)

	// PostProductsImportTransactionIdConfirmWithResponse request
	PostProductsImportTransactionIdConfirmWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*PostProductsImportTransactionIdConfirmResponse, error)

	// DeleteProductsIdWithResponse request
	DeleteProductsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductsIdResponse, error)

	// GetProductsIdWithResponse request
	GetProductsIdWithResponse(ctx context.Context, id string, params *GetProductsIdParams, reqEditors ...RequestEditorFn) (*GetProductsIdResponse, error)

	// PostProductsIdWithBodyWithResponse request with any body
	PostProductsIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdResponse, error)

	PostProductsIdWithResponse(ctx context.Context, id string, params *PostProductsIdParams, body PostProductsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdResponse, error)

	// GetProductsIdOptionsWithResponse request
	GetProductsIdOptionsWithResponse(ctx context.Context, id string, params *GetProductsIdOptionsParams, reqEditors ...RequestEditorFn) (*GetProductsIdOptionsResponse, error)

	// PostProductsIdOptionsWithBodyWithResponse request with any body
	PostProductsIdOptionsWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsResponse, error)

	PostProductsIdOptionsWithResponse(ctx context.Context, id string, params *PostProductsIdOptionsParams, body PostProductsIdOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsResponse, error)

	// DeleteProductsIdOptionsOptionIdWithResponse request
	DeleteProductsIdOptionsOptionIdWithResponse(ctx context.Context, id string, optionId string, params *DeleteProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*DeleteProductsIdOptionsOptionIdResponse, error)

	// GetProductsIdOptionsOptionIdWithResponse request
	GetProductsIdOptionsOptionIdWithResponse(ctx context.Context, id string, optionId string, params *GetProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*GetProductsIdOptionsOptionIdResponse, error)

	// PostProductsIdOptionsOptionIdWithBodyWithResponse request with any body
	PostProductsIdOptionsOptionIdWithBodyWithResponse(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsOptionIdResponse, error)

	PostProductsIdOptionsOptionIdWithResponse(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, body PostProductsIdOptionsOptionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsOptionIdResponse, error)

	// GetProductsIdVariantsWithResponse request
	GetProductsIdVariantsWithResponse(ctx context.Context, id string, params *GetProductsIdVariantsParams, reqEditors ...RequestEditorFn) (*GetProductsIdVariantsResponse, error)

	// PostProductsIdVariantsWithBodyWithResponse request with any body
	PostProductsIdVariantsWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsResponse, error)

	PostProductsIdVariantsWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsParams, body PostProductsIdVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsResponse, error)

	// PostProductsIdVariantsBatchWithBodyWithResponse request with any body
	PostProductsIdVariantsBatchWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsBatchResponse, error)

	PostProductsIdVariantsBatchWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, body PostProductsIdVariantsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsBatchResponse, error)

	// PostProductsIdVariantsInventoryItemsBatchWithBodyWithResponse request with any body
	PostProductsIdVariantsInventoryItemsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsInventoryItemsBatchResponse, error)

	PostProductsIdVariantsInventoryItemsBatchWithResponse(ctx context.Context, id string, body PostProductsIdVariantsInventoryItemsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsInventoryItemsBatchResponse, error)

	// DeleteProductsIdVariantsVariantIdWithResponse request
	DeleteProductsIdVariantsVariantIdWithResponse(ctx context.Context, id string, variantId string, params *DeleteProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*DeleteProductsIdVariantsVariantIdResponse, error)

	// GetProductsIdVariantsVariantIdWithResponse request
	GetProductsIdVariantsVariantIdWithResponse(ctx context.Context, id string, variantId string, params *GetProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*GetProductsIdVariantsVariantIdResponse, error)

	// PostProductsIdVariantsVariantIdWithBodyWithResponse request with any body
	PostProductsIdVariantsVariantIdWithBodyWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdResponse, error)

	PostProductsIdVariantsVariantIdWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, body PostProductsIdVariantsVariantIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdResponse, error)

	// PostProductsIdVariantsVariantIdInventoryItemsWithBodyWithResponse request with any body
	PostProductsIdVariantsVariantIdInventoryItemsWithBodyWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsResponse, error)

	PostProductsIdVariantsVariantIdInventoryItemsWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, body PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsResponse, error)

	// DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse request
	DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse(ctx context.Context, id string, variantId string, inventoryItemId string, params *DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, reqEditors ...RequestEditorFn) (*DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error)

	// PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBodyWithResponse request with any body
	PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBodyWithResponse(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error)

	PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, body PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error)

	// GetPromotionsWithResponse request
	GetPromotionsWithResponse(ctx context.Context, params *GetPromotionsParams, reqEditors ...RequestEditorFn) (*GetPromotionsResponse, error)

	// PostPromotionsWithBodyWithResponse request with any body
	PostPromotionsWithBodyWithResponse(ctx context.Context, params *PostPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsResponse, error)

	PostPromotionsWithResponse(ctx context.Context, params *PostPromotionsParams, body PostPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsResponse, error)

	// GetPromotionsRuleAttributeOptionsRuleTypeWithResponse request
	GetPromotionsRuleAttributeOptionsRuleTypeWithResponse(ctx context.Context, ruleType GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType, params *GetPromotionsRuleAttributeOptionsRuleTypeParams, reqEditors ...RequestEditorFn) (*GetPromotionsRuleAttributeOptionsRuleTypeResponse, error)

	// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdWithResponse request
	GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdWithResponse(ctx context.Context, ruleType GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType, ruleAttributeId string, params *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams, reqEditors ...RequestEditorFn) (*GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse, error)

	// DeletePromotionsIdWithResponse request
	DeletePromotionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePromotionsIdResponse, error)

	// GetPromotionsIdWithResponse request
	GetPromotionsIdWithResponse(ctx context.Context, id string, params *GetPromotionsIdParams, reqEditors ...RequestEditorFn) (*GetPromotionsIdResponse, error)

	// PostPromotionsIdWithBodyWithResponse request with any body
	PostPromotionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdResponse, error)

	PostPromotionsIdWithResponse(ctx context.Context, id string, params *PostPromotionsIdParams, body PostPromotionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdResponse, error)

	// PostPromotionsIdBuyRulesBatchWithBodyWithResponse request with any body
	PostPromotionsIdBuyRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdBuyRulesBatchResponse, error)

	PostPromotionsIdBuyRulesBatchWithResponse(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, body PostPromotionsIdBuyRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdBuyRulesBatchResponse, error)

	// PostPromotionsIdRulesBatchWithBodyWithResponse request with any body
	PostPromotionsIdRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdRulesBatchResponse, error)

	PostPromotionsIdRulesBatchWithResponse(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, body PostPromotionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdRulesBatchResponse, error)

	// PostPromotionsIdTargetRulesBatchWithBodyWithResponse request with any body
	PostPromotionsIdTargetRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdTargetRulesBatchResponse, error)

	PostPromotionsIdTargetRulesBatchWithResponse(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, body PostPromotionsIdTargetRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdTargetRulesBatchResponse, error)

	// GetPromotionsIdRuleTypeWithResponse request
	GetPromotionsIdRuleTypeWithResponse(ctx context.Context, id string, ruleType GetPromotionsIdRuleTypeParamsRuleType, params *GetPromotionsIdRuleTypeParams, reqEditors ...RequestEditorFn) (*GetPromotionsIdRuleTypeResponse, error)

	// GetRefundReasonsWithResponse request
	GetRefundReasonsWithResponse(ctx context.Context, params *GetRefundReasonsParams, reqEditors ...RequestEditorFn) (*GetRefundReasonsResponse, error)

	// PostRefundReasonsWithBodyWithResponse request with any body
	PostRefundReasonsWithBodyWithResponse(ctx context.Context, params *PostRefundReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRefundReasonsResponse, error)

	PostRefundReasonsWithResponse(ctx context.Context, params *PostRefundReasonsParams, body PostRefundReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRefundReasonsResponse, error)

	// DeleteRefundReasonsIdWithResponse request
	DeleteRefundReasonsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRefundReasonsIdResponse, error)

	// GetRefundReasonsIdWithResponse request
	GetRefundReasonsIdWithResponse(ctx context.Context, id string, params *GetRefundReasonsIdParams, reqEditors ...RequestEditorFn) (*GetRefundReasonsIdResponse, error)

	// PostRefundReasonsIdWithBodyWithResponse request with any body
	PostRefundReasonsIdWithBodyWithResponse(ctx context.Context, id string, params *PostRefundReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRefundReasonsIdResponse, error)

	PostRefundReasonsIdWithResponse(ctx context.Context, id string, params *PostRefundReasonsIdParams, body PostRefundReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRefundReasonsIdResponse, error)

	// GetRegionsWithResponse request
	GetRegionsWithResponse(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*GetRegionsResponse, error)

	// PostRegionsWithBodyWithResponse request with any body
	PostRegionsWithBodyWithResponse(ctx context.Context, params *PostRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error)

	PostRegionsWithResponse(ctx context.Context, params *PostRegionsParams, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error)

	// DeleteRegionsIdWithResponse request
	DeleteRegionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRegionsIdResponse, error)

	// GetRegionsIdWithResponse request
	GetRegionsIdWithResponse(ctx context.Context, id string, params *GetRegionsIdParams, reqEditors ...RequestEditorFn) (*GetRegionsIdResponse, error)

	// PostRegionsIdWithBodyWithResponse request with any body
	PostRegionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostRegionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsIdResponse, error)

	PostRegionsIdWithResponse(ctx context.Context, id string, params *PostRegionsIdParams, body PostRegionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsIdResponse, error)

	// GetReservationsWithResponse request
	GetReservationsWithResponse(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*GetReservationsResponse, error)

	// PostReservationsWithBodyWithResponse request with any body
	PostReservationsWithBodyWithResponse(ctx context.Context, params *PostReservationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error)

	PostReservationsWithResponse(ctx context.Context, params *PostReservationsParams, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error)

	// DeleteReservationsIdWithResponse request
	DeleteReservationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReservationsIdResponse, error)

	// GetReservationsIdWithResponse request
	GetReservationsIdWithResponse(ctx context.Context, id string, params *GetReservationsIdParams, reqEditors ...RequestEditorFn) (*GetReservationsIdResponse, error)

	// PostReservationsIdWithBodyWithResponse request with any body
	PostReservationsIdWithBodyWithResponse(ctx context.Context, id string, params *PostReservationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsIdResponse, error)

	PostReservationsIdWithResponse(ctx context.Context, id string, params *PostReservationsIdParams, body PostReservationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsIdResponse, error)

	// GetReturnReasonsWithResponse request
	GetReturnReasonsWithResponse(ctx context.Context, params *GetReturnReasonsParams, reqEditors ...RequestEditorFn) (*GetReturnReasonsResponse, error)

	// PostReturnReasonsWithBodyWithResponse request with any body
	PostReturnReasonsWithBodyWithResponse(ctx context.Context, params *PostReturnReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error)

	PostReturnReasonsWithResponse(ctx context.Context, params *PostReturnReasonsParams, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error)

	// DeleteReturnReasonsIdWithResponse request
	DeleteReturnReasonsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnReasonsIdResponse, error)

	// GetReturnReasonsIdWithResponse request
	GetReturnReasonsIdWithResponse(ctx context.Context, id string, params *GetReturnReasonsIdParams, reqEditors ...RequestEditorFn) (*GetReturnReasonsIdResponse, error)

	// PostReturnReasonsIdWithBodyWithResponse request with any body
	PostReturnReasonsIdWithBodyWithResponse(ctx context.Context, id string, params *PostReturnReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsIdResponse, error)

	PostReturnReasonsIdWithResponse(ctx context.Context, id string, params *PostReturnReasonsIdParams, body PostReturnReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsIdResponse, error)

	// GetReturnsWithResponse request
	GetReturnsWithResponse(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*GetReturnsResponse, error)

	// PostReturnsWithBodyWithResponse request with any body
	PostReturnsWithBodyWithResponse(ctx context.Context, params *PostReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsResponse, error)

	PostReturnsWithResponse(ctx context.Context, params *PostReturnsParams, body PostReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsResponse, error)

	// GetReturnsIdWithResponse request
	GetReturnsIdWithResponse(ctx context.Context, id string, params *GetReturnsIdParams, reqEditors ...RequestEditorFn) (*GetReturnsIdResponse, error)

	// PostReturnsIdWithBodyWithResponse request with any body
	PostReturnsIdWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdResponse, error)

	PostReturnsIdWithResponse(ctx context.Context, id string, params *PostReturnsIdParams, body PostReturnsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdResponse, error)

	// PostReturnsIdCancelWithBodyWithResponse request with any body
	PostReturnsIdCancelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdCancelResponse, error)

	PostReturnsIdCancelWithResponse(ctx context.Context, id string, body PostReturnsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdCancelResponse, error)

	// PostReturnsIdDismissItemsWithBodyWithResponse request with any body
	PostReturnsIdDismissItemsWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsResponse, error)

	PostReturnsIdDismissItemsWithResponse(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, body PostReturnsIdDismissItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsResponse, error)

	// DeleteReturnsIdDismissItemsActionIdWithResponse request
	DeleteReturnsIdDismissItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdDismissItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdDismissItemsActionIdResponse, error)

	// PostReturnsIdDismissItemsActionIdWithBodyWithResponse request with any body
	PostReturnsIdDismissItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsActionIdResponse, error)

	PostReturnsIdDismissItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, body PostReturnsIdDismissItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsActionIdResponse, error)

	// DeleteReturnsIdReceiveWithResponse request
	DeleteReturnsIdReceiveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnsIdReceiveResponse, error)

	// PostReturnsIdReceiveWithBodyWithResponse request with any body
	PostReturnsIdReceiveWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveResponse, error)

	PostReturnsIdReceiveWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveParams, body PostReturnsIdReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveResponse, error)

	// PostReturnsIdReceiveItemsWithBodyWithResponse request with any body
	PostReturnsIdReceiveItemsWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsResponse, error)

	PostReturnsIdReceiveItemsWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, body PostReturnsIdReceiveItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsResponse, error)

	// DeleteReturnsIdReceiveItemsActionIdWithResponse request
	DeleteReturnsIdReceiveItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdReceiveItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdReceiveItemsActionIdResponse, error)

	// PostReturnsIdReceiveItemsActionIdWithBodyWithResponse request with any body
	PostReturnsIdReceiveItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsActionIdResponse, error)

	PostReturnsIdReceiveItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, body PostReturnsIdReceiveItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsActionIdResponse, error)

	// PostReturnsIdReceiveConfirmWithBodyWithResponse request with any body
	PostReturnsIdReceiveConfirmWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveConfirmResponse, error)

	PostReturnsIdReceiveConfirmWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, body PostReturnsIdReceiveConfirmJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveConfirmResponse, error)

	// DeleteReturnsIdRequestWithResponse request
	DeleteReturnsIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnsIdRequestResponse, error)

	// PostReturnsIdRequestWithBodyWithResponse request with any body
	PostReturnsIdRequestWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestResponse, error)

	PostReturnsIdRequestWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestParams, body PostReturnsIdRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestResponse, error)

	// PostReturnsIdRequestItemsWithBodyWithResponse request with any body
	PostReturnsIdRequestItemsWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsResponse, error)

	PostReturnsIdRequestItemsWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, body PostReturnsIdRequestItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsResponse, error)

	// DeleteReturnsIdRequestItemsActionIdWithResponse request
	DeleteReturnsIdRequestItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdRequestItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdRequestItemsActionIdResponse, error)

	// PostReturnsIdRequestItemsActionIdWithBodyWithResponse request with any body
	PostReturnsIdRequestItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsActionIdResponse, error)

	PostReturnsIdRequestItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, body PostReturnsIdRequestItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsActionIdResponse, error)

	// PostReturnsIdShippingMethodWithBodyWithResponse request with any body
	PostReturnsIdShippingMethodWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodResponse, error)

	PostReturnsIdShippingMethodWithResponse(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, body PostReturnsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodResponse, error)

	// DeleteReturnsIdShippingMethodActionIdWithResponse request
	DeleteReturnsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdShippingMethodActionIdResponse, error)

	// PostReturnsIdShippingMethodActionIdWithBodyWithResponse request with any body
	PostReturnsIdShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodActionIdResponse, error)

	PostReturnsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, body PostReturnsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodActionIdResponse, error)

	// GetSalesChannelsWithResponse request
	GetSalesChannelsWithResponse(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*GetSalesChannelsResponse, error)

	// PostSalesChannelsWithBodyWithResponse request with any body
	PostSalesChannelsWithBodyWithResponse(ctx context.Context, params *PostSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error)

	PostSalesChannelsWithResponse(ctx context.Context, params *PostSalesChannelsParams, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error)

	// DeleteSalesChannelsIdWithResponse request
	DeleteSalesChannelsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsIdResponse, error)

	// GetSalesChannelsIdWithResponse request
	GetSalesChannelsIdWithResponse(ctx context.Context, id string, params *GetSalesChannelsIdParams, reqEditors ...RequestEditorFn) (*GetSalesChannelsIdResponse, error)

	// PostSalesChannelsIdWithBodyWithResponse request with any body
	PostSalesChannelsIdWithBodyWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdResponse, error)

	PostSalesChannelsIdWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdParams, body PostSalesChannelsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdResponse, error)

	// PostSalesChannelsIdProductsWithBodyWithResponse request with any body
	PostSalesChannelsIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdProductsResponse, error)

	PostSalesChannelsIdProductsWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, body PostSalesChannelsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdProductsResponse, error)

	// GetShippingOptionsWithResponse request
	GetShippingOptionsWithResponse(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*GetShippingOptionsResponse, error)

	// PostShippingOptionsWithBodyWithResponse request with any body
	PostShippingOptionsWithBodyWithResponse(ctx context.Context, params *PostShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error)

	PostShippingOptionsWithResponse(ctx context.Context, params *PostShippingOptionsParams, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error)

	// DeleteShippingOptionsIdWithResponse request
	DeleteShippingOptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingOptionsIdResponse, error)

	// GetShippingOptionsIdWithResponse request
	GetShippingOptionsIdWithResponse(ctx context.Context, id string, params *GetShippingOptionsIdParams, reqEditors ...RequestEditorFn) (*GetShippingOptionsIdResponse, error)

	// PostShippingOptionsIdWithBodyWithResponse request with any body
	PostShippingOptionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdResponse, error)

	PostShippingOptionsIdWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdParams, body PostShippingOptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdResponse, error)

	// PostShippingOptionsIdRulesBatchWithBodyWithResponse request with any body
	PostShippingOptionsIdRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdRulesBatchResponse, error)

	PostShippingOptionsIdRulesBatchWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, body PostShippingOptionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdRulesBatchResponse, error)

	// GetShippingProfilesWithResponse request
	GetShippingProfilesWithResponse(ctx context.Context, params *GetShippingProfilesParams, reqEditors ...RequestEditorFn) (*GetShippingProfilesResponse, error)

	// PostShippingProfilesWithBodyWithResponse request with any body
	PostShippingProfilesWithBodyWithResponse(ctx context.Context, params *PostShippingProfilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error)

	PostShippingProfilesWithResponse(ctx context.Context, params *PostShippingProfilesParams, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error)

	// DeleteShippingProfilesIdWithResponse request
	DeleteShippingProfilesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingProfilesIdResponse, error)

	// GetShippingProfilesIdWithResponse request
	GetShippingProfilesIdWithResponse(ctx context.Context, id string, params *GetShippingProfilesIdParams, reqEditors ...RequestEditorFn) (*GetShippingProfilesIdResponse, error)

	// PostShippingProfilesIdWithBodyWithResponse request with any body
	PostShippingProfilesIdWithBodyWithResponse(ctx context.Context, id string, params *PostShippingProfilesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesIdResponse, error)

	PostShippingProfilesIdWithResponse(ctx context.Context, id string, params *PostShippingProfilesIdParams, body PostShippingProfilesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesIdResponse, error)

	// GetStockLocationsWithResponse request
	GetStockLocationsWithResponse(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*GetStockLocationsResponse, error)

	// PostStockLocationsWithBodyWithResponse request with any body
	PostStockLocationsWithBodyWithResponse(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error)

	PostStockLocationsWithResponse(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error)

	// DeleteStockLocationsIdWithResponse request
	DeleteStockLocationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteStockLocationsIdResponse, error)

	// GetStockLocationsIdWithResponse request
	GetStockLocationsIdWithResponse(ctx context.Context, id string, params *GetStockLocationsIdParams, reqEditors ...RequestEditorFn) (*GetStockLocationsIdResponse, error)

	// PostStockLocationsIdWithBodyWithResponse request with any body
	PostStockLocationsIdWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdResponse, error)

	PostStockLocationsIdWithResponse(ctx context.Context, id string, params *PostStockLocationsIdParams, body PostStockLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdResponse, error)

	// PostStockLocationsIdFulfillmentProvidersWithBodyWithResponse request with any body
	PostStockLocationsIdFulfillmentProvidersWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentProvidersResponse, error)

	PostStockLocationsIdFulfillmentProvidersWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, body PostStockLocationsIdFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentProvidersResponse, error)

	// PostStockLocationsIdFulfillmentSetsWithBodyWithResponse request with any body
	PostStockLocationsIdFulfillmentSetsWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentSetsResponse, error)

	PostStockLocationsIdFulfillmentSetsWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, body PostStockLocationsIdFulfillmentSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentSetsResponse, error)

	// PostStockLocationsIdSalesChannelsWithBodyWithResponse request with any body
	PostStockLocationsIdSalesChannelsWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdSalesChannelsResponse, error)

	PostStockLocationsIdSalesChannelsWithResponse(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, body PostStockLocationsIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdSalesChannelsResponse, error)

	// GetStoresWithResponse request
	GetStoresWithResponse(ctx context.Context, params *GetStoresParams, reqEditors ...RequestEditorFn) (*GetStoresResponse, error)

	// GetStoresIdWithResponse request
	GetStoresIdWithResponse(ctx context.Context, id string, params *GetStoresIdParams, reqEditors ...RequestEditorFn) (*GetStoresIdResponse, error)

	// PostStoresIdWithBodyWithResponse request with any body
	PostStoresIdWithBodyWithResponse(ctx context.Context, id string, params *PostStoresIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStoresIdResponse, error)

	PostStoresIdWithResponse(ctx context.Context, id string, params *PostStoresIdParams, body PostStoresIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStoresIdResponse, error)

	// GetTaxRatesWithResponse request
	GetTaxRatesWithResponse(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*GetTaxRatesResponse, error)

	// PostTaxRatesWithBodyWithResponse request with any body
	PostTaxRatesWithBodyWithResponse(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error)

	PostTaxRatesWithResponse(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error)

	// DeleteTaxRatesIdWithResponse request
	DeleteTaxRatesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTaxRatesIdResponse, error)

	// GetTaxRatesIdWithResponse request
	GetTaxRatesIdWithResponse(ctx context.Context, id string, params *GetTaxRatesIdParams, reqEditors ...RequestEditorFn) (*GetTaxRatesIdResponse, error)

	// PostTaxRatesIdWithBodyWithResponse request with any body
	PostTaxRatesIdWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesIdResponse, error)

	PostTaxRatesIdWithResponse(ctx context.Context, id string, params *PostTaxRatesIdParams, body PostTaxRatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesIdResponse, error)

	// PostTaxRatesIdRulesWithBodyWithResponse request with any body
	PostTaxRatesIdRulesWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesIdRulesResponse, error)

	PostTaxRatesIdRulesWithResponse(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, body PostTaxRatesIdRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesIdRulesResponse, error)

	// DeleteTaxRatesIdRulesRuleIdWithResponse request
	DeleteTaxRatesIdRulesRuleIdWithResponse(ctx context.Context, id string, ruleId string, params *DeleteTaxRatesIdRulesRuleIdParams, reqEditors ...RequestEditorFn) (*DeleteTaxRatesIdRulesRuleIdResponse, error)

	// GetTaxRegionsWithResponse request
	GetTaxRegionsWithResponse(ctx context.Context, params *GetTaxRegionsParams, reqEditors ...RequestEditorFn) (*GetTaxRegionsResponse, error)

	// PostTaxRegionsWithBodyWithResponse request with any body
	PostTaxRegionsWithBodyWithResponse(ctx context.Context, params *PostTaxRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRegionsResponse, error)

	PostTaxRegionsWithResponse(ctx context.Context, params *PostTaxRegionsParams, body PostTaxRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRegionsResponse, error)

	// DeleteTaxRegionsIdWithResponse request
	DeleteTaxRegionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTaxRegionsIdResponse, error)

	// GetTaxRegionsIdWithResponse request
	GetTaxRegionsIdWithResponse(ctx context.Context, id string, params *GetTaxRegionsIdParams, reqEditors ...RequestEditorFn) (*GetTaxRegionsIdResponse, error)

	// PostUploadsWithBodyWithResponse request with any body
	PostUploadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsResponse, error)

	PostUploadsWithResponse(ctx context.Context, body PostUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUploadsResponse, error)

	// DeleteUploadsIdWithResponse request
	DeleteUploadsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUploadsIdResponse, error)

	// GetUploadsIdWithResponse request
	GetUploadsIdWithResponse(ctx context.Context, id string, params *GetUploadsIdParams, reqEditors ...RequestEditorFn) (*GetUploadsIdResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// GetUsersMeWithResponse request
	GetUsersMeWithResponse(ctx context.Context, params *GetUsersMeParams, reqEditors ...RequestEditorFn) (*GetUsersMeResponse, error)

	// DeleteUsersIdWithResponse request
	DeleteUsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUsersIdResponse, error)

	// GetUsersIdWithResponse request
	GetUsersIdWithResponse(ctx context.Context, id string, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error)

	// PostUsersIdWithBodyWithResponse request with any body
	PostUsersIdWithBodyWithResponse(ctx context.Context, id string, params *PostUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersIdResponse, error)

	PostUsersIdWithResponse(ctx context.Context, id string, params *PostUsersIdParams, body PostUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersIdResponse, error)

	// GetWorkflowsExecutionsWithResponse request
	GetWorkflowsExecutionsWithResponse(ctx context.Context, params *GetWorkflowsExecutionsParams, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsResponse, error)

	// GetWorkflowsExecutionsIdWithResponse request
	GetWorkflowsExecutionsIdWithResponse(ctx context.Context, id string, params *GetWorkflowsExecutionsIdParams, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsIdResponse, error)

	// PostWorkflowsExecutionsWorkflowIdRunWithBodyWithResponse request with any body
	PostWorkflowsExecutionsWorkflowIdRunWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdRunResponse, error)

	PostWorkflowsExecutionsWorkflowIdRunWithResponse(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdRunResponse, error)

	// PostWorkflowsExecutionsWorkflowIdStepsFailureWithBodyWithResponse request with any body
	PostWorkflowsExecutionsWorkflowIdStepsFailureWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsFailureResponse, error)

	PostWorkflowsExecutionsWorkflowIdStepsFailureWithResponse(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsFailureResponse, error)

	// PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBodyWithResponse request with any body
	PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse, error)

	PostWorkflowsExecutionsWorkflowIdStepsSuccessWithResponse(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse, error)

	// GetWorkflowsExecutionsWorkflowIdSubscribeWithResponse request
	GetWorkflowsExecutionsWorkflowIdSubscribeWithResponse(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsWorkflowIdSubscribeResponse, error)

	// GetWorkflowsExecutionsWorkflowIdTransactionIdWithResponse request
	GetWorkflowsExecutionsWorkflowIdTransactionIdWithResponse(ctx context.Context, workflowId string, transactionId string, params *GetWorkflowsExecutionsWorkflowIdTransactionIdParams, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsWorkflowIdTransactionIdResponse, error)

	// GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeWithResponse request
	GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeWithResponse(ctx context.Context, workflowId string, transactionId string, stepId string, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse, error)

	// DeleteSessionWithResponse request
	DeleteSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error)

	// PostSessionWithResponse request
	PostSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSessionResponse, error)

	// PostAdminAuthTokenRefreshWithResponse request
	PostAdminAuthTokenRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAdminAuthTokenRefreshResponse, error)

	// PostActorTypeAuthProviderWithBodyWithResponse request with any body
	PostActorTypeAuthProviderWithBodyWithResponse(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderResponse, error)

	PostActorTypeAuthProviderWithResponse(ctx context.Context, authProvider string, body PostActorTypeAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderResponse, error)

	// PostActorTypeAuthProviderCallbackWithResponse request
	PostActorTypeAuthProviderCallbackWithResponse(ctx context.Context, authProvider string, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderCallbackResponse, error)

	// PostActorTypeAuthProviderRegisterWithBodyWithResponse request with any body
	PostActorTypeAuthProviderRegisterWithBodyWithResponse(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderRegisterResponse, error)

	PostActorTypeAuthProviderRegisterWithResponse(ctx context.Context, authProvider string, body PostActorTypeAuthProviderRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderRegisterResponse, error)
}

type GetApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ApiKeys The list of API keys.
		ApiKeys []ApiKeyResponse `json:"api_keys"`

		// Count The total count of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned in the list.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiKeyResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeysIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the API key was deleted.
		Deleted bool `json:"deleted"`

		// Id The API key's ID.
		Id string `json:"id"`

		// Object The name of the object that was deleted.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeysIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeysIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiKeysIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiKeyResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetApiKeysIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiKeysIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiKeysIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiKeyResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostApiKeysIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiKeysIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiKeysIdRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiKeyResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostApiKeysIdRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiKeysIdRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiKeysIdSalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiKeyResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostApiKeysIdSalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiKeysIdSalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Campaigns The list of campaigns.
		Campaigns []CampaignResponse `json:"campaigns"`

		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items retrieved.
		Limit float32 `json:"limit"`

		// Offset The number of its skipped before the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCampaignResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCampaignsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the campaign was deleted.
		Deleted bool `json:"deleted"`

		// Id The campaign's ID.
		Id string `json:"id"`

		// Object The name of the object that was deleted.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCampaignsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCampaignsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCampaignResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCampaignsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCampaignResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCampaignsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCampaignsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCampaignsIdPromotionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCampaignResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCampaignsIdPromotionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCampaignsIdPromotionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClaimsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetClaimsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClaimsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClaimsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetClaimsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClaimsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdClaimItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdClaimItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdClaimItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClaimsIdClaimItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteClaimsIdClaimItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClaimsIdClaimItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdClaimItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdClaimItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdClaimItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdInboundItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdInboundItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdInboundItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClaimsIdInboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteClaimsIdInboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClaimsIdInboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdInboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdInboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdInboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdInboundShippingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdInboundShippingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdInboundShippingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClaimsIdInboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteClaimsIdInboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClaimsIdInboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdInboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdInboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdInboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdOutboundItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdOutboundItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdOutboundItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClaimsIdOutboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteClaimsIdOutboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClaimsIdOutboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdOutboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdOutboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdOutboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdOutboundShippingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdOutboundShippingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdOutboundShippingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClaimsIdOutboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteClaimsIdOutboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClaimsIdOutboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdOutboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdOutboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdOutboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClaimsIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteClaimsIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClaimsIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClaimsIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminClaimRequestResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostClaimsIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClaimsIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCollectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionsIdProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCollectionsIdProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionsIdProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCurrencyListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrenciesCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCurrencyResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCurrenciesCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrenciesCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items
		Count float32 `json:"count"`

		// CustomerGroups The list of customer groups.
		CustomerGroups []AdminCustomerGroup `json:"customer_groups"`

		// Limit The maximum number of items retrieved.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted The customer group's deleted.
		Deleted bool `json:"deleted"`

		// Id The customer group's ID.
		Id string `json:"id"`

		// Object The customer group's object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomerGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerGroupsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomerGroupsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerGroupsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerGroupsIdCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomerGroupsIdCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerGroupsIdCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Customers The customer's details.
		Customers AdminCustomer `json:"customers"`

		// Limit The maximum number of items returned in the list.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted The customer's deleted.
		Deleted bool `json:"deleted"`

		// Id The customer's ID.
		Id string `json:"id"`

		// Object The customer's object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersIdAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Addresses The customer addresses.
		Addresses []AdminCustomerAddress `json:"addresses"`

		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomersIdAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersIdAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersIdAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomersIdAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersIdAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomersIdAddressesAddressIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the Customer was deleted.
		Deleted bool `json:"deleted"`

		// Id The customer's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`

		// Parent The customer's details.
		Parent *AdminCustomer `json:"parent,omitempty"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCustomersIdAddressesAddressIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomersIdAddressesAddressIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersIdAddressesAddressIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerAddressResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomersIdAddressesAddressIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersIdAddressesAddressIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersIdAddressesAddressIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomersIdAddressesAddressIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersIdAddressesAddressIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDraftOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// DraftOrders The order's details.
		DraftOrders AdminOrder `json:"draft_orders"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDraftOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDraftOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDraftOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDraftOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDraftOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDraftOrdersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDraftOrdersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDraftOrdersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Exchanges The exchange's exchanges.
		Exchanges []AdminExchange `json:"exchanges"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExchangesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetExchangesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExchangesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdInboundItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdInboundItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdInboundItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExchangesIdInboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteExchangesIdInboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExchangesIdInboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdInboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdInboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdInboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdInboundShippingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdInboundShippingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdInboundShippingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExchangesIdInboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteExchangesIdInboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExchangesIdInboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdInboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdInboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdInboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdOutboundItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdOutboundItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdOutboundItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExchangesIdOutboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteExchangesIdOutboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExchangesIdOutboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdOutboundItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdOutboundItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdOutboundItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdOutboundShippingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdOutboundShippingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdOutboundShippingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExchangesIdOutboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteExchangesIdOutboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExchangesIdOutboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdOutboundShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangePreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdOutboundShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdOutboundShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExchangesIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteExchangesIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExchangesIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExchangesIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExchangeRequestResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostExchangesIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExchangesIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFulfillmentProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentProviderListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetFulfillmentProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFulfillmentProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFulfillmentSetsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentSetDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteFulfillmentSetsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFulfillmentSetsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFulfillmentSetsIdServiceZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentSetResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostFulfillmentSetsIdServiceZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFulfillmentSetsIdServiceZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFulfillmentSetsIdServiceZonesZoneIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminServiceZoneDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteFulfillmentSetsIdServiceZonesZoneIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFulfillmentSetsIdServiceZonesZoneIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFulfillmentSetsIdServiceZonesZoneIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminServiceZoneResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetFulfillmentSetsIdServiceZonesZoneIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFulfillmentSetsIdServiceZonesZoneIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFulfillmentSetsIdServiceZonesZoneIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentSetResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostFulfillmentSetsIdServiceZonesZoneIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFulfillmentSetsIdServiceZonesZoneIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFulfillmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostFulfillmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFulfillmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFulfillmentsIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostFulfillmentsIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFulfillmentsIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFulfillmentsIdShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFulfillmentResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostFulfillmentsIdShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFulfillmentsIdShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// InventoryItems The inventory item's inventory items.
		InventoryItems []AdminInventoryItem `json:"inventory_items"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryItemsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the inventory item was deleted.
		Deleted bool `json:"deleted"`

		// Id The inventory item's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryItemsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryItemsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemsIdLocationLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// InventoryLevels The inventory item's inventory levels.
		InventoryLevels []InventoryLevel `json:"inventory_levels"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemsIdLocationLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemsIdLocationLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsIdLocationLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsIdLocationLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsIdLocationLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsIdLocationLevelsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// InventoryItem The inventory item's details.
		InventoryItem map[string]interface{} `json:"inventory_item"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsIdLocationLevelsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsIdLocationLevelsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryItemsIdLocationLevelsLocationIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the Inventory Item was deleted.
		Deleted bool `json:"deleted"`

		// Id The inventory item's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`

		// Parent The reservation's inventory item.
		Parent *AdminInventoryItem `json:"parent,omitempty"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryItemsIdLocationLevelsLocationIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryItemsIdLocationLevelsLocationIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsIdLocationLevelsLocationIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsIdLocationLevelsLocationIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsIdLocationLevelsLocationIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Invites The list of invites.
		Invites []AdminInvite `json:"invites"`

		// Limit The maximum number of items retrieved.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before the returned items.
		Offset float32 `json:"offset"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInviteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvitesAcceptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInvitesAcceptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvitesAcceptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInvitesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the invite was deleted.
		Deleted bool `json:"deleted"`

		// Id The invite's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteInvitesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvitesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvitesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInviteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInvitesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvitesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvitesIdResendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInviteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInvitesIdResendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvitesIdResendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotificationListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotificationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderEditsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the order edit was deleted.
		Deleted bool `json:"deleted"`

		// Id The order edit's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrderEditsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderEditsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdItemsItemItemIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdItemsItemItemIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdItemsItemItemIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderEditsIdItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrderEditsIdItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderEditsIdItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdShippingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdShippingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdShippingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderEditsIdShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrderEditsIdShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderEditsIdShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsIdShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsIdShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsIdShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total count of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before the returned items.
		Offset float32 `json:"offset"`

		// Orders The list of orders.
		Orders []AdminOrder `json:"orders"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdArchiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdArchiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdArchiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersIdChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderChangesResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersIdChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersIdChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdFulfillmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdFulfillmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdFulfillmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdFulfillmentsFulfillmentIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdFulfillmentsFulfillmentIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdFulfillmentsFulfillmentIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersIdPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersIdPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersIdPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentCollectionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDeletePaymentCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePaymentCollectionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentCollectionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentCollectionsIdMarkAsPaidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentCollectionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentCollectionsIdMarkAsPaidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentCollectionsIdMarkAsPaidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of payments.
		Count float32 `json:"count"`

		// Limit The maximum number of returned items.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before the returned items.
		Offset float32 `json:"offset"`

		// Payments The list of payments.
		Payments []AdminPayment `json:"payments"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentsPaymentProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before the returned items.
		Offset float32 `json:"offset"`

		// PaymentProviders The list of payment providers.
		PaymentProviders []AdminPaymentProvider `json:"payment_providers"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPaymentsPaymentProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentsPaymentProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPaymentsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentsIdCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentsIdCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentsIdCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentsIdRefundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentsIdRefundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentsIdRefundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPriceListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPriceListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPriceListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePriceListsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePriceListsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePriceListsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPriceListsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPriceListsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPriceListsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsIdPricesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListBatchResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsIdPricesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsIdPricesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsIdProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsIdProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsIdProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricePreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPricePreferenceListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPricePreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricePreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPricePreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPricePreferenceResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPricePreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPricePreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePricePreferencesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPricePreferenceDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePricePreferencesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePricePreferencesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricePreferencesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPricePreferenceResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPricePreferencesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricePreferencesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPricePreferencesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPricePreferenceResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPricePreferencesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPricePreferencesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoryListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoryResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoryDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoryResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoryResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductCategoriesIdProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoryResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductCategoriesIdProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductCategoriesIdProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTagListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTagResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductTagsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTagDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductTagsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductTagsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductTagsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTagResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductTagsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductTagsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductTagsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTagResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductTagsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductTagsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTypeListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTypeResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductTypesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTypeDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductTypesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductTypesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductTypesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTypeResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductTypesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductTypesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductTypesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTypeResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductTypesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductTypesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductVariantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// Variants The product variant's variants.
		Variants []AdminProductVariant `json:"variants"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductVariantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductVariantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// Products The list of products.
		Products []map[string]interface{} `json:"products"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBatchProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AdminExportProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AdminImportProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsImportTransactionIdConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsImportTransactionIdConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsImportTransactionIdConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsIdOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before the returned items.
		Offset float32 `json:"offset"`

		// ProductOptions The list of product options.
		ProductOptions []AdminProductOption `json:"product_options"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsIdOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsIdOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsIdOptionsOptionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductOptionDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsIdOptionsOptionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsIdOptionsOptionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsIdOptionsOptionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductOptionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsIdOptionsOptionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsIdOptionsOptionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdOptionsOptionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdOptionsOptionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdOptionsOptionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsIdVariantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of returned items.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before the returned item.
		Offset float32 `json:"offset"`

		// Variants The list of product variants.
		Variants []AdminProductVariant `json:"variants"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsIdVariantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsIdVariantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdVariantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdVariantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdVariantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdVariantsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBatchProductVariantResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdVariantsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdVariantsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdVariantsInventoryItemsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductVariantInventoryBatchResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdVariantsInventoryItemsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdVariantsInventoryItemsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsIdVariantsVariantIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductVariantDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsIdVariantsVariantIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsIdVariantsVariantIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsIdVariantsVariantIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductVariantResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsIdVariantsVariantIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsIdVariantsVariantIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdVariantsVariantIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdVariantsVariantIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdVariantsVariantIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdVariantsVariantIdInventoryItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductVariantResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdVariantsVariantIdInventoryItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdVariantsVariantIdInventoryItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductVariantInventoryLinkDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductVariantResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// Promotions The list of promotions.
		Promotions []AdminPromotion `json:"promotions"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPromotionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPromotionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPromotionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPromotionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPromotionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionsRuleAttributeOptionsRuleTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Attributes The list of attributes.
		Attributes []AdminRuleAttributeOption `json:"attributes"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPromotionsRuleAttributeOptionsRuleTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionsRuleAttributeOptionsRuleTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Values The list of rule values.
		Values []AdminRuleValueOption `json:"values"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePromotionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the promotion was deleted.
		Deleted bool `json:"deleted"`

		// Id The promotion's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePromotionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePromotionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPromotionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPromotionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPromotionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPromotionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPromotionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPromotionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPromotionsIdBuyRulesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created The created buy rules.
		Created []AdminPromotionRule `json:"created"`

		// Deleted The details of the deleted buy rules.
		Deleted struct {
			// Deleted Whether the buy rules were deleted.
			Deleted bool `json:"deleted"`

			// Ids The IDs of the buy rules that were deleted.
			Ids []string `json:"ids"`

			// Object The name of the object that was deleted.
			Object string `json:"object"`
		} `json:"deleted"`

		// Updated The updated buy rules.
		Updated []AdminPromotionRule `json:"updated"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPromotionsIdBuyRulesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPromotionsIdBuyRulesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPromotionsIdRulesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created The created rules.
		Created []AdminPromotionRule `json:"created"`

		// Deleted The details of the deleted buy rules.
		Deleted struct {
			// Deleted Whether the rules were deleted.
			Deleted bool `json:"deleted"`

			// Ids The IDs of the deleted rules.
			Ids []string `json:"ids"`

			// Object The name of the object that was deleted.
			Object string `json:"object"`
		} `json:"deleted"`

		// Updated The updated rules.
		Updated []AdminPromotionRule `json:"updated"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPromotionsIdRulesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPromotionsIdRulesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPromotionsIdTargetRulesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created The created target rules.
		Created []AdminPromotionRule `json:"created"`

		// Deleted The details of the deleted target rules.
		Deleted struct {
			// Deleted Whether the target rules were deleted.
			Deleted bool `json:"deleted"`

			// Ids The IDs of deleted target rules.
			Ids []string `json:"ids"`

			// Object The name of the object that was deleted.
			Object string `json:"object"`
		} `json:"deleted"`

		// Updated The updated target rules.
		Updated []AdminPromotionRule `json:"updated"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPromotionsIdTargetRulesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPromotionsIdTargetRulesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionsIdRuleTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Rules The list of promotion rules.
		Rules []AdminPromotionRule `json:"rules"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPromotionsIdRuleTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionsIdRuleTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRefundReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// RefundReasons The refund reason's refund reasons.
		RefundReasons []AdminRefundReason `json:"refund_reasons"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRefundReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRefundReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRefundReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefundReasonResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRefundReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRefundReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRefundReasonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the refund reason was deleted.
		Deleted bool `json:"deleted"`

		// Id The refund reason's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteRefundReasonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRefundReasonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRefundReasonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefundReasonResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRefundReasonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRefundReasonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRefundReasonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefundReasonResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRefundReasonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRefundReasonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// Regions The list of regions.
		Regions []AdminRegion `json:"regions"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRegionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the region was deleted.
		Deleted bool `json:"deleted"`

		// Id The region's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteRegionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRegionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRegionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// Reservations The list of reservations.
		Reservations []AdminReservation `json:"reservations"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the reservation was deleted.
		Deleted bool `json:"deleted"`

		// Id The reservation's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReservationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReservationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnReasonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnReasonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnReasonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnReasonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnReasonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnReasonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnReasonsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnReasonsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnReasonsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// Returns The return's returns.
		Returns []AdminReturn `json:"returns"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdDismissItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdDismissItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdDismissItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnsIdDismissItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnsIdDismissItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnsIdDismissItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdDismissItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdDismissItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdDismissItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnsIdReceiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the return was deleted.
		Deleted bool `json:"deleted"`

		// Id The return's ID.
		Id string `json:"id"`

		// Object The name of the returned object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnsIdReceiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnsIdReceiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdReceiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderReturnResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdReceiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdReceiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdReceiveItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdReceiveItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdReceiveItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnsIdReceiveItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnsIdReceiveItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnsIdReceiveItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdReceiveItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdReceiveItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdReceiveItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdReceiveConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdReceiveConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdReceiveConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnsIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the return was deleted.
		Deleted bool `json:"deleted"`

		// Id The return's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnsIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnsIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdRequestItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdRequestItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdRequestItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnsIdRequestItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnsIdRequestItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnsIdRequestItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdRequestItemsActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdRequestItemsActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdRequestItemsActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdShippingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdShippingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdShippingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnsIdShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnsIdShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnsIdShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsIdShippingMethodActionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnPreviewResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsIdShippingMethodActionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsIdShippingMethodActionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// SalesChannels The list of sales channels.
		SalesChannels []AdminSalesChannel `json:"sales_channels"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetSalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSalesChannelsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteSalesChannelsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSalesChannelsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSalesChannelsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetSalesChannelsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSalesChannelsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsIdProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsIdProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsIdProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// ShippingOptions The list of shipping options.
		ShippingOptions []map[string]interface{} `json:"shipping_options"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShippingOptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteShippingOptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShippingOptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingOptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingOptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingOptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingOptionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingOptionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingOptionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingOptionsIdRulesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created The created shipping option rules.
		Created []AdminShippingOptionRule `json:"created"`

		// Deleted The details of the deleted shipping option rules.
		Deleted struct {
			// Deleted The deleted's details.
			Deleted bool `json:"deleted"`

			// Ids The IDs of the deleted shipping option rules.
			Ids []string `json:"ids"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		} `json:"deleted"`

		// Updated The updated shipping option rules.
		Updated []AdminShippingOptionRule `json:"updated"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingOptionsIdRulesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingOptionsIdRulesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// ShippingProfiles The list of shipping profiles.
		ShippingProfiles []AdminShippingProfile `json:"shipping_profiles"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfileResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShippingProfilesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfileDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteShippingProfilesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShippingProfilesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingProfilesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfileResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingProfilesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingProfilesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingProfilesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfileResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingProfilesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingProfilesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStockLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStockLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStockLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStockLocationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteStockLocationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStockLocationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStockLocationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStockLocationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStockLocationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsIdFulfillmentProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsIdFulfillmentProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsIdFulfillmentProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsIdFulfillmentSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsIdFulfillmentSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsIdFulfillmentSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsIdSalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsIdSalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsIdSalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStoreListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoresIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStoreResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStoresIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoresIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStoresIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStoreResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStoresIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStoresIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// TaxRates The tax rate's tax rates.
		TaxRates []AdminTaxRate `json:"tax_rates"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetTaxRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRateResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRateDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxRatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRateResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetTaxRatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxRatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRateResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesIdRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRateResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesIdRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesIdRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRatesIdRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the Tax Rate was deleted.
		Deleted bool `json:"deleted"`

		// Id The tax rate's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`

		// Parent The tax rate's details.
		Parent *AdminTaxRate `json:"parent,omitempty"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRatesIdRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRatesIdRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// TaxRegions The list of tax regions.
		TaxRegions []map[string]interface{} `json:"tax_regions"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetTaxRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRegionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRegionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRegionDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRegionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRegionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxRegionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRegionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetTaxRegionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxRegionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUploadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFileListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUploadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUploadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUploadsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Deleted Whether the file was deleted.
		Deleted bool `json:"deleted"`

		// Id The file's ID.
		Id string `json:"id"`

		// Object The name of the deleted object.
		Object string `json:"object"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteUploadsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUploadsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminFileResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetUploadsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserListResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetUsersMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserDeleteResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowsExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Count The total number of items.
		Count float32 `json:"count"`

		// Limit The maximum number of items returned.
		Limit float32 `json:"limit"`

		// Offset The number of items skipped before retrieving the returned items.
		Offset float32 `json:"offset"`

		// WorkflowExecutions The workflows execution's workflow executions.
		WorkflowExecutions []AdminWorkflowExecution `json:"workflow_executions"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r GetWorkflowsExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowsExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowsExecutionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminWorkflowExecutionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetWorkflowsExecutionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowsExecutionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkflowsExecutionsWorkflowIdRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Acknowledgement The workflow's details
		Acknowledgement struct {
			// HasFailed Whether the workflow execution has failed.
			HasFailed bool `json:"hasFailed"`

			// HasFinished Whether the workflow execution has finished.
			HasFinished bool `json:"hasFinished"`

			// ParentStepIdempotencyKey The idempotency key of the workflow execution.
			ParentStepIdempotencyKey *string `json:"parentStepIdempotencyKey,omitempty"`

			// TransactionId The ID of the workflow exection's transaction. Use this later to track the workflow execution's progress or succeed / fail its steps.
			TransactionId string `json:"transactionId"`

			// WorkflowId The ID of the executed workflow.
			WorkflowId string `json:"workflowId"`
		} `json:"acknowledgement"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostWorkflowsExecutionsWorkflowIdRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkflowsExecutionsWorkflowIdRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkflowsExecutionsWorkflowIdStepsFailureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether the workflow step has failed successfully.
		Success bool `json:"success"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostWorkflowsExecutionsWorkflowIdStepsFailureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkflowsExecutionsWorkflowIdStepsFailureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether the workflow step was succeeded.
		Success bool `json:"success"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowsExecutionsWorkflowIdSubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetWorkflowsExecutionsWorkflowIdSubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowsExecutionsWorkflowIdSubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowsExecutionsWorkflowIdTransactionIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminWorkflowExecutionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetWorkflowsExecutionsWorkflowIdTransactionIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowsExecutionsWorkflowIdTransactionIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Success Whether the session was deleted successfully.
		Success bool `json:"success"`
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthAdminSessionResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAdminAuthTokenRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostAdminAuthTokenRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAdminAuthTokenRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostActorTypeAuthProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON400 *N400Error
	JSON404 *NotFoundError
	JSON409 *InvalidStateError
	JSON422 *InvalidRequestError
	JSON500 *N500Error
}

// Status returns HTTPResponse.Status
func (r PostActorTypeAuthProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostActorTypeAuthProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostActorTypeAuthProviderCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostActorTypeAuthProviderCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostActorTypeAuthProviderCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostActorTypeAuthProviderRegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthResponse
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostActorTypeAuthProviderRegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostActorTypeAuthProviderRegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetApiKeysWithResponse request returning *GetApiKeysResponse
func (c *ClientWithResponses) GetApiKeysWithResponse(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error) {
	rsp, err := c.GetApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiKeysResponse(rsp)
}

// PostApiKeysWithBodyWithResponse request with arbitrary body returning *PostApiKeysResponse
func (c *ClientWithResponses) PostApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error) {
	rsp, err := c.PostApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysResponse(rsp)
}

func (c *ClientWithResponses) PostApiKeysWithResponse(ctx context.Context, body PostApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysResponse, error) {
	rsp, err := c.PostApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysResponse(rsp)
}

// DeleteApiKeysIdWithResponse request returning *DeleteApiKeysIdResponse
func (c *ClientWithResponses) DeleteApiKeysIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteApiKeysIdResponse, error) {
	rsp, err := c.DeleteApiKeysId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeysIdResponse(rsp)
}

// GetApiKeysIdWithResponse request returning *GetApiKeysIdResponse
func (c *ClientWithResponses) GetApiKeysIdWithResponse(ctx context.Context, id string, params *GetApiKeysIdParams, reqEditors ...RequestEditorFn) (*GetApiKeysIdResponse, error) {
	rsp, err := c.GetApiKeysId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiKeysIdResponse(rsp)
}

// PostApiKeysIdWithBodyWithResponse request with arbitrary body returning *PostApiKeysIdResponse
func (c *ClientWithResponses) PostApiKeysIdWithBodyWithResponse(ctx context.Context, id string, params *PostApiKeysIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysIdResponse, error) {
	rsp, err := c.PostApiKeysIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysIdResponse(rsp)
}

func (c *ClientWithResponses) PostApiKeysIdWithResponse(ctx context.Context, id string, params *PostApiKeysIdParams, body PostApiKeysIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysIdResponse, error) {
	rsp, err := c.PostApiKeysId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysIdResponse(rsp)
}

// PostApiKeysIdRevokeWithBodyWithResponse request with arbitrary body returning *PostApiKeysIdRevokeResponse
func (c *ClientWithResponses) PostApiKeysIdRevokeWithBodyWithResponse(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysIdRevokeResponse, error) {
	rsp, err := c.PostApiKeysIdRevokeWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysIdRevokeResponse(rsp)
}

func (c *ClientWithResponses) PostApiKeysIdRevokeWithResponse(ctx context.Context, id string, params *PostApiKeysIdRevokeParams, body PostApiKeysIdRevokeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysIdRevokeResponse, error) {
	rsp, err := c.PostApiKeysIdRevoke(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysIdRevokeResponse(rsp)
}

// PostApiKeysIdSalesChannelsWithBodyWithResponse request with arbitrary body returning *PostApiKeysIdSalesChannelsResponse
func (c *ClientWithResponses) PostApiKeysIdSalesChannelsWithBodyWithResponse(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApiKeysIdSalesChannelsResponse, error) {
	rsp, err := c.PostApiKeysIdSalesChannelsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysIdSalesChannelsResponse(rsp)
}

func (c *ClientWithResponses) PostApiKeysIdSalesChannelsWithResponse(ctx context.Context, id string, params *PostApiKeysIdSalesChannelsParams, body PostApiKeysIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApiKeysIdSalesChannelsResponse, error) {
	rsp, err := c.PostApiKeysIdSalesChannels(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiKeysIdSalesChannelsResponse(rsp)
}

// GetCampaignsWithResponse request returning *GetCampaignsResponse
func (c *ClientWithResponses) GetCampaignsWithResponse(ctx context.Context, params *GetCampaignsParams, reqEditors ...RequestEditorFn) (*GetCampaignsResponse, error) {
	rsp, err := c.GetCampaigns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsResponse(rsp)
}

// PostCampaignsWithBodyWithResponse request with arbitrary body returning *PostCampaignsResponse
func (c *ClientWithResponses) PostCampaignsWithBodyWithResponse(ctx context.Context, params *PostCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCampaignsResponse, error) {
	rsp, err := c.PostCampaignsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCampaignsResponse(rsp)
}

func (c *ClientWithResponses) PostCampaignsWithResponse(ctx context.Context, params *PostCampaignsParams, body PostCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCampaignsResponse, error) {
	rsp, err := c.PostCampaigns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCampaignsResponse(rsp)
}

// DeleteCampaignsIdWithResponse request returning *DeleteCampaignsIdResponse
func (c *ClientWithResponses) DeleteCampaignsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCampaignsIdResponse, error) {
	rsp, err := c.DeleteCampaignsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCampaignsIdResponse(rsp)
}

// GetCampaignsIdWithResponse request returning *GetCampaignsIdResponse
func (c *ClientWithResponses) GetCampaignsIdWithResponse(ctx context.Context, id string, params *GetCampaignsIdParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdResponse, error) {
	rsp, err := c.GetCampaignsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdResponse(rsp)
}

// PostCampaignsIdWithBodyWithResponse request with arbitrary body returning *PostCampaignsIdResponse
func (c *ClientWithResponses) PostCampaignsIdWithBodyWithResponse(ctx context.Context, id string, params *PostCampaignsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCampaignsIdResponse, error) {
	rsp, err := c.PostCampaignsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCampaignsIdResponse(rsp)
}

func (c *ClientWithResponses) PostCampaignsIdWithResponse(ctx context.Context, id string, params *PostCampaignsIdParams, body PostCampaignsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCampaignsIdResponse, error) {
	rsp, err := c.PostCampaignsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCampaignsIdResponse(rsp)
}

// PostCampaignsIdPromotionsWithBodyWithResponse request with arbitrary body returning *PostCampaignsIdPromotionsResponse
func (c *ClientWithResponses) PostCampaignsIdPromotionsWithBodyWithResponse(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCampaignsIdPromotionsResponse, error) {
	rsp, err := c.PostCampaignsIdPromotionsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCampaignsIdPromotionsResponse(rsp)
}

func (c *ClientWithResponses) PostCampaignsIdPromotionsWithResponse(ctx context.Context, id string, params *PostCampaignsIdPromotionsParams, body PostCampaignsIdPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCampaignsIdPromotionsResponse, error) {
	rsp, err := c.PostCampaignsIdPromotions(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCampaignsIdPromotionsResponse(rsp)
}

// GetClaimsWithResponse request returning *GetClaimsResponse
func (c *ClientWithResponses) GetClaimsWithResponse(ctx context.Context, params *GetClaimsParams, reqEditors ...RequestEditorFn) (*GetClaimsResponse, error) {
	rsp, err := c.GetClaims(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClaimsResponse(rsp)
}

// PostClaimsWithBodyWithResponse request with arbitrary body returning *PostClaimsResponse
func (c *ClientWithResponses) PostClaimsWithBodyWithResponse(ctx context.Context, params *PostClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsResponse, error) {
	rsp, err := c.PostClaimsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsWithResponse(ctx context.Context, params *PostClaimsParams, body PostClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsResponse, error) {
	rsp, err := c.PostClaims(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsResponse(rsp)
}

// GetClaimsIdWithResponse request returning *GetClaimsIdResponse
func (c *ClientWithResponses) GetClaimsIdWithResponse(ctx context.Context, id string, params *GetClaimsIdParams, reqEditors ...RequestEditorFn) (*GetClaimsIdResponse, error) {
	rsp, err := c.GetClaimsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClaimsIdResponse(rsp)
}

// PostClaimsIdCancelWithBodyWithResponse request with arbitrary body returning *PostClaimsIdCancelResponse
func (c *ClientWithResponses) PostClaimsIdCancelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdCancelResponse, error) {
	rsp, err := c.PostClaimsIdCancelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdCancelResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdCancelWithResponse(ctx context.Context, id string, body PostClaimsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdCancelResponse, error) {
	rsp, err := c.PostClaimsIdCancel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdCancelResponse(rsp)
}

// PostClaimsIdClaimItemsWithBodyWithResponse request with arbitrary body returning *PostClaimsIdClaimItemsResponse
func (c *ClientWithResponses) PostClaimsIdClaimItemsWithBodyWithResponse(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsResponse, error) {
	rsp, err := c.PostClaimsIdClaimItemsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdClaimItemsResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdClaimItemsWithResponse(ctx context.Context, id string, params *PostClaimsIdClaimItemsParams, body PostClaimsIdClaimItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsResponse, error) {
	rsp, err := c.PostClaimsIdClaimItems(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdClaimItemsResponse(rsp)
}

// DeleteClaimsIdClaimItemsActionIdWithResponse request returning *DeleteClaimsIdClaimItemsActionIdResponse
func (c *ClientWithResponses) DeleteClaimsIdClaimItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteClaimsIdClaimItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteClaimsIdClaimItemsActionIdResponse, error) {
	rsp, err := c.DeleteClaimsIdClaimItemsActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClaimsIdClaimItemsActionIdResponse(rsp)
}

// PostClaimsIdClaimItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostClaimsIdClaimItemsActionIdResponse
func (c *ClientWithResponses) PostClaimsIdClaimItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsActionIdResponse, error) {
	rsp, err := c.PostClaimsIdClaimItemsActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdClaimItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdClaimItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdClaimItemsActionIdParams, body PostClaimsIdClaimItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdClaimItemsActionIdResponse, error) {
	rsp, err := c.PostClaimsIdClaimItemsActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdClaimItemsActionIdResponse(rsp)
}

// PostClaimsIdInboundItemsWithBodyWithResponse request with arbitrary body returning *PostClaimsIdInboundItemsResponse
func (c *ClientWithResponses) PostClaimsIdInboundItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsResponse, error) {
	rsp, err := c.PostClaimsIdInboundItemsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundItemsResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdInboundItemsWithResponse(ctx context.Context, id string, body PostClaimsIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsResponse, error) {
	rsp, err := c.PostClaimsIdInboundItems(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundItemsResponse(rsp)
}

// DeleteClaimsIdInboundItemsActionIdWithResponse request returning *DeleteClaimsIdInboundItemsActionIdResponse
func (c *ClientWithResponses) DeleteClaimsIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteClaimsIdInboundItemsActionIdResponse, error) {
	rsp, err := c.DeleteClaimsIdInboundItemsActionId(ctx, id, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClaimsIdInboundItemsActionIdResponse(rsp)
}

// PostClaimsIdInboundItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostClaimsIdInboundItemsActionIdResponse
func (c *ClientWithResponses) PostClaimsIdInboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsActionIdResponse, error) {
	rsp, err := c.PostClaimsIdInboundItemsActionIdWithBody(ctx, id, actionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, body PostClaimsIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundItemsActionIdResponse, error) {
	rsp, err := c.PostClaimsIdInboundItemsActionId(ctx, id, actionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundItemsActionIdResponse(rsp)
}

// PostClaimsIdInboundShippingMethodWithBodyWithResponse request with arbitrary body returning *PostClaimsIdInboundShippingMethodResponse
func (c *ClientWithResponses) PostClaimsIdInboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodResponse, error) {
	rsp, err := c.PostClaimsIdInboundShippingMethodWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundShippingMethodResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdInboundShippingMethodWithResponse(ctx context.Context, id string, body PostClaimsIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodResponse, error) {
	rsp, err := c.PostClaimsIdInboundShippingMethod(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundShippingMethodResponse(rsp)
}

// DeleteClaimsIdInboundShippingMethodActionIdWithResponse request returning *DeleteClaimsIdInboundShippingMethodActionIdResponse
func (c *ClientWithResponses) DeleteClaimsIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteClaimsIdInboundShippingMethodActionIdResponse, error) {
	rsp, err := c.DeleteClaimsIdInboundShippingMethodActionId(ctx, id, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClaimsIdInboundShippingMethodActionIdResponse(rsp)
}

// PostClaimsIdInboundShippingMethodActionIdWithBodyWithResponse request with arbitrary body returning *PostClaimsIdInboundShippingMethodActionIdResponse
func (c *ClientWithResponses) PostClaimsIdInboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostClaimsIdInboundShippingMethodActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundShippingMethodActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdInboundShippingMethodActionIdParams, body PostClaimsIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdInboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostClaimsIdInboundShippingMethodActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdInboundShippingMethodActionIdResponse(rsp)
}

// PostClaimsIdOutboundItemsWithBodyWithResponse request with arbitrary body returning *PostClaimsIdOutboundItemsResponse
func (c *ClientWithResponses) PostClaimsIdOutboundItemsWithBodyWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsResponse, error) {
	rsp, err := c.PostClaimsIdOutboundItemsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundItemsResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdOutboundItemsWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundItemsParams, body PostClaimsIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsResponse, error) {
	rsp, err := c.PostClaimsIdOutboundItems(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundItemsResponse(rsp)
}

// DeleteClaimsIdOutboundItemsActionIdWithResponse request returning *DeleteClaimsIdOutboundItemsActionIdResponse
func (c *ClientWithResponses) DeleteClaimsIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteClaimsIdOutboundItemsActionIdResponse, error) {
	rsp, err := c.DeleteClaimsIdOutboundItemsActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClaimsIdOutboundItemsActionIdResponse(rsp)
}

// PostClaimsIdOutboundItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostClaimsIdOutboundItemsActionIdResponse
func (c *ClientWithResponses) PostClaimsIdOutboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsActionIdResponse, error) {
	rsp, err := c.PostClaimsIdOutboundItemsActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundItemsActionIdParams, body PostClaimsIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundItemsActionIdResponse, error) {
	rsp, err := c.PostClaimsIdOutboundItemsActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundItemsActionIdResponse(rsp)
}

// PostClaimsIdOutboundShippingMethodWithBodyWithResponse request with arbitrary body returning *PostClaimsIdOutboundShippingMethodResponse
func (c *ClientWithResponses) PostClaimsIdOutboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodResponse, error) {
	rsp, err := c.PostClaimsIdOutboundShippingMethodWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundShippingMethodResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdOutboundShippingMethodWithResponse(ctx context.Context, id string, params *PostClaimsIdOutboundShippingMethodParams, body PostClaimsIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodResponse, error) {
	rsp, err := c.PostClaimsIdOutboundShippingMethod(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundShippingMethodResponse(rsp)
}

// DeleteClaimsIdOutboundShippingMethodActionIdWithResponse request returning *DeleteClaimsIdOutboundShippingMethodActionIdResponse
func (c *ClientWithResponses) DeleteClaimsIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteClaimsIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*DeleteClaimsIdOutboundShippingMethodActionIdResponse, error) {
	rsp, err := c.DeleteClaimsIdOutboundShippingMethodActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClaimsIdOutboundShippingMethodActionIdResponse(rsp)
}

// PostClaimsIdOutboundShippingMethodActionIdWithBodyWithResponse request with arbitrary body returning *PostClaimsIdOutboundShippingMethodActionIdResponse
func (c *ClientWithResponses) PostClaimsIdOutboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostClaimsIdOutboundShippingMethodActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundShippingMethodActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostClaimsIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostClaimsIdOutboundShippingMethodActionIdParams, body PostClaimsIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClaimsIdOutboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostClaimsIdOutboundShippingMethodActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdOutboundShippingMethodActionIdResponse(rsp)
}

// DeleteClaimsIdRequestWithResponse request returning *DeleteClaimsIdRequestResponse
func (c *ClientWithResponses) DeleteClaimsIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteClaimsIdRequestResponse, error) {
	rsp, err := c.DeleteClaimsIdRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClaimsIdRequestResponse(rsp)
}

// PostClaimsIdRequestWithResponse request returning *PostClaimsIdRequestResponse
func (c *ClientWithResponses) PostClaimsIdRequestWithResponse(ctx context.Context, id string, params *PostClaimsIdRequestParams, reqEditors ...RequestEditorFn) (*PostClaimsIdRequestResponse, error) {
	rsp, err := c.PostClaimsIdRequest(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClaimsIdRequestResponse(rsp)
}

// GetCollectionsWithResponse request returning *GetCollectionsResponse
func (c *ClientWithResponses) GetCollectionsWithResponse(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*GetCollectionsResponse, error) {
	rsp, err := c.GetCollections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsResponse(rsp)
}

// PostCollectionsWithBodyWithResponse request with arbitrary body returning *PostCollectionsResponse
func (c *ClientWithResponses) PostCollectionsWithBodyWithResponse(ctx context.Context, params *PostCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error) {
	rsp, err := c.PostCollectionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsResponse(rsp)
}

func (c *ClientWithResponses) PostCollectionsWithResponse(ctx context.Context, params *PostCollectionsParams, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error) {
	rsp, err := c.PostCollections(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsResponse(rsp)
}

// DeleteCollectionsIdWithResponse request returning *DeleteCollectionsIdResponse
func (c *ClientWithResponses) DeleteCollectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCollectionsIdResponse, error) {
	rsp, err := c.DeleteCollectionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionsIdResponse(rsp)
}

// GetCollectionsIdWithResponse request returning *GetCollectionsIdResponse
func (c *ClientWithResponses) GetCollectionsIdWithResponse(ctx context.Context, id string, params *GetCollectionsIdParams, reqEditors ...RequestEditorFn) (*GetCollectionsIdResponse, error) {
	rsp, err := c.GetCollectionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsIdResponse(rsp)
}

// PostCollectionsIdWithBodyWithResponse request with arbitrary body returning *PostCollectionsIdResponse
func (c *ClientWithResponses) PostCollectionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostCollectionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsIdResponse, error) {
	rsp, err := c.PostCollectionsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsIdResponse(rsp)
}

func (c *ClientWithResponses) PostCollectionsIdWithResponse(ctx context.Context, id string, params *PostCollectionsIdParams, body PostCollectionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsIdResponse, error) {
	rsp, err := c.PostCollectionsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsIdResponse(rsp)
}

// PostCollectionsIdProductsWithBodyWithResponse request with arbitrary body returning *PostCollectionsIdProductsResponse
func (c *ClientWithResponses) PostCollectionsIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostCollectionsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsIdProductsResponse, error) {
	rsp, err := c.PostCollectionsIdProductsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsIdProductsResponse(rsp)
}

func (c *ClientWithResponses) PostCollectionsIdProductsWithResponse(ctx context.Context, id string, params *PostCollectionsIdProductsParams, body PostCollectionsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsIdProductsResponse, error) {
	rsp, err := c.PostCollectionsIdProducts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsIdProductsResponse(rsp)
}

// GetCurrenciesWithResponse request returning *GetCurrenciesResponse
func (c *ClientWithResponses) GetCurrenciesWithResponse(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*GetCurrenciesResponse, error) {
	rsp, err := c.GetCurrencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrenciesResponse(rsp)
}

// GetCurrenciesCodeWithResponse request returning *GetCurrenciesCodeResponse
func (c *ClientWithResponses) GetCurrenciesCodeWithResponse(ctx context.Context, code string, params *GetCurrenciesCodeParams, reqEditors ...RequestEditorFn) (*GetCurrenciesCodeResponse, error) {
	rsp, err := c.GetCurrenciesCode(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrenciesCodeResponse(rsp)
}

// GetCustomerGroupsWithResponse request returning *GetCustomerGroupsResponse
func (c *ClientWithResponses) GetCustomerGroupsWithResponse(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsResponse, error) {
	rsp, err := c.GetCustomerGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerGroupsResponse(rsp)
}

// PostCustomerGroupsWithBodyWithResponse request with arbitrary body returning *PostCustomerGroupsResponse
func (c *ClientWithResponses) PostCustomerGroupsWithBodyWithResponse(ctx context.Context, params *PostCustomerGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error) {
	rsp, err := c.PostCustomerGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerGroupsWithResponse(ctx context.Context, params *PostCustomerGroupsParams, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error) {
	rsp, err := c.PostCustomerGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsResponse(rsp)
}

// DeleteCustomerGroupsIdWithResponse request returning *DeleteCustomerGroupsIdResponse
func (c *ClientWithResponses) DeleteCustomerGroupsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsIdResponse, error) {
	rsp, err := c.DeleteCustomerGroupsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerGroupsIdResponse(rsp)
}

// GetCustomerGroupsIdWithResponse request returning *GetCustomerGroupsIdResponse
func (c *ClientWithResponses) GetCustomerGroupsIdWithResponse(ctx context.Context, id string, params *GetCustomerGroupsIdParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsIdResponse, error) {
	rsp, err := c.GetCustomerGroupsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerGroupsIdResponse(rsp)
}

// PostCustomerGroupsIdWithBodyWithResponse request with arbitrary body returning *PostCustomerGroupsIdResponse
func (c *ClientWithResponses) PostCustomerGroupsIdWithBodyWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdResponse, error) {
	rsp, err := c.PostCustomerGroupsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsIdResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerGroupsIdWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdParams, body PostCustomerGroupsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdResponse, error) {
	rsp, err := c.PostCustomerGroupsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsIdResponse(rsp)
}

// PostCustomerGroupsIdCustomersWithBodyWithResponse request with arbitrary body returning *PostCustomerGroupsIdCustomersResponse
func (c *ClientWithResponses) PostCustomerGroupsIdCustomersWithBodyWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdCustomersResponse, error) {
	rsp, err := c.PostCustomerGroupsIdCustomersWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsIdCustomersResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerGroupsIdCustomersWithResponse(ctx context.Context, id string, params *PostCustomerGroupsIdCustomersParams, body PostCustomerGroupsIdCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsIdCustomersResponse, error) {
	rsp, err := c.PostCustomerGroupsIdCustomers(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsIdCustomersResponse(rsp)
}

// GetCustomersWithResponse request returning *GetCustomersResponse
func (c *ClientWithResponses) GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*GetCustomersResponse, error) {
	rsp, err := c.GetCustomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersResponse(rsp)
}

// PostCustomersWithBodyWithResponse request with arbitrary body returning *PostCustomersResponse
func (c *ClientWithResponses) PostCustomersWithBodyWithResponse(ctx context.Context, params *PostCustomersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error) {
	rsp, err := c.PostCustomersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersWithResponse(ctx context.Context, params *PostCustomersParams, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error) {
	rsp, err := c.PostCustomers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersResponse(rsp)
}

// DeleteCustomersIdWithResponse request returning *DeleteCustomersIdResponse
func (c *ClientWithResponses) DeleteCustomersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCustomersIdResponse, error) {
	rsp, err := c.DeleteCustomersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomersIdResponse(rsp)
}

// GetCustomersIdWithResponse request returning *GetCustomersIdResponse
func (c *ClientWithResponses) GetCustomersIdWithResponse(ctx context.Context, id string, params *GetCustomersIdParams, reqEditors ...RequestEditorFn) (*GetCustomersIdResponse, error) {
	rsp, err := c.GetCustomersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersIdResponse(rsp)
}

// PostCustomersIdWithBodyWithResponse request with arbitrary body returning *PostCustomersIdResponse
func (c *ClientWithResponses) PostCustomersIdWithBodyWithResponse(ctx context.Context, id string, params *PostCustomersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersIdResponse, error) {
	rsp, err := c.PostCustomersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersIdWithResponse(ctx context.Context, id string, params *PostCustomersIdParams, body PostCustomersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersIdResponse, error) {
	rsp, err := c.PostCustomersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdResponse(rsp)
}

// GetCustomersIdAddressesWithResponse request returning *GetCustomersIdAddressesResponse
func (c *ClientWithResponses) GetCustomersIdAddressesWithResponse(ctx context.Context, id string, params *GetCustomersIdAddressesParams, reqEditors ...RequestEditorFn) (*GetCustomersIdAddressesResponse, error) {
	rsp, err := c.GetCustomersIdAddresses(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersIdAddressesResponse(rsp)
}

// PostCustomersIdAddressesWithBodyWithResponse request with arbitrary body returning *PostCustomersIdAddressesResponse
func (c *ClientWithResponses) PostCustomersIdAddressesWithBodyWithResponse(ctx context.Context, id string, params *PostCustomersIdAddressesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesResponse, error) {
	rsp, err := c.PostCustomersIdAddressesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdAddressesResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersIdAddressesWithResponse(ctx context.Context, id string, params *PostCustomersIdAddressesParams, body PostCustomersIdAddressesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesResponse, error) {
	rsp, err := c.PostCustomersIdAddresses(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdAddressesResponse(rsp)
}

// DeleteCustomersIdAddressesAddressIdWithResponse request returning *DeleteCustomersIdAddressesAddressIdResponse
func (c *ClientWithResponses) DeleteCustomersIdAddressesAddressIdWithResponse(ctx context.Context, id string, addressId string, params *DeleteCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*DeleteCustomersIdAddressesAddressIdResponse, error) {
	rsp, err := c.DeleteCustomersIdAddressesAddressId(ctx, id, addressId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomersIdAddressesAddressIdResponse(rsp)
}

// GetCustomersIdAddressesAddressIdWithResponse request returning *GetCustomersIdAddressesAddressIdResponse
func (c *ClientWithResponses) GetCustomersIdAddressesAddressIdWithResponse(ctx context.Context, id string, addressId string, params *GetCustomersIdAddressesAddressIdParams, reqEditors ...RequestEditorFn) (*GetCustomersIdAddressesAddressIdResponse, error) {
	rsp, err := c.GetCustomersIdAddressesAddressId(ctx, id, addressId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersIdAddressesAddressIdResponse(rsp)
}

// PostCustomersIdAddressesAddressIdWithBodyWithResponse request with arbitrary body returning *PostCustomersIdAddressesAddressIdResponse
func (c *ClientWithResponses) PostCustomersIdAddressesAddressIdWithBodyWithResponse(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesAddressIdResponse, error) {
	rsp, err := c.PostCustomersIdAddressesAddressIdWithBody(ctx, id, addressId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdAddressesAddressIdResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersIdAddressesAddressIdWithResponse(ctx context.Context, id string, addressId string, params *PostCustomersIdAddressesAddressIdParams, body PostCustomersIdAddressesAddressIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersIdAddressesAddressIdResponse, error) {
	rsp, err := c.PostCustomersIdAddressesAddressId(ctx, id, addressId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdAddressesAddressIdResponse(rsp)
}

// GetDraftOrdersWithResponse request returning *GetDraftOrdersResponse
func (c *ClientWithResponses) GetDraftOrdersWithResponse(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*GetDraftOrdersResponse, error) {
	rsp, err := c.GetDraftOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDraftOrdersResponse(rsp)
}

// PostDraftOrdersWithBodyWithResponse request with arbitrary body returning *PostDraftOrdersResponse
func (c *ClientWithResponses) PostDraftOrdersWithBodyWithResponse(ctx context.Context, params *PostDraftOrdersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error) {
	rsp, err := c.PostDraftOrdersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersResponse(rsp)
}

func (c *ClientWithResponses) PostDraftOrdersWithResponse(ctx context.Context, params *PostDraftOrdersParams, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error) {
	rsp, err := c.PostDraftOrders(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersResponse(rsp)
}

// GetDraftOrdersIdWithResponse request returning *GetDraftOrdersIdResponse
func (c *ClientWithResponses) GetDraftOrdersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDraftOrdersIdResponse, error) {
	rsp, err := c.GetDraftOrdersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDraftOrdersIdResponse(rsp)
}

// GetExchangesWithResponse request returning *GetExchangesResponse
func (c *ClientWithResponses) GetExchangesWithResponse(ctx context.Context, params *GetExchangesParams, reqEditors ...RequestEditorFn) (*GetExchangesResponse, error) {
	rsp, err := c.GetExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesResponse(rsp)
}

// PostExchangesWithBodyWithResponse request with arbitrary body returning *PostExchangesResponse
func (c *ClientWithResponses) PostExchangesWithBodyWithResponse(ctx context.Context, params *PostExchangesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesResponse, error) {
	rsp, err := c.PostExchangesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesWithResponse(ctx context.Context, params *PostExchangesParams, body PostExchangesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesResponse, error) {
	rsp, err := c.PostExchanges(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesResponse(rsp)
}

// GetExchangesIdWithResponse request returning *GetExchangesIdResponse
func (c *ClientWithResponses) GetExchangesIdWithResponse(ctx context.Context, id string, params *GetExchangesIdParams, reqEditors ...RequestEditorFn) (*GetExchangesIdResponse, error) {
	rsp, err := c.GetExchangesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExchangesIdResponse(rsp)
}

// PostExchangesIdCancelWithBodyWithResponse request with arbitrary body returning *PostExchangesIdCancelResponse
func (c *ClientWithResponses) PostExchangesIdCancelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdCancelResponse, error) {
	rsp, err := c.PostExchangesIdCancelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdCancelResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdCancelWithResponse(ctx context.Context, id string, body PostExchangesIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdCancelResponse, error) {
	rsp, err := c.PostExchangesIdCancel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdCancelResponse(rsp)
}

// PostExchangesIdInboundItemsWithBodyWithResponse request with arbitrary body returning *PostExchangesIdInboundItemsResponse
func (c *ClientWithResponses) PostExchangesIdInboundItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsResponse, error) {
	rsp, err := c.PostExchangesIdInboundItemsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundItemsResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdInboundItemsWithResponse(ctx context.Context, id string, body PostExchangesIdInboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsResponse, error) {
	rsp, err := c.PostExchangesIdInboundItems(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundItemsResponse(rsp)
}

// DeleteExchangesIdInboundItemsActionIdWithResponse request returning *DeleteExchangesIdInboundItemsActionIdResponse
func (c *ClientWithResponses) DeleteExchangesIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteExchangesIdInboundItemsActionIdResponse, error) {
	rsp, err := c.DeleteExchangesIdInboundItemsActionId(ctx, id, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExchangesIdInboundItemsActionIdResponse(rsp)
}

// PostExchangesIdInboundItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostExchangesIdInboundItemsActionIdResponse
func (c *ClientWithResponses) PostExchangesIdInboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsActionIdResponse, error) {
	rsp, err := c.PostExchangesIdInboundItemsActionIdWithBody(ctx, id, actionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdInboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, body PostExchangesIdInboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundItemsActionIdResponse, error) {
	rsp, err := c.PostExchangesIdInboundItemsActionId(ctx, id, actionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundItemsActionIdResponse(rsp)
}

// PostExchangesIdInboundShippingMethodWithBodyWithResponse request with arbitrary body returning *PostExchangesIdInboundShippingMethodResponse
func (c *ClientWithResponses) PostExchangesIdInboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodResponse, error) {
	rsp, err := c.PostExchangesIdInboundShippingMethodWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundShippingMethodResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdInboundShippingMethodWithResponse(ctx context.Context, id string, body PostExchangesIdInboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodResponse, error) {
	rsp, err := c.PostExchangesIdInboundShippingMethod(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundShippingMethodResponse(rsp)
}

// DeleteExchangesIdInboundShippingMethodActionIdWithResponse request returning *DeleteExchangesIdInboundShippingMethodActionIdResponse
func (c *ClientWithResponses) DeleteExchangesIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteExchangesIdInboundShippingMethodActionIdResponse, error) {
	rsp, err := c.DeleteExchangesIdInboundShippingMethodActionId(ctx, id, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExchangesIdInboundShippingMethodActionIdResponse(rsp)
}

// PostExchangesIdInboundShippingMethodActionIdWithBodyWithResponse request with arbitrary body returning *PostExchangesIdInboundShippingMethodActionIdResponse
func (c *ClientWithResponses) PostExchangesIdInboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostExchangesIdInboundShippingMethodActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundShippingMethodActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdInboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdInboundShippingMethodActionIdParams, body PostExchangesIdInboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdInboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostExchangesIdInboundShippingMethodActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdInboundShippingMethodActionIdResponse(rsp)
}

// PostExchangesIdOutboundItemsWithBodyWithResponse request with arbitrary body returning *PostExchangesIdOutboundItemsResponse
func (c *ClientWithResponses) PostExchangesIdOutboundItemsWithBodyWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsResponse, error) {
	rsp, err := c.PostExchangesIdOutboundItemsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundItemsResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdOutboundItemsWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundItemsParams, body PostExchangesIdOutboundItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsResponse, error) {
	rsp, err := c.PostExchangesIdOutboundItems(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundItemsResponse(rsp)
}

// DeleteExchangesIdOutboundItemsActionIdWithResponse request returning *DeleteExchangesIdOutboundItemsActionIdResponse
func (c *ClientWithResponses) DeleteExchangesIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteExchangesIdOutboundItemsActionIdResponse, error) {
	rsp, err := c.DeleteExchangesIdOutboundItemsActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExchangesIdOutboundItemsActionIdResponse(rsp)
}

// PostExchangesIdOutboundItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostExchangesIdOutboundItemsActionIdResponse
func (c *ClientWithResponses) PostExchangesIdOutboundItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsActionIdResponse, error) {
	rsp, err := c.PostExchangesIdOutboundItemsActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdOutboundItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundItemsActionIdParams, body PostExchangesIdOutboundItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundItemsActionIdResponse, error) {
	rsp, err := c.PostExchangesIdOutboundItemsActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundItemsActionIdResponse(rsp)
}

// PostExchangesIdOutboundShippingMethodWithBodyWithResponse request with arbitrary body returning *PostExchangesIdOutboundShippingMethodResponse
func (c *ClientWithResponses) PostExchangesIdOutboundShippingMethodWithBodyWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodResponse, error) {
	rsp, err := c.PostExchangesIdOutboundShippingMethodWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundShippingMethodResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdOutboundShippingMethodWithResponse(ctx context.Context, id string, params *PostExchangesIdOutboundShippingMethodParams, body PostExchangesIdOutboundShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodResponse, error) {
	rsp, err := c.PostExchangesIdOutboundShippingMethod(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundShippingMethodResponse(rsp)
}

// DeleteExchangesIdOutboundShippingMethodActionIdWithResponse request returning *DeleteExchangesIdOutboundShippingMethodActionIdResponse
func (c *ClientWithResponses) DeleteExchangesIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteExchangesIdOutboundShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*DeleteExchangesIdOutboundShippingMethodActionIdResponse, error) {
	rsp, err := c.DeleteExchangesIdOutboundShippingMethodActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExchangesIdOutboundShippingMethodActionIdResponse(rsp)
}

// PostExchangesIdOutboundShippingMethodActionIdWithBodyWithResponse request with arbitrary body returning *PostExchangesIdOutboundShippingMethodActionIdResponse
func (c *ClientWithResponses) PostExchangesIdOutboundShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostExchangesIdOutboundShippingMethodActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundShippingMethodActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostExchangesIdOutboundShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostExchangesIdOutboundShippingMethodActionIdParams, body PostExchangesIdOutboundShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExchangesIdOutboundShippingMethodActionIdResponse, error) {
	rsp, err := c.PostExchangesIdOutboundShippingMethodActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdOutboundShippingMethodActionIdResponse(rsp)
}

// DeleteExchangesIdRequestWithResponse request returning *DeleteExchangesIdRequestResponse
func (c *ClientWithResponses) DeleteExchangesIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteExchangesIdRequestResponse, error) {
	rsp, err := c.DeleteExchangesIdRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExchangesIdRequestResponse(rsp)
}

// PostExchangesIdRequestWithResponse request returning *PostExchangesIdRequestResponse
func (c *ClientWithResponses) PostExchangesIdRequestWithResponse(ctx context.Context, id string, params *PostExchangesIdRequestParams, reqEditors ...RequestEditorFn) (*PostExchangesIdRequestResponse, error) {
	rsp, err := c.PostExchangesIdRequest(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExchangesIdRequestResponse(rsp)
}

// GetFulfillmentProvidersWithResponse request returning *GetFulfillmentProvidersResponse
func (c *ClientWithResponses) GetFulfillmentProvidersWithResponse(ctx context.Context, params *GetFulfillmentProvidersParams, reqEditors ...RequestEditorFn) (*GetFulfillmentProvidersResponse, error) {
	rsp, err := c.GetFulfillmentProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFulfillmentProvidersResponse(rsp)
}

// DeleteFulfillmentSetsIdWithResponse request returning *DeleteFulfillmentSetsIdResponse
func (c *ClientWithResponses) DeleteFulfillmentSetsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteFulfillmentSetsIdResponse, error) {
	rsp, err := c.DeleteFulfillmentSetsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFulfillmentSetsIdResponse(rsp)
}

// PostFulfillmentSetsIdServiceZonesWithBodyWithResponse request with arbitrary body returning *PostFulfillmentSetsIdServiceZonesResponse
func (c *ClientWithResponses) PostFulfillmentSetsIdServiceZonesWithBodyWithResponse(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesResponse, error) {
	rsp, err := c.PostFulfillmentSetsIdServiceZonesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentSetsIdServiceZonesResponse(rsp)
}

func (c *ClientWithResponses) PostFulfillmentSetsIdServiceZonesWithResponse(ctx context.Context, id string, params *PostFulfillmentSetsIdServiceZonesParams, body PostFulfillmentSetsIdServiceZonesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesResponse, error) {
	rsp, err := c.PostFulfillmentSetsIdServiceZones(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentSetsIdServiceZonesResponse(rsp)
}

// DeleteFulfillmentSetsIdServiceZonesZoneIdWithResponse request returning *DeleteFulfillmentSetsIdServiceZonesZoneIdResponse
func (c *ClientWithResponses) DeleteFulfillmentSetsIdServiceZonesZoneIdWithResponse(ctx context.Context, id string, zoneId string, reqEditors ...RequestEditorFn) (*DeleteFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	rsp, err := c.DeleteFulfillmentSetsIdServiceZonesZoneId(ctx, id, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFulfillmentSetsIdServiceZonesZoneIdResponse(rsp)
}

// GetFulfillmentSetsIdServiceZonesZoneIdWithResponse request returning *GetFulfillmentSetsIdServiceZonesZoneIdResponse
func (c *ClientWithResponses) GetFulfillmentSetsIdServiceZonesZoneIdWithResponse(ctx context.Context, id string, zoneId string, params *GetFulfillmentSetsIdServiceZonesZoneIdParams, reqEditors ...RequestEditorFn) (*GetFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	rsp, err := c.GetFulfillmentSetsIdServiceZonesZoneId(ctx, id, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFulfillmentSetsIdServiceZonesZoneIdResponse(rsp)
}

// PostFulfillmentSetsIdServiceZonesZoneIdWithBodyWithResponse request with arbitrary body returning *PostFulfillmentSetsIdServiceZonesZoneIdResponse
func (c *ClientWithResponses) PostFulfillmentSetsIdServiceZonesZoneIdWithBodyWithResponse(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	rsp, err := c.PostFulfillmentSetsIdServiceZonesZoneIdWithBody(ctx, id, zoneId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentSetsIdServiceZonesZoneIdResponse(rsp)
}

func (c *ClientWithResponses) PostFulfillmentSetsIdServiceZonesZoneIdWithResponse(ctx context.Context, id string, zoneId string, params *PostFulfillmentSetsIdServiceZonesZoneIdParams, body PostFulfillmentSetsIdServiceZonesZoneIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	rsp, err := c.PostFulfillmentSetsIdServiceZonesZoneId(ctx, id, zoneId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentSetsIdServiceZonesZoneIdResponse(rsp)
}

// PostFulfillmentsWithBodyWithResponse request with arbitrary body returning *PostFulfillmentsResponse
func (c *ClientWithResponses) PostFulfillmentsWithBodyWithResponse(ctx context.Context, params *PostFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentsResponse, error) {
	rsp, err := c.PostFulfillmentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentsResponse(rsp)
}

func (c *ClientWithResponses) PostFulfillmentsWithResponse(ctx context.Context, params *PostFulfillmentsParams, body PostFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentsResponse, error) {
	rsp, err := c.PostFulfillments(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentsResponse(rsp)
}

// PostFulfillmentsIdCancelWithResponse request returning *PostFulfillmentsIdCancelResponse
func (c *ClientWithResponses) PostFulfillmentsIdCancelWithResponse(ctx context.Context, id string, params *PostFulfillmentsIdCancelParams, reqEditors ...RequestEditorFn) (*PostFulfillmentsIdCancelResponse, error) {
	rsp, err := c.PostFulfillmentsIdCancel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentsIdCancelResponse(rsp)
}

// PostFulfillmentsIdShipmentWithBodyWithResponse request with arbitrary body returning *PostFulfillmentsIdShipmentResponse
func (c *ClientWithResponses) PostFulfillmentsIdShipmentWithBodyWithResponse(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFulfillmentsIdShipmentResponse, error) {
	rsp, err := c.PostFulfillmentsIdShipmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentsIdShipmentResponse(rsp)
}

func (c *ClientWithResponses) PostFulfillmentsIdShipmentWithResponse(ctx context.Context, id string, params *PostFulfillmentsIdShipmentParams, body PostFulfillmentsIdShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFulfillmentsIdShipmentResponse, error) {
	rsp, err := c.PostFulfillmentsIdShipment(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFulfillmentsIdShipmentResponse(rsp)
}

// GetInventoryItemsWithResponse request returning *GetInventoryItemsResponse
func (c *ClientWithResponses) GetInventoryItemsWithResponse(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsResponse, error) {
	rsp, err := c.GetInventoryItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemsResponse(rsp)
}

// PostInventoryItemsWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsResponse
func (c *ClientWithResponses) PostInventoryItemsWithBodyWithResponse(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error) {
	rsp, err := c.PostInventoryItemsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsWithResponse(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error) {
	rsp, err := c.PostInventoryItems(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsResponse(rsp)
}

// DeleteInventoryItemsIdWithResponse request returning *DeleteInventoryItemsIdResponse
func (c *ClientWithResponses) DeleteInventoryItemsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsIdResponse, error) {
	rsp, err := c.DeleteInventoryItemsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryItemsIdResponse(rsp)
}

// GetInventoryItemsIdWithResponse request returning *GetInventoryItemsIdResponse
func (c *ClientWithResponses) GetInventoryItemsIdWithResponse(ctx context.Context, id string, params *GetInventoryItemsIdParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsIdResponse, error) {
	rsp, err := c.GetInventoryItemsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemsIdResponse(rsp)
}

// PostInventoryItemsIdWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsIdResponse
func (c *ClientWithResponses) PostInventoryItemsIdWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdResponse, error) {
	rsp, err := c.PostInventoryItemsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsIdWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdParams, body PostInventoryItemsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdResponse, error) {
	rsp, err := c.PostInventoryItemsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdResponse(rsp)
}

// GetInventoryItemsIdLocationLevelsWithResponse request returning *GetInventoryItemsIdLocationLevelsResponse
func (c *ClientWithResponses) GetInventoryItemsIdLocationLevelsWithResponse(ctx context.Context, id string, params *GetInventoryItemsIdLocationLevelsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsIdLocationLevelsResponse, error) {
	rsp, err := c.GetInventoryItemsIdLocationLevels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemsIdLocationLevelsResponse(rsp)
}

// PostInventoryItemsIdLocationLevelsWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsIdLocationLevelsResponse
func (c *ClientWithResponses) PostInventoryItemsIdLocationLevelsWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsResponse, error) {
	rsp, err := c.PostInventoryItemsIdLocationLevelsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdLocationLevelsResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsIdLocationLevelsWithResponse(ctx context.Context, id string, params *PostInventoryItemsIdLocationLevelsParams, body PostInventoryItemsIdLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsResponse, error) {
	rsp, err := c.PostInventoryItemsIdLocationLevels(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdLocationLevelsResponse(rsp)
}

// PostInventoryItemsIdLocationLevelsBatchWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsIdLocationLevelsBatchResponse
func (c *ClientWithResponses) PostInventoryItemsIdLocationLevelsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsBatchResponse, error) {
	rsp, err := c.PostInventoryItemsIdLocationLevelsBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdLocationLevelsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsIdLocationLevelsBatchWithResponse(ctx context.Context, id string, body PostInventoryItemsIdLocationLevelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsBatchResponse, error) {
	rsp, err := c.PostInventoryItemsIdLocationLevelsBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdLocationLevelsBatchResponse(rsp)
}

// DeleteInventoryItemsIdLocationLevelsLocationIdWithResponse request returning *DeleteInventoryItemsIdLocationLevelsLocationIdResponse
func (c *ClientWithResponses) DeleteInventoryItemsIdLocationLevelsLocationIdWithResponse(ctx context.Context, id string, locationId string, params *DeleteInventoryItemsIdLocationLevelsLocationIdParams, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsIdLocationLevelsLocationIdResponse, error) {
	rsp, err := c.DeleteInventoryItemsIdLocationLevelsLocationId(ctx, id, locationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryItemsIdLocationLevelsLocationIdResponse(rsp)
}

// PostInventoryItemsIdLocationLevelsLocationIdWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsIdLocationLevelsLocationIdResponse
func (c *ClientWithResponses) PostInventoryItemsIdLocationLevelsLocationIdWithBodyWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsLocationIdResponse, error) {
	rsp, err := c.PostInventoryItemsIdLocationLevelsLocationIdWithBody(ctx, id, locationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdLocationLevelsLocationIdResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsIdLocationLevelsLocationIdWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsIdLocationLevelsLocationIdParams, body PostInventoryItemsIdLocationLevelsLocationIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsIdLocationLevelsLocationIdResponse, error) {
	rsp, err := c.PostInventoryItemsIdLocationLevelsLocationId(ctx, id, locationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsIdLocationLevelsLocationIdResponse(rsp)
}

// GetInvitesWithResponse request returning *GetInvitesResponse
func (c *ClientWithResponses) GetInvitesWithResponse(ctx context.Context, params *GetInvitesParams, reqEditors ...RequestEditorFn) (*GetInvitesResponse, error) {
	rsp, err := c.GetInvites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvitesResponse(rsp)
}

// PostInvitesWithBodyWithResponse request with arbitrary body returning *PostInvitesResponse
func (c *ClientWithResponses) PostInvitesWithBodyWithResponse(ctx context.Context, params *PostInvitesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error) {
	rsp, err := c.PostInvitesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesResponse(rsp)
}

func (c *ClientWithResponses) PostInvitesWithResponse(ctx context.Context, params *PostInvitesParams, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error) {
	rsp, err := c.PostInvites(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesResponse(rsp)
}

// PostInvitesAcceptWithBodyWithResponse request with arbitrary body returning *PostInvitesAcceptResponse
func (c *ClientWithResponses) PostInvitesAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesAcceptResponse, error) {
	rsp, err := c.PostInvitesAcceptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesAcceptResponse(rsp)
}

func (c *ClientWithResponses) PostInvitesAcceptWithResponse(ctx context.Context, body PostInvitesAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesAcceptResponse, error) {
	rsp, err := c.PostInvitesAccept(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesAcceptResponse(rsp)
}

// DeleteInvitesIdWithResponse request returning *DeleteInvitesIdResponse
func (c *ClientWithResponses) DeleteInvitesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInvitesIdResponse, error) {
	rsp, err := c.DeleteInvitesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInvitesIdResponse(rsp)
}

// GetInvitesIdWithResponse request returning *GetInvitesIdResponse
func (c *ClientWithResponses) GetInvitesIdWithResponse(ctx context.Context, id string, params *GetInvitesIdParams, reqEditors ...RequestEditorFn) (*GetInvitesIdResponse, error) {
	rsp, err := c.GetInvitesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvitesIdResponse(rsp)
}

// PostInvitesIdResendWithResponse request returning *PostInvitesIdResendResponse
func (c *ClientWithResponses) PostInvitesIdResendWithResponse(ctx context.Context, id string, params *PostInvitesIdResendParams, reqEditors ...RequestEditorFn) (*PostInvitesIdResendResponse, error) {
	rsp, err := c.PostInvitesIdResend(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesIdResendResponse(rsp)
}

// GetNotificationsWithResponse request returning *GetNotificationsResponse
func (c *ClientWithResponses) GetNotificationsWithResponse(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error) {
	rsp, err := c.GetNotifications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsResponse(rsp)
}

// GetNotificationsIdWithResponse request returning *GetNotificationsIdResponse
func (c *ClientWithResponses) GetNotificationsIdWithResponse(ctx context.Context, id string, params *GetNotificationsIdParams, reqEditors ...RequestEditorFn) (*GetNotificationsIdResponse, error) {
	rsp, err := c.GetNotificationsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsIdResponse(rsp)
}

// PostOrderEditsWithBodyWithResponse request with arbitrary body returning *PostOrderEditsResponse
func (c *ClientWithResponses) PostOrderEditsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error) {
	rsp, err := c.PostOrderEditsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsWithResponse(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error) {
	rsp, err := c.PostOrderEdits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsResponse(rsp)
}

// DeleteOrderEditsIdWithResponse request returning *DeleteOrderEditsIdResponse
func (c *ClientWithResponses) DeleteOrderEditsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsIdResponse, error) {
	rsp, err := c.DeleteOrderEditsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderEditsIdResponse(rsp)
}

// PostOrderEditsIdConfirmWithResponse request returning *PostOrderEditsIdConfirmResponse
func (c *ClientWithResponses) PostOrderEditsIdConfirmWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsIdConfirmResponse, error) {
	rsp, err := c.PostOrderEditsIdConfirm(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdConfirmResponse(rsp)
}

// PostOrderEditsIdItemsWithBodyWithResponse request with arbitrary body returning *PostOrderEditsIdItemsResponse
func (c *ClientWithResponses) PostOrderEditsIdItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsResponse, error) {
	rsp, err := c.PostOrderEditsIdItemsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdItemsResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsIdItemsWithResponse(ctx context.Context, id string, body PostOrderEditsIdItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsResponse, error) {
	rsp, err := c.PostOrderEditsIdItems(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdItemsResponse(rsp)
}

// PostOrderEditsIdItemsItemItemIdWithBodyWithResponse request with arbitrary body returning *PostOrderEditsIdItemsItemItemIdResponse
func (c *ClientWithResponses) PostOrderEditsIdItemsItemItemIdWithBodyWithResponse(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsItemItemIdResponse, error) {
	rsp, err := c.PostOrderEditsIdItemsItemItemIdWithBody(ctx, id, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdItemsItemItemIdResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsIdItemsItemItemIdWithResponse(ctx context.Context, id string, itemId string, body PostOrderEditsIdItemsItemItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsItemItemIdResponse, error) {
	rsp, err := c.PostOrderEditsIdItemsItemItemId(ctx, id, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdItemsItemItemIdResponse(rsp)
}

// DeleteOrderEditsIdItemsActionIdWithResponse request returning *DeleteOrderEditsIdItemsActionIdResponse
func (c *ClientWithResponses) DeleteOrderEditsIdItemsActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsIdItemsActionIdResponse, error) {
	rsp, err := c.DeleteOrderEditsIdItemsActionId(ctx, id, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderEditsIdItemsActionIdResponse(rsp)
}

// PostOrderEditsIdItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostOrderEditsIdItemsActionIdResponse
func (c *ClientWithResponses) PostOrderEditsIdItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsActionIdResponse, error) {
	rsp, err := c.PostOrderEditsIdItemsActionIdWithBody(ctx, id, actionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsIdItemsActionIdWithResponse(ctx context.Context, id string, actionId string, body PostOrderEditsIdItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdItemsActionIdResponse, error) {
	rsp, err := c.PostOrderEditsIdItemsActionId(ctx, id, actionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdItemsActionIdResponse(rsp)
}

// PostOrderEditsIdRequestWithResponse request returning *PostOrderEditsIdRequestResponse
func (c *ClientWithResponses) PostOrderEditsIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsIdRequestResponse, error) {
	rsp, err := c.PostOrderEditsIdRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdRequestResponse(rsp)
}

// PostOrderEditsIdShippingMethodWithBodyWithResponse request with arbitrary body returning *PostOrderEditsIdShippingMethodResponse
func (c *ClientWithResponses) PostOrderEditsIdShippingMethodWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodResponse, error) {
	rsp, err := c.PostOrderEditsIdShippingMethodWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdShippingMethodResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsIdShippingMethodWithResponse(ctx context.Context, id string, body PostOrderEditsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodResponse, error) {
	rsp, err := c.PostOrderEditsIdShippingMethod(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdShippingMethodResponse(rsp)
}

// DeleteOrderEditsIdShippingMethodActionIdWithResponse request returning *DeleteOrderEditsIdShippingMethodActionIdResponse
func (c *ClientWithResponses) DeleteOrderEditsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsIdShippingMethodActionIdResponse, error) {
	rsp, err := c.DeleteOrderEditsIdShippingMethodActionId(ctx, id, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderEditsIdShippingMethodActionIdResponse(rsp)
}

// PostOrderEditsIdShippingMethodActionIdWithBodyWithResponse request with arbitrary body returning *PostOrderEditsIdShippingMethodActionIdResponse
func (c *ClientWithResponses) PostOrderEditsIdShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodActionIdResponse, error) {
	rsp, err := c.PostOrderEditsIdShippingMethodActionIdWithBody(ctx, id, actionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdShippingMethodActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, body PostOrderEditsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsIdShippingMethodActionIdResponse, error) {
	rsp, err := c.PostOrderEditsIdShippingMethodActionId(ctx, id, actionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsIdShippingMethodActionIdResponse(rsp)
}

// GetOrdersWithResponse request returning *GetOrdersResponse
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error) {
	rsp, err := c.GetOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResponse(rsp)
}

// GetOrdersIdWithResponse request returning *GetOrdersIdResponse
func (c *ClientWithResponses) GetOrdersIdWithResponse(ctx context.Context, id string, params *GetOrdersIdParams, reqEditors ...RequestEditorFn) (*GetOrdersIdResponse, error) {
	rsp, err := c.GetOrdersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersIdResponse(rsp)
}

// PostOrdersIdWithResponse request returning *PostOrdersIdResponse
func (c *ClientWithResponses) PostOrdersIdWithResponse(ctx context.Context, id string, params *PostOrdersIdParams, reqEditors ...RequestEditorFn) (*PostOrdersIdResponse, error) {
	rsp, err := c.PostOrdersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdResponse(rsp)
}

// PostOrdersIdArchiveWithResponse request returning *PostOrdersIdArchiveResponse
func (c *ClientWithResponses) PostOrdersIdArchiveWithResponse(ctx context.Context, id string, params *PostOrdersIdArchiveParams, reqEditors ...RequestEditorFn) (*PostOrdersIdArchiveResponse, error) {
	rsp, err := c.PostOrdersIdArchive(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdArchiveResponse(rsp)
}

// PostOrdersIdCancelWithResponse request returning *PostOrdersIdCancelResponse
func (c *ClientWithResponses) PostOrdersIdCancelWithResponse(ctx context.Context, id string, params *PostOrdersIdCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersIdCancelResponse, error) {
	rsp, err := c.PostOrdersIdCancel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdCancelResponse(rsp)
}

// GetOrdersIdChangesWithResponse request returning *GetOrdersIdChangesResponse
func (c *ClientWithResponses) GetOrdersIdChangesWithResponse(ctx context.Context, id string, params *GetOrdersIdChangesParams, reqEditors ...RequestEditorFn) (*GetOrdersIdChangesResponse, error) {
	rsp, err := c.GetOrdersIdChanges(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersIdChangesResponse(rsp)
}

// PostOrdersIdCompleteWithBodyWithResponse request with arbitrary body returning *PostOrdersIdCompleteResponse
func (c *ClientWithResponses) PostOrdersIdCompleteWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersIdCompleteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdCompleteResponse, error) {
	rsp, err := c.PostOrdersIdCompleteWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdCompleteResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersIdCompleteWithResponse(ctx context.Context, id string, params *PostOrdersIdCompleteParams, body PostOrdersIdCompleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdCompleteResponse, error) {
	rsp, err := c.PostOrdersIdComplete(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdCompleteResponse(rsp)
}

// PostOrdersIdFulfillmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersIdFulfillmentsResponse
func (c *ClientWithResponses) PostOrdersIdFulfillmentsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersIdFulfillmentsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersIdFulfillmentsWithResponse(ctx context.Context, id string, params *PostOrdersIdFulfillmentsParams, body PostOrdersIdFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersIdFulfillments(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsResponse(rsp)
}

// PostOrdersIdFulfillmentsFulfillmentIdCancelWithBodyWithResponse request with arbitrary body returning *PostOrdersIdFulfillmentsFulfillmentIdCancelResponse
func (c *ClientWithResponses) PostOrdersIdFulfillmentsFulfillmentIdCancelWithBodyWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdCancelResponse, error) {
	rsp, err := c.PostOrdersIdFulfillmentsFulfillmentIdCancelWithBody(ctx, id, fulfillmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsFulfillmentIdCancelResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersIdFulfillmentsFulfillmentIdCancelWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdCancelParams, body PostOrdersIdFulfillmentsFulfillmentIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdCancelResponse, error) {
	rsp, err := c.PostOrdersIdFulfillmentsFulfillmentIdCancel(ctx, id, fulfillmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsFulfillmentIdCancelResponse(rsp)
}

// PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredWithResponse request returning *PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse
func (c *ClientWithResponses) PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredParams, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse, error) {
	rsp, err := c.PostOrdersIdFulfillmentsFulfillmentIdMarkAsDelivered(ctx, id, fulfillmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse(rsp)
}

// PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse
func (c *ClientWithResponses) PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBodyWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse, error) {
	rsp, err := c.PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithBody(ctx, id, fulfillmentId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersIdFulfillmentsFulfillmentIdShipmentsParams, body PostOrdersIdFulfillmentsFulfillmentIdShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse, error) {
	rsp, err := c.PostOrdersIdFulfillmentsFulfillmentIdShipments(ctx, id, fulfillmentId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse(rsp)
}

// GetOrdersIdPreviewWithResponse request returning *GetOrdersIdPreviewResponse
func (c *ClientWithResponses) GetOrdersIdPreviewWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetOrdersIdPreviewResponse, error) {
	rsp, err := c.GetOrdersIdPreview(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersIdPreviewResponse(rsp)
}

// PostPaymentCollectionsWithBodyWithResponse request with arbitrary body returning *PostPaymentCollectionsResponse
func (c *ClientWithResponses) PostPaymentCollectionsWithBodyWithResponse(ctx context.Context, params *PostPaymentCollectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsResponse, error) {
	rsp, err := c.PostPaymentCollectionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsResponse(rsp)
}

func (c *ClientWithResponses) PostPaymentCollectionsWithResponse(ctx context.Context, params *PostPaymentCollectionsParams, body PostPaymentCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsResponse, error) {
	rsp, err := c.PostPaymentCollections(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsResponse(rsp)
}

// DeletePaymentCollectionsIdWithResponse request returning *DeletePaymentCollectionsIdResponse
func (c *ClientWithResponses) DeletePaymentCollectionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePaymentCollectionsIdResponse, error) {
	rsp, err := c.DeletePaymentCollectionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentCollectionsIdResponse(rsp)
}

// PostPaymentCollectionsIdMarkAsPaidWithBodyWithResponse request with arbitrary body returning *PostPaymentCollectionsIdMarkAsPaidResponse
func (c *ClientWithResponses) PostPaymentCollectionsIdMarkAsPaidWithBodyWithResponse(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsIdMarkAsPaidResponse, error) {
	rsp, err := c.PostPaymentCollectionsIdMarkAsPaidWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsIdMarkAsPaidResponse(rsp)
}

func (c *ClientWithResponses) PostPaymentCollectionsIdMarkAsPaidWithResponse(ctx context.Context, id string, params *PostPaymentCollectionsIdMarkAsPaidParams, body PostPaymentCollectionsIdMarkAsPaidJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsIdMarkAsPaidResponse, error) {
	rsp, err := c.PostPaymentCollectionsIdMarkAsPaid(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsIdMarkAsPaidResponse(rsp)
}

// GetPaymentsWithResponse request returning *GetPaymentsResponse
func (c *ClientWithResponses) GetPaymentsWithResponse(ctx context.Context, params *GetPaymentsParams, reqEditors ...RequestEditorFn) (*GetPaymentsResponse, error) {
	rsp, err := c.GetPayments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentsResponse(rsp)
}

// GetPaymentsPaymentProvidersWithResponse request returning *GetPaymentsPaymentProvidersResponse
func (c *ClientWithResponses) GetPaymentsPaymentProvidersWithResponse(ctx context.Context, params *GetPaymentsPaymentProvidersParams, reqEditors ...RequestEditorFn) (*GetPaymentsPaymentProvidersResponse, error) {
	rsp, err := c.GetPaymentsPaymentProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentsPaymentProvidersResponse(rsp)
}

// GetPaymentsIdWithResponse request returning *GetPaymentsIdResponse
func (c *ClientWithResponses) GetPaymentsIdWithResponse(ctx context.Context, id string, params *GetPaymentsIdParams, reqEditors ...RequestEditorFn) (*GetPaymentsIdResponse, error) {
	rsp, err := c.GetPaymentsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentsIdResponse(rsp)
}

// PostPaymentsIdCaptureWithBodyWithResponse request with arbitrary body returning *PostPaymentsIdCaptureResponse
func (c *ClientWithResponses) PostPaymentsIdCaptureWithBodyWithResponse(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentsIdCaptureResponse, error) {
	rsp, err := c.PostPaymentsIdCaptureWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsIdCaptureResponse(rsp)
}

func (c *ClientWithResponses) PostPaymentsIdCaptureWithResponse(ctx context.Context, id string, params *PostPaymentsIdCaptureParams, body PostPaymentsIdCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentsIdCaptureResponse, error) {
	rsp, err := c.PostPaymentsIdCapture(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsIdCaptureResponse(rsp)
}

// PostPaymentsIdRefundWithBodyWithResponse request with arbitrary body returning *PostPaymentsIdRefundResponse
func (c *ClientWithResponses) PostPaymentsIdRefundWithBodyWithResponse(ctx context.Context, id string, params *PostPaymentsIdRefundParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentsIdRefundResponse, error) {
	rsp, err := c.PostPaymentsIdRefundWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsIdRefundResponse(rsp)
}

func (c *ClientWithResponses) PostPaymentsIdRefundWithResponse(ctx context.Context, id string, params *PostPaymentsIdRefundParams, body PostPaymentsIdRefundJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentsIdRefundResponse, error) {
	rsp, err := c.PostPaymentsIdRefund(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsIdRefundResponse(rsp)
}

// GetPriceListsWithResponse request returning *GetPriceListsResponse
func (c *ClientWithResponses) GetPriceListsWithResponse(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*GetPriceListsResponse, error) {
	rsp, err := c.GetPriceLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPriceListsResponse(rsp)
}

// PostPriceListsWithBodyWithResponse request with arbitrary body returning *PostPriceListsResponse
func (c *ClientWithResponses) PostPriceListsWithBodyWithResponse(ctx context.Context, params *PostPriceListsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsResponse, error) {
	rsp, err := c.PostPriceListsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsWithResponse(ctx context.Context, params *PostPriceListsParams, body PostPriceListsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsResponse, error) {
	rsp, err := c.PostPriceLists(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsResponse(rsp)
}

// DeletePriceListsIdWithResponse request returning *DeletePriceListsIdResponse
func (c *ClientWithResponses) DeletePriceListsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePriceListsIdResponse, error) {
	rsp, err := c.DeletePriceListsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsIdResponse(rsp)
}

// GetPriceListsIdWithResponse request returning *GetPriceListsIdResponse
func (c *ClientWithResponses) GetPriceListsIdWithResponse(ctx context.Context, id string, params *GetPriceListsIdParams, reqEditors ...RequestEditorFn) (*GetPriceListsIdResponse, error) {
	rsp, err := c.GetPriceListsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPriceListsIdResponse(rsp)
}

// PostPriceListsIdWithBodyWithResponse request with arbitrary body returning *PostPriceListsIdResponse
func (c *ClientWithResponses) PostPriceListsIdWithBodyWithResponse(ctx context.Context, id string, params *PostPriceListsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsIdResponse, error) {
	rsp, err := c.PostPriceListsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsIdResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsIdWithResponse(ctx context.Context, id string, params *PostPriceListsIdParams, body PostPriceListsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsIdResponse, error) {
	rsp, err := c.PostPriceListsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsIdResponse(rsp)
}

// PostPriceListsIdPricesBatchWithBodyWithResponse request with arbitrary body returning *PostPriceListsIdPricesBatchResponse
func (c *ClientWithResponses) PostPriceListsIdPricesBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsIdPricesBatchResponse, error) {
	rsp, err := c.PostPriceListsIdPricesBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsIdPricesBatchResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsIdPricesBatchWithResponse(ctx context.Context, id string, body PostPriceListsIdPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsIdPricesBatchResponse, error) {
	rsp, err := c.PostPriceListsIdPricesBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsIdPricesBatchResponse(rsp)
}

// PostPriceListsIdProductsWithBodyWithResponse request with arbitrary body returning *PostPriceListsIdProductsResponse
func (c *ClientWithResponses) PostPriceListsIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostPriceListsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsIdProductsResponse, error) {
	rsp, err := c.PostPriceListsIdProductsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsIdProductsResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsIdProductsWithResponse(ctx context.Context, id string, params *PostPriceListsIdProductsParams, body PostPriceListsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsIdProductsResponse, error) {
	rsp, err := c.PostPriceListsIdProducts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsIdProductsResponse(rsp)
}

// GetPricePreferencesWithResponse request returning *GetPricePreferencesResponse
func (c *ClientWithResponses) GetPricePreferencesWithResponse(ctx context.Context, params *GetPricePreferencesParams, reqEditors ...RequestEditorFn) (*GetPricePreferencesResponse, error) {
	rsp, err := c.GetPricePreferences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricePreferencesResponse(rsp)
}

// PostPricePreferencesWithBodyWithResponse request with arbitrary body returning *PostPricePreferencesResponse
func (c *ClientWithResponses) PostPricePreferencesWithBodyWithResponse(ctx context.Context, params *PostPricePreferencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPricePreferencesResponse, error) {
	rsp, err := c.PostPricePreferencesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPricePreferencesResponse(rsp)
}

func (c *ClientWithResponses) PostPricePreferencesWithResponse(ctx context.Context, params *PostPricePreferencesParams, body PostPricePreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPricePreferencesResponse, error) {
	rsp, err := c.PostPricePreferences(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPricePreferencesResponse(rsp)
}

// DeletePricePreferencesIdWithResponse request returning *DeletePricePreferencesIdResponse
func (c *ClientWithResponses) DeletePricePreferencesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePricePreferencesIdResponse, error) {
	rsp, err := c.DeletePricePreferencesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePricePreferencesIdResponse(rsp)
}

// GetPricePreferencesIdWithResponse request returning *GetPricePreferencesIdResponse
func (c *ClientWithResponses) GetPricePreferencesIdWithResponse(ctx context.Context, id string, params *GetPricePreferencesIdParams, reqEditors ...RequestEditorFn) (*GetPricePreferencesIdResponse, error) {
	rsp, err := c.GetPricePreferencesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricePreferencesIdResponse(rsp)
}

// PostPricePreferencesIdWithBodyWithResponse request with arbitrary body returning *PostPricePreferencesIdResponse
func (c *ClientWithResponses) PostPricePreferencesIdWithBodyWithResponse(ctx context.Context, id string, params *PostPricePreferencesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPricePreferencesIdResponse, error) {
	rsp, err := c.PostPricePreferencesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPricePreferencesIdResponse(rsp)
}

func (c *ClientWithResponses) PostPricePreferencesIdWithResponse(ctx context.Context, id string, params *PostPricePreferencesIdParams, body PostPricePreferencesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPricePreferencesIdResponse, error) {
	rsp, err := c.PostPricePreferencesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPricePreferencesIdResponse(rsp)
}

// GetProductCategoriesWithResponse request returning *GetProductCategoriesResponse
func (c *ClientWithResponses) GetProductCategoriesWithResponse(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesResponse, error) {
	rsp, err := c.GetProductCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductCategoriesResponse(rsp)
}

// PostProductCategoriesWithBodyWithResponse request with arbitrary body returning *PostProductCategoriesResponse
func (c *ClientWithResponses) PostProductCategoriesWithBodyWithResponse(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error) {
	rsp, err := c.PostProductCategoriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesResponse(rsp)
}

func (c *ClientWithResponses) PostProductCategoriesWithResponse(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error) {
	rsp, err := c.PostProductCategories(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesResponse(rsp)
}

// DeleteProductCategoriesIdWithResponse request returning *DeleteProductCategoriesIdResponse
func (c *ClientWithResponses) DeleteProductCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesIdResponse, error) {
	rsp, err := c.DeleteProductCategoriesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductCategoriesIdResponse(rsp)
}

// GetProductCategoriesIdWithResponse request returning *GetProductCategoriesIdResponse
func (c *ClientWithResponses) GetProductCategoriesIdWithResponse(ctx context.Context, id string, params *GetProductCategoriesIdParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesIdResponse, error) {
	rsp, err := c.GetProductCategoriesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductCategoriesIdResponse(rsp)
}

// PostProductCategoriesIdWithBodyWithResponse request with arbitrary body returning *PostProductCategoriesIdResponse
func (c *ClientWithResponses) PostProductCategoriesIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdResponse, error) {
	rsp, err := c.PostProductCategoriesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductCategoriesIdWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdParams, body PostProductCategoriesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdResponse, error) {
	rsp, err := c.PostProductCategoriesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesIdResponse(rsp)
}

// PostProductCategoriesIdProductsWithBodyWithResponse request with arbitrary body returning *PostProductCategoriesIdProductsResponse
func (c *ClientWithResponses) PostProductCategoriesIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdProductsResponse, error) {
	rsp, err := c.PostProductCategoriesIdProductsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesIdProductsResponse(rsp)
}

func (c *ClientWithResponses) PostProductCategoriesIdProductsWithResponse(ctx context.Context, id string, params *PostProductCategoriesIdProductsParams, body PostProductCategoriesIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesIdProductsResponse, error) {
	rsp, err := c.PostProductCategoriesIdProducts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesIdProductsResponse(rsp)
}

// GetProductTagsWithResponse request returning *GetProductTagsResponse
func (c *ClientWithResponses) GetProductTagsWithResponse(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*GetProductTagsResponse, error) {
	rsp, err := c.GetProductTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductTagsResponse(rsp)
}

// PostProductTagsWithBodyWithResponse request with arbitrary body returning *PostProductTagsResponse
func (c *ClientWithResponses) PostProductTagsWithBodyWithResponse(ctx context.Context, params *PostProductTagsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTagsResponse, error) {
	rsp, err := c.PostProductTagsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTagsResponse(rsp)
}

func (c *ClientWithResponses) PostProductTagsWithResponse(ctx context.Context, params *PostProductTagsParams, body PostProductTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTagsResponse, error) {
	rsp, err := c.PostProductTags(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTagsResponse(rsp)
}

// DeleteProductTagsIdWithResponse request returning *DeleteProductTagsIdResponse
func (c *ClientWithResponses) DeleteProductTagsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductTagsIdResponse, error) {
	rsp, err := c.DeleteProductTagsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductTagsIdResponse(rsp)
}

// GetProductTagsIdWithResponse request returning *GetProductTagsIdResponse
func (c *ClientWithResponses) GetProductTagsIdWithResponse(ctx context.Context, id string, params *GetProductTagsIdParams, reqEditors ...RequestEditorFn) (*GetProductTagsIdResponse, error) {
	rsp, err := c.GetProductTagsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductTagsIdResponse(rsp)
}

// PostProductTagsIdWithBodyWithResponse request with arbitrary body returning *PostProductTagsIdResponse
func (c *ClientWithResponses) PostProductTagsIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductTagsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTagsIdResponse, error) {
	rsp, err := c.PostProductTagsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTagsIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductTagsIdWithResponse(ctx context.Context, id string, params *PostProductTagsIdParams, body PostProductTagsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTagsIdResponse, error) {
	rsp, err := c.PostProductTagsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTagsIdResponse(rsp)
}

// GetProductTypesWithResponse request returning *GetProductTypesResponse
func (c *ClientWithResponses) GetProductTypesWithResponse(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*GetProductTypesResponse, error) {
	rsp, err := c.GetProductTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductTypesResponse(rsp)
}

// PostProductTypesWithBodyWithResponse request with arbitrary body returning *PostProductTypesResponse
func (c *ClientWithResponses) PostProductTypesWithBodyWithResponse(ctx context.Context, params *PostProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTypesResponse, error) {
	rsp, err := c.PostProductTypesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTypesResponse(rsp)
}

func (c *ClientWithResponses) PostProductTypesWithResponse(ctx context.Context, params *PostProductTypesParams, body PostProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTypesResponse, error) {
	rsp, err := c.PostProductTypes(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTypesResponse(rsp)
}

// DeleteProductTypesIdWithResponse request returning *DeleteProductTypesIdResponse
func (c *ClientWithResponses) DeleteProductTypesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductTypesIdResponse, error) {
	rsp, err := c.DeleteProductTypesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductTypesIdResponse(rsp)
}

// GetProductTypesIdWithResponse request returning *GetProductTypesIdResponse
func (c *ClientWithResponses) GetProductTypesIdWithResponse(ctx context.Context, id string, params *GetProductTypesIdParams, reqEditors ...RequestEditorFn) (*GetProductTypesIdResponse, error) {
	rsp, err := c.GetProductTypesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductTypesIdResponse(rsp)
}

// PostProductTypesIdWithBodyWithResponse request with arbitrary body returning *PostProductTypesIdResponse
func (c *ClientWithResponses) PostProductTypesIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductTypesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductTypesIdResponse, error) {
	rsp, err := c.PostProductTypesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTypesIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductTypesIdWithResponse(ctx context.Context, id string, params *PostProductTypesIdParams, body PostProductTypesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductTypesIdResponse, error) {
	rsp, err := c.PostProductTypesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductTypesIdResponse(rsp)
}

// GetProductVariantsWithResponse request returning *GetProductVariantsResponse
func (c *ClientWithResponses) GetProductVariantsWithResponse(ctx context.Context, params *GetProductVariantsParams, reqEditors ...RequestEditorFn) (*GetProductVariantsResponse, error) {
	rsp, err := c.GetProductVariants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductVariantsResponse(rsp)
}

// GetProductsWithResponse request returning *GetProductsResponse
func (c *ClientWithResponses) GetProductsWithResponse(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*GetProductsResponse, error) {
	rsp, err := c.GetProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsResponse(rsp)
}

// PostProductsWithBodyWithResponse request with arbitrary body returning *PostProductsResponse
func (c *ClientWithResponses) PostProductsWithBodyWithResponse(ctx context.Context, params *PostProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsResponse, error) {
	rsp, err := c.PostProductsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsWithResponse(ctx context.Context, params *PostProductsParams, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsResponse, error) {
	rsp, err := c.PostProducts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsResponse(rsp)
}

// PostProductsBatchWithBodyWithResponse request with arbitrary body returning *PostProductsBatchResponse
func (c *ClientWithResponses) PostProductsBatchWithBodyWithResponse(ctx context.Context, params *PostProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsBatchResponse, error) {
	rsp, err := c.PostProductsBatchWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostProductsBatchWithResponse(ctx context.Context, params *PostProductsBatchParams, body PostProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsBatchResponse, error) {
	rsp, err := c.PostProductsBatch(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsBatchResponse(rsp)
}

// PostProductsExportWithResponse request returning *PostProductsExportResponse
func (c *ClientWithResponses) PostProductsExportWithResponse(ctx context.Context, params *PostProductsExportParams, reqEditors ...RequestEditorFn) (*PostProductsExportResponse, error) {
	rsp, err := c.PostProductsExport(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsExportResponse(rsp)
}

// PostProductsImportWithBodyWithResponse request with arbitrary body returning *PostProductsImportResponse
func (c *ClientWithResponses) PostProductsImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsImportResponse, error) {
	rsp, err := c.PostProductsImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsImportResponse(rsp)
}

func (c *ClientWithResponses) PostProductsImportWithResponse(ctx context.Context, body PostProductsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsImportResponse, error) {
	rsp, err := c.PostProductsImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsImportResponse(rsp)
}

// PostProductsImportTransactionIdConfirmWithResponse request returning *PostProductsImportTransactionIdConfirmResponse
func (c *ClientWithResponses) PostProductsImportTransactionIdConfirmWithResponse(ctx context.Context, transactionId string, reqEditors ...RequestEditorFn) (*PostProductsImportTransactionIdConfirmResponse, error) {
	rsp, err := c.PostProductsImportTransactionIdConfirm(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsImportTransactionIdConfirmResponse(rsp)
}

// DeleteProductsIdWithResponse request returning *DeleteProductsIdResponse
func (c *ClientWithResponses) DeleteProductsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductsIdResponse, error) {
	rsp, err := c.DeleteProductsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsIdResponse(rsp)
}

// GetProductsIdWithResponse request returning *GetProductsIdResponse
func (c *ClientWithResponses) GetProductsIdWithResponse(ctx context.Context, id string, params *GetProductsIdParams, reqEditors ...RequestEditorFn) (*GetProductsIdResponse, error) {
	rsp, err := c.GetProductsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsIdResponse(rsp)
}

// PostProductsIdWithBodyWithResponse request with arbitrary body returning *PostProductsIdResponse
func (c *ClientWithResponses) PostProductsIdWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdResponse, error) {
	rsp, err := c.PostProductsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdWithResponse(ctx context.Context, id string, params *PostProductsIdParams, body PostProductsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdResponse, error) {
	rsp, err := c.PostProductsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdResponse(rsp)
}

// GetProductsIdOptionsWithResponse request returning *GetProductsIdOptionsResponse
func (c *ClientWithResponses) GetProductsIdOptionsWithResponse(ctx context.Context, id string, params *GetProductsIdOptionsParams, reqEditors ...RequestEditorFn) (*GetProductsIdOptionsResponse, error) {
	rsp, err := c.GetProductsIdOptions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsIdOptionsResponse(rsp)
}

// PostProductsIdOptionsWithBodyWithResponse request with arbitrary body returning *PostProductsIdOptionsResponse
func (c *ClientWithResponses) PostProductsIdOptionsWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsResponse, error) {
	rsp, err := c.PostProductsIdOptionsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdOptionsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdOptionsWithResponse(ctx context.Context, id string, params *PostProductsIdOptionsParams, body PostProductsIdOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsResponse, error) {
	rsp, err := c.PostProductsIdOptions(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdOptionsResponse(rsp)
}

// DeleteProductsIdOptionsOptionIdWithResponse request returning *DeleteProductsIdOptionsOptionIdResponse
func (c *ClientWithResponses) DeleteProductsIdOptionsOptionIdWithResponse(ctx context.Context, id string, optionId string, params *DeleteProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*DeleteProductsIdOptionsOptionIdResponse, error) {
	rsp, err := c.DeleteProductsIdOptionsOptionId(ctx, id, optionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsIdOptionsOptionIdResponse(rsp)
}

// GetProductsIdOptionsOptionIdWithResponse request returning *GetProductsIdOptionsOptionIdResponse
func (c *ClientWithResponses) GetProductsIdOptionsOptionIdWithResponse(ctx context.Context, id string, optionId string, params *GetProductsIdOptionsOptionIdParams, reqEditors ...RequestEditorFn) (*GetProductsIdOptionsOptionIdResponse, error) {
	rsp, err := c.GetProductsIdOptionsOptionId(ctx, id, optionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsIdOptionsOptionIdResponse(rsp)
}

// PostProductsIdOptionsOptionIdWithBodyWithResponse request with arbitrary body returning *PostProductsIdOptionsOptionIdResponse
func (c *ClientWithResponses) PostProductsIdOptionsOptionIdWithBodyWithResponse(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsOptionIdResponse, error) {
	rsp, err := c.PostProductsIdOptionsOptionIdWithBody(ctx, id, optionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdOptionsOptionIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdOptionsOptionIdWithResponse(ctx context.Context, id string, optionId string, params *PostProductsIdOptionsOptionIdParams, body PostProductsIdOptionsOptionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdOptionsOptionIdResponse, error) {
	rsp, err := c.PostProductsIdOptionsOptionId(ctx, id, optionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdOptionsOptionIdResponse(rsp)
}

// GetProductsIdVariantsWithResponse request returning *GetProductsIdVariantsResponse
func (c *ClientWithResponses) GetProductsIdVariantsWithResponse(ctx context.Context, id string, params *GetProductsIdVariantsParams, reqEditors ...RequestEditorFn) (*GetProductsIdVariantsResponse, error) {
	rsp, err := c.GetProductsIdVariants(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsIdVariantsResponse(rsp)
}

// PostProductsIdVariantsWithBodyWithResponse request with arbitrary body returning *PostProductsIdVariantsResponse
func (c *ClientWithResponses) PostProductsIdVariantsWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsResponse, error) {
	rsp, err := c.PostProductsIdVariantsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdVariantsWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsParams, body PostProductsIdVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsResponse, error) {
	rsp, err := c.PostProductsIdVariants(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsResponse(rsp)
}

// PostProductsIdVariantsBatchWithBodyWithResponse request with arbitrary body returning *PostProductsIdVariantsBatchResponse
func (c *ClientWithResponses) PostProductsIdVariantsBatchWithBodyWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsBatchResponse, error) {
	rsp, err := c.PostProductsIdVariantsBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdVariantsBatchWithResponse(ctx context.Context, id string, params *PostProductsIdVariantsBatchParams, body PostProductsIdVariantsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsBatchResponse, error) {
	rsp, err := c.PostProductsIdVariantsBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsBatchResponse(rsp)
}

// PostProductsIdVariantsInventoryItemsBatchWithBodyWithResponse request with arbitrary body returning *PostProductsIdVariantsInventoryItemsBatchResponse
func (c *ClientWithResponses) PostProductsIdVariantsInventoryItemsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsInventoryItemsBatchResponse, error) {
	rsp, err := c.PostProductsIdVariantsInventoryItemsBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsInventoryItemsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdVariantsInventoryItemsBatchWithResponse(ctx context.Context, id string, body PostProductsIdVariantsInventoryItemsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsInventoryItemsBatchResponse, error) {
	rsp, err := c.PostProductsIdVariantsInventoryItemsBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsInventoryItemsBatchResponse(rsp)
}

// DeleteProductsIdVariantsVariantIdWithResponse request returning *DeleteProductsIdVariantsVariantIdResponse
func (c *ClientWithResponses) DeleteProductsIdVariantsVariantIdWithResponse(ctx context.Context, id string, variantId string, params *DeleteProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*DeleteProductsIdVariantsVariantIdResponse, error) {
	rsp, err := c.DeleteProductsIdVariantsVariantId(ctx, id, variantId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsIdVariantsVariantIdResponse(rsp)
}

// GetProductsIdVariantsVariantIdWithResponse request returning *GetProductsIdVariantsVariantIdResponse
func (c *ClientWithResponses) GetProductsIdVariantsVariantIdWithResponse(ctx context.Context, id string, variantId string, params *GetProductsIdVariantsVariantIdParams, reqEditors ...RequestEditorFn) (*GetProductsIdVariantsVariantIdResponse, error) {
	rsp, err := c.GetProductsIdVariantsVariantId(ctx, id, variantId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsIdVariantsVariantIdResponse(rsp)
}

// PostProductsIdVariantsVariantIdWithBodyWithResponse request with arbitrary body returning *PostProductsIdVariantsVariantIdResponse
func (c *ClientWithResponses) PostProductsIdVariantsVariantIdWithBodyWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdResponse, error) {
	rsp, err := c.PostProductsIdVariantsVariantIdWithBody(ctx, id, variantId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsVariantIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdVariantsVariantIdWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdParams, body PostProductsIdVariantsVariantIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdResponse, error) {
	rsp, err := c.PostProductsIdVariantsVariantId(ctx, id, variantId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsVariantIdResponse(rsp)
}

// PostProductsIdVariantsVariantIdInventoryItemsWithBodyWithResponse request with arbitrary body returning *PostProductsIdVariantsVariantIdInventoryItemsResponse
func (c *ClientWithResponses) PostProductsIdVariantsVariantIdInventoryItemsWithBodyWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsResponse, error) {
	rsp, err := c.PostProductsIdVariantsVariantIdInventoryItemsWithBody(ctx, id, variantId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsVariantIdInventoryItemsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdVariantsVariantIdInventoryItemsWithResponse(ctx context.Context, id string, variantId string, params *PostProductsIdVariantsVariantIdInventoryItemsParams, body PostProductsIdVariantsVariantIdInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsResponse, error) {
	rsp, err := c.PostProductsIdVariantsVariantIdInventoryItems(ctx, id, variantId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsVariantIdInventoryItemsResponse(rsp)
}

// DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse request returning *DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse
func (c *ClientWithResponses) DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse(ctx context.Context, id string, variantId string, inventoryItemId string, params *DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, reqEditors ...RequestEditorFn) (*DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error) {
	rsp, err := c.DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemId(ctx, id, variantId, inventoryItemId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse(rsp)
}

// PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBodyWithResponse request with arbitrary body returning *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse
func (c *ClientWithResponses) PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBodyWithResponse(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error) {
	rsp, err := c.PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithBody(ctx, id, variantId, inventoryItemId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse(rsp)
}

func (c *ClientWithResponses) PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse(ctx context.Context, id string, variantId string, inventoryItemId string, params *PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdParams, body PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error) {
	rsp, err := c.PostProductsIdVariantsVariantIdInventoryItemsInventoryItemId(ctx, id, variantId, inventoryItemId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse(rsp)
}

// GetPromotionsWithResponse request returning *GetPromotionsResponse
func (c *ClientWithResponses) GetPromotionsWithResponse(ctx context.Context, params *GetPromotionsParams, reqEditors ...RequestEditorFn) (*GetPromotionsResponse, error) {
	rsp, err := c.GetPromotions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionsResponse(rsp)
}

// PostPromotionsWithBodyWithResponse request with arbitrary body returning *PostPromotionsResponse
func (c *ClientWithResponses) PostPromotionsWithBodyWithResponse(ctx context.Context, params *PostPromotionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsResponse, error) {
	rsp, err := c.PostPromotionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsResponse(rsp)
}

func (c *ClientWithResponses) PostPromotionsWithResponse(ctx context.Context, params *PostPromotionsParams, body PostPromotionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsResponse, error) {
	rsp, err := c.PostPromotions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsResponse(rsp)
}

// GetPromotionsRuleAttributeOptionsRuleTypeWithResponse request returning *GetPromotionsRuleAttributeOptionsRuleTypeResponse
func (c *ClientWithResponses) GetPromotionsRuleAttributeOptionsRuleTypeWithResponse(ctx context.Context, ruleType GetPromotionsRuleAttributeOptionsRuleTypeParamsRuleType, params *GetPromotionsRuleAttributeOptionsRuleTypeParams, reqEditors ...RequestEditorFn) (*GetPromotionsRuleAttributeOptionsRuleTypeResponse, error) {
	rsp, err := c.GetPromotionsRuleAttributeOptionsRuleType(ctx, ruleType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionsRuleAttributeOptionsRuleTypeResponse(rsp)
}

// GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdWithResponse request returning *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse
func (c *ClientWithResponses) GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdWithResponse(ctx context.Context, ruleType GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParamsRuleType, ruleAttributeId string, params *GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdParams, reqEditors ...RequestEditorFn) (*GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse, error) {
	rsp, err := c.GetPromotionsRuleValueOptionsRuleTypeRuleAttributeId(ctx, ruleType, ruleAttributeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse(rsp)
}

// DeletePromotionsIdWithResponse request returning *DeletePromotionsIdResponse
func (c *ClientWithResponses) DeletePromotionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePromotionsIdResponse, error) {
	rsp, err := c.DeletePromotionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePromotionsIdResponse(rsp)
}

// GetPromotionsIdWithResponse request returning *GetPromotionsIdResponse
func (c *ClientWithResponses) GetPromotionsIdWithResponse(ctx context.Context, id string, params *GetPromotionsIdParams, reqEditors ...RequestEditorFn) (*GetPromotionsIdResponse, error) {
	rsp, err := c.GetPromotionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionsIdResponse(rsp)
}

// PostPromotionsIdWithBodyWithResponse request with arbitrary body returning *PostPromotionsIdResponse
func (c *ClientWithResponses) PostPromotionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdResponse, error) {
	rsp, err := c.PostPromotionsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdResponse(rsp)
}

func (c *ClientWithResponses) PostPromotionsIdWithResponse(ctx context.Context, id string, params *PostPromotionsIdParams, body PostPromotionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdResponse, error) {
	rsp, err := c.PostPromotionsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdResponse(rsp)
}

// PostPromotionsIdBuyRulesBatchWithBodyWithResponse request with arbitrary body returning *PostPromotionsIdBuyRulesBatchResponse
func (c *ClientWithResponses) PostPromotionsIdBuyRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdBuyRulesBatchResponse, error) {
	rsp, err := c.PostPromotionsIdBuyRulesBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdBuyRulesBatchResponse(rsp)
}

func (c *ClientWithResponses) PostPromotionsIdBuyRulesBatchWithResponse(ctx context.Context, id string, params *PostPromotionsIdBuyRulesBatchParams, body PostPromotionsIdBuyRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdBuyRulesBatchResponse, error) {
	rsp, err := c.PostPromotionsIdBuyRulesBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdBuyRulesBatchResponse(rsp)
}

// PostPromotionsIdRulesBatchWithBodyWithResponse request with arbitrary body returning *PostPromotionsIdRulesBatchResponse
func (c *ClientWithResponses) PostPromotionsIdRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdRulesBatchResponse, error) {
	rsp, err := c.PostPromotionsIdRulesBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdRulesBatchResponse(rsp)
}

func (c *ClientWithResponses) PostPromotionsIdRulesBatchWithResponse(ctx context.Context, id string, params *PostPromotionsIdRulesBatchParams, body PostPromotionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdRulesBatchResponse, error) {
	rsp, err := c.PostPromotionsIdRulesBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdRulesBatchResponse(rsp)
}

// PostPromotionsIdTargetRulesBatchWithBodyWithResponse request with arbitrary body returning *PostPromotionsIdTargetRulesBatchResponse
func (c *ClientWithResponses) PostPromotionsIdTargetRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPromotionsIdTargetRulesBatchResponse, error) {
	rsp, err := c.PostPromotionsIdTargetRulesBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdTargetRulesBatchResponse(rsp)
}

func (c *ClientWithResponses) PostPromotionsIdTargetRulesBatchWithResponse(ctx context.Context, id string, params *PostPromotionsIdTargetRulesBatchParams, body PostPromotionsIdTargetRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPromotionsIdTargetRulesBatchResponse, error) {
	rsp, err := c.PostPromotionsIdTargetRulesBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPromotionsIdTargetRulesBatchResponse(rsp)
}

// GetPromotionsIdRuleTypeWithResponse request returning *GetPromotionsIdRuleTypeResponse
func (c *ClientWithResponses) GetPromotionsIdRuleTypeWithResponse(ctx context.Context, id string, ruleType GetPromotionsIdRuleTypeParamsRuleType, params *GetPromotionsIdRuleTypeParams, reqEditors ...RequestEditorFn) (*GetPromotionsIdRuleTypeResponse, error) {
	rsp, err := c.GetPromotionsIdRuleType(ctx, id, ruleType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionsIdRuleTypeResponse(rsp)
}

// GetRefundReasonsWithResponse request returning *GetRefundReasonsResponse
func (c *ClientWithResponses) GetRefundReasonsWithResponse(ctx context.Context, params *GetRefundReasonsParams, reqEditors ...RequestEditorFn) (*GetRefundReasonsResponse, error) {
	rsp, err := c.GetRefundReasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRefundReasonsResponse(rsp)
}

// PostRefundReasonsWithBodyWithResponse request with arbitrary body returning *PostRefundReasonsResponse
func (c *ClientWithResponses) PostRefundReasonsWithBodyWithResponse(ctx context.Context, params *PostRefundReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRefundReasonsResponse, error) {
	rsp, err := c.PostRefundReasonsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRefundReasonsResponse(rsp)
}

func (c *ClientWithResponses) PostRefundReasonsWithResponse(ctx context.Context, params *PostRefundReasonsParams, body PostRefundReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRefundReasonsResponse, error) {
	rsp, err := c.PostRefundReasons(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRefundReasonsResponse(rsp)
}

// DeleteRefundReasonsIdWithResponse request returning *DeleteRefundReasonsIdResponse
func (c *ClientWithResponses) DeleteRefundReasonsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRefundReasonsIdResponse, error) {
	rsp, err := c.DeleteRefundReasonsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRefundReasonsIdResponse(rsp)
}

// GetRefundReasonsIdWithResponse request returning *GetRefundReasonsIdResponse
func (c *ClientWithResponses) GetRefundReasonsIdWithResponse(ctx context.Context, id string, params *GetRefundReasonsIdParams, reqEditors ...RequestEditorFn) (*GetRefundReasonsIdResponse, error) {
	rsp, err := c.GetRefundReasonsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRefundReasonsIdResponse(rsp)
}

// PostRefundReasonsIdWithBodyWithResponse request with arbitrary body returning *PostRefundReasonsIdResponse
func (c *ClientWithResponses) PostRefundReasonsIdWithBodyWithResponse(ctx context.Context, id string, params *PostRefundReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRefundReasonsIdResponse, error) {
	rsp, err := c.PostRefundReasonsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRefundReasonsIdResponse(rsp)
}

func (c *ClientWithResponses) PostRefundReasonsIdWithResponse(ctx context.Context, id string, params *PostRefundReasonsIdParams, body PostRefundReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRefundReasonsIdResponse, error) {
	rsp, err := c.PostRefundReasonsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRefundReasonsIdResponse(rsp)
}

// GetRegionsWithResponse request returning *GetRegionsResponse
func (c *ClientWithResponses) GetRegionsWithResponse(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*GetRegionsResponse, error) {
	rsp, err := c.GetRegions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionsResponse(rsp)
}

// PostRegionsWithBodyWithResponse request with arbitrary body returning *PostRegionsResponse
func (c *ClientWithResponses) PostRegionsWithBodyWithResponse(ctx context.Context, params *PostRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error) {
	rsp, err := c.PostRegionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsWithResponse(ctx context.Context, params *PostRegionsParams, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error) {
	rsp, err := c.PostRegions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsResponse(rsp)
}

// DeleteRegionsIdWithResponse request returning *DeleteRegionsIdResponse
func (c *ClientWithResponses) DeleteRegionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRegionsIdResponse, error) {
	rsp, err := c.DeleteRegionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRegionsIdResponse(rsp)
}

// GetRegionsIdWithResponse request returning *GetRegionsIdResponse
func (c *ClientWithResponses) GetRegionsIdWithResponse(ctx context.Context, id string, params *GetRegionsIdParams, reqEditors ...RequestEditorFn) (*GetRegionsIdResponse, error) {
	rsp, err := c.GetRegionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionsIdResponse(rsp)
}

// PostRegionsIdWithBodyWithResponse request with arbitrary body returning *PostRegionsIdResponse
func (c *ClientWithResponses) PostRegionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostRegionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsIdResponse, error) {
	rsp, err := c.PostRegionsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsIdResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsIdWithResponse(ctx context.Context, id string, params *PostRegionsIdParams, body PostRegionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsIdResponse, error) {
	rsp, err := c.PostRegionsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsIdResponse(rsp)
}

// GetReservationsWithResponse request returning *GetReservationsResponse
func (c *ClientWithResponses) GetReservationsWithResponse(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*GetReservationsResponse, error) {
	rsp, err := c.GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservationsResponse(rsp)
}

// PostReservationsWithBodyWithResponse request with arbitrary body returning *PostReservationsResponse
func (c *ClientWithResponses) PostReservationsWithBodyWithResponse(ctx context.Context, params *PostReservationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error) {
	rsp, err := c.PostReservationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsResponse(rsp)
}

func (c *ClientWithResponses) PostReservationsWithResponse(ctx context.Context, params *PostReservationsParams, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error) {
	rsp, err := c.PostReservations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsResponse(rsp)
}

// DeleteReservationsIdWithResponse request returning *DeleteReservationsIdResponse
func (c *ClientWithResponses) DeleteReservationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReservationsIdResponse, error) {
	rsp, err := c.DeleteReservationsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservationsIdResponse(rsp)
}

// GetReservationsIdWithResponse request returning *GetReservationsIdResponse
func (c *ClientWithResponses) GetReservationsIdWithResponse(ctx context.Context, id string, params *GetReservationsIdParams, reqEditors ...RequestEditorFn) (*GetReservationsIdResponse, error) {
	rsp, err := c.GetReservationsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservationsIdResponse(rsp)
}

// PostReservationsIdWithBodyWithResponse request with arbitrary body returning *PostReservationsIdResponse
func (c *ClientWithResponses) PostReservationsIdWithBodyWithResponse(ctx context.Context, id string, params *PostReservationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsIdResponse, error) {
	rsp, err := c.PostReservationsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsIdResponse(rsp)
}

func (c *ClientWithResponses) PostReservationsIdWithResponse(ctx context.Context, id string, params *PostReservationsIdParams, body PostReservationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsIdResponse, error) {
	rsp, err := c.PostReservationsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsIdResponse(rsp)
}

// GetReturnReasonsWithResponse request returning *GetReturnReasonsResponse
func (c *ClientWithResponses) GetReturnReasonsWithResponse(ctx context.Context, params *GetReturnReasonsParams, reqEditors ...RequestEditorFn) (*GetReturnReasonsResponse, error) {
	rsp, err := c.GetReturnReasons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnReasonsResponse(rsp)
}

// PostReturnReasonsWithBodyWithResponse request with arbitrary body returning *PostReturnReasonsResponse
func (c *ClientWithResponses) PostReturnReasonsWithBodyWithResponse(ctx context.Context, params *PostReturnReasonsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error) {
	rsp, err := c.PostReturnReasonsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsResponse(rsp)
}

func (c *ClientWithResponses) PostReturnReasonsWithResponse(ctx context.Context, params *PostReturnReasonsParams, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error) {
	rsp, err := c.PostReturnReasons(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsResponse(rsp)
}

// DeleteReturnReasonsIdWithResponse request returning *DeleteReturnReasonsIdResponse
func (c *ClientWithResponses) DeleteReturnReasonsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnReasonsIdResponse, error) {
	rsp, err := c.DeleteReturnReasonsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnReasonsIdResponse(rsp)
}

// GetReturnReasonsIdWithResponse request returning *GetReturnReasonsIdResponse
func (c *ClientWithResponses) GetReturnReasonsIdWithResponse(ctx context.Context, id string, params *GetReturnReasonsIdParams, reqEditors ...RequestEditorFn) (*GetReturnReasonsIdResponse, error) {
	rsp, err := c.GetReturnReasonsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnReasonsIdResponse(rsp)
}

// PostReturnReasonsIdWithBodyWithResponse request with arbitrary body returning *PostReturnReasonsIdResponse
func (c *ClientWithResponses) PostReturnReasonsIdWithBodyWithResponse(ctx context.Context, id string, params *PostReturnReasonsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsIdResponse, error) {
	rsp, err := c.PostReturnReasonsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsIdResponse(rsp)
}

func (c *ClientWithResponses) PostReturnReasonsIdWithResponse(ctx context.Context, id string, params *PostReturnReasonsIdParams, body PostReturnReasonsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsIdResponse, error) {
	rsp, err := c.PostReturnReasonsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsIdResponse(rsp)
}

// GetReturnsWithResponse request returning *GetReturnsResponse
func (c *ClientWithResponses) GetReturnsWithResponse(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*GetReturnsResponse, error) {
	rsp, err := c.GetReturns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnsResponse(rsp)
}

// PostReturnsWithBodyWithResponse request with arbitrary body returning *PostReturnsResponse
func (c *ClientWithResponses) PostReturnsWithBodyWithResponse(ctx context.Context, params *PostReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsResponse, error) {
	rsp, err := c.PostReturnsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsWithResponse(ctx context.Context, params *PostReturnsParams, body PostReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsResponse, error) {
	rsp, err := c.PostReturns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsResponse(rsp)
}

// GetReturnsIdWithResponse request returning *GetReturnsIdResponse
func (c *ClientWithResponses) GetReturnsIdWithResponse(ctx context.Context, id string, params *GetReturnsIdParams, reqEditors ...RequestEditorFn) (*GetReturnsIdResponse, error) {
	rsp, err := c.GetReturnsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnsIdResponse(rsp)
}

// PostReturnsIdWithBodyWithResponse request with arbitrary body returning *PostReturnsIdResponse
func (c *ClientWithResponses) PostReturnsIdWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdResponse, error) {
	rsp, err := c.PostReturnsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdWithResponse(ctx context.Context, id string, params *PostReturnsIdParams, body PostReturnsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdResponse, error) {
	rsp, err := c.PostReturnsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdResponse(rsp)
}

// PostReturnsIdCancelWithBodyWithResponse request with arbitrary body returning *PostReturnsIdCancelResponse
func (c *ClientWithResponses) PostReturnsIdCancelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdCancelResponse, error) {
	rsp, err := c.PostReturnsIdCancelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdCancelResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdCancelWithResponse(ctx context.Context, id string, body PostReturnsIdCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdCancelResponse, error) {
	rsp, err := c.PostReturnsIdCancel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdCancelResponse(rsp)
}

// PostReturnsIdDismissItemsWithBodyWithResponse request with arbitrary body returning *PostReturnsIdDismissItemsResponse
func (c *ClientWithResponses) PostReturnsIdDismissItemsWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsResponse, error) {
	rsp, err := c.PostReturnsIdDismissItemsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdDismissItemsResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdDismissItemsWithResponse(ctx context.Context, id string, params *PostReturnsIdDismissItemsParams, body PostReturnsIdDismissItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsResponse, error) {
	rsp, err := c.PostReturnsIdDismissItems(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdDismissItemsResponse(rsp)
}

// DeleteReturnsIdDismissItemsActionIdWithResponse request returning *DeleteReturnsIdDismissItemsActionIdResponse
func (c *ClientWithResponses) DeleteReturnsIdDismissItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdDismissItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdDismissItemsActionIdResponse, error) {
	rsp, err := c.DeleteReturnsIdDismissItemsActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnsIdDismissItemsActionIdResponse(rsp)
}

// PostReturnsIdDismissItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostReturnsIdDismissItemsActionIdResponse
func (c *ClientWithResponses) PostReturnsIdDismissItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsActionIdResponse, error) {
	rsp, err := c.PostReturnsIdDismissItemsActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdDismissItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdDismissItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdDismissItemsActionIdParams, body PostReturnsIdDismissItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdDismissItemsActionIdResponse, error) {
	rsp, err := c.PostReturnsIdDismissItemsActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdDismissItemsActionIdResponse(rsp)
}

// DeleteReturnsIdReceiveWithResponse request returning *DeleteReturnsIdReceiveResponse
func (c *ClientWithResponses) DeleteReturnsIdReceiveWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnsIdReceiveResponse, error) {
	rsp, err := c.DeleteReturnsIdReceive(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnsIdReceiveResponse(rsp)
}

// PostReturnsIdReceiveWithBodyWithResponse request with arbitrary body returning *PostReturnsIdReceiveResponse
func (c *ClientWithResponses) PostReturnsIdReceiveWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveResponse, error) {
	rsp, err := c.PostReturnsIdReceiveWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdReceiveWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveParams, body PostReturnsIdReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveResponse, error) {
	rsp, err := c.PostReturnsIdReceive(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveResponse(rsp)
}

// PostReturnsIdReceiveItemsWithBodyWithResponse request with arbitrary body returning *PostReturnsIdReceiveItemsResponse
func (c *ClientWithResponses) PostReturnsIdReceiveItemsWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsResponse, error) {
	rsp, err := c.PostReturnsIdReceiveItemsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveItemsResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdReceiveItemsWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveItemsParams, body PostReturnsIdReceiveItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsResponse, error) {
	rsp, err := c.PostReturnsIdReceiveItems(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveItemsResponse(rsp)
}

// DeleteReturnsIdReceiveItemsActionIdWithResponse request returning *DeleteReturnsIdReceiveItemsActionIdResponse
func (c *ClientWithResponses) DeleteReturnsIdReceiveItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdReceiveItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdReceiveItemsActionIdResponse, error) {
	rsp, err := c.DeleteReturnsIdReceiveItemsActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnsIdReceiveItemsActionIdResponse(rsp)
}

// PostReturnsIdReceiveItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostReturnsIdReceiveItemsActionIdResponse
func (c *ClientWithResponses) PostReturnsIdReceiveItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsActionIdResponse, error) {
	rsp, err := c.PostReturnsIdReceiveItemsActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdReceiveItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdReceiveItemsActionIdParams, body PostReturnsIdReceiveItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveItemsActionIdResponse, error) {
	rsp, err := c.PostReturnsIdReceiveItemsActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveItemsActionIdResponse(rsp)
}

// PostReturnsIdReceiveConfirmWithBodyWithResponse request with arbitrary body returning *PostReturnsIdReceiveConfirmResponse
func (c *ClientWithResponses) PostReturnsIdReceiveConfirmWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveConfirmResponse, error) {
	rsp, err := c.PostReturnsIdReceiveConfirmWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveConfirmResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdReceiveConfirmWithResponse(ctx context.Context, id string, params *PostReturnsIdReceiveConfirmParams, body PostReturnsIdReceiveConfirmJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdReceiveConfirmResponse, error) {
	rsp, err := c.PostReturnsIdReceiveConfirm(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdReceiveConfirmResponse(rsp)
}

// DeleteReturnsIdRequestWithResponse request returning *DeleteReturnsIdRequestResponse
func (c *ClientWithResponses) DeleteReturnsIdRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnsIdRequestResponse, error) {
	rsp, err := c.DeleteReturnsIdRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnsIdRequestResponse(rsp)
}

// PostReturnsIdRequestWithBodyWithResponse request with arbitrary body returning *PostReturnsIdRequestResponse
func (c *ClientWithResponses) PostReturnsIdRequestWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestResponse, error) {
	rsp, err := c.PostReturnsIdRequestWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdRequestResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdRequestWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestParams, body PostReturnsIdRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestResponse, error) {
	rsp, err := c.PostReturnsIdRequest(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdRequestResponse(rsp)
}

// PostReturnsIdRequestItemsWithBodyWithResponse request with arbitrary body returning *PostReturnsIdRequestItemsResponse
func (c *ClientWithResponses) PostReturnsIdRequestItemsWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsResponse, error) {
	rsp, err := c.PostReturnsIdRequestItemsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdRequestItemsResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdRequestItemsWithResponse(ctx context.Context, id string, params *PostReturnsIdRequestItemsParams, body PostReturnsIdRequestItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsResponse, error) {
	rsp, err := c.PostReturnsIdRequestItems(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdRequestItemsResponse(rsp)
}

// DeleteReturnsIdRequestItemsActionIdWithResponse request returning *DeleteReturnsIdRequestItemsActionIdResponse
func (c *ClientWithResponses) DeleteReturnsIdRequestItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdRequestItemsActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdRequestItemsActionIdResponse, error) {
	rsp, err := c.DeleteReturnsIdRequestItemsActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnsIdRequestItemsActionIdResponse(rsp)
}

// PostReturnsIdRequestItemsActionIdWithBodyWithResponse request with arbitrary body returning *PostReturnsIdRequestItemsActionIdResponse
func (c *ClientWithResponses) PostReturnsIdRequestItemsActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsActionIdResponse, error) {
	rsp, err := c.PostReturnsIdRequestItemsActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdRequestItemsActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdRequestItemsActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdRequestItemsActionIdParams, body PostReturnsIdRequestItemsActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdRequestItemsActionIdResponse, error) {
	rsp, err := c.PostReturnsIdRequestItemsActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdRequestItemsActionIdResponse(rsp)
}

// PostReturnsIdShippingMethodWithBodyWithResponse request with arbitrary body returning *PostReturnsIdShippingMethodResponse
func (c *ClientWithResponses) PostReturnsIdShippingMethodWithBodyWithResponse(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodResponse, error) {
	rsp, err := c.PostReturnsIdShippingMethodWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdShippingMethodResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdShippingMethodWithResponse(ctx context.Context, id string, params *PostReturnsIdShippingMethodParams, body PostReturnsIdShippingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodResponse, error) {
	rsp, err := c.PostReturnsIdShippingMethod(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdShippingMethodResponse(rsp)
}

// DeleteReturnsIdShippingMethodActionIdWithResponse request returning *DeleteReturnsIdShippingMethodActionIdResponse
func (c *ClientWithResponses) DeleteReturnsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *DeleteReturnsIdShippingMethodActionIdParams, reqEditors ...RequestEditorFn) (*DeleteReturnsIdShippingMethodActionIdResponse, error) {
	rsp, err := c.DeleteReturnsIdShippingMethodActionId(ctx, id, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnsIdShippingMethodActionIdResponse(rsp)
}

// PostReturnsIdShippingMethodActionIdWithBodyWithResponse request with arbitrary body returning *PostReturnsIdShippingMethodActionIdResponse
func (c *ClientWithResponses) PostReturnsIdShippingMethodActionIdWithBodyWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodActionIdResponse, error) {
	rsp, err := c.PostReturnsIdShippingMethodActionIdWithBody(ctx, id, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdShippingMethodActionIdResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsIdShippingMethodActionIdWithResponse(ctx context.Context, id string, actionId string, params *PostReturnsIdShippingMethodActionIdParams, body PostReturnsIdShippingMethodActionIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsIdShippingMethodActionIdResponse, error) {
	rsp, err := c.PostReturnsIdShippingMethodActionId(ctx, id, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsIdShippingMethodActionIdResponse(rsp)
}

// GetSalesChannelsWithResponse request returning *GetSalesChannelsResponse
func (c *ClientWithResponses) GetSalesChannelsWithResponse(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*GetSalesChannelsResponse, error) {
	rsp, err := c.GetSalesChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSalesChannelsResponse(rsp)
}

// PostSalesChannelsWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsResponse
func (c *ClientWithResponses) PostSalesChannelsWithBodyWithResponse(ctx context.Context, params *PostSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error) {
	rsp, err := c.PostSalesChannelsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsWithResponse(ctx context.Context, params *PostSalesChannelsParams, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error) {
	rsp, err := c.PostSalesChannels(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsResponse(rsp)
}

// DeleteSalesChannelsIdWithResponse request returning *DeleteSalesChannelsIdResponse
func (c *ClientWithResponses) DeleteSalesChannelsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsIdResponse, error) {
	rsp, err := c.DeleteSalesChannelsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSalesChannelsIdResponse(rsp)
}

// GetSalesChannelsIdWithResponse request returning *GetSalesChannelsIdResponse
func (c *ClientWithResponses) GetSalesChannelsIdWithResponse(ctx context.Context, id string, params *GetSalesChannelsIdParams, reqEditors ...RequestEditorFn) (*GetSalesChannelsIdResponse, error) {
	rsp, err := c.GetSalesChannelsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSalesChannelsIdResponse(rsp)
}

// PostSalesChannelsIdWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsIdResponse
func (c *ClientWithResponses) PostSalesChannelsIdWithBodyWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdResponse, error) {
	rsp, err := c.PostSalesChannelsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsIdResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsIdWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdParams, body PostSalesChannelsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdResponse, error) {
	rsp, err := c.PostSalesChannelsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsIdResponse(rsp)
}

// PostSalesChannelsIdProductsWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsIdProductsResponse
func (c *ClientWithResponses) PostSalesChannelsIdProductsWithBodyWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdProductsResponse, error) {
	rsp, err := c.PostSalesChannelsIdProductsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsIdProductsResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsIdProductsWithResponse(ctx context.Context, id string, params *PostSalesChannelsIdProductsParams, body PostSalesChannelsIdProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsIdProductsResponse, error) {
	rsp, err := c.PostSalesChannelsIdProducts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsIdProductsResponse(rsp)
}

// GetShippingOptionsWithResponse request returning *GetShippingOptionsResponse
func (c *ClientWithResponses) GetShippingOptionsWithResponse(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*GetShippingOptionsResponse, error) {
	rsp, err := c.GetShippingOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingOptionsResponse(rsp)
}

// PostShippingOptionsWithBodyWithResponse request with arbitrary body returning *PostShippingOptionsResponse
func (c *ClientWithResponses) PostShippingOptionsWithBodyWithResponse(ctx context.Context, params *PostShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error) {
	rsp, err := c.PostShippingOptionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsResponse(rsp)
}

func (c *ClientWithResponses) PostShippingOptionsWithResponse(ctx context.Context, params *PostShippingOptionsParams, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error) {
	rsp, err := c.PostShippingOptions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsResponse(rsp)
}

// DeleteShippingOptionsIdWithResponse request returning *DeleteShippingOptionsIdResponse
func (c *ClientWithResponses) DeleteShippingOptionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingOptionsIdResponse, error) {
	rsp, err := c.DeleteShippingOptionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShippingOptionsIdResponse(rsp)
}

// GetShippingOptionsIdWithResponse request returning *GetShippingOptionsIdResponse
func (c *ClientWithResponses) GetShippingOptionsIdWithResponse(ctx context.Context, id string, params *GetShippingOptionsIdParams, reqEditors ...RequestEditorFn) (*GetShippingOptionsIdResponse, error) {
	rsp, err := c.GetShippingOptionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingOptionsIdResponse(rsp)
}

// PostShippingOptionsIdWithBodyWithResponse request with arbitrary body returning *PostShippingOptionsIdResponse
func (c *ClientWithResponses) PostShippingOptionsIdWithBodyWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdResponse, error) {
	rsp, err := c.PostShippingOptionsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsIdResponse(rsp)
}

func (c *ClientWithResponses) PostShippingOptionsIdWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdParams, body PostShippingOptionsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdResponse, error) {
	rsp, err := c.PostShippingOptionsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsIdResponse(rsp)
}

// PostShippingOptionsIdRulesBatchWithBodyWithResponse request with arbitrary body returning *PostShippingOptionsIdRulesBatchResponse
func (c *ClientWithResponses) PostShippingOptionsIdRulesBatchWithBodyWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdRulesBatchResponse, error) {
	rsp, err := c.PostShippingOptionsIdRulesBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsIdRulesBatchResponse(rsp)
}

func (c *ClientWithResponses) PostShippingOptionsIdRulesBatchWithResponse(ctx context.Context, id string, params *PostShippingOptionsIdRulesBatchParams, body PostShippingOptionsIdRulesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsIdRulesBatchResponse, error) {
	rsp, err := c.PostShippingOptionsIdRulesBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsIdRulesBatchResponse(rsp)
}

// GetShippingProfilesWithResponse request returning *GetShippingProfilesResponse
func (c *ClientWithResponses) GetShippingProfilesWithResponse(ctx context.Context, params *GetShippingProfilesParams, reqEditors ...RequestEditorFn) (*GetShippingProfilesResponse, error) {
	rsp, err := c.GetShippingProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingProfilesResponse(rsp)
}

// PostShippingProfilesWithBodyWithResponse request with arbitrary body returning *PostShippingProfilesResponse
func (c *ClientWithResponses) PostShippingProfilesWithBodyWithResponse(ctx context.Context, params *PostShippingProfilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error) {
	rsp, err := c.PostShippingProfilesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesResponse(rsp)
}

func (c *ClientWithResponses) PostShippingProfilesWithResponse(ctx context.Context, params *PostShippingProfilesParams, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error) {
	rsp, err := c.PostShippingProfiles(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesResponse(rsp)
}

// DeleteShippingProfilesIdWithResponse request returning *DeleteShippingProfilesIdResponse
func (c *ClientWithResponses) DeleteShippingProfilesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingProfilesIdResponse, error) {
	rsp, err := c.DeleteShippingProfilesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShippingProfilesIdResponse(rsp)
}

// GetShippingProfilesIdWithResponse request returning *GetShippingProfilesIdResponse
func (c *ClientWithResponses) GetShippingProfilesIdWithResponse(ctx context.Context, id string, params *GetShippingProfilesIdParams, reqEditors ...RequestEditorFn) (*GetShippingProfilesIdResponse, error) {
	rsp, err := c.GetShippingProfilesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingProfilesIdResponse(rsp)
}

// PostShippingProfilesIdWithBodyWithResponse request with arbitrary body returning *PostShippingProfilesIdResponse
func (c *ClientWithResponses) PostShippingProfilesIdWithBodyWithResponse(ctx context.Context, id string, params *PostShippingProfilesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesIdResponse, error) {
	rsp, err := c.PostShippingProfilesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesIdResponse(rsp)
}

func (c *ClientWithResponses) PostShippingProfilesIdWithResponse(ctx context.Context, id string, params *PostShippingProfilesIdParams, body PostShippingProfilesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesIdResponse, error) {
	rsp, err := c.PostShippingProfilesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesIdResponse(rsp)
}

// GetStockLocationsWithResponse request returning *GetStockLocationsResponse
func (c *ClientWithResponses) GetStockLocationsWithResponse(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*GetStockLocationsResponse, error) {
	rsp, err := c.GetStockLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStockLocationsResponse(rsp)
}

// PostStockLocationsWithBodyWithResponse request with arbitrary body returning *PostStockLocationsResponse
func (c *ClientWithResponses) PostStockLocationsWithBodyWithResponse(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error) {
	rsp, err := c.PostStockLocationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsWithResponse(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error) {
	rsp, err := c.PostStockLocations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsResponse(rsp)
}

// DeleteStockLocationsIdWithResponse request returning *DeleteStockLocationsIdResponse
func (c *ClientWithResponses) DeleteStockLocationsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteStockLocationsIdResponse, error) {
	rsp, err := c.DeleteStockLocationsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStockLocationsIdResponse(rsp)
}

// GetStockLocationsIdWithResponse request returning *GetStockLocationsIdResponse
func (c *ClientWithResponses) GetStockLocationsIdWithResponse(ctx context.Context, id string, params *GetStockLocationsIdParams, reqEditors ...RequestEditorFn) (*GetStockLocationsIdResponse, error) {
	rsp, err := c.GetStockLocationsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStockLocationsIdResponse(rsp)
}

// PostStockLocationsIdWithBodyWithResponse request with arbitrary body returning *PostStockLocationsIdResponse
func (c *ClientWithResponses) PostStockLocationsIdWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdResponse, error) {
	rsp, err := c.PostStockLocationsIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsIdWithResponse(ctx context.Context, id string, params *PostStockLocationsIdParams, body PostStockLocationsIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdResponse, error) {
	rsp, err := c.PostStockLocationsId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdResponse(rsp)
}

// PostStockLocationsIdFulfillmentProvidersWithBodyWithResponse request with arbitrary body returning *PostStockLocationsIdFulfillmentProvidersResponse
func (c *ClientWithResponses) PostStockLocationsIdFulfillmentProvidersWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentProvidersResponse, error) {
	rsp, err := c.PostStockLocationsIdFulfillmentProvidersWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdFulfillmentProvidersResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsIdFulfillmentProvidersWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentProvidersParams, body PostStockLocationsIdFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentProvidersResponse, error) {
	rsp, err := c.PostStockLocationsIdFulfillmentProviders(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdFulfillmentProvidersResponse(rsp)
}

// PostStockLocationsIdFulfillmentSetsWithBodyWithResponse request with arbitrary body returning *PostStockLocationsIdFulfillmentSetsResponse
func (c *ClientWithResponses) PostStockLocationsIdFulfillmentSetsWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentSetsResponse, error) {
	rsp, err := c.PostStockLocationsIdFulfillmentSetsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdFulfillmentSetsResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsIdFulfillmentSetsWithResponse(ctx context.Context, id string, params *PostStockLocationsIdFulfillmentSetsParams, body PostStockLocationsIdFulfillmentSetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdFulfillmentSetsResponse, error) {
	rsp, err := c.PostStockLocationsIdFulfillmentSets(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdFulfillmentSetsResponse(rsp)
}

// PostStockLocationsIdSalesChannelsWithBodyWithResponse request with arbitrary body returning *PostStockLocationsIdSalesChannelsResponse
func (c *ClientWithResponses) PostStockLocationsIdSalesChannelsWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsIdSalesChannelsResponse, error) {
	rsp, err := c.PostStockLocationsIdSalesChannelsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdSalesChannelsResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsIdSalesChannelsWithResponse(ctx context.Context, id string, params *PostStockLocationsIdSalesChannelsParams, body PostStockLocationsIdSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsIdSalesChannelsResponse, error) {
	rsp, err := c.PostStockLocationsIdSalesChannels(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsIdSalesChannelsResponse(rsp)
}

// GetStoresWithResponse request returning *GetStoresResponse
func (c *ClientWithResponses) GetStoresWithResponse(ctx context.Context, params *GetStoresParams, reqEditors ...RequestEditorFn) (*GetStoresResponse, error) {
	rsp, err := c.GetStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoresResponse(rsp)
}

// GetStoresIdWithResponse request returning *GetStoresIdResponse
func (c *ClientWithResponses) GetStoresIdWithResponse(ctx context.Context, id string, params *GetStoresIdParams, reqEditors ...RequestEditorFn) (*GetStoresIdResponse, error) {
	rsp, err := c.GetStoresId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoresIdResponse(rsp)
}

// PostStoresIdWithBodyWithResponse request with arbitrary body returning *PostStoresIdResponse
func (c *ClientWithResponses) PostStoresIdWithBodyWithResponse(ctx context.Context, id string, params *PostStoresIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStoresIdResponse, error) {
	rsp, err := c.PostStoresIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStoresIdResponse(rsp)
}

func (c *ClientWithResponses) PostStoresIdWithResponse(ctx context.Context, id string, params *PostStoresIdParams, body PostStoresIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStoresIdResponse, error) {
	rsp, err := c.PostStoresId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStoresIdResponse(rsp)
}

// GetTaxRatesWithResponse request returning *GetTaxRatesResponse
func (c *ClientWithResponses) GetTaxRatesWithResponse(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*GetTaxRatesResponse, error) {
	rsp, err := c.GetTaxRates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxRatesResponse(rsp)
}

// PostTaxRatesWithBodyWithResponse request with arbitrary body returning *PostTaxRatesResponse
func (c *ClientWithResponses) PostTaxRatesWithBodyWithResponse(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error) {
	rsp, err := c.PostTaxRatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesWithResponse(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error) {
	rsp, err := c.PostTaxRates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesResponse(rsp)
}

// DeleteTaxRatesIdWithResponse request returning *DeleteTaxRatesIdResponse
func (c *ClientWithResponses) DeleteTaxRatesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTaxRatesIdResponse, error) {
	rsp, err := c.DeleteTaxRatesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesIdResponse(rsp)
}

// GetTaxRatesIdWithResponse request returning *GetTaxRatesIdResponse
func (c *ClientWithResponses) GetTaxRatesIdWithResponse(ctx context.Context, id string, params *GetTaxRatesIdParams, reqEditors ...RequestEditorFn) (*GetTaxRatesIdResponse, error) {
	rsp, err := c.GetTaxRatesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxRatesIdResponse(rsp)
}

// PostTaxRatesIdWithBodyWithResponse request with arbitrary body returning *PostTaxRatesIdResponse
func (c *ClientWithResponses) PostTaxRatesIdWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesIdResponse, error) {
	rsp, err := c.PostTaxRatesIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesIdResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesIdWithResponse(ctx context.Context, id string, params *PostTaxRatesIdParams, body PostTaxRatesIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesIdResponse, error) {
	rsp, err := c.PostTaxRatesId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesIdResponse(rsp)
}

// PostTaxRatesIdRulesWithBodyWithResponse request with arbitrary body returning *PostTaxRatesIdRulesResponse
func (c *ClientWithResponses) PostTaxRatesIdRulesWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesIdRulesResponse, error) {
	rsp, err := c.PostTaxRatesIdRulesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesIdRulesResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesIdRulesWithResponse(ctx context.Context, id string, params *PostTaxRatesIdRulesParams, body PostTaxRatesIdRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesIdRulesResponse, error) {
	rsp, err := c.PostTaxRatesIdRules(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesIdRulesResponse(rsp)
}

// DeleteTaxRatesIdRulesRuleIdWithResponse request returning *DeleteTaxRatesIdRulesRuleIdResponse
func (c *ClientWithResponses) DeleteTaxRatesIdRulesRuleIdWithResponse(ctx context.Context, id string, ruleId string, params *DeleteTaxRatesIdRulesRuleIdParams, reqEditors ...RequestEditorFn) (*DeleteTaxRatesIdRulesRuleIdResponse, error) {
	rsp, err := c.DeleteTaxRatesIdRulesRuleId(ctx, id, ruleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesIdRulesRuleIdResponse(rsp)
}

// GetTaxRegionsWithResponse request returning *GetTaxRegionsResponse
func (c *ClientWithResponses) GetTaxRegionsWithResponse(ctx context.Context, params *GetTaxRegionsParams, reqEditors ...RequestEditorFn) (*GetTaxRegionsResponse, error) {
	rsp, err := c.GetTaxRegions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxRegionsResponse(rsp)
}

// PostTaxRegionsWithBodyWithResponse request with arbitrary body returning *PostTaxRegionsResponse
func (c *ClientWithResponses) PostTaxRegionsWithBodyWithResponse(ctx context.Context, params *PostTaxRegionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRegionsResponse, error) {
	rsp, err := c.PostTaxRegionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRegionsResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRegionsWithResponse(ctx context.Context, params *PostTaxRegionsParams, body PostTaxRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRegionsResponse, error) {
	rsp, err := c.PostTaxRegions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRegionsResponse(rsp)
}

// DeleteTaxRegionsIdWithResponse request returning *DeleteTaxRegionsIdResponse
func (c *ClientWithResponses) DeleteTaxRegionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTaxRegionsIdResponse, error) {
	rsp, err := c.DeleteTaxRegionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRegionsIdResponse(rsp)
}

// GetTaxRegionsIdWithResponse request returning *GetTaxRegionsIdResponse
func (c *ClientWithResponses) GetTaxRegionsIdWithResponse(ctx context.Context, id string, params *GetTaxRegionsIdParams, reqEditors ...RequestEditorFn) (*GetTaxRegionsIdResponse, error) {
	rsp, err := c.GetTaxRegionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxRegionsIdResponse(rsp)
}

// PostUploadsWithBodyWithResponse request with arbitrary body returning *PostUploadsResponse
func (c *ClientWithResponses) PostUploadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsResponse, error) {
	rsp, err := c.PostUploadsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadsResponse(rsp)
}

func (c *ClientWithResponses) PostUploadsWithResponse(ctx context.Context, body PostUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUploadsResponse, error) {
	rsp, err := c.PostUploads(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadsResponse(rsp)
}

// DeleteUploadsIdWithResponse request returning *DeleteUploadsIdResponse
func (c *ClientWithResponses) DeleteUploadsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUploadsIdResponse, error) {
	rsp, err := c.DeleteUploadsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUploadsIdResponse(rsp)
}

// GetUploadsIdWithResponse request returning *GetUploadsIdResponse
func (c *ClientWithResponses) GetUploadsIdWithResponse(ctx context.Context, id string, params *GetUploadsIdParams, reqEditors ...RequestEditorFn) (*GetUploadsIdResponse, error) {
	rsp, err := c.GetUploadsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadsIdResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// GetUsersMeWithResponse request returning *GetUsersMeResponse
func (c *ClientWithResponses) GetUsersMeWithResponse(ctx context.Context, params *GetUsersMeParams, reqEditors ...RequestEditorFn) (*GetUsersMeResponse, error) {
	rsp, err := c.GetUsersMe(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersMeResponse(rsp)
}

// DeleteUsersIdWithResponse request returning *DeleteUsersIdResponse
func (c *ClientWithResponses) DeleteUsersIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUsersIdResponse, error) {
	rsp, err := c.DeleteUsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersIdResponse(rsp)
}

// GetUsersIdWithResponse request returning *GetUsersIdResponse
func (c *ClientWithResponses) GetUsersIdWithResponse(ctx context.Context, id string, params *GetUsersIdParams, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error) {
	rsp, err := c.GetUsersId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdResponse(rsp)
}

// PostUsersIdWithBodyWithResponse request with arbitrary body returning *PostUsersIdResponse
func (c *ClientWithResponses) PostUsersIdWithBodyWithResponse(ctx context.Context, id string, params *PostUsersIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersIdResponse, error) {
	rsp, err := c.PostUsersIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersIdResponse(rsp)
}

func (c *ClientWithResponses) PostUsersIdWithResponse(ctx context.Context, id string, params *PostUsersIdParams, body PostUsersIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersIdResponse, error) {
	rsp, err := c.PostUsersId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersIdResponse(rsp)
}

// GetWorkflowsExecutionsWithResponse request returning *GetWorkflowsExecutionsResponse
func (c *ClientWithResponses) GetWorkflowsExecutionsWithResponse(ctx context.Context, params *GetWorkflowsExecutionsParams, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsResponse, error) {
	rsp, err := c.GetWorkflowsExecutions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowsExecutionsResponse(rsp)
}

// GetWorkflowsExecutionsIdWithResponse request returning *GetWorkflowsExecutionsIdResponse
func (c *ClientWithResponses) GetWorkflowsExecutionsIdWithResponse(ctx context.Context, id string, params *GetWorkflowsExecutionsIdParams, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsIdResponse, error) {
	rsp, err := c.GetWorkflowsExecutionsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowsExecutionsIdResponse(rsp)
}

// PostWorkflowsExecutionsWorkflowIdRunWithBodyWithResponse request with arbitrary body returning *PostWorkflowsExecutionsWorkflowIdRunResponse
func (c *ClientWithResponses) PostWorkflowsExecutionsWorkflowIdRunWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdRunResponse, error) {
	rsp, err := c.PostWorkflowsExecutionsWorkflowIdRunWithBody(ctx, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkflowsExecutionsWorkflowIdRunResponse(rsp)
}

func (c *ClientWithResponses) PostWorkflowsExecutionsWorkflowIdRunWithResponse(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdRunJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdRunResponse, error) {
	rsp, err := c.PostWorkflowsExecutionsWorkflowIdRun(ctx, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkflowsExecutionsWorkflowIdRunResponse(rsp)
}

// PostWorkflowsExecutionsWorkflowIdStepsFailureWithBodyWithResponse request with arbitrary body returning *PostWorkflowsExecutionsWorkflowIdStepsFailureResponse
func (c *ClientWithResponses) PostWorkflowsExecutionsWorkflowIdStepsFailureWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsFailureResponse, error) {
	rsp, err := c.PostWorkflowsExecutionsWorkflowIdStepsFailureWithBody(ctx, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkflowsExecutionsWorkflowIdStepsFailureResponse(rsp)
}

func (c *ClientWithResponses) PostWorkflowsExecutionsWorkflowIdStepsFailureWithResponse(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsFailureJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsFailureResponse, error) {
	rsp, err := c.PostWorkflowsExecutionsWorkflowIdStepsFailure(ctx, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkflowsExecutionsWorkflowIdStepsFailureResponse(rsp)
}

// PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBodyWithResponse request with arbitrary body returning *PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse
func (c *ClientWithResponses) PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse, error) {
	rsp, err := c.PostWorkflowsExecutionsWorkflowIdStepsSuccessWithBody(ctx, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkflowsExecutionsWorkflowIdStepsSuccessResponse(rsp)
}

func (c *ClientWithResponses) PostWorkflowsExecutionsWorkflowIdStepsSuccessWithResponse(ctx context.Context, workflowId string, body PostWorkflowsExecutionsWorkflowIdStepsSuccessJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse, error) {
	rsp, err := c.PostWorkflowsExecutionsWorkflowIdStepsSuccess(ctx, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWorkflowsExecutionsWorkflowIdStepsSuccessResponse(rsp)
}

// GetWorkflowsExecutionsWorkflowIdSubscribeWithResponse request returning *GetWorkflowsExecutionsWorkflowIdSubscribeResponse
func (c *ClientWithResponses) GetWorkflowsExecutionsWorkflowIdSubscribeWithResponse(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsWorkflowIdSubscribeResponse, error) {
	rsp, err := c.GetWorkflowsExecutionsWorkflowIdSubscribe(ctx, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowsExecutionsWorkflowIdSubscribeResponse(rsp)
}

// GetWorkflowsExecutionsWorkflowIdTransactionIdWithResponse request returning *GetWorkflowsExecutionsWorkflowIdTransactionIdResponse
func (c *ClientWithResponses) GetWorkflowsExecutionsWorkflowIdTransactionIdWithResponse(ctx context.Context, workflowId string, transactionId string, params *GetWorkflowsExecutionsWorkflowIdTransactionIdParams, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsWorkflowIdTransactionIdResponse, error) {
	rsp, err := c.GetWorkflowsExecutionsWorkflowIdTransactionId(ctx, workflowId, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowsExecutionsWorkflowIdTransactionIdResponse(rsp)
}

// GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeWithResponse request returning *GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse
func (c *ClientWithResponses) GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeWithResponse(ctx context.Context, workflowId string, transactionId string, stepId string, reqEditors ...RequestEditorFn) (*GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse, error) {
	rsp, err := c.GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribe(ctx, workflowId, transactionId, stepId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse(rsp)
}

// DeleteSessionWithResponse request returning *DeleteSessionResponse
func (c *ClientWithResponses) DeleteSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteSessionResponse, error) {
	rsp, err := c.DeleteSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSessionResponse(rsp)
}

// PostSessionWithResponse request returning *PostSessionResponse
func (c *ClientWithResponses) PostSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSessionResponse, error) {
	rsp, err := c.PostSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSessionResponse(rsp)
}

// PostAdminAuthTokenRefreshWithResponse request returning *PostAdminAuthTokenRefreshResponse
func (c *ClientWithResponses) PostAdminAuthTokenRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAdminAuthTokenRefreshResponse, error) {
	rsp, err := c.PostAdminAuthTokenRefresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAdminAuthTokenRefreshResponse(rsp)
}

// PostActorTypeAuthProviderWithBodyWithResponse request with arbitrary body returning *PostActorTypeAuthProviderResponse
func (c *ClientWithResponses) PostActorTypeAuthProviderWithBodyWithResponse(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderResponse, error) {
	rsp, err := c.PostActorTypeAuthProviderWithBody(ctx, authProvider, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActorTypeAuthProviderResponse(rsp)
}

func (c *ClientWithResponses) PostActorTypeAuthProviderWithResponse(ctx context.Context, authProvider string, body PostActorTypeAuthProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderResponse, error) {
	rsp, err := c.PostActorTypeAuthProvider(ctx, authProvider, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActorTypeAuthProviderResponse(rsp)
}

// PostActorTypeAuthProviderCallbackWithResponse request returning *PostActorTypeAuthProviderCallbackResponse
func (c *ClientWithResponses) PostActorTypeAuthProviderCallbackWithResponse(ctx context.Context, authProvider string, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderCallbackResponse, error) {
	rsp, err := c.PostActorTypeAuthProviderCallback(ctx, authProvider, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActorTypeAuthProviderCallbackResponse(rsp)
}

// PostActorTypeAuthProviderRegisterWithBodyWithResponse request with arbitrary body returning *PostActorTypeAuthProviderRegisterResponse
func (c *ClientWithResponses) PostActorTypeAuthProviderRegisterWithBodyWithResponse(ctx context.Context, authProvider string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderRegisterResponse, error) {
	rsp, err := c.PostActorTypeAuthProviderRegisterWithBody(ctx, authProvider, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActorTypeAuthProviderRegisterResponse(rsp)
}

func (c *ClientWithResponses) PostActorTypeAuthProviderRegisterWithResponse(ctx context.Context, authProvider string, body PostActorTypeAuthProviderRegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActorTypeAuthProviderRegisterResponse, error) {
	rsp, err := c.PostActorTypeAuthProviderRegister(ctx, authProvider, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActorTypeAuthProviderRegisterResponse(rsp)
}

// ParseGetApiKeysResponse parses an HTTP response from a GetApiKeysWithResponse call
func ParseGetApiKeysResponse(rsp *http.Response) (*GetApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ApiKeys The list of API keys.
			ApiKeys []ApiKeyResponse `json:"api_keys"`

			// Count The total count of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned in the list.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostApiKeysResponse parses an HTTP response from a PostApiKeysWithResponse call
func ParsePostApiKeysResponse(rsp *http.Response) (*PostApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeysIdResponse parses an HTTP response from a DeleteApiKeysIdWithResponse call
func ParseDeleteApiKeysIdResponse(rsp *http.Response) (*DeleteApiKeysIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeysIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the API key was deleted.
			Deleted bool `json:"deleted"`

			// Id The API key's ID.
			Id string `json:"id"`

			// Object The name of the object that was deleted.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiKeysIdResponse parses an HTTP response from a GetApiKeysIdWithResponse call
func ParseGetApiKeysIdResponse(rsp *http.Response) (*GetApiKeysIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiKeysIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostApiKeysIdResponse parses an HTTP response from a PostApiKeysIdWithResponse call
func ParsePostApiKeysIdResponse(rsp *http.Response) (*PostApiKeysIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiKeysIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostApiKeysIdRevokeResponse parses an HTTP response from a PostApiKeysIdRevokeWithResponse call
func ParsePostApiKeysIdRevokeResponse(rsp *http.Response) (*PostApiKeysIdRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiKeysIdRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostApiKeysIdSalesChannelsResponse parses an HTTP response from a PostApiKeysIdSalesChannelsWithResponse call
func ParsePostApiKeysIdSalesChannelsResponse(rsp *http.Response) (*PostApiKeysIdSalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiKeysIdSalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCampaignsResponse parses an HTTP response from a GetCampaignsWithResponse call
func ParseGetCampaignsResponse(rsp *http.Response) (*GetCampaignsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Campaigns The list of campaigns.
			Campaigns []CampaignResponse `json:"campaigns"`

			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items retrieved.
			Limit float32 `json:"limit"`

			// Offset The number of its skipped before the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCampaignsResponse parses an HTTP response from a PostCampaignsWithResponse call
func ParsePostCampaignsResponse(rsp *http.Response) (*PostCampaignsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCampaignsIdResponse parses an HTTP response from a DeleteCampaignsIdWithResponse call
func ParseDeleteCampaignsIdResponse(rsp *http.Response) (*DeleteCampaignsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCampaignsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the campaign was deleted.
			Deleted bool `json:"deleted"`

			// Id The campaign's ID.
			Id string `json:"id"`

			// Object The name of the object that was deleted.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdResponse parses an HTTP response from a GetCampaignsIdWithResponse call
func ParseGetCampaignsIdResponse(rsp *http.Response) (*GetCampaignsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCampaignsIdResponse parses an HTTP response from a PostCampaignsIdWithResponse call
func ParsePostCampaignsIdResponse(rsp *http.Response) (*PostCampaignsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCampaignsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCampaignsIdPromotionsResponse parses an HTTP response from a PostCampaignsIdPromotionsWithResponse call
func ParsePostCampaignsIdPromotionsResponse(rsp *http.Response) (*PostCampaignsIdPromotionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCampaignsIdPromotionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClaimsResponse parses an HTTP response from a GetClaimsWithResponse call
func ParseGetClaimsResponse(rsp *http.Response) (*GetClaimsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClaimsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsResponse parses an HTTP response from a PostClaimsWithResponse call
func ParsePostClaimsResponse(rsp *http.Response) (*PostClaimsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetClaimsIdResponse parses an HTTP response from a GetClaimsIdWithResponse call
func ParseGetClaimsIdResponse(rsp *http.Response) (*GetClaimsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClaimsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdCancelResponse parses an HTTP response from a PostClaimsIdCancelWithResponse call
func ParsePostClaimsIdCancelResponse(rsp *http.Response) (*PostClaimsIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdClaimItemsResponse parses an HTTP response from a PostClaimsIdClaimItemsWithResponse call
func ParsePostClaimsIdClaimItemsResponse(rsp *http.Response) (*PostClaimsIdClaimItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdClaimItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClaimsIdClaimItemsActionIdResponse parses an HTTP response from a DeleteClaimsIdClaimItemsActionIdWithResponse call
func ParseDeleteClaimsIdClaimItemsActionIdResponse(rsp *http.Response) (*DeleteClaimsIdClaimItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClaimsIdClaimItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdClaimItemsActionIdResponse parses an HTTP response from a PostClaimsIdClaimItemsActionIdWithResponse call
func ParsePostClaimsIdClaimItemsActionIdResponse(rsp *http.Response) (*PostClaimsIdClaimItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdClaimItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdInboundItemsResponse parses an HTTP response from a PostClaimsIdInboundItemsWithResponse call
func ParsePostClaimsIdInboundItemsResponse(rsp *http.Response) (*PostClaimsIdInboundItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdInboundItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClaimsIdInboundItemsActionIdResponse parses an HTTP response from a DeleteClaimsIdInboundItemsActionIdWithResponse call
func ParseDeleteClaimsIdInboundItemsActionIdResponse(rsp *http.Response) (*DeleteClaimsIdInboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClaimsIdInboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdInboundItemsActionIdResponse parses an HTTP response from a PostClaimsIdInboundItemsActionIdWithResponse call
func ParsePostClaimsIdInboundItemsActionIdResponse(rsp *http.Response) (*PostClaimsIdInboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdInboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdInboundShippingMethodResponse parses an HTTP response from a PostClaimsIdInboundShippingMethodWithResponse call
func ParsePostClaimsIdInboundShippingMethodResponse(rsp *http.Response) (*PostClaimsIdInboundShippingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdInboundShippingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClaimsIdInboundShippingMethodActionIdResponse parses an HTTP response from a DeleteClaimsIdInboundShippingMethodActionIdWithResponse call
func ParseDeleteClaimsIdInboundShippingMethodActionIdResponse(rsp *http.Response) (*DeleteClaimsIdInboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClaimsIdInboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdInboundShippingMethodActionIdResponse parses an HTTP response from a PostClaimsIdInboundShippingMethodActionIdWithResponse call
func ParsePostClaimsIdInboundShippingMethodActionIdResponse(rsp *http.Response) (*PostClaimsIdInboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdInboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdOutboundItemsResponse parses an HTTP response from a PostClaimsIdOutboundItemsWithResponse call
func ParsePostClaimsIdOutboundItemsResponse(rsp *http.Response) (*PostClaimsIdOutboundItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdOutboundItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClaimsIdOutboundItemsActionIdResponse parses an HTTP response from a DeleteClaimsIdOutboundItemsActionIdWithResponse call
func ParseDeleteClaimsIdOutboundItemsActionIdResponse(rsp *http.Response) (*DeleteClaimsIdOutboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClaimsIdOutboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdOutboundItemsActionIdResponse parses an HTTP response from a PostClaimsIdOutboundItemsActionIdWithResponse call
func ParsePostClaimsIdOutboundItemsActionIdResponse(rsp *http.Response) (*PostClaimsIdOutboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdOutboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdOutboundShippingMethodResponse parses an HTTP response from a PostClaimsIdOutboundShippingMethodWithResponse call
func ParsePostClaimsIdOutboundShippingMethodResponse(rsp *http.Response) (*PostClaimsIdOutboundShippingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdOutboundShippingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClaimsIdOutboundShippingMethodActionIdResponse parses an HTTP response from a DeleteClaimsIdOutboundShippingMethodActionIdWithResponse call
func ParseDeleteClaimsIdOutboundShippingMethodActionIdResponse(rsp *http.Response) (*DeleteClaimsIdOutboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClaimsIdOutboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdOutboundShippingMethodActionIdResponse parses an HTTP response from a PostClaimsIdOutboundShippingMethodActionIdWithResponse call
func ParsePostClaimsIdOutboundShippingMethodActionIdResponse(rsp *http.Response) (*PostClaimsIdOutboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdOutboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClaimsIdRequestResponse parses an HTTP response from a DeleteClaimsIdRequestWithResponse call
func ParseDeleteClaimsIdRequestResponse(rsp *http.Response) (*DeleteClaimsIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClaimsIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostClaimsIdRequestResponse parses an HTTP response from a PostClaimsIdRequestWithResponse call
func ParsePostClaimsIdRequestResponse(rsp *http.Response) (*PostClaimsIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClaimsIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminClaimRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionsResponse parses an HTTP response from a GetCollectionsWithResponse call
func ParseGetCollectionsResponse(rsp *http.Response) (*GetCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionsResponse parses an HTTP response from a PostCollectionsWithResponse call
func ParsePostCollectionsResponse(rsp *http.Response) (*PostCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionsIdResponse parses an HTTP response from a DeleteCollectionsIdWithResponse call
func ParseDeleteCollectionsIdResponse(rsp *http.Response) (*DeleteCollectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionsIdResponse parses an HTTP response from a GetCollectionsIdWithResponse call
func ParseGetCollectionsIdResponse(rsp *http.Response) (*GetCollectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionsIdResponse parses an HTTP response from a PostCollectionsIdWithResponse call
func ParsePostCollectionsIdResponse(rsp *http.Response) (*PostCollectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionsIdProductsResponse parses an HTTP response from a PostCollectionsIdProductsWithResponse call
func ParsePostCollectionsIdProductsResponse(rsp *http.Response) (*PostCollectionsIdProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionsIdProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrenciesResponse parses an HTTP response from a GetCurrenciesWithResponse call
func ParseGetCurrenciesResponse(rsp *http.Response) (*GetCurrenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCurrencyListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrenciesCodeResponse parses an HTTP response from a GetCurrenciesCodeWithResponse call
func ParseGetCurrenciesCodeResponse(rsp *http.Response) (*GetCurrenciesCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrenciesCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCurrencyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomerGroupsResponse parses an HTTP response from a GetCustomerGroupsWithResponse call
func ParseGetCustomerGroupsResponse(rsp *http.Response) (*GetCustomerGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items
			Count float32 `json:"count"`

			// CustomerGroups The list of customer groups.
			CustomerGroups []AdminCustomerGroup `json:"customer_groups"`

			// Limit The maximum number of items retrieved.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomerGroupsResponse parses an HTTP response from a PostCustomerGroupsWithResponse call
func ParsePostCustomerGroupsResponse(rsp *http.Response) (*PostCustomerGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomerGroupsIdResponse parses an HTTP response from a DeleteCustomerGroupsIdWithResponse call
func ParseDeleteCustomerGroupsIdResponse(rsp *http.Response) (*DeleteCustomerGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted The customer group's deleted.
			Deleted bool `json:"deleted"`

			// Id The customer group's ID.
			Id string `json:"id"`

			// Object The customer group's object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomerGroupsIdResponse parses an HTTP response from a GetCustomerGroupsIdWithResponse call
func ParseGetCustomerGroupsIdResponse(rsp *http.Response) (*GetCustomerGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomerGroupsIdResponse parses an HTTP response from a PostCustomerGroupsIdWithResponse call
func ParsePostCustomerGroupsIdResponse(rsp *http.Response) (*PostCustomerGroupsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerGroupsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomerGroupsIdCustomersResponse parses an HTTP response from a PostCustomerGroupsIdCustomersWithResponse call
func ParsePostCustomerGroupsIdCustomersResponse(rsp *http.Response) (*PostCustomerGroupsIdCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerGroupsIdCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomersResponse parses an HTTP response from a GetCustomersWithResponse call
func ParseGetCustomersResponse(rsp *http.Response) (*GetCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Customers The customer's details.
			Customers AdminCustomer `json:"customers"`

			// Limit The maximum number of items returned in the list.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomersResponse parses an HTTP response from a PostCustomersWithResponse call
func ParsePostCustomersResponse(rsp *http.Response) (*PostCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomersIdResponse parses an HTTP response from a DeleteCustomersIdWithResponse call
func ParseDeleteCustomersIdResponse(rsp *http.Response) (*DeleteCustomersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted The customer's deleted.
			Deleted bool `json:"deleted"`

			// Id The customer's ID.
			Id string `json:"id"`

			// Object The customer's object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomersIdResponse parses an HTTP response from a GetCustomersIdWithResponse call
func ParseGetCustomersIdResponse(rsp *http.Response) (*GetCustomersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomersIdResponse parses an HTTP response from a PostCustomersIdWithResponse call
func ParsePostCustomersIdResponse(rsp *http.Response) (*PostCustomersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomersIdAddressesResponse parses an HTTP response from a GetCustomersIdAddressesWithResponse call
func ParseGetCustomersIdAddressesResponse(rsp *http.Response) (*GetCustomersIdAddressesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersIdAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Addresses The customer addresses.
			Addresses []AdminCustomerAddress `json:"addresses"`

			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomersIdAddressesResponse parses an HTTP response from a PostCustomersIdAddressesWithResponse call
func ParsePostCustomersIdAddressesResponse(rsp *http.Response) (*PostCustomersIdAddressesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersIdAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomersIdAddressesAddressIdResponse parses an HTTP response from a DeleteCustomersIdAddressesAddressIdWithResponse call
func ParseDeleteCustomersIdAddressesAddressIdResponse(rsp *http.Response) (*DeleteCustomersIdAddressesAddressIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomersIdAddressesAddressIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the Customer was deleted.
			Deleted bool `json:"deleted"`

			// Id The customer's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`

			// Parent The customer's details.
			Parent *AdminCustomer `json:"parent,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomersIdAddressesAddressIdResponse parses an HTTP response from a GetCustomersIdAddressesAddressIdWithResponse call
func ParseGetCustomersIdAddressesAddressIdResponse(rsp *http.Response) (*GetCustomersIdAddressesAddressIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersIdAddressesAddressIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerAddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomersIdAddressesAddressIdResponse parses an HTTP response from a PostCustomersIdAddressesAddressIdWithResponse call
func ParsePostCustomersIdAddressesAddressIdResponse(rsp *http.Response) (*PostCustomersIdAddressesAddressIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersIdAddressesAddressIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDraftOrdersResponse parses an HTTP response from a GetDraftOrdersWithResponse call
func ParseGetDraftOrdersResponse(rsp *http.Response) (*GetDraftOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDraftOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// DraftOrders The order's details.
			DraftOrders AdminOrder `json:"draft_orders"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDraftOrdersResponse parses an HTTP response from a PostDraftOrdersWithResponse call
func ParsePostDraftOrdersResponse(rsp *http.Response) (*PostDraftOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDraftOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDraftOrdersIdResponse parses an HTTP response from a GetDraftOrdersIdWithResponse call
func ParseGetDraftOrdersIdResponse(rsp *http.Response) (*GetDraftOrdersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDraftOrdersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExchangesResponse parses an HTTP response from a GetExchangesWithResponse call
func ParseGetExchangesResponse(rsp *http.Response) (*GetExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Exchanges The exchange's exchanges.
			Exchanges []AdminExchange `json:"exchanges"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesResponse parses an HTTP response from a PostExchangesWithResponse call
func ParsePostExchangesResponse(rsp *http.Response) (*PostExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExchangesIdResponse parses an HTTP response from a GetExchangesIdWithResponse call
func ParseGetExchangesIdResponse(rsp *http.Response) (*GetExchangesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExchangesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdCancelResponse parses an HTTP response from a PostExchangesIdCancelWithResponse call
func ParsePostExchangesIdCancelResponse(rsp *http.Response) (*PostExchangesIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdInboundItemsResponse parses an HTTP response from a PostExchangesIdInboundItemsWithResponse call
func ParsePostExchangesIdInboundItemsResponse(rsp *http.Response) (*PostExchangesIdInboundItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdInboundItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExchangesIdInboundItemsActionIdResponse parses an HTTP response from a DeleteExchangesIdInboundItemsActionIdWithResponse call
func ParseDeleteExchangesIdInboundItemsActionIdResponse(rsp *http.Response) (*DeleteExchangesIdInboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExchangesIdInboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdInboundItemsActionIdResponse parses an HTTP response from a PostExchangesIdInboundItemsActionIdWithResponse call
func ParsePostExchangesIdInboundItemsActionIdResponse(rsp *http.Response) (*PostExchangesIdInboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdInboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdInboundShippingMethodResponse parses an HTTP response from a PostExchangesIdInboundShippingMethodWithResponse call
func ParsePostExchangesIdInboundShippingMethodResponse(rsp *http.Response) (*PostExchangesIdInboundShippingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdInboundShippingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExchangesIdInboundShippingMethodActionIdResponse parses an HTTP response from a DeleteExchangesIdInboundShippingMethodActionIdWithResponse call
func ParseDeleteExchangesIdInboundShippingMethodActionIdResponse(rsp *http.Response) (*DeleteExchangesIdInboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExchangesIdInboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdInboundShippingMethodActionIdResponse parses an HTTP response from a PostExchangesIdInboundShippingMethodActionIdWithResponse call
func ParsePostExchangesIdInboundShippingMethodActionIdResponse(rsp *http.Response) (*PostExchangesIdInboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdInboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdOutboundItemsResponse parses an HTTP response from a PostExchangesIdOutboundItemsWithResponse call
func ParsePostExchangesIdOutboundItemsResponse(rsp *http.Response) (*PostExchangesIdOutboundItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdOutboundItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExchangesIdOutboundItemsActionIdResponse parses an HTTP response from a DeleteExchangesIdOutboundItemsActionIdWithResponse call
func ParseDeleteExchangesIdOutboundItemsActionIdResponse(rsp *http.Response) (*DeleteExchangesIdOutboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExchangesIdOutboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdOutboundItemsActionIdResponse parses an HTTP response from a PostExchangesIdOutboundItemsActionIdWithResponse call
func ParsePostExchangesIdOutboundItemsActionIdResponse(rsp *http.Response) (*PostExchangesIdOutboundItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdOutboundItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdOutboundShippingMethodResponse parses an HTTP response from a PostExchangesIdOutboundShippingMethodWithResponse call
func ParsePostExchangesIdOutboundShippingMethodResponse(rsp *http.Response) (*PostExchangesIdOutboundShippingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdOutboundShippingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExchangesIdOutboundShippingMethodActionIdResponse parses an HTTP response from a DeleteExchangesIdOutboundShippingMethodActionIdWithResponse call
func ParseDeleteExchangesIdOutboundShippingMethodActionIdResponse(rsp *http.Response) (*DeleteExchangesIdOutboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExchangesIdOutboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdOutboundShippingMethodActionIdResponse parses an HTTP response from a PostExchangesIdOutboundShippingMethodActionIdWithResponse call
func ParsePostExchangesIdOutboundShippingMethodActionIdResponse(rsp *http.Response) (*PostExchangesIdOutboundShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdOutboundShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteExchangesIdRequestResponse parses an HTTP response from a DeleteExchangesIdRequestWithResponse call
func ParseDeleteExchangesIdRequestResponse(rsp *http.Response) (*DeleteExchangesIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExchangesIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostExchangesIdRequestResponse parses an HTTP response from a PostExchangesIdRequestWithResponse call
func ParsePostExchangesIdRequestResponse(rsp *http.Response) (*PostExchangesIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExchangesIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExchangeRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFulfillmentProvidersResponse parses an HTTP response from a GetFulfillmentProvidersWithResponse call
func ParseGetFulfillmentProvidersResponse(rsp *http.Response) (*GetFulfillmentProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFulfillmentProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentProviderListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFulfillmentSetsIdResponse parses an HTTP response from a DeleteFulfillmentSetsIdWithResponse call
func ParseDeleteFulfillmentSetsIdResponse(rsp *http.Response) (*DeleteFulfillmentSetsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFulfillmentSetsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentSetDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFulfillmentSetsIdServiceZonesResponse parses an HTTP response from a PostFulfillmentSetsIdServiceZonesWithResponse call
func ParsePostFulfillmentSetsIdServiceZonesResponse(rsp *http.Response) (*PostFulfillmentSetsIdServiceZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFulfillmentSetsIdServiceZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFulfillmentSetsIdServiceZonesZoneIdResponse parses an HTTP response from a DeleteFulfillmentSetsIdServiceZonesZoneIdWithResponse call
func ParseDeleteFulfillmentSetsIdServiceZonesZoneIdResponse(rsp *http.Response) (*DeleteFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFulfillmentSetsIdServiceZonesZoneIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminServiceZoneDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFulfillmentSetsIdServiceZonesZoneIdResponse parses an HTTP response from a GetFulfillmentSetsIdServiceZonesZoneIdWithResponse call
func ParseGetFulfillmentSetsIdServiceZonesZoneIdResponse(rsp *http.Response) (*GetFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFulfillmentSetsIdServiceZonesZoneIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminServiceZoneResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFulfillmentSetsIdServiceZonesZoneIdResponse parses an HTTP response from a PostFulfillmentSetsIdServiceZonesZoneIdWithResponse call
func ParsePostFulfillmentSetsIdServiceZonesZoneIdResponse(rsp *http.Response) (*PostFulfillmentSetsIdServiceZonesZoneIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFulfillmentSetsIdServiceZonesZoneIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFulfillmentsResponse parses an HTTP response from a PostFulfillmentsWithResponse call
func ParsePostFulfillmentsResponse(rsp *http.Response) (*PostFulfillmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFulfillmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFulfillmentsIdCancelResponse parses an HTTP response from a PostFulfillmentsIdCancelWithResponse call
func ParsePostFulfillmentsIdCancelResponse(rsp *http.Response) (*PostFulfillmentsIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFulfillmentsIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFulfillmentsIdShipmentResponse parses an HTTP response from a PostFulfillmentsIdShipmentWithResponse call
func ParsePostFulfillmentsIdShipmentResponse(rsp *http.Response) (*PostFulfillmentsIdShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFulfillmentsIdShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFulfillmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemsResponse parses an HTTP response from a GetInventoryItemsWithResponse call
func ParseGetInventoryItemsResponse(rsp *http.Response) (*GetInventoryItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// InventoryItems The inventory item's inventory items.
			InventoryItems []AdminInventoryItem `json:"inventory_items"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsResponse parses an HTTP response from a PostInventoryItemsWithResponse call
func ParsePostInventoryItemsResponse(rsp *http.Response) (*PostInventoryItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryItemsIdResponse parses an HTTP response from a DeleteInventoryItemsIdWithResponse call
func ParseDeleteInventoryItemsIdResponse(rsp *http.Response) (*DeleteInventoryItemsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryItemsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the inventory item was deleted.
			Deleted bool `json:"deleted"`

			// Id The inventory item's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemsIdResponse parses an HTTP response from a GetInventoryItemsIdWithResponse call
func ParseGetInventoryItemsIdResponse(rsp *http.Response) (*GetInventoryItemsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsIdResponse parses an HTTP response from a PostInventoryItemsIdWithResponse call
func ParsePostInventoryItemsIdResponse(rsp *http.Response) (*PostInventoryItemsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemsIdLocationLevelsResponse parses an HTTP response from a GetInventoryItemsIdLocationLevelsWithResponse call
func ParseGetInventoryItemsIdLocationLevelsResponse(rsp *http.Response) (*GetInventoryItemsIdLocationLevelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemsIdLocationLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// InventoryLevels The inventory item's inventory levels.
			InventoryLevels []InventoryLevel `json:"inventory_levels"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsIdLocationLevelsResponse parses an HTTP response from a PostInventoryItemsIdLocationLevelsWithResponse call
func ParsePostInventoryItemsIdLocationLevelsResponse(rsp *http.Response) (*PostInventoryItemsIdLocationLevelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsIdLocationLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsIdLocationLevelsBatchResponse parses an HTTP response from a PostInventoryItemsIdLocationLevelsBatchWithResponse call
func ParsePostInventoryItemsIdLocationLevelsBatchResponse(rsp *http.Response) (*PostInventoryItemsIdLocationLevelsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsIdLocationLevelsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// InventoryItem The inventory item's details.
			InventoryItem map[string]interface{} `json:"inventory_item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryItemsIdLocationLevelsLocationIdResponse parses an HTTP response from a DeleteInventoryItemsIdLocationLevelsLocationIdWithResponse call
func ParseDeleteInventoryItemsIdLocationLevelsLocationIdResponse(rsp *http.Response) (*DeleteInventoryItemsIdLocationLevelsLocationIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryItemsIdLocationLevelsLocationIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the Inventory Item was deleted.
			Deleted bool `json:"deleted"`

			// Id The inventory item's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`

			// Parent The reservation's inventory item.
			Parent *AdminInventoryItem `json:"parent,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsIdLocationLevelsLocationIdResponse parses an HTTP response from a PostInventoryItemsIdLocationLevelsLocationIdWithResponse call
func ParsePostInventoryItemsIdLocationLevelsLocationIdResponse(rsp *http.Response) (*PostInventoryItemsIdLocationLevelsLocationIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsIdLocationLevelsLocationIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInvitesResponse parses an HTTP response from a GetInvitesWithResponse call
func ParseGetInvitesResponse(rsp *http.Response) (*GetInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Invites The list of invites.
			Invites []AdminInvite `json:"invites"`

			// Limit The maximum number of items retrieved.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before the returned items.
			Offset float32 `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInvitesResponse parses an HTTP response from a PostInvitesWithResponse call
func ParsePostInvitesResponse(rsp *http.Response) (*PostInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInviteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInvitesAcceptResponse parses an HTTP response from a PostInvitesAcceptWithResponse call
func ParsePostInvitesAcceptResponse(rsp *http.Response) (*PostInvitesAcceptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInvitesAcceptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInvitesIdResponse parses an HTTP response from a DeleteInvitesIdWithResponse call
func ParseDeleteInvitesIdResponse(rsp *http.Response) (*DeleteInvitesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInvitesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the invite was deleted.
			Deleted bool `json:"deleted"`

			// Id The invite's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInvitesIdResponse parses an HTTP response from a GetInvitesIdWithResponse call
func ParseGetInvitesIdResponse(rsp *http.Response) (*GetInvitesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvitesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInviteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInvitesIdResendResponse parses an HTTP response from a PostInvitesIdResendWithResponse call
func ParsePostInvitesIdResendResponse(rsp *http.Response) (*PostInvitesIdResendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInvitesIdResendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInviteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationsResponse parses an HTTP response from a GetNotificationsWithResponse call
func ParseGetNotificationsResponse(rsp *http.Response) (*GetNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotificationListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationsIdResponse parses an HTTP response from a GetNotificationsIdWithResponse call
func ParseGetNotificationsIdResponse(rsp *http.Response) (*GetNotificationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsResponse parses an HTTP response from a PostOrderEditsWithResponse call
func ParsePostOrderEditsResponse(rsp *http.Response) (*PostOrderEditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrderEditsIdResponse parses an HTTP response from a DeleteOrderEditsIdWithResponse call
func ParseDeleteOrderEditsIdResponse(rsp *http.Response) (*DeleteOrderEditsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderEditsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the order edit was deleted.
			Deleted bool `json:"deleted"`

			// Id The order edit's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdConfirmResponse parses an HTTP response from a PostOrderEditsIdConfirmWithResponse call
func ParsePostOrderEditsIdConfirmResponse(rsp *http.Response) (*PostOrderEditsIdConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdItemsResponse parses an HTTP response from a PostOrderEditsIdItemsWithResponse call
func ParsePostOrderEditsIdItemsResponse(rsp *http.Response) (*PostOrderEditsIdItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdItemsItemItemIdResponse parses an HTTP response from a PostOrderEditsIdItemsItemItemIdWithResponse call
func ParsePostOrderEditsIdItemsItemItemIdResponse(rsp *http.Response) (*PostOrderEditsIdItemsItemItemIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdItemsItemItemIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrderEditsIdItemsActionIdResponse parses an HTTP response from a DeleteOrderEditsIdItemsActionIdWithResponse call
func ParseDeleteOrderEditsIdItemsActionIdResponse(rsp *http.Response) (*DeleteOrderEditsIdItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderEditsIdItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdItemsActionIdResponse parses an HTTP response from a PostOrderEditsIdItemsActionIdWithResponse call
func ParsePostOrderEditsIdItemsActionIdResponse(rsp *http.Response) (*PostOrderEditsIdItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdRequestResponse parses an HTTP response from a PostOrderEditsIdRequestWithResponse call
func ParsePostOrderEditsIdRequestResponse(rsp *http.Response) (*PostOrderEditsIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdShippingMethodResponse parses an HTTP response from a PostOrderEditsIdShippingMethodWithResponse call
func ParsePostOrderEditsIdShippingMethodResponse(rsp *http.Response) (*PostOrderEditsIdShippingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdShippingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrderEditsIdShippingMethodActionIdResponse parses an HTTP response from a DeleteOrderEditsIdShippingMethodActionIdWithResponse call
func ParseDeleteOrderEditsIdShippingMethodActionIdResponse(rsp *http.Response) (*DeleteOrderEditsIdShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderEditsIdShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsIdShippingMethodActionIdResponse parses an HTTP response from a PostOrderEditsIdShippingMethodActionIdWithResponse call
func ParsePostOrderEditsIdShippingMethodActionIdResponse(rsp *http.Response) (*PostOrderEditsIdShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsIdShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersResponse parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResponse(rsp *http.Response) (*GetOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total count of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before the returned items.
			Offset float32 `json:"offset"`

			// Orders The list of orders.
			Orders []AdminOrder `json:"orders"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersIdResponse parses an HTTP response from a GetOrdersIdWithResponse call
func ParseGetOrdersIdResponse(rsp *http.Response) (*GetOrdersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdResponse parses an HTTP response from a PostOrdersIdWithResponse call
func ParsePostOrdersIdResponse(rsp *http.Response) (*PostOrdersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdArchiveResponse parses an HTTP response from a PostOrdersIdArchiveWithResponse call
func ParsePostOrdersIdArchiveResponse(rsp *http.Response) (*PostOrdersIdArchiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdArchiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdCancelResponse parses an HTTP response from a PostOrdersIdCancelWithResponse call
func ParsePostOrdersIdCancelResponse(rsp *http.Response) (*PostOrdersIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersIdChangesResponse parses an HTTP response from a GetOrdersIdChangesWithResponse call
func ParseGetOrdersIdChangesResponse(rsp *http.Response) (*GetOrdersIdChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersIdChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderChangesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdCompleteResponse parses an HTTP response from a PostOrdersIdCompleteWithResponse call
func ParsePostOrdersIdCompleteResponse(rsp *http.Response) (*PostOrdersIdCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdFulfillmentsResponse parses an HTTP response from a PostOrdersIdFulfillmentsWithResponse call
func ParsePostOrdersIdFulfillmentsResponse(rsp *http.Response) (*PostOrdersIdFulfillmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdFulfillmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdFulfillmentsFulfillmentIdCancelResponse parses an HTTP response from a PostOrdersIdFulfillmentsFulfillmentIdCancelWithResponse call
func ParsePostOrdersIdFulfillmentsFulfillmentIdCancelResponse(rsp *http.Response) (*PostOrdersIdFulfillmentsFulfillmentIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdFulfillmentsFulfillmentIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse parses an HTTP response from a PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredWithResponse call
func ParsePostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse(rsp *http.Response) (*PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdFulfillmentsFulfillmentIdMarkAsDeliveredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse parses an HTTP response from a PostOrdersIdFulfillmentsFulfillmentIdShipmentsWithResponse call
func ParsePostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse(rsp *http.Response) (*PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersIdFulfillmentsFulfillmentIdShipmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersIdPreviewResponse parses an HTTP response from a GetOrdersIdPreviewWithResponse call
func ParseGetOrdersIdPreviewResponse(rsp *http.Response) (*GetOrdersIdPreviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersIdPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentCollectionsResponse parses an HTTP response from a PostPaymentCollectionsWithResponse call
func ParsePostPaymentCollectionsResponse(rsp *http.Response) (*PostPaymentCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePaymentCollectionsIdResponse parses an HTTP response from a DeletePaymentCollectionsIdWithResponse call
func ParseDeletePaymentCollectionsIdResponse(rsp *http.Response) (*DeletePaymentCollectionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentCollectionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDeletePaymentCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentCollectionsIdMarkAsPaidResponse parses an HTTP response from a PostPaymentCollectionsIdMarkAsPaidWithResponse call
func ParsePostPaymentCollectionsIdMarkAsPaidResponse(rsp *http.Response) (*PostPaymentCollectionsIdMarkAsPaidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentCollectionsIdMarkAsPaidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPaymentsResponse parses an HTTP response from a GetPaymentsWithResponse call
func ParseGetPaymentsResponse(rsp *http.Response) (*GetPaymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of payments.
			Count float32 `json:"count"`

			// Limit The maximum number of returned items.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before the returned items.
			Offset float32 `json:"offset"`

			// Payments The list of payments.
			Payments []AdminPayment `json:"payments"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPaymentsPaymentProvidersResponse parses an HTTP response from a GetPaymentsPaymentProvidersWithResponse call
func ParseGetPaymentsPaymentProvidersResponse(rsp *http.Response) (*GetPaymentsPaymentProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentsPaymentProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before the returned items.
			Offset float32 `json:"offset"`

			// PaymentProviders The list of payment providers.
			PaymentProviders []AdminPaymentProvider `json:"payment_providers"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPaymentsIdResponse parses an HTTP response from a GetPaymentsIdWithResponse call
func ParseGetPaymentsIdResponse(rsp *http.Response) (*GetPaymentsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentsIdCaptureResponse parses an HTTP response from a PostPaymentsIdCaptureWithResponse call
func ParsePostPaymentsIdCaptureResponse(rsp *http.Response) (*PostPaymentsIdCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentsIdCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentsIdRefundResponse parses an HTTP response from a PostPaymentsIdRefundWithResponse call
func ParsePostPaymentsIdRefundResponse(rsp *http.Response) (*PostPaymentsIdRefundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentsIdRefundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPriceListsResponse parses an HTTP response from a GetPriceListsWithResponse call
func ParseGetPriceListsResponse(rsp *http.Response) (*GetPriceListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPriceListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsResponse parses an HTTP response from a PostPriceListsWithResponse call
func ParsePostPriceListsResponse(rsp *http.Response) (*PostPriceListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePriceListsIdResponse parses an HTTP response from a DeletePriceListsIdWithResponse call
func ParseDeletePriceListsIdResponse(rsp *http.Response) (*DeletePriceListsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePriceListsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPriceListsIdResponse parses an HTTP response from a GetPriceListsIdWithResponse call
func ParseGetPriceListsIdResponse(rsp *http.Response) (*GetPriceListsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPriceListsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsIdResponse parses an HTTP response from a PostPriceListsIdWithResponse call
func ParsePostPriceListsIdResponse(rsp *http.Response) (*PostPriceListsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsIdPricesBatchResponse parses an HTTP response from a PostPriceListsIdPricesBatchWithResponse call
func ParsePostPriceListsIdPricesBatchResponse(rsp *http.Response) (*PostPriceListsIdPricesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsIdPricesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsIdProductsResponse parses an HTTP response from a PostPriceListsIdProductsWithResponse call
func ParsePostPriceListsIdProductsResponse(rsp *http.Response) (*PostPriceListsIdProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsIdProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPricePreferencesResponse parses an HTTP response from a GetPricePreferencesWithResponse call
func ParseGetPricePreferencesResponse(rsp *http.Response) (*GetPricePreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricePreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPricePreferenceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPricePreferencesResponse parses an HTTP response from a PostPricePreferencesWithResponse call
func ParsePostPricePreferencesResponse(rsp *http.Response) (*PostPricePreferencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPricePreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPricePreferenceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePricePreferencesIdResponse parses an HTTP response from a DeletePricePreferencesIdWithResponse call
func ParseDeletePricePreferencesIdResponse(rsp *http.Response) (*DeletePricePreferencesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePricePreferencesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPricePreferenceDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPricePreferencesIdResponse parses an HTTP response from a GetPricePreferencesIdWithResponse call
func ParseGetPricePreferencesIdResponse(rsp *http.Response) (*GetPricePreferencesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricePreferencesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPricePreferenceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPricePreferencesIdResponse parses an HTTP response from a PostPricePreferencesIdWithResponse call
func ParsePostPricePreferencesIdResponse(rsp *http.Response) (*PostPricePreferencesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPricePreferencesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPricePreferenceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductCategoriesResponse parses an HTTP response from a GetProductCategoriesWithResponse call
func ParseGetProductCategoriesResponse(rsp *http.Response) (*GetProductCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoryListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductCategoriesResponse parses an HTTP response from a PostProductCategoriesWithResponse call
func ParsePostProductCategoriesResponse(rsp *http.Response) (*PostProductCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductCategoriesIdResponse parses an HTTP response from a DeleteProductCategoriesIdWithResponse call
func ParseDeleteProductCategoriesIdResponse(rsp *http.Response) (*DeleteProductCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoryDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductCategoriesIdResponse parses an HTTP response from a GetProductCategoriesIdWithResponse call
func ParseGetProductCategoriesIdResponse(rsp *http.Response) (*GetProductCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductCategoriesIdResponse parses an HTTP response from a PostProductCategoriesIdWithResponse call
func ParsePostProductCategoriesIdResponse(rsp *http.Response) (*PostProductCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductCategoriesIdProductsResponse parses an HTTP response from a PostProductCategoriesIdProductsWithResponse call
func ParsePostProductCategoriesIdProductsResponse(rsp *http.Response) (*PostProductCategoriesIdProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductCategoriesIdProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductTagsResponse parses an HTTP response from a GetProductTagsWithResponse call
func ParseGetProductTagsResponse(rsp *http.Response) (*GetProductTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTagListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductTagsResponse parses an HTTP response from a PostProductTagsWithResponse call
func ParsePostProductTagsResponse(rsp *http.Response) (*PostProductTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductTagsIdResponse parses an HTTP response from a DeleteProductTagsIdWithResponse call
func ParseDeleteProductTagsIdResponse(rsp *http.Response) (*DeleteProductTagsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductTagsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTagDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductTagsIdResponse parses an HTTP response from a GetProductTagsIdWithResponse call
func ParseGetProductTagsIdResponse(rsp *http.Response) (*GetProductTagsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductTagsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductTagsIdResponse parses an HTTP response from a PostProductTagsIdWithResponse call
func ParsePostProductTagsIdResponse(rsp *http.Response) (*PostProductTagsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductTagsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductTypesResponse parses an HTTP response from a GetProductTypesWithResponse call
func ParseGetProductTypesResponse(rsp *http.Response) (*GetProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTypeListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductTypesResponse parses an HTTP response from a PostProductTypesWithResponse call
func ParsePostProductTypesResponse(rsp *http.Response) (*PostProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductTypesIdResponse parses an HTTP response from a DeleteProductTypesIdWithResponse call
func ParseDeleteProductTypesIdResponse(rsp *http.Response) (*DeleteProductTypesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductTypesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTypeDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductTypesIdResponse parses an HTTP response from a GetProductTypesIdWithResponse call
func ParseGetProductTypesIdResponse(rsp *http.Response) (*GetProductTypesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductTypesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductTypesIdResponse parses an HTTP response from a PostProductTypesIdWithResponse call
func ParsePostProductTypesIdResponse(rsp *http.Response) (*PostProductTypesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductTypesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTypeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductVariantsResponse parses an HTTP response from a GetProductVariantsWithResponse call
func ParseGetProductVariantsResponse(rsp *http.Response) (*GetProductVariantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductVariantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// Variants The product variant's variants.
			Variants []AdminProductVariant `json:"variants"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsResponse parses an HTTP response from a GetProductsWithResponse call
func ParseGetProductsResponse(rsp *http.Response) (*GetProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// Products The list of products.
			Products []map[string]interface{} `json:"products"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsResponse parses an HTTP response from a PostProductsWithResponse call
func ParsePostProductsResponse(rsp *http.Response) (*PostProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsBatchResponse parses an HTTP response from a PostProductsBatchWithResponse call
func ParsePostProductsBatchResponse(rsp *http.Response) (*PostProductsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBatchProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsExportResponse parses an HTTP response from a PostProductsExportWithResponse call
func ParsePostProductsExportResponse(rsp *http.Response) (*PostProductsExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AdminExportProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsImportResponse parses an HTTP response from a PostProductsImportWithResponse call
func ParsePostProductsImportResponse(rsp *http.Response) (*PostProductsImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AdminImportProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsImportTransactionIdConfirmResponse parses an HTTP response from a PostProductsImportTransactionIdConfirmWithResponse call
func ParsePostProductsImportTransactionIdConfirmResponse(rsp *http.Response) (*PostProductsImportTransactionIdConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsImportTransactionIdConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsIdResponse parses an HTTP response from a DeleteProductsIdWithResponse call
func ParseDeleteProductsIdResponse(rsp *http.Response) (*DeleteProductsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsIdResponse parses an HTTP response from a GetProductsIdWithResponse call
func ParseGetProductsIdResponse(rsp *http.Response) (*GetProductsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdResponse parses an HTTP response from a PostProductsIdWithResponse call
func ParsePostProductsIdResponse(rsp *http.Response) (*PostProductsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsIdOptionsResponse parses an HTTP response from a GetProductsIdOptionsWithResponse call
func ParseGetProductsIdOptionsResponse(rsp *http.Response) (*GetProductsIdOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsIdOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before the returned items.
			Offset float32 `json:"offset"`

			// ProductOptions The list of product options.
			ProductOptions []AdminProductOption `json:"product_options"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdOptionsResponse parses an HTTP response from a PostProductsIdOptionsWithResponse call
func ParsePostProductsIdOptionsResponse(rsp *http.Response) (*PostProductsIdOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsIdOptionsOptionIdResponse parses an HTTP response from a DeleteProductsIdOptionsOptionIdWithResponse call
func ParseDeleteProductsIdOptionsOptionIdResponse(rsp *http.Response) (*DeleteProductsIdOptionsOptionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsIdOptionsOptionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductOptionDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsIdOptionsOptionIdResponse parses an HTTP response from a GetProductsIdOptionsOptionIdWithResponse call
func ParseGetProductsIdOptionsOptionIdResponse(rsp *http.Response) (*GetProductsIdOptionsOptionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsIdOptionsOptionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdOptionsOptionIdResponse parses an HTTP response from a PostProductsIdOptionsOptionIdWithResponse call
func ParsePostProductsIdOptionsOptionIdResponse(rsp *http.Response) (*PostProductsIdOptionsOptionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdOptionsOptionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsIdVariantsResponse parses an HTTP response from a GetProductsIdVariantsWithResponse call
func ParseGetProductsIdVariantsResponse(rsp *http.Response) (*GetProductsIdVariantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsIdVariantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of returned items.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before the returned item.
			Offset float32 `json:"offset"`

			// Variants The list of product variants.
			Variants []AdminProductVariant `json:"variants"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdVariantsResponse parses an HTTP response from a PostProductsIdVariantsWithResponse call
func ParsePostProductsIdVariantsResponse(rsp *http.Response) (*PostProductsIdVariantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdVariantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdVariantsBatchResponse parses an HTTP response from a PostProductsIdVariantsBatchWithResponse call
func ParsePostProductsIdVariantsBatchResponse(rsp *http.Response) (*PostProductsIdVariantsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdVariantsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBatchProductVariantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdVariantsInventoryItemsBatchResponse parses an HTTP response from a PostProductsIdVariantsInventoryItemsBatchWithResponse call
func ParsePostProductsIdVariantsInventoryItemsBatchResponse(rsp *http.Response) (*PostProductsIdVariantsInventoryItemsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdVariantsInventoryItemsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductVariantInventoryBatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsIdVariantsVariantIdResponse parses an HTTP response from a DeleteProductsIdVariantsVariantIdWithResponse call
func ParseDeleteProductsIdVariantsVariantIdResponse(rsp *http.Response) (*DeleteProductsIdVariantsVariantIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsIdVariantsVariantIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductVariantDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsIdVariantsVariantIdResponse parses an HTTP response from a GetProductsIdVariantsVariantIdWithResponse call
func ParseGetProductsIdVariantsVariantIdResponse(rsp *http.Response) (*GetProductsIdVariantsVariantIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsIdVariantsVariantIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductVariantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdVariantsVariantIdResponse parses an HTTP response from a PostProductsIdVariantsVariantIdWithResponse call
func ParsePostProductsIdVariantsVariantIdResponse(rsp *http.Response) (*PostProductsIdVariantsVariantIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdVariantsVariantIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdVariantsVariantIdInventoryItemsResponse parses an HTTP response from a PostProductsIdVariantsVariantIdInventoryItemsWithResponse call
func ParsePostProductsIdVariantsVariantIdInventoryItemsResponse(rsp *http.Response) (*PostProductsIdVariantsVariantIdInventoryItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdVariantsVariantIdInventoryItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductVariantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse parses an HTTP response from a DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse call
func ParseDeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse(rsp *http.Response) (*DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductVariantInventoryLinkDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse parses an HTTP response from a PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdWithResponse call
func ParsePostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse(rsp *http.Response) (*PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsIdVariantsVariantIdInventoryItemsInventoryItemIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductVariantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPromotionsResponse parses an HTTP response from a GetPromotionsWithResponse call
func ParseGetPromotionsResponse(rsp *http.Response) (*GetPromotionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// Promotions The list of promotions.
			Promotions []AdminPromotion `json:"promotions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPromotionsResponse parses an HTTP response from a PostPromotionsWithResponse call
func ParsePostPromotionsResponse(rsp *http.Response) (*PostPromotionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPromotionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPromotionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPromotionsRuleAttributeOptionsRuleTypeResponse parses an HTTP response from a GetPromotionsRuleAttributeOptionsRuleTypeWithResponse call
func ParseGetPromotionsRuleAttributeOptionsRuleTypeResponse(rsp *http.Response) (*GetPromotionsRuleAttributeOptionsRuleTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionsRuleAttributeOptionsRuleTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Attributes The list of attributes.
			Attributes []AdminRuleAttributeOption `json:"attributes"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse parses an HTTP response from a GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdWithResponse call
func ParseGetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse(rsp *http.Response) (*GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionsRuleValueOptionsRuleTypeRuleAttributeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Values The list of rule values.
			Values []AdminRuleValueOption `json:"values"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePromotionsIdResponse parses an HTTP response from a DeletePromotionsIdWithResponse call
func ParseDeletePromotionsIdResponse(rsp *http.Response) (*DeletePromotionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePromotionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the promotion was deleted.
			Deleted bool `json:"deleted"`

			// Id The promotion's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPromotionsIdResponse parses an HTTP response from a GetPromotionsIdWithResponse call
func ParseGetPromotionsIdResponse(rsp *http.Response) (*GetPromotionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPromotionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPromotionsIdResponse parses an HTTP response from a PostPromotionsIdWithResponse call
func ParsePostPromotionsIdResponse(rsp *http.Response) (*PostPromotionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPromotionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPromotionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPromotionsIdBuyRulesBatchResponse parses an HTTP response from a PostPromotionsIdBuyRulesBatchWithResponse call
func ParsePostPromotionsIdBuyRulesBatchResponse(rsp *http.Response) (*PostPromotionsIdBuyRulesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPromotionsIdBuyRulesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created The created buy rules.
			Created []AdminPromotionRule `json:"created"`

			// Deleted The details of the deleted buy rules.
			Deleted struct {
				// Deleted Whether the buy rules were deleted.
				Deleted bool `json:"deleted"`

				// Ids The IDs of the buy rules that were deleted.
				Ids []string `json:"ids"`

				// Object The name of the object that was deleted.
				Object string `json:"object"`
			} `json:"deleted"`

			// Updated The updated buy rules.
			Updated []AdminPromotionRule `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPromotionsIdRulesBatchResponse parses an HTTP response from a PostPromotionsIdRulesBatchWithResponse call
func ParsePostPromotionsIdRulesBatchResponse(rsp *http.Response) (*PostPromotionsIdRulesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPromotionsIdRulesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created The created rules.
			Created []AdminPromotionRule `json:"created"`

			// Deleted The details of the deleted buy rules.
			Deleted struct {
				// Deleted Whether the rules were deleted.
				Deleted bool `json:"deleted"`

				// Ids The IDs of the deleted rules.
				Ids []string `json:"ids"`

				// Object The name of the object that was deleted.
				Object string `json:"object"`
			} `json:"deleted"`

			// Updated The updated rules.
			Updated []AdminPromotionRule `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPromotionsIdTargetRulesBatchResponse parses an HTTP response from a PostPromotionsIdTargetRulesBatchWithResponse call
func ParsePostPromotionsIdTargetRulesBatchResponse(rsp *http.Response) (*PostPromotionsIdTargetRulesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPromotionsIdTargetRulesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created The created target rules.
			Created []AdminPromotionRule `json:"created"`

			// Deleted The details of the deleted target rules.
			Deleted struct {
				// Deleted Whether the target rules were deleted.
				Deleted bool `json:"deleted"`

				// Ids The IDs of deleted target rules.
				Ids []string `json:"ids"`

				// Object The name of the object that was deleted.
				Object string `json:"object"`
			} `json:"deleted"`

			// Updated The updated target rules.
			Updated []AdminPromotionRule `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPromotionsIdRuleTypeResponse parses an HTTP response from a GetPromotionsIdRuleTypeWithResponse call
func ParseGetPromotionsIdRuleTypeResponse(rsp *http.Response) (*GetPromotionsIdRuleTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionsIdRuleTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Rules The list of promotion rules.
			Rules []AdminPromotionRule `json:"rules"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRefundReasonsResponse parses an HTTP response from a GetRefundReasonsWithResponse call
func ParseGetRefundReasonsResponse(rsp *http.Response) (*GetRefundReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRefundReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// RefundReasons The refund reason's refund reasons.
			RefundReasons []AdminRefundReason `json:"refund_reasons"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRefundReasonsResponse parses an HTTP response from a PostRefundReasonsWithResponse call
func ParsePostRefundReasonsResponse(rsp *http.Response) (*PostRefundReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRefundReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefundReasonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRefundReasonsIdResponse parses an HTTP response from a DeleteRefundReasonsIdWithResponse call
func ParseDeleteRefundReasonsIdResponse(rsp *http.Response) (*DeleteRefundReasonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRefundReasonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the refund reason was deleted.
			Deleted bool `json:"deleted"`

			// Id The refund reason's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRefundReasonsIdResponse parses an HTTP response from a GetRefundReasonsIdWithResponse call
func ParseGetRefundReasonsIdResponse(rsp *http.Response) (*GetRefundReasonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRefundReasonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefundReasonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRefundReasonsIdResponse parses an HTTP response from a PostRefundReasonsIdWithResponse call
func ParsePostRefundReasonsIdResponse(rsp *http.Response) (*PostRefundReasonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRefundReasonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefundReasonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionsResponse parses an HTTP response from a GetRegionsWithResponse call
func ParseGetRegionsResponse(rsp *http.Response) (*GetRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// Regions The list of regions.
			Regions []AdminRegion `json:"regions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsResponse parses an HTTP response from a PostRegionsWithResponse call
func ParsePostRegionsResponse(rsp *http.Response) (*PostRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRegionsIdResponse parses an HTTP response from a DeleteRegionsIdWithResponse call
func ParseDeleteRegionsIdResponse(rsp *http.Response) (*DeleteRegionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRegionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the region was deleted.
			Deleted bool `json:"deleted"`

			// Id The region's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionsIdResponse parses an HTTP response from a GetRegionsIdWithResponse call
func ParseGetRegionsIdResponse(rsp *http.Response) (*GetRegionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsIdResponse parses an HTTP response from a PostRegionsIdWithResponse call
func ParsePostRegionsIdResponse(rsp *http.Response) (*PostRegionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReservationsResponse parses an HTTP response from a GetReservationsWithResponse call
func ParseGetReservationsResponse(rsp *http.Response) (*GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// Reservations The list of reservations.
			Reservations []AdminReservation `json:"reservations"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReservationsResponse parses an HTTP response from a PostReservationsWithResponse call
func ParsePostReservationsResponse(rsp *http.Response) (*PostReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReservationsIdResponse parses an HTTP response from a DeleteReservationsIdWithResponse call
func ParseDeleteReservationsIdResponse(rsp *http.Response) (*DeleteReservationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the reservation was deleted.
			Deleted bool `json:"deleted"`

			// Id The reservation's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReservationsIdResponse parses an HTTP response from a GetReservationsIdWithResponse call
func ParseGetReservationsIdResponse(rsp *http.Response) (*GetReservationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReservationsIdResponse parses an HTTP response from a PostReservationsIdWithResponse call
func ParsePostReservationsIdResponse(rsp *http.Response) (*PostReservationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnReasonsResponse parses an HTTP response from a GetReturnReasonsWithResponse call
func ParseGetReturnReasonsResponse(rsp *http.Response) (*GetReturnReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnReasonsResponse parses an HTTP response from a PostReturnReasonsWithResponse call
func ParsePostReturnReasonsResponse(rsp *http.Response) (*PostReturnReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnReasonsIdResponse parses an HTTP response from a DeleteReturnReasonsIdWithResponse call
func ParseDeleteReturnReasonsIdResponse(rsp *http.Response) (*DeleteReturnReasonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnReasonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnReasonsIdResponse parses an HTTP response from a GetReturnReasonsIdWithResponse call
func ParseGetReturnReasonsIdResponse(rsp *http.Response) (*GetReturnReasonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnReasonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnReasonsIdResponse parses an HTTP response from a PostReturnReasonsIdWithResponse call
func ParsePostReturnReasonsIdResponse(rsp *http.Response) (*PostReturnReasonsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnReasonsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnsResponse parses an HTTP response from a GetReturnsWithResponse call
func ParseGetReturnsResponse(rsp *http.Response) (*GetReturnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// Returns The return's returns.
			Returns []AdminReturn `json:"returns"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsResponse parses an HTTP response from a PostReturnsWithResponse call
func ParsePostReturnsResponse(rsp *http.Response) (*PostReturnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnsIdResponse parses an HTTP response from a GetReturnsIdWithResponse call
func ParseGetReturnsIdResponse(rsp *http.Response) (*GetReturnsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdResponse parses an HTTP response from a PostReturnsIdWithResponse call
func ParsePostReturnsIdResponse(rsp *http.Response) (*PostReturnsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdCancelResponse parses an HTTP response from a PostReturnsIdCancelWithResponse call
func ParsePostReturnsIdCancelResponse(rsp *http.Response) (*PostReturnsIdCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdDismissItemsResponse parses an HTTP response from a PostReturnsIdDismissItemsWithResponse call
func ParsePostReturnsIdDismissItemsResponse(rsp *http.Response) (*PostReturnsIdDismissItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdDismissItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnsIdDismissItemsActionIdResponse parses an HTTP response from a DeleteReturnsIdDismissItemsActionIdWithResponse call
func ParseDeleteReturnsIdDismissItemsActionIdResponse(rsp *http.Response) (*DeleteReturnsIdDismissItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnsIdDismissItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdDismissItemsActionIdResponse parses an HTTP response from a PostReturnsIdDismissItemsActionIdWithResponse call
func ParsePostReturnsIdDismissItemsActionIdResponse(rsp *http.Response) (*PostReturnsIdDismissItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdDismissItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnsIdReceiveResponse parses an HTTP response from a DeleteReturnsIdReceiveWithResponse call
func ParseDeleteReturnsIdReceiveResponse(rsp *http.Response) (*DeleteReturnsIdReceiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnsIdReceiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the return was deleted.
			Deleted bool `json:"deleted"`

			// Id The return's ID.
			Id string `json:"id"`

			// Object The name of the returned object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdReceiveResponse parses an HTTP response from a PostReturnsIdReceiveWithResponse call
func ParsePostReturnsIdReceiveResponse(rsp *http.Response) (*PostReturnsIdReceiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdReceiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderReturnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdReceiveItemsResponse parses an HTTP response from a PostReturnsIdReceiveItemsWithResponse call
func ParsePostReturnsIdReceiveItemsResponse(rsp *http.Response) (*PostReturnsIdReceiveItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdReceiveItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnsIdReceiveItemsActionIdResponse parses an HTTP response from a DeleteReturnsIdReceiveItemsActionIdWithResponse call
func ParseDeleteReturnsIdReceiveItemsActionIdResponse(rsp *http.Response) (*DeleteReturnsIdReceiveItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnsIdReceiveItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdReceiveItemsActionIdResponse parses an HTTP response from a PostReturnsIdReceiveItemsActionIdWithResponse call
func ParsePostReturnsIdReceiveItemsActionIdResponse(rsp *http.Response) (*PostReturnsIdReceiveItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdReceiveItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdReceiveConfirmResponse parses an HTTP response from a PostReturnsIdReceiveConfirmWithResponse call
func ParsePostReturnsIdReceiveConfirmResponse(rsp *http.Response) (*PostReturnsIdReceiveConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdReceiveConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnsIdRequestResponse parses an HTTP response from a DeleteReturnsIdRequestWithResponse call
func ParseDeleteReturnsIdRequestResponse(rsp *http.Response) (*DeleteReturnsIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnsIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the return was deleted.
			Deleted bool `json:"deleted"`

			// Id The return's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdRequestResponse parses an HTTP response from a PostReturnsIdRequestWithResponse call
func ParsePostReturnsIdRequestResponse(rsp *http.Response) (*PostReturnsIdRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdRequestItemsResponse parses an HTTP response from a PostReturnsIdRequestItemsWithResponse call
func ParsePostReturnsIdRequestItemsResponse(rsp *http.Response) (*PostReturnsIdRequestItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdRequestItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnsIdRequestItemsActionIdResponse parses an HTTP response from a DeleteReturnsIdRequestItemsActionIdWithResponse call
func ParseDeleteReturnsIdRequestItemsActionIdResponse(rsp *http.Response) (*DeleteReturnsIdRequestItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnsIdRequestItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdRequestItemsActionIdResponse parses an HTTP response from a PostReturnsIdRequestItemsActionIdWithResponse call
func ParsePostReturnsIdRequestItemsActionIdResponse(rsp *http.Response) (*PostReturnsIdRequestItemsActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdRequestItemsActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdShippingMethodResponse parses an HTTP response from a PostReturnsIdShippingMethodWithResponse call
func ParsePostReturnsIdShippingMethodResponse(rsp *http.Response) (*PostReturnsIdShippingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdShippingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnsIdShippingMethodActionIdResponse parses an HTTP response from a DeleteReturnsIdShippingMethodActionIdWithResponse call
func ParseDeleteReturnsIdShippingMethodActionIdResponse(rsp *http.Response) (*DeleteReturnsIdShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnsIdShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsIdShippingMethodActionIdResponse parses an HTTP response from a PostReturnsIdShippingMethodActionIdWithResponse call
func ParsePostReturnsIdShippingMethodActionIdResponse(rsp *http.Response) (*PostReturnsIdShippingMethodActionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsIdShippingMethodActionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSalesChannelsResponse parses an HTTP response from a GetSalesChannelsWithResponse call
func ParseGetSalesChannelsResponse(rsp *http.Response) (*GetSalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// SalesChannels The list of sales channels.
			SalesChannels []AdminSalesChannel `json:"sales_channels"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsResponse parses an HTTP response from a PostSalesChannelsWithResponse call
func ParsePostSalesChannelsResponse(rsp *http.Response) (*PostSalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSalesChannelsIdResponse parses an HTTP response from a DeleteSalesChannelsIdWithResponse call
func ParseDeleteSalesChannelsIdResponse(rsp *http.Response) (*DeleteSalesChannelsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSalesChannelsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSalesChannelsIdResponse parses an HTTP response from a GetSalesChannelsIdWithResponse call
func ParseGetSalesChannelsIdResponse(rsp *http.Response) (*GetSalesChannelsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSalesChannelsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsIdResponse parses an HTTP response from a PostSalesChannelsIdWithResponse call
func ParsePostSalesChannelsIdResponse(rsp *http.Response) (*PostSalesChannelsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsIdProductsResponse parses an HTTP response from a PostSalesChannelsIdProductsWithResponse call
func ParsePostSalesChannelsIdProductsResponse(rsp *http.Response) (*PostSalesChannelsIdProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsIdProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingOptionsResponse parses an HTTP response from a GetShippingOptionsWithResponse call
func ParseGetShippingOptionsResponse(rsp *http.Response) (*GetShippingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// ShippingOptions The list of shipping options.
			ShippingOptions []map[string]interface{} `json:"shipping_options"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingOptionsResponse parses an HTTP response from a PostShippingOptionsWithResponse call
func ParsePostShippingOptionsResponse(rsp *http.Response) (*PostShippingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteShippingOptionsIdResponse parses an HTTP response from a DeleteShippingOptionsIdWithResponse call
func ParseDeleteShippingOptionsIdResponse(rsp *http.Response) (*DeleteShippingOptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShippingOptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingOptionsIdResponse parses an HTTP response from a GetShippingOptionsIdWithResponse call
func ParseGetShippingOptionsIdResponse(rsp *http.Response) (*GetShippingOptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingOptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingOptionsIdResponse parses an HTTP response from a PostShippingOptionsIdWithResponse call
func ParsePostShippingOptionsIdResponse(rsp *http.Response) (*PostShippingOptionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingOptionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingOptionsIdRulesBatchResponse parses an HTTP response from a PostShippingOptionsIdRulesBatchWithResponse call
func ParsePostShippingOptionsIdRulesBatchResponse(rsp *http.Response) (*PostShippingOptionsIdRulesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingOptionsIdRulesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created The created shipping option rules.
			Created []AdminShippingOptionRule `json:"created"`

			// Deleted The details of the deleted shipping option rules.
			Deleted struct {
				// Deleted The deleted's details.
				Deleted bool `json:"deleted"`

				// Ids The IDs of the deleted shipping option rules.
				Ids []string `json:"ids"`

				// Object The name of the deleted object.
				Object string `json:"object"`
			} `json:"deleted"`

			// Updated The updated shipping option rules.
			Updated []AdminShippingOptionRule `json:"updated"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingProfilesResponse parses an HTTP response from a GetShippingProfilesWithResponse call
func ParseGetShippingProfilesResponse(rsp *http.Response) (*GetShippingProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// ShippingProfiles The list of shipping profiles.
			ShippingProfiles []AdminShippingProfile `json:"shipping_profiles"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingProfilesResponse parses an HTTP response from a PostShippingProfilesWithResponse call
func ParsePostShippingProfilesResponse(rsp *http.Response) (*PostShippingProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteShippingProfilesIdResponse parses an HTTP response from a DeleteShippingProfilesIdWithResponse call
func ParseDeleteShippingProfilesIdResponse(rsp *http.Response) (*DeleteShippingProfilesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShippingProfilesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfileDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingProfilesIdResponse parses an HTTP response from a GetShippingProfilesIdWithResponse call
func ParseGetShippingProfilesIdResponse(rsp *http.Response) (*GetShippingProfilesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingProfilesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingProfilesIdResponse parses an HTTP response from a PostShippingProfilesIdWithResponse call
func ParsePostShippingProfilesIdResponse(rsp *http.Response) (*PostShippingProfilesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingProfilesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStockLocationsResponse parses an HTTP response from a GetStockLocationsWithResponse call
func ParseGetStockLocationsResponse(rsp *http.Response) (*GetStockLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStockLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsResponse parses an HTTP response from a PostStockLocationsWithResponse call
func ParsePostStockLocationsResponse(rsp *http.Response) (*PostStockLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteStockLocationsIdResponse parses an HTTP response from a DeleteStockLocationsIdWithResponse call
func ParseDeleteStockLocationsIdResponse(rsp *http.Response) (*DeleteStockLocationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStockLocationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStockLocationsIdResponse parses an HTTP response from a GetStockLocationsIdWithResponse call
func ParseGetStockLocationsIdResponse(rsp *http.Response) (*GetStockLocationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStockLocationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsIdResponse parses an HTTP response from a PostStockLocationsIdWithResponse call
func ParsePostStockLocationsIdResponse(rsp *http.Response) (*PostStockLocationsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsIdFulfillmentProvidersResponse parses an HTTP response from a PostStockLocationsIdFulfillmentProvidersWithResponse call
func ParsePostStockLocationsIdFulfillmentProvidersResponse(rsp *http.Response) (*PostStockLocationsIdFulfillmentProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsIdFulfillmentProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsIdFulfillmentSetsResponse parses an HTTP response from a PostStockLocationsIdFulfillmentSetsWithResponse call
func ParsePostStockLocationsIdFulfillmentSetsResponse(rsp *http.Response) (*PostStockLocationsIdFulfillmentSetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsIdFulfillmentSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsIdSalesChannelsResponse parses an HTTP response from a PostStockLocationsIdSalesChannelsWithResponse call
func ParsePostStockLocationsIdSalesChannelsResponse(rsp *http.Response) (*PostStockLocationsIdSalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsIdSalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStoresResponse parses an HTTP response from a GetStoresWithResponse call
func ParseGetStoresResponse(rsp *http.Response) (*GetStoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStoreListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStoresIdResponse parses an HTTP response from a GetStoresIdWithResponse call
func ParseGetStoresIdResponse(rsp *http.Response) (*GetStoresIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoresIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStoresIdResponse parses an HTTP response from a PostStoresIdWithResponse call
func ParsePostStoresIdResponse(rsp *http.Response) (*PostStoresIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStoresIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaxRatesResponse parses an HTTP response from a GetTaxRatesWithResponse call
func ParseGetTaxRatesResponse(rsp *http.Response) (*GetTaxRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// TaxRates The tax rate's tax rates.
			TaxRates []AdminTaxRate `json:"tax_rates"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesResponse parses an HTTP response from a PostTaxRatesWithResponse call
func ParsePostTaxRatesResponse(rsp *http.Response) (*PostTaxRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRatesIdResponse parses an HTTP response from a DeleteTaxRatesIdWithResponse call
func ParseDeleteTaxRatesIdResponse(rsp *http.Response) (*DeleteTaxRatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRateDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaxRatesIdResponse parses an HTTP response from a GetTaxRatesIdWithResponse call
func ParseGetTaxRatesIdResponse(rsp *http.Response) (*GetTaxRatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxRatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesIdResponse parses an HTTP response from a PostTaxRatesIdWithResponse call
func ParsePostTaxRatesIdResponse(rsp *http.Response) (*PostTaxRatesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesIdRulesResponse parses an HTTP response from a PostTaxRatesIdRulesWithResponse call
func ParsePostTaxRatesIdRulesResponse(rsp *http.Response) (*PostTaxRatesIdRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesIdRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRatesIdRulesRuleIdResponse parses an HTTP response from a DeleteTaxRatesIdRulesRuleIdWithResponse call
func ParseDeleteTaxRatesIdRulesRuleIdResponse(rsp *http.Response) (*DeleteTaxRatesIdRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRatesIdRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the Tax Rate was deleted.
			Deleted bool `json:"deleted"`

			// Id The tax rate's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`

			// Parent The tax rate's details.
			Parent *AdminTaxRate `json:"parent,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaxRegionsResponse parses an HTTP response from a GetTaxRegionsWithResponse call
func ParseGetTaxRegionsResponse(rsp *http.Response) (*GetTaxRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// TaxRegions The list of tax regions.
			TaxRegions []map[string]interface{} `json:"tax_regions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRegionsResponse parses an HTTP response from a PostTaxRegionsWithResponse call
func ParsePostTaxRegionsResponse(rsp *http.Response) (*PostTaxRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRegionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRegionsIdResponse parses an HTTP response from a DeleteTaxRegionsIdWithResponse call
func ParseDeleteTaxRegionsIdResponse(rsp *http.Response) (*DeleteTaxRegionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRegionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRegionDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaxRegionsIdResponse parses an HTTP response from a GetTaxRegionsIdWithResponse call
func ParseGetTaxRegionsIdResponse(rsp *http.Response) (*GetTaxRegionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxRegionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRegionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUploadsResponse parses an HTTP response from a PostUploadsWithResponse call
func ParsePostUploadsResponse(rsp *http.Response) (*PostUploadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUploadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFileListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUploadsIdResponse parses an HTTP response from a DeleteUploadsIdWithResponse call
func ParseDeleteUploadsIdResponse(rsp *http.Response) (*DeleteUploadsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUploadsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Deleted Whether the file was deleted.
			Deleted bool `json:"deleted"`

			// Id The file's ID.
			Id string `json:"id"`

			// Object The name of the deleted object.
			Object string `json:"object"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUploadsIdResponse parses an HTTP response from a GetUploadsIdWithResponse call
func ParseGetUploadsIdResponse(rsp *http.Response) (*GetUploadsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersMeResponse parses an HTTP response from a GetUsersMeWithResponse call
func ParseGetUsersMeResponse(rsp *http.Response) (*GetUsersMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUsersIdResponse parses an HTTP response from a DeleteUsersIdWithResponse call
func ParseDeleteUsersIdResponse(rsp *http.Response) (*DeleteUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersIdResponse parses an HTTP response from a GetUsersIdWithResponse call
func ParseGetUsersIdResponse(rsp *http.Response) (*GetUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUsersIdResponse parses an HTTP response from a PostUsersIdWithResponse call
func ParsePostUsersIdResponse(rsp *http.Response) (*PostUsersIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkflowsExecutionsResponse parses an HTTP response from a GetWorkflowsExecutionsWithResponse call
func ParseGetWorkflowsExecutionsResponse(rsp *http.Response) (*GetWorkflowsExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowsExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Count The total number of items.
			Count float32 `json:"count"`

			// Limit The maximum number of items returned.
			Limit float32 `json:"limit"`

			// Offset The number of items skipped before retrieving the returned items.
			Offset float32 `json:"offset"`

			// WorkflowExecutions The workflows execution's workflow executions.
			WorkflowExecutions []AdminWorkflowExecution `json:"workflow_executions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkflowsExecutionsIdResponse parses an HTTP response from a GetWorkflowsExecutionsIdWithResponse call
func ParseGetWorkflowsExecutionsIdResponse(rsp *http.Response) (*GetWorkflowsExecutionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowsExecutionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminWorkflowExecutionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWorkflowsExecutionsWorkflowIdRunResponse parses an HTTP response from a PostWorkflowsExecutionsWorkflowIdRunWithResponse call
func ParsePostWorkflowsExecutionsWorkflowIdRunResponse(rsp *http.Response) (*PostWorkflowsExecutionsWorkflowIdRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkflowsExecutionsWorkflowIdRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Acknowledgement The workflow's details
			Acknowledgement struct {
				// HasFailed Whether the workflow execution has failed.
				HasFailed bool `json:"hasFailed"`

				// HasFinished Whether the workflow execution has finished.
				HasFinished bool `json:"hasFinished"`

				// ParentStepIdempotencyKey The idempotency key of the workflow execution.
				ParentStepIdempotencyKey *string `json:"parentStepIdempotencyKey,omitempty"`

				// TransactionId The ID of the workflow exection's transaction. Use this later to track the workflow execution's progress or succeed / fail its steps.
				TransactionId string `json:"transactionId"`

				// WorkflowId The ID of the executed workflow.
				WorkflowId string `json:"workflowId"`
			} `json:"acknowledgement"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWorkflowsExecutionsWorkflowIdStepsFailureResponse parses an HTTP response from a PostWorkflowsExecutionsWorkflowIdStepsFailureWithResponse call
func ParsePostWorkflowsExecutionsWorkflowIdStepsFailureResponse(rsp *http.Response) (*PostWorkflowsExecutionsWorkflowIdStepsFailureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkflowsExecutionsWorkflowIdStepsFailureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether the workflow step has failed successfully.
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostWorkflowsExecutionsWorkflowIdStepsSuccessResponse parses an HTTP response from a PostWorkflowsExecutionsWorkflowIdStepsSuccessWithResponse call
func ParsePostWorkflowsExecutionsWorkflowIdStepsSuccessResponse(rsp *http.Response) (*PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWorkflowsExecutionsWorkflowIdStepsSuccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether the workflow step was succeeded.
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkflowsExecutionsWorkflowIdSubscribeResponse parses an HTTP response from a GetWorkflowsExecutionsWorkflowIdSubscribeWithResponse call
func ParseGetWorkflowsExecutionsWorkflowIdSubscribeResponse(rsp *http.Response) (*GetWorkflowsExecutionsWorkflowIdSubscribeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowsExecutionsWorkflowIdSubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkflowsExecutionsWorkflowIdTransactionIdResponse parses an HTTP response from a GetWorkflowsExecutionsWorkflowIdTransactionIdWithResponse call
func ParseGetWorkflowsExecutionsWorkflowIdTransactionIdResponse(rsp *http.Response) (*GetWorkflowsExecutionsWorkflowIdTransactionIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowsExecutionsWorkflowIdTransactionIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminWorkflowExecutionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse parses an HTTP response from a GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeWithResponse call
func ParseGetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse(rsp *http.Response) (*GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowsExecutionsWorkflowIdTransactionIdStepIdSubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSessionResponse parses an HTTP response from a DeleteSessionWithResponse call
func ParseDeleteSessionResponse(rsp *http.Response) (*DeleteSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Success Whether the session was deleted successfully.
			Success bool `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSessionResponse parses an HTTP response from a PostSessionWithResponse call
func ParsePostSessionResponse(rsp *http.Response) (*PostSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthAdminSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAdminAuthTokenRefreshResponse parses an HTTP response from a PostAdminAuthTokenRefreshWithResponse call
func ParsePostAdminAuthTokenRefreshResponse(rsp *http.Response) (*PostAdminAuthTokenRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAdminAuthTokenRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostActorTypeAuthProviderResponse parses an HTTP response from a PostActorTypeAuthProviderWithResponse call
func ParsePostActorTypeAuthProviderResponse(rsp *http.Response) (*PostActorTypeAuthProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostActorTypeAuthProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostActorTypeAuthProviderCallbackResponse parses an HTTP response from a PostActorTypeAuthProviderCallbackWithResponse call
func ParsePostActorTypeAuthProviderCallbackResponse(rsp *http.Response) (*PostActorTypeAuthProviderCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostActorTypeAuthProviderCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostActorTypeAuthProviderRegisterResponse parses an HTTP response from a PostActorTypeAuthProviderRegisterWithResponse call
func ParsePostActorTypeAuthProviderRegisterResponse(rsp *http.Response) (*PostActorTypeAuthProviderRegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostActorTypeAuthProviderRegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
