// Package medusa provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package medusa

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_tokenScopes   = "api_token.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
	Jwt_tokenScopes   = "jwt_token.Scopes"
)

// Defines values for AdminCreateUserRequestRole.
const (
	AdminCreateUserRequestRoleAdmin     AdminCreateUserRequestRole = "admin"
	AdminCreateUserRequestRoleDeveloper AdminCreateUserRequestRole = "developer"
	AdminCreateUserRequestRoleMember    AdminCreateUserRequestRole = "member"
)

// Defines values for AdminPostDiscountsDiscountConditionsOperator.
const (
	AdminPostDiscountsDiscountConditionsOperatorIn    AdminPostDiscountsDiscountConditionsOperator = "in"
	AdminPostDiscountsDiscountConditionsOperatorNotIn AdminPostDiscountsDiscountConditionsOperator = "not_in"
)

// Defines values for AdminPostDiscountsDiscountReqRuleAllocation.
const (
	AdminPostDiscountsDiscountReqRuleAllocationItem  AdminPostDiscountsDiscountReqRuleAllocation = "item"
	AdminPostDiscountsDiscountReqRuleAllocationTotal AdminPostDiscountsDiscountReqRuleAllocation = "total"
)

// Defines values for AdminPostDiscountsDiscountReqRuleConditionsOperator.
const (
	AdminPostDiscountsDiscountReqRuleConditionsOperatorIn    AdminPostDiscountsDiscountReqRuleConditionsOperator = "in"
	AdminPostDiscountsDiscountReqRuleConditionsOperatorNotIn AdminPostDiscountsDiscountReqRuleConditionsOperator = "not_in"
)

// Defines values for AdminPostDiscountsReqRuleAllocation.
const (
	AdminPostDiscountsReqRuleAllocationItem  AdminPostDiscountsReqRuleAllocation = "item"
	AdminPostDiscountsReqRuleAllocationTotal AdminPostDiscountsReqRuleAllocation = "total"
)

// Defines values for AdminPostDiscountsReqRuleConditionsOperator.
const (
	AdminPostDiscountsReqRuleConditionsOperatorIn    AdminPostDiscountsReqRuleConditionsOperator = "in"
	AdminPostDiscountsReqRuleConditionsOperatorNotIn AdminPostDiscountsReqRuleConditionsOperator = "not_in"
)

// Defines values for AdminPostDiscountsReqRuleType.
const (
	AdminPostDiscountsReqRuleTypeFixed        AdminPostDiscountsReqRuleType = "fixed"
	AdminPostDiscountsReqRuleTypeFreeShipping AdminPostDiscountsReqRuleType = "free_shipping"
	AdminPostDiscountsReqRuleTypePercentage   AdminPostDiscountsReqRuleType = "percentage"
)

// Defines values for AdminPostDraftOrdersReqStatus.
const (
	AdminPostDraftOrdersReqStatusCompleted AdminPostDraftOrdersReqStatus = "completed"
	AdminPostDraftOrdersReqStatusOpen      AdminPostDraftOrdersReqStatus = "open"
)

// Defines values for AdminPostInvitesReqRole.
const (
	AdminPostInvitesReqRoleAdmin     AdminPostInvitesReqRole = "admin"
	AdminPostInvitesReqRoleDeveloper AdminPostInvitesReqRole = "developer"
	AdminPostInvitesReqRoleMember    AdminPostInvitesReqRole = "member"
)

// Defines values for AdminPostOrdersOrderClaimsClaimReqClaimItemsReason.
const (
	AdminPostOrdersOrderClaimsClaimReqClaimItemsReasonMissingItem       AdminPostOrdersOrderClaimsClaimReqClaimItemsReason = "missing_item"
	AdminPostOrdersOrderClaimsClaimReqClaimItemsReasonOther             AdminPostOrdersOrderClaimsClaimReqClaimItemsReason = "other"
	AdminPostOrdersOrderClaimsClaimReqClaimItemsReasonProductionFailure AdminPostOrdersOrderClaimsClaimReqClaimItemsReason = "production_failure"
	AdminPostOrdersOrderClaimsClaimReqClaimItemsReasonWrongItem         AdminPostOrdersOrderClaimsClaimReqClaimItemsReason = "wrong_item"
)

// Defines values for AdminPostOrdersOrderClaimsReqClaimItemsReason.
const (
	AdminPostOrdersOrderClaimsReqClaimItemsReasonMissingItem       AdminPostOrdersOrderClaimsReqClaimItemsReason = "missing_item"
	AdminPostOrdersOrderClaimsReqClaimItemsReasonOther             AdminPostOrdersOrderClaimsReqClaimItemsReason = "other"
	AdminPostOrdersOrderClaimsReqClaimItemsReasonProductionFailure AdminPostOrdersOrderClaimsReqClaimItemsReason = "production_failure"
	AdminPostOrdersOrderClaimsReqClaimItemsReasonWrongItem         AdminPostOrdersOrderClaimsReqClaimItemsReason = "wrong_item"
)

// Defines values for AdminPostOrdersOrderClaimsReqType.
const (
	AdminPostOrdersOrderClaimsReqTypeRefund  AdminPostOrdersOrderClaimsReqType = "refund"
	AdminPostOrdersOrderClaimsReqTypeReplace AdminPostOrdersOrderClaimsReqType = "replace"
)

// Defines values for AdminPostPriceListsPriceListPriceListReqStatus.
const (
	AdminPostPriceListsPriceListPriceListReqStatusActive AdminPostPriceListsPriceListPriceListReqStatus = "active"
	AdminPostPriceListsPriceListPriceListReqStatusDraft  AdminPostPriceListsPriceListPriceListReqStatus = "draft"
)

// Defines values for AdminPostPriceListsPriceListPriceListReqType.
const (
	AdminPostPriceListsPriceListPriceListReqTypeOverride AdminPostPriceListsPriceListPriceListReqType = "override"
	AdminPostPriceListsPriceListPriceListReqTypeSale     AdminPostPriceListsPriceListPriceListReqType = "sale"
)

// Defines values for AdminPostPriceListsPriceListReqStatus.
const (
	AdminPostPriceListsPriceListReqStatusActive AdminPostPriceListsPriceListReqStatus = "active"
	AdminPostPriceListsPriceListReqStatusDraft  AdminPostPriceListsPriceListReqStatus = "draft"
)

// Defines values for AdminPostPriceListsPriceListReqType.
const (
	AdminPostPriceListsPriceListReqTypeOverride AdminPostPriceListsPriceListReqType = "override"
	AdminPostPriceListsPriceListReqTypeSale     AdminPostPriceListsPriceListReqType = "sale"
)

// Defines values for AdminPostProductsProductReqStatus.
const (
	AdminPostProductsProductReqStatusDraft     AdminPostProductsProductReqStatus = "draft"
	AdminPostProductsProductReqStatusProposed  AdminPostProductsProductReqStatus = "proposed"
	AdminPostProductsProductReqStatusPublished AdminPostProductsProductReqStatus = "published"
	AdminPostProductsProductReqStatusRejected  AdminPostProductsProductReqStatus = "rejected"
)

// Defines values for AdminPostProductsReqStatus.
const (
	AdminPostProductsReqStatusDraft     AdminPostProductsReqStatus = "draft"
	AdminPostProductsReqStatusProposed  AdminPostProductsReqStatus = "proposed"
	AdminPostProductsReqStatusPublished AdminPostProductsReqStatus = "published"
	AdminPostProductsReqStatusRejected  AdminPostProductsReqStatus = "rejected"
)

// Defines values for AdminPostShippingOptionsOptionReqRequirementsType.
const (
	AdminPostShippingOptionsOptionReqRequirementsTypeMaxSubtotal AdminPostShippingOptionsOptionReqRequirementsType = "max_subtotal"
	AdminPostShippingOptionsOptionReqRequirementsTypeMinSubtotal AdminPostShippingOptionsOptionReqRequirementsType = "min_subtotal"
)

// Defines values for AdminPostShippingOptionsReqPriceType.
const (
	AdminPostShippingOptionsReqPriceTypeCalculated AdminPostShippingOptionsReqPriceType = "calculated"
	AdminPostShippingOptionsReqPriceTypeFlatRate   AdminPostShippingOptionsReqPriceType = "flat_rate"
)

// Defines values for AdminPostShippingOptionsReqRequirementsType.
const (
	AdminPostShippingOptionsReqRequirementsTypeMaxSubtotal AdminPostShippingOptionsReqRequirementsType = "max_subtotal"
	AdminPostShippingOptionsReqRequirementsTypeMinSubtotal AdminPostShippingOptionsReqRequirementsType = "min_subtotal"
)

// Defines values for AdminUpdateUserRequestRole.
const (
	AdminUpdateUserRequestRoleAdmin     AdminUpdateUserRequestRole = "admin"
	AdminUpdateUserRequestRoleDeveloper AdminUpdateUserRequestRole = "developer"
	AdminUpdateUserRequestRoleMember    AdminUpdateUserRequestRole = "member"
)

// Defines values for BatchJobStatus.
const (
	BatchJobStatusCanceled     BatchJobStatus = "canceled"
	BatchJobStatusCompleted    BatchJobStatus = "completed"
	BatchJobStatusConfirmed    BatchJobStatus = "confirmed"
	BatchJobStatusCreated      BatchJobStatus = "created"
	BatchJobStatusFailed       BatchJobStatus = "failed"
	BatchJobStatusPreProcessed BatchJobStatus = "pre_processed"
	BatchJobStatusProcessing   BatchJobStatus = "processing"
)

// Defines values for BatchJobType.
const (
	ProductExport BatchJobType = "product-export"
	ProductImport BatchJobType = "product-import"
)

// Defines values for CartType.
const (
	CartTypeClaim       CartType = "claim"
	CartTypeDefault     CartType = "default"
	CartTypeDraftOrder  CartType = "draft_order"
	CartTypePaymentLink CartType = "payment_link"
	CartTypeSwap        CartType = "swap"
)

// Defines values for ClaimItemReason.
const (
	MissingItem       ClaimItemReason = "missing_item"
	Other             ClaimItemReason = "other"
	ProductionFailure ClaimItemReason = "production_failure"
	WrongItem         ClaimItemReason = "wrong_item"
)

// Defines values for ClaimOrderFulfillmentStatus.
const (
	ClaimOrderFulfillmentStatusCanceled           ClaimOrderFulfillmentStatus = "canceled"
	ClaimOrderFulfillmentStatusFulfilled          ClaimOrderFulfillmentStatus = "fulfilled"
	ClaimOrderFulfillmentStatusNotFulfilled       ClaimOrderFulfillmentStatus = "not_fulfilled"
	ClaimOrderFulfillmentStatusPartiallyFulfilled ClaimOrderFulfillmentStatus = "partially_fulfilled"
	ClaimOrderFulfillmentStatusPartiallyReturned  ClaimOrderFulfillmentStatus = "partially_returned"
	ClaimOrderFulfillmentStatusPartiallyShipped   ClaimOrderFulfillmentStatus = "partially_shipped"
	ClaimOrderFulfillmentStatusRequiresAction     ClaimOrderFulfillmentStatus = "requires_action"
	ClaimOrderFulfillmentStatusReturned           ClaimOrderFulfillmentStatus = "returned"
	ClaimOrderFulfillmentStatusShipped            ClaimOrderFulfillmentStatus = "shipped"
)

// Defines values for ClaimOrderPaymentStatus.
const (
	ClaimOrderPaymentStatusNa          ClaimOrderPaymentStatus = "na"
	ClaimOrderPaymentStatusNotRefunded ClaimOrderPaymentStatus = "not_refunded"
	ClaimOrderPaymentStatusRefunded    ClaimOrderPaymentStatus = "refunded"
)

// Defines values for ClaimOrderType.
const (
	ClaimOrderTypeRefund  ClaimOrderType = "refund"
	ClaimOrderTypeReplace ClaimOrderType = "replace"
)

// Defines values for DiscountConditionOperator.
const (
	DiscountConditionOperatorIn    DiscountConditionOperator = "in"
	DiscountConditionOperatorNotIn DiscountConditionOperator = "not_in"
)

// Defines values for DiscountConditionType.
const (
	CustomerGroups     DiscountConditionType = "customer_groups"
	ProductCollections DiscountConditionType = "product_collections"
	ProductTags        DiscountConditionType = "product_tags"
	ProductTypes       DiscountConditionType = "product_types"
	Products           DiscountConditionType = "products"
)

// Defines values for DiscountRuleAllocation.
const (
	DiscountRuleAllocationItem  DiscountRuleAllocation = "item"
	DiscountRuleAllocationTotal DiscountRuleAllocation = "total"
)

// Defines values for DiscountRuleType.
const (
	DiscountRuleTypeFixed        DiscountRuleType = "fixed"
	DiscountRuleTypeFreeShipping DiscountRuleType = "free_shipping"
	DiscountRuleTypePercentage   DiscountRuleType = "percentage"
)

// Defines values for DraftOrderStatus.
const (
	DraftOrderStatusCompleted DraftOrderStatus = "completed"
	DraftOrderStatusOpen      DraftOrderStatus = "open"
)

// Defines values for ErrorCode.
const (
	ErrorCodeApiError            ErrorCode = "api_error"
	ErrorCodeInvalidRequestError ErrorCode = "invalid_request_error"
	ErrorCodeInvalidStateError   ErrorCode = "invalid_state_error"
	ErrorCodeUnknownError        ErrorCode = "unknown_error"
)

// Defines values for ErrorType.
const (
	ErrorTypeConflict                        ErrorType = "conflict"
	ErrorTypeDatabaseError                   ErrorType = "database_error"
	ErrorTypeDuplicateError                  ErrorType = "duplicate_error"
	ErrorTypeInvalidArgument                 ErrorType = "invalid_argument"
	ErrorTypeInvalidData                     ErrorType = "invalid_data"
	ErrorTypeNotAllowed                      ErrorType = "not_allowed"
	ErrorTypeNotFound                        ErrorType = "not_found"
	ErrorTypePaymentAuthorizationError       ErrorType = "payment_authorization_error"
	ErrorTypeQueryRunnerAlreadyReleasedError ErrorType = "QueryRunnerAlreadyReleasedError"
	ErrorTypeTransactionAlreadyStartedError  ErrorType = "TransactionAlreadyStartedError"
	ErrorTypeTransactionNotStartedError      ErrorType = "TransactionNotStartedError"
	ErrorTypeUnauthorized                    ErrorType = "unauthorized"
	ErrorTypeUnexpectedState                 ErrorType = "unexpected_state"
	ErrorTypeUnknownError                    ErrorType = "unknown_error"
)

// Defines values for InviteRole.
const (
	InviteRoleAdmin     InviteRole = "admin"
	InviteRoleDeveloper InviteRole = "developer"
	InviteRoleMember    InviteRole = "member"
)

// Defines values for OrderFulfillmentStatus.
const (
	OrderFulfillmentStatusCanceled           OrderFulfillmentStatus = "canceled"
	OrderFulfillmentStatusFulfilled          OrderFulfillmentStatus = "fulfilled"
	OrderFulfillmentStatusNotFulfilled       OrderFulfillmentStatus = "not_fulfilled"
	OrderFulfillmentStatusPartiallyFulfilled OrderFulfillmentStatus = "partially_fulfilled"
	OrderFulfillmentStatusPartiallyReturned  OrderFulfillmentStatus = "partially_returned"
	OrderFulfillmentStatusPartiallyShipped   OrderFulfillmentStatus = "partially_shipped"
	OrderFulfillmentStatusRequiresAction     OrderFulfillmentStatus = "requires_action"
	OrderFulfillmentStatusReturned           OrderFulfillmentStatus = "returned"
	OrderFulfillmentStatusShipped            OrderFulfillmentStatus = "shipped"
)

// Defines values for OrderPaymentStatus.
const (
	OrderPaymentStatusAwaiting          OrderPaymentStatus = "awaiting"
	OrderPaymentStatusCanceled          OrderPaymentStatus = "canceled"
	OrderPaymentStatusCaptured          OrderPaymentStatus = "captured"
	OrderPaymentStatusNotPaid           OrderPaymentStatus = "not_paid"
	OrderPaymentStatusPartiallyRefunded OrderPaymentStatus = "partially_refunded"
	OrderPaymentStatusRefunded          OrderPaymentStatus = "refunded"
	OrderPaymentStatusRequiresAction    OrderPaymentStatus = "requires_action"
)

// Defines values for OrderStatus.
const (
	OrderStatusArchived       OrderStatus = "archived"
	OrderStatusCanceled       OrderStatus = "canceled"
	OrderStatusCompleted      OrderStatus = "completed"
	OrderStatusPending        OrderStatus = "pending"
	OrderStatusRequiresAction OrderStatus = "requires_action"
)

// Defines values for OrderEditStatus.
const (
	OrderEditStatusCanceled  OrderEditStatus = "canceled"
	OrderEditStatusConfirmed OrderEditStatus = "confirmed"
	OrderEditStatusCreated   OrderEditStatus = "created"
	OrderEditStatusDeclined  OrderEditStatus = "declined"
	OrderEditStatusRequested OrderEditStatus = "requested"
)

// Defines values for OrderItemChangeType.
const (
	ItemAdd    OrderItemChangeType = "item_add"
	ItemRemove OrderItemChangeType = "item_remove"
	ItemUpdate OrderItemChangeType = "item_update"
)

// Defines values for PaymentCollectionStatus.
const (
	PaymentCollectionStatusAuthorized          PaymentCollectionStatus = "authorized"
	PaymentCollectionStatusAwaiting            PaymentCollectionStatus = "awaiting"
	PaymentCollectionStatusCanceled            PaymentCollectionStatus = "canceled"
	PaymentCollectionStatusNotPaid             PaymentCollectionStatus = "not_paid"
	PaymentCollectionStatusPartiallyAuthorized PaymentCollectionStatus = "partially_authorized"
)

// Defines values for PaymentCollectionType.
const (
	PaymentCollectionTypeOrderEdit PaymentCollectionType = "order_edit"
)

// Defines values for PaymentSessionStatus.
const (
	PaymentSessionStatusAuthorized   PaymentSessionStatus = "authorized"
	PaymentSessionStatusCanceled     PaymentSessionStatus = "canceled"
	PaymentSessionStatusError        PaymentSessionStatus = "error"
	PaymentSessionStatusPending      PaymentSessionStatus = "pending"
	PaymentSessionStatusRequiresMore PaymentSessionStatus = "requires_more"
)

// Defines values for PriceListStatus.
const (
	PriceListStatusActive PriceListStatus = "active"
	PriceListStatusDraft  PriceListStatus = "draft"
)

// Defines values for PriceListType.
const (
	PriceListTypeOverride PriceListType = "override"
	PriceListTypeSale     PriceListType = "sale"
)

// Defines values for PricedProductStatus.
const (
	PricedProductStatusDraft     PricedProductStatus = "draft"
	PricedProductStatusProposed  PricedProductStatus = "proposed"
	PricedProductStatusPublished PricedProductStatus = "published"
	PricedProductStatusRejected  PricedProductStatus = "rejected"
)

// Defines values for PricedShippingOptionPriceType.
const (
	PricedShippingOptionPriceTypeCalculated PricedShippingOptionPriceType = "calculated"
	PricedShippingOptionPriceTypeFlatRate   PricedShippingOptionPriceType = "flat_rate"
)

// Defines values for ProductStatus.
const (
	ProductStatusDraft     ProductStatus = "draft"
	ProductStatusProposed  ProductStatus = "proposed"
	ProductStatusPublished ProductStatus = "published"
	ProductStatusRejected  ProductStatus = "rejected"
)

// Defines values for RefundReason.
const (
	RefundReasonClaim    RefundReason = "claim"
	RefundReasonDiscount RefundReason = "discount"
	RefundReasonOther    RefundReason = "other"
	RefundReasonReturn   RefundReason = "return"
	RefundReasonSwap     RefundReason = "swap"
)

// Defines values for ReturnStatus.
const (
	ReturnStatusCanceled       ReturnStatus = "canceled"
	ReturnStatusReceived       ReturnStatus = "received"
	ReturnStatusRequested      ReturnStatus = "requested"
	ReturnStatusRequiresAction ReturnStatus = "requires_action"
)

// Defines values for ShippingOptionPriceType.
const (
	Calculated ShippingOptionPriceType = "calculated"
	FlatRate   ShippingOptionPriceType = "flat_rate"
)

// Defines values for ShippingOptionRequirementType.
const (
	MaxSubtotal ShippingOptionRequirementType = "max_subtotal"
	MinSubtotal ShippingOptionRequirementType = "min_subtotal"
)

// Defines values for SwapFulfillmentStatus.
const (
	SwapFulfillmentStatusCanceled         SwapFulfillmentStatus = "canceled"
	SwapFulfillmentStatusFulfilled        SwapFulfillmentStatus = "fulfilled"
	SwapFulfillmentStatusNotFulfilled     SwapFulfillmentStatus = "not_fulfilled"
	SwapFulfillmentStatusPartiallyShipped SwapFulfillmentStatus = "partially_shipped"
	SwapFulfillmentStatusRequiresAction   SwapFulfillmentStatus = "requires_action"
	SwapFulfillmentStatusShipped          SwapFulfillmentStatus = "shipped"
)

// Defines values for SwapPaymentStatus.
const (
	SwapPaymentStatusAwaiting           SwapPaymentStatus = "awaiting"
	SwapPaymentStatusCanceled           SwapPaymentStatus = "canceled"
	SwapPaymentStatusCaptured           SwapPaymentStatus = "captured"
	SwapPaymentStatusConfirmed          SwapPaymentStatus = "confirmed"
	SwapPaymentStatusDifferenceRefunded SwapPaymentStatus = "difference_refunded"
	SwapPaymentStatusNotPaid            SwapPaymentStatus = "not_paid"
	SwapPaymentStatusPartiallyRefunded  SwapPaymentStatus = "partially_refunded"
	SwapPaymentStatusRefunded           SwapPaymentStatus = "refunded"
	SwapPaymentStatusRequiresAction     SwapPaymentStatus = "requires_action"
)

// Defines values for UserRole.
const (
	Admin     UserRole = "admin"
	Developer UserRole = "developer"
	Member    UserRole = "member"
)

// Defines values for GetDiscountsParamsRuleAllocation.
const (
	GetDiscountsParamsRuleAllocationItem  GetDiscountsParamsRuleAllocation = "item"
	GetDiscountsParamsRuleAllocationTotal GetDiscountsParamsRuleAllocation = "total"
)

// Defines values for GetDiscountsParamsRuleType.
const (
	Fixed        GetDiscountsParamsRuleType = "fixed"
	FreeShipping GetDiscountsParamsRuleType = "free_shipping"
	Percentage   GetDiscountsParamsRuleType = "percentage"
)

// Defines values for GetDraftOrdersParamsStatus.
const (
	GetDraftOrdersParamsStatusCompleted GetDraftOrdersParamsStatus = "completed"
	GetDraftOrdersParamsStatusOpen      GetDraftOrdersParamsStatus = "open"
)

// Defines values for GetOrdersParamsStatus.
const (
	GetOrdersParamsStatusArchived       GetOrdersParamsStatus = "archived"
	GetOrdersParamsStatusCanceled       GetOrdersParamsStatus = "canceled"
	GetOrdersParamsStatusCompleted      GetOrdersParamsStatus = "completed"
	GetOrdersParamsStatusPending        GetOrdersParamsStatus = "pending"
	GetOrdersParamsStatusRequiresAction GetOrdersParamsStatus = "requires_action"
)

// Defines values for GetOrdersParamsFulfillmentStatus.
const (
	GetOrdersParamsFulfillmentStatusCanceled           GetOrdersParamsFulfillmentStatus = "canceled"
	GetOrdersParamsFulfillmentStatusFulfilled          GetOrdersParamsFulfillmentStatus = "fulfilled"
	GetOrdersParamsFulfillmentStatusNotFulfilled       GetOrdersParamsFulfillmentStatus = "not_fulfilled"
	GetOrdersParamsFulfillmentStatusPartiallyFulfilled GetOrdersParamsFulfillmentStatus = "partially_fulfilled"
	GetOrdersParamsFulfillmentStatusPartiallyReturned  GetOrdersParamsFulfillmentStatus = "partially_returned"
	GetOrdersParamsFulfillmentStatusPartiallyShipped   GetOrdersParamsFulfillmentStatus = "partially_shipped"
	GetOrdersParamsFulfillmentStatusRequiresAction     GetOrdersParamsFulfillmentStatus = "requires_action"
	GetOrdersParamsFulfillmentStatusReturned           GetOrdersParamsFulfillmentStatus = "returned"
	GetOrdersParamsFulfillmentStatusShipped            GetOrdersParamsFulfillmentStatus = "shipped"
)

// Defines values for GetOrdersParamsPaymentStatus.
const (
	GetOrdersParamsPaymentStatusAwaiting          GetOrdersParamsPaymentStatus = "awaiting"
	GetOrdersParamsPaymentStatusCanceled          GetOrdersParamsPaymentStatus = "canceled"
	GetOrdersParamsPaymentStatusCaptured          GetOrdersParamsPaymentStatus = "captured"
	GetOrdersParamsPaymentStatusNotPaid           GetOrdersParamsPaymentStatus = "not_paid"
	GetOrdersParamsPaymentStatusPartiallyRefunded GetOrdersParamsPaymentStatus = "partially_refunded"
	GetOrdersParamsPaymentStatusRefunded          GetOrdersParamsPaymentStatus = "refunded"
	GetOrdersParamsPaymentStatusRequiresAction    GetOrdersParamsPaymentStatus = "requires_action"
)

// Defines values for GetPriceListsParamsStatus.
const (
	GetPriceListsParamsStatusActive GetPriceListsParamsStatus = "active"
	GetPriceListsParamsStatusDraft  GetPriceListsParamsStatus = "draft"
)

// Defines values for GetPriceListsParamsType.
const (
	GetPriceListsParamsTypeOverride GetPriceListsParamsType = "override"
	GetPriceListsParamsTypeSale     GetPriceListsParamsType = "sale"
)

// Defines values for GetPriceListsPriceListProductsParamsStatus.
const (
	GetPriceListsPriceListProductsParamsStatusDraft     GetPriceListsPriceListProductsParamsStatus = "draft"
	GetPriceListsPriceListProductsParamsStatusProposed  GetPriceListsPriceListProductsParamsStatus = "proposed"
	GetPriceListsPriceListProductsParamsStatusPublished GetPriceListsPriceListProductsParamsStatus = "published"
	GetPriceListsPriceListProductsParamsStatusRejected  GetPriceListsPriceListProductsParamsStatus = "rejected"
)

// Defines values for GetProductsParamsStatus.
const (
	GetProductsParamsStatusDraft     GetProductsParamsStatus = "draft"
	GetProductsParamsStatusProposed  GetProductsParamsStatus = "proposed"
	GetProductsParamsStatusPublished GetProductsParamsStatus = "published"
	GetProductsParamsStatusRejected  GetProductsParamsStatus = "rejected"
)

// Address An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
type Address struct {
	// Address1 Address line 1
	Address1 *string `json:"address_1"`

	// Address2 Address line 2
	Address2 *string `json:"address_2"`

	// City City
	City *string `json:"city"`

	// Company Company name
	Company *string `json:"company"`

	// Country Country details
	Country *Country `json:"country,omitempty"`

	// CountryCode The 2 character ISO code of the country in lower case
	CountryCode *string `json:"country_code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Customer Available if the relation `customer` is expanded.
	Customer *map[string]interface{} `json:"customer"`

	// CustomerId ID of the customer this address belongs to
	CustomerId *string `json:"customer_id"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// FirstName First name
	FirstName *string `json:"first_name"`

	// Id ID of the address
	Id string `json:"id"`

	// LastName Last name
	LastName *string `json:"last_name"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Phone Phone Number
	Phone *string `json:"phone"`

	// PostalCode Postal Code
	PostalCode *string `json:"postal_code"`

	// Province Province
	Province *string `json:"province"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// AddressCreatePayload Address fields used when creating an address.
type AddressCreatePayload struct {
	// Address1 Address line 1
	Address1 string `json:"address_1"`

	// Address2 Address line 2
	Address2 *string `json:"address_2,omitempty"`

	// City City
	City    string  `json:"city"`
	Company *string `json:"company,omitempty"`

	// CountryCode The 2 character ISO code of the country in lower case
	CountryCode string `json:"country_code"`

	// FirstName First name
	FirstName string `json:"first_name"`

	// LastName Last name
	LastName string `json:"last_name"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone Phone Number
	Phone *string `json:"phone,omitempty"`

	// PostalCode Postal Code
	PostalCode string `json:"postal_code"`

	// Province Province
	Province *string `json:"province,omitempty"`
}

// AddressPayload Address fields used when creating/updating an address.
type AddressPayload struct {
	// Address1 Address line 1
	Address1 *string `json:"address_1,omitempty"`

	// Address2 Address line 2
	Address2 *string `json:"address_2,omitempty"`

	// City City
	City *string `json:"city,omitempty"`

	// Company Company
	Company *string `json:"company,omitempty"`

	// CountryCode The 2 character ISO code of the country in lower case
	CountryCode *string `json:"country_code,omitempty"`

	// FirstName First name
	FirstName *string `json:"first_name,omitempty"`

	// LastName Last name
	LastName *string `json:"last_name,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone Phone Number
	Phone *string `json:"phone,omitempty"`

	// PostalCode Postal Code
	PostalCode *string `json:"postal_code,omitempty"`

	// Province Province
	Province *string `json:"province,omitempty"`
}

// AdminAppsListRes defines model for AdminAppsListRes.
type AdminAppsListRes struct {
	// Apps An array of app details.
	Apps []OAuth `json:"apps"`
}

// AdminAppsRes defines model for AdminAppsRes.
type AdminAppsRes struct {
	// Apps An Oauth app is typically created by a plugin to handle authentication to third-party services.
	Apps OAuth `json:"apps"`
}

// AdminAuthRes The user's details.
type AdminAuthRes struct {
	// User A User is an administrator who can manage store settings and data.
	User User `json:"user"`
}

// AdminBatchJobListRes defines model for AdminBatchJobListRes.
type AdminBatchJobListRes struct {
	// BatchJobs An array of batch job details.
	BatchJobs []BatchJob `json:"batch_jobs"`

	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of batch jobs skipped when retrieving the batch jobs.
	Offset int `json:"offset"`
}

// AdminBatchJobRes The batch job's details.
type AdminBatchJobRes struct {
	// BatchJob A Batch Job indicates an asynchronus task stored in the Medusa backend. Its status determines whether it has been executed or not.
	BatchJob BatchJob `json:"batch_job"`
}

// AdminBearerAuthRes The access token of the user, if they're authenticated successfully.
type AdminBearerAuthRes struct {
	// AccessToken Access token that can be used to send authenticated requests.
	AccessToken *string `json:"access_token,omitempty"`
}

// AdminCollectionsDeleteRes defines model for AdminCollectionsDeleteRes.
type AdminCollectionsDeleteRes struct {
	// Deleted Whether the collection was deleted successfully or not.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Collection
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminCollectionsListRes defines model for AdminCollectionsListRes.
type AdminCollectionsListRes struct {
	// Collections an array of collection details
	Collections []ProductCollection `json:"collections"`

	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of product collections skipped when retrieving the product collections.
	Offset int `json:"offset"`
}

// AdminCollectionsRes The collection's details.
type AdminCollectionsRes struct {
	// Collection A Product Collection allows grouping together products for promotional purposes. For example, an admin can create a Summer collection, add products to it, and showcase it on the storefront.
	Collection ProductCollection `json:"collection"`
}

// AdminCreateUserRequest defines model for AdminCreateUserRequest.
type AdminCreateUserRequest struct {
	// Email The User's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The first name of the User.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The last name of the User.
	LastName *string `json:"last_name,omitempty"`

	// Password The User's password.
	Password string `json:"password"`

	// Role The role assigned to the user. These roles don't provide any different privileges.
	Role *AdminCreateUserRequestRole `json:"role,omitempty"`
}

// AdminCreateUserRequestRole The role assigned to the user. These roles don't provide any different privileges.
type AdminCreateUserRequestRole string

// AdminCurrenciesListRes List of currencies with pagination fields.
type AdminCurrenciesListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Currencies An array of currency details.
	Currencies []Currency `json:"currencies"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of currencies skipped when retrieving the currencies.
	Offset int `json:"offset"`
}

// AdminCurrenciesRes A currency's details.
type AdminCurrenciesRes struct {
	// Currency Currency
	Currency Currency `json:"currency"`
}

// AdminCustomerGroupsDeleteRes defines model for AdminCustomerGroupsDeleteRes.
type AdminCustomerGroupsDeleteRes struct {
	// Deleted Whether the customer group was deleted successfully or not.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted customer group.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminCustomerGroupsListRes defines model for AdminCustomerGroupsListRes.
type AdminCustomerGroupsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// CustomerGroups An array of customer group details.
	CustomerGroups []CustomerGroup `json:"customer_groups"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of customer groups skipped when retrieving the customer groups.
	Offset int `json:"offset"`
}

// AdminCustomerGroupsRes The customer group's details.
type AdminCustomerGroupsRes struct {
	// CustomerGroup A customer group that can be used to organize customers into groups of similar traits.
	CustomerGroup CustomerGroup `json:"customer_group"`
}

// AdminCustomersListRes The list of customers with pagination fields.
type AdminCustomersListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Customers An array of customer details.
	Customers []Customer `json:"customers"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of customers skipped when retrieving the customers.
	Offset int `json:"offset"`
}

// AdminCustomersRes The customer's details.
type AdminCustomersRes struct {
	// Customer A customer can make purchases in your store and manage their profile.
	Customer Customer `json:"customer"`
}

// AdminDeleteCustomerGroupsGroupCustomerBatchReq The customers to remove from the customer group.
type AdminDeleteCustomerGroupsGroupCustomerBatchReq struct {
	// CustomerIds The ids of the customers to remove
	CustomerIds []struct {
		// Id ID of the customer
		Id string `json:"id"`
	} `json:"customer_ids"`
}

// AdminDeleteDiscountsDiscountConditionsConditionBatchReq The resources to remove.
type AdminDeleteDiscountsDiscountConditionsConditionBatchReq struct {
	// Resources The resources to be removed from the discount condition
	Resources []struct {
		// Id The id of the item
		Id string `json:"id"`
	} `json:"resources"`
}

// AdminDeletePriceListPricesPricesReq The details of the prices to delete.
type AdminDeletePriceListPricesPricesReq struct {
	// PriceIds The IDs of the prices to delete.
	PriceIds *[]string `json:"price_ids,omitempty"`
}

// AdminDeletePriceListsPriceListProductsPricesBatchReq The details of the products' prices to delete.
type AdminDeletePriceListsPriceListProductsPricesBatchReq struct {
	// ProductIds The IDs of the products to delete their associated prices.
	ProductIds *[]string `json:"product_ids,omitempty"`
}

// AdminDeleteProductCategoriesCategoryProductsBatchReq The details of the products to delete from the product category.
type AdminDeleteProductCategoriesCategoryProductsBatchReq struct {
	// ProductIds The IDs of the products to delete from the product category.
	ProductIds []struct {
		// Id The ID of a product
		Id string `json:"id"`
	} `json:"product_ids"`
}

// AdminDeleteProductsFromCollectionReq The details of the products to remove from the collection.
type AdminDeleteProductsFromCollectionReq struct {
	// ProductIds An array of Product IDs to remove from the Product Collection.
	ProductIds []string `json:"product_ids"`
}

// AdminDeleteProductsFromCollectionRes Deletion operation details
type AdminDeleteProductsFromCollectionRes struct {
	// Id The ID of the collection
	Id string `json:"id"`

	// Object The type of object the removal was executed on
	Object string `json:"object"`

	// RemovedProducts The IDs of the products removed from the collection
	RemovedProducts []string `json:"removed_products"`
}

// AdminDeletePublishableApiKeySalesChannelsBatchReq The details of the sales channels to remove from the publishable API key.
type AdminDeletePublishableApiKeySalesChannelsBatchReq struct {
	// SalesChannelIds The IDs of the sales channels to remove from the publishable API key
	SalesChannelIds []struct {
		// Id The ID of the sales channel
		Id string `json:"id"`
	} `json:"sales_channel_ids"`
}

// AdminDeleteSalesChannelsChannelProductsBatchReq The details of the products to delete from the sales channel.
type AdminDeleteSalesChannelsChannelProductsBatchReq struct {
	// ProductIds The IDs of the products to remove from the sales channel.
	ProductIds []struct {
		// Id The ID of a product
		Id string `json:"id"`
	} `json:"product_ids"`
}

// AdminDeleteSalesChannelsChannelStockLocationsReq defines model for AdminDeleteSalesChannelsChannelStockLocationsReq.
type AdminDeleteSalesChannelsChannelStockLocationsReq struct {
	// LocationId The ID of the stock location
	LocationId string `json:"location_id"`
}

// AdminDeleteShippingProfileRes defines model for AdminDeleteShippingProfileRes.
type AdminDeleteShippingProfileRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Shipping Profile.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminDeleteTaxRatesTaxRateProductTypesReq Product types to remove from the tax rates.
type AdminDeleteTaxRatesTaxRateProductTypesReq struct {
	// ProductTypes The IDs of the product types to remove their association with this tax rate.
	ProductTypes []string `json:"product_types"`
}

// AdminDeleteTaxRatesTaxRateProductsReq The details of the products to remove their associated with the tax rate.
type AdminDeleteTaxRatesTaxRateProductsReq struct {
	// Products The IDs of the products to remove their association with this tax rate.
	Products []string `json:"products"`
}

// AdminDeleteTaxRatesTaxRateShippingOptionsReq The details of the shipping options to remove their associate with the tax rate.
type AdminDeleteTaxRatesTaxRateShippingOptionsReq struct {
	// ShippingOptions The IDs of the shipping options to remove their association with this tax rate.
	ShippingOptions []string `json:"shipping_options"`
}

// AdminDeleteUploadsReq The details of the file to delete.
type AdminDeleteUploadsReq struct {
	// FileKey key of the file to delete. This is obtained when you first uploaded the file, or by the file service if you used it directly.
	FileKey string `json:"file_key"`
}

// AdminDeleteUploadsRes defines model for AdminDeleteUploadsRes.
type AdminDeleteUploadsRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The file key of the upload deleted
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminDeleteUserRes defines model for AdminDeleteUserRes.
type AdminDeleteUserRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted user.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminDiscountConditionsDeleteRes defines model for AdminDiscountConditionsDeleteRes.
type AdminDiscountConditionsDeleteRes struct {
	// Deleted Whether the discount condition was deleted successfully.
	Deleted bool `json:"deleted"`

	// Discount A discount can be applied to a cart for promotional purposes.
	Discount Discount `json:"discount"`

	// Id The ID of the deleted Discount Condition
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminDiscountConditionsRes defines model for AdminDiscountConditionsRes.
type AdminDiscountConditionsRes struct {
	// DiscountCondition Holds rule conditions for when a discount is applicable
	DiscountCondition DiscountCondition `json:"discount_condition"`
}

// AdminDiscountsDeleteRes defines model for AdminDiscountsDeleteRes.
type AdminDiscountsDeleteRes struct {
	// Deleted Whether the discount was deleted successfully.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Discount
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminDiscountsListRes The list of discounts with pagination fields.
type AdminDiscountsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Discounts The list of discounts.
	Discounts []Discount `json:"discounts"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of discounts skipped when retrieving the discounts.
	Offset int `json:"offset"`
}

// AdminDiscountsRes The discount's details.
type AdminDiscountsRes struct {
	// Discount A discount can be applied to a cart for promotional purposes.
	Discount Discount `json:"discount"`
}

// AdminDraftOrdersDeleteRes defines model for AdminDraftOrdersDeleteRes.
type AdminDraftOrdersDeleteRes struct {
	// Deleted Whether the draft order was deleted successfully.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Draft Order.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminDraftOrdersListRes The list of draft orders with pagination fields.
type AdminDraftOrdersListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// DraftOrders An array of draft order's details.
	DraftOrders []DraftOrder `json:"draft_orders"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of draft orders skipped when retrieving the draft orders.
	Offset int `json:"offset"`
}

// AdminDraftOrdersRes The list of draft orders.
type AdminDraftOrdersRes struct {
	// DraftOrder A draft order is created by an admin without direct involvement of the customer. Once its payment is marked as captured, it is transformed into an order.
	DraftOrder DraftOrder `json:"draft_order"`
}

// AdminExtendedStoresRes The store's details with additional details like payment and tax providers.
type AdminExtendedStoresRes struct {
	Store ExtendedStoreDTO `json:"store"`
}

// AdminGetRegionsRegionFulfillmentOptionsRes The list of fulfillment options in a region.
type AdminGetRegionsRegionFulfillmentOptionsRes struct {
	// FulfillmentOptions Fulfillment providers details.
	FulfillmentOptions []struct {
		// Options fulfillment provider options
		Options []map[string]interface{} `json:"options"`

		// ProviderId ID of the fulfillment provider
		ProviderId string `json:"provider_id"`
	} `json:"fulfillment_options"`
}

// AdminGetVariantsVariantInventoryRes The variant's inventory details.
type AdminGetVariantsVariantInventoryRes struct {
	Variant *VariantInventory `json:"variant,omitempty"`
}

// AdminGiftCardsDeleteRes defines model for AdminGiftCardsDeleteRes.
type AdminGiftCardsDeleteRes struct {
	// Deleted Whether the gift card was deleted successfully.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Gift Card
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminGiftCardsListRes The list of gift cards with pagination fields.
type AdminGiftCardsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// GiftCards The list of gift cards.
	GiftCards []GiftCard `json:"gift_cards"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of gift cards skipped when retrieving the gift cards.
	Offset int `json:"offset"`
}

// AdminGiftCardsRes The gift card's details.
type AdminGiftCardsRes struct {
	// GiftCard Gift Cards are redeemable and represent a value that can be used towards the payment of an Order.
	GiftCard GiftCard `json:"gift_card"`
}

// AdminInventoryItemsDeleteRes defines model for AdminInventoryItemsDeleteRes.
type AdminInventoryItemsDeleteRes struct {
	// Deleted Whether or not the Inventory Item was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Inventory Item.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminInventoryItemsListRes defines model for AdminInventoryItemsListRes.
type AdminInventoryItemsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// InventoryItems an array of Inventory Item details
	InventoryItems []InventoryItemDTO `json:"inventory_items"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of inventory items skipped when retrieving the inventory items.
	Offset int `json:"offset"`
}

// AdminInventoryItemsListWithVariantsAndLocationLevelsRes defines model for AdminInventoryItemsListWithVariantsAndLocationLevelsRes.
type AdminInventoryItemsListWithVariantsAndLocationLevelsRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// InventoryItems an array of Inventory Item details
	InventoryItems []DecoratedInventoryItemDTO `json:"inventory_items"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of inventory items skipped when retrieving the inventory items.
	Offset int `json:"offset"`
}

// AdminInventoryItemsLocationLevelsRes Details of inventory items and their associated location levels.
type AdminInventoryItemsLocationLevelsRes struct {
	// InventoryItem An inventory item's ID and associated location levels.
	InventoryItem struct {
		// Id The id of the location
		Id string `json:"id"`

		// LocationLevels List of stock levels at a given location
		LocationLevels []InventoryLevelDTO `json:"location_levels"`
	} `json:"inventory_item"`
}

// AdminInventoryItemsRes The inventory item's details.
type AdminInventoryItemsRes struct {
	InventoryItem InventoryItemDTO `json:"inventory_item"`
}

// AdminInviteDeleteRes defines model for AdminInviteDeleteRes.
type AdminInviteDeleteRes struct {
	// Deleted Whether or not the invite was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Invite.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminListInvitesRes The list of invites.
type AdminListInvitesRes struct {
	// Invites An array of invites
	Invites []Invite `json:"invites"`
}

// AdminNotesDeleteRes defines model for AdminNotesDeleteRes.
type AdminNotesDeleteRes struct {
	// Deleted Whether or not the Note was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Note.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminNotesListRes The list of notes with pagination fields.
type AdminNotesListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Notes An array of notes
	Notes []Note `json:"notes"`

	// Offset The number of notes skipped when retrieving the notes.
	Offset int `json:"offset"`
}

// AdminNotesRes The note's details.
type AdminNotesRes struct {
	// Note A Note is an element that can be used in association with different resources to allow admin users to describe additional information. For example, they can be used to add additional information about orders.
	Note Note `json:"note"`
}

// AdminNotificationsListRes defines model for AdminNotificationsListRes.
type AdminNotificationsListRes struct {
	// Count The total number of notifications
	Count *int `json:"count,omitempty"`

	// Limit The number of notifications per page
	Limit *int `json:"limit,omitempty"`

	// Notifications an array of notifications
	Notifications []Notification `json:"notifications"`

	// Offset The number of notifications skipped when retrieving the notifications.
	Offset *int `json:"offset,omitempty"`
}

// AdminNotificationsRes The notification's details.
type AdminNotificationsRes struct {
	// Notification A notification is an alert sent, typically to customers, using the installed Notification Provider as a reaction to internal events such as `order.placed`. Notifications can be resent.
	Notification Notification `json:"notification"`
}

// AdminOrderEditDeleteRes defines model for AdminOrderEditDeleteRes.
type AdminOrderEditDeleteRes struct {
	// Deleted Whether or not the Order Edit was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Order Edit.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminOrderEditItemChangeDeleteRes The details of deleting order edit item changes.
type AdminOrderEditItemChangeDeleteRes struct {
	// Deleted Whether or not the Order Edit Item Change was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Order Edit Item Change.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminOrderEditsListRes The list of order edits with pagination fields.
type AdminOrderEditsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of order edits skipped when retrieving the order edits.
	Offset int `json:"offset"`

	// OrderEdits An array of order edit details
	OrderEdits []OrderEdit `json:"order_edits"`
}

// AdminOrderEditsRes The order edit details.
type AdminOrderEditsRes struct {
	// OrderEdit Order edit allows modifying items in an order, such as adding, updating, or deleting items from the original order. Once the order edit is confirmed, the changes are reflected on the original order.
	OrderEdit OrderEdit `json:"order_edit"`
}

// AdminOrdersListRes The list of orders with pagination fields.
type AdminOrdersListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of orders skipped when retrieving the orders.
	Offset int `json:"offset"`

	// Orders An array of order details.
	Orders []Order `json:"orders"`
}

// AdminOrdersOrderLineItemReservationReq defines model for AdminOrdersOrderLineItemReservationReq.
type AdminOrdersOrderLineItemReservationReq struct {
	// LocationId The ID of the location of the reservation
	LocationId string `json:"location_id"`

	// Quantity The quantity to reserve
	Quantity *float32 `json:"quantity,omitempty"`
}

// AdminOrdersRes The order's details.
type AdminOrdersRes struct {
	// Order An order is a purchase made by a customer. It holds details about payment and fulfillment of the order. An order may also be created from a draft order, which is created by an admin user.
	Order Order `json:"order"`
}

// AdminPaymentCollectionDeleteRes The details of deleting a payment collection.
type AdminPaymentCollectionDeleteRes struct {
	// Deleted Whether or not the Payment Collection was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Payment Collection.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminPaymentCollectionsRes The payment collection's details.
type AdminPaymentCollectionsRes struct {
	// PaymentCollection A payment collection allows grouping and managing a list of payments at one. This can be helpful when making additional payment for order edits or integrating installment payments.
	PaymentCollection PaymentCollection `json:"payment_collection"`
}

// AdminPaymentProvidersList The list of payment providers in a store.
type AdminPaymentProvidersList struct {
	// PaymentProviders An array of payment providers details.
	PaymentProviders []PaymentProvider `json:"payment_providers"`
}

// AdminPaymentRes The payment's details.
type AdminPaymentRes struct {
	// Payment A payment is originally created from a payment session. Once a payment session is authorized, the payment is created to represent the authorized amount with a given payment method. Payments can be captured, canceled or refunded. Payments can be made towards orders, swaps, order edits, or other resources.
	Payment Payment `json:"payment"`
}

// AdminPostAppsReq defines model for AdminPostAppsReq.
type AdminPostAppsReq struct {
	// ApplicationName Name of the application for to generate the token for.
	ApplicationName string `json:"application_name"`

	// Code The code for the generated token.
	Code string `json:"code"`

	// State State of the application.
	State string `json:"state"`
}

// AdminPostAuthReq The admin's credentials used to log in.
type AdminPostAuthReq struct {
	// Email The user's email.
	Email openapi_types.Email `json:"email"`

	// Password The user's password.
	Password string `json:"password"`
}

// AdminPostBatchesReq The details of the batch job to create.
type AdminPostBatchesReq struct {
	// Context Additional infomration regarding the batch to be used for processing.
	Context map[string]interface{} `json:"context"`

	// DryRun Set a batch job in dry_run mode, which would delay executing the batch job until it's confirmed.
	DryRun *bool `json:"dry_run,omitempty"`

	// Type The type of batch job to start, which is defined by the `batchType` property of the associated batch job strategy.
	Type string `json:"type"`
}

// AdminPostCollectionsCollectionReq The product collection's details to update.
type AdminPostCollectionsCollectionReq struct {
	// Handle An optional handle to be used in slugs. If none is provided, the kebab-case version of the title will be used.
	Handle *string `json:"handle,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Title The title of the collection.
	Title *string `json:"title,omitempty"`
}

// AdminPostCollectionsReq The product collection's details.
type AdminPostCollectionsReq struct {
	// Handle An optional handle to be used in slugs. If none is provided, the kebab-case version of the title will be used.
	Handle *string `json:"handle,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Title The title of the collection.
	Title string `json:"title"`
}

// AdminPostCurrenciesCurrencyReq The details to update in the currency
type AdminPostCurrenciesCurrencyReq struct {
	// IncludesTax Tax included in prices of currency.
	IncludesTax *bool `json:"includes_tax,omitempty"`
}

// AdminPostCustomerGroupsGroupCustomersBatchReq The customers to add to the customer group.
type AdminPostCustomerGroupsGroupCustomersBatchReq struct {
	// CustomerIds The ids of the customers to add
	CustomerIds []struct {
		// Id ID of the customer
		Id string `json:"id"`
	} `json:"customer_ids"`
}

// AdminPostCustomerGroupsGroupReq The details to update in the customer group.
type AdminPostCustomerGroupsGroupReq struct {
	// Metadata Metadata of the customer group.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Name of the customer group
	Name *string `json:"name,omitempty"`
}

// AdminPostCustomerGroupsReq The details of the customer group to create.
type AdminPostCustomerGroupsReq struct {
	// Metadata Metadata of the customer group.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Name of the customer group
	Name string `json:"name"`
}

// AdminPostCustomersCustomerReq The details of the customer to update.
type AdminPostCustomersCustomerReq struct {
	// Email The Customer's email. You can't update the email of a registered customer.
	Email *openapi_types.Email `json:"email,omitempty"`

	// FirstName The Customer's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Groups A list of customer groups to which the customer belongs.
	Groups *[]struct {
		// Id The ID of a customer group
		Id string `json:"id"`
	} `json:"groups,omitempty"`

	// LastName The Customer's last name.
	LastName *string `json:"last_name,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Password The Customer's password.
	Password *string `json:"password,omitempty"`

	// Phone The Customer's phone number.
	Phone *string `json:"phone,omitempty"`
}

// AdminPostCustomersReq The details of the customer to create.
type AdminPostCustomersReq struct {
	// Email The customer's email.
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name.
	FirstName string `json:"first_name"`

	// LastName The customer's last name.
	LastName string `json:"last_name"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Password The customer's password.
	Password string `json:"password"`

	// Phone The customer's phone number.
	Phone *string `json:"phone,omitempty"`
}

// AdminPostDiscountsDiscountConditions defines model for AdminPostDiscountsDiscountConditions.
type AdminPostDiscountsDiscountConditions struct {
	// CustomerGroups list of customer group IDs if the condition's type is `customer_groups`.
	CustomerGroups *[]string `json:"customer_groups,omitempty"`

	// Operator Operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
	Operator AdminPostDiscountsDiscountConditionsOperator `json:"operator"`

	// ProductCollections list of product collection IDs if the condition's type is `product_collections`.
	ProductCollections *[]string `json:"product_collections,omitempty"`

	// ProductTags list of product tag IDs if the condition's type is `product_tags`.
	ProductTags *[]string `json:"product_tags,omitempty"`

	// ProductTypes list of product type IDs if the condition's type is `product_types`.
	ProductTypes *[]string `json:"product_types,omitempty"`

	// Products list of product IDs if the condition's type is `products`.
	Products *[]string `json:"products,omitempty"`
}

// AdminPostDiscountsDiscountConditionsOperator Operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
type AdminPostDiscountsDiscountConditionsOperator string

// AdminPostDiscountsDiscountConditionsCondition defines model for AdminPostDiscountsDiscountConditionsCondition.
type AdminPostDiscountsDiscountConditionsCondition struct {
	// CustomerGroups list of customer group IDs if the condition's type is `customer_groups`.
	CustomerGroups *[]string `json:"customer_groups,omitempty"`

	// ProductCollections list of product collection IDs if the condition's type is `product_collections`.
	ProductCollections *[]string `json:"product_collections,omitempty"`

	// ProductTags list of product tag IDs if the condition's type is `product_tags`
	ProductTags *[]string `json:"product_tags,omitempty"`

	// ProductTypes list of product type IDs if the condition's type is `product_types`.
	ProductTypes *[]string `json:"product_types,omitempty"`

	// Products list of product IDs if the condition's type is `products`.
	Products *[]string `json:"products,omitempty"`
}

// AdminPostDiscountsDiscountConditionsConditionBatchReq The details of the resources to add.
type AdminPostDiscountsDiscountConditionsConditionBatchReq struct {
	// Resources The resources to be added to the discount condition
	Resources []struct {
		// Id The ID of the item
		Id string `json:"id"`
	} `json:"resources"`
}

// AdminPostDiscountsDiscountDynamicCodesReq The details of the dynamic discount to create.
type AdminPostDiscountsDiscountDynamicCodesReq struct {
	// Code A unique code that will be used to redeem the Discount
	Code string `json:"code"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// UsageLimit Maximum number of times the discount code can be used
	UsageLimit *float32 `json:"usage_limit,omitempty"`
}

// AdminPostDiscountsDiscountReq The details of the discount to update.
type AdminPostDiscountsDiscountReq struct {
	// Code A unique code that will be used to redeem the discount
	Code *string `json:"code,omitempty"`

	// EndsAt The date and time at which the discount should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// IsDisabled Whether the discount code is disabled on creation. If set to `true`, it will not be available for customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Metadata An object containing metadata of the discount
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Regions A list of region IDs representing the Regions in which the Discount can be used.
	Regions *[]string `json:"regions,omitempty"`

	// Rule The discount rule that defines how discounts are calculated
	Rule *struct {
		// Allocation The scope that the discount should apply to. `total` indicates that the discount should be applied on the cart total, and `item` indicates that the discount should be applied to each discountable item in the cart.
		Allocation *AdminPostDiscountsDiscountReqRuleAllocation `json:"allocation,omitempty"`

		// Conditions A set of conditions that can be used to limit when the discount can be used. Only one of `products`, `product_types`, `product_collections`, `product_tags`, and `customer_groups` should be provided based on the discount condition's type.
		Conditions *[]struct {
			// CustomerGroups list of customer group IDs if the condition's type is `customer_groups`.
			CustomerGroups *[]string `json:"customer_groups,omitempty"`

			// Id The ID of the condition
			Id *string `json:"id,omitempty"`

			// Operator Operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
			Operator AdminPostDiscountsDiscountReqRuleConditionsOperator `json:"operator"`

			// ProductCollections list of product collection IDs if the condition's type is `product_collections`.
			ProductCollections *[]string `json:"product_collections,omitempty"`

			// ProductTags list of product tag IDs if the condition's type is `product_tags`.
			ProductTags *[]string `json:"product_tags,omitempty"`

			// ProductTypes list of product type IDs if the condition's type is `product_types`.
			ProductTypes *[]string `json:"product_types,omitempty"`

			// Products list of product IDs if the condition's type is `products`.
			Products *[]string `json:"products,omitempty"`
		} `json:"conditions,omitempty"`

		// Description A short description of the discount
		Description *string `json:"description,omitempty"`

		// Id The ID of the Rule
		Id string `json:"id"`

		// Value The value that the discount represents. This will depend on the type of the discount.
		Value *float32 `json:"value,omitempty"`
	} `json:"rule,omitempty"`

	// StartsAt The date and time at which the discount should be available.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// UsageLimit Maximum number of times the discount can be used
	UsageLimit *float32 `json:"usage_limit,omitempty"`

	// ValidDuration The duration the discount runs between
	ValidDuration *string `json:"valid_duration,omitempty"`
}

// AdminPostDiscountsDiscountReqRuleAllocation The scope that the discount should apply to. `total` indicates that the discount should be applied on the cart total, and `item` indicates that the discount should be applied to each discountable item in the cart.
type AdminPostDiscountsDiscountReqRuleAllocation string

// AdminPostDiscountsDiscountReqRuleConditionsOperator Operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
type AdminPostDiscountsDiscountReqRuleConditionsOperator string

// AdminPostDiscountsReq The details of the discount to create.
type AdminPostDiscountsReq struct {
	// Code A unique code that will be used to redeem the discount
	Code string `json:"code"`

	// EndsAt The date and time at which the discount should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// IsDisabled Whether the discount code is disabled on creation. If set to `true`, it will not be available for customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// IsDynamic Whether the discount should have multiple instances of itself, each with a different code. This can be useful for automatically generated discount codes that all have to follow a common set of rules.
	IsDynamic *bool `json:"is_dynamic,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Regions A list of region IDs representing the Regions in which the Discount can be used.
	Regions []string `json:"regions"`

	// Rule The discount rule that defines how discounts are calculated
	Rule struct {
		// Allocation The scope that the discount should apply to. `total` indicates that the discount should be applied on the cart total, and `item` indicates that the discount should be applied to each discountable item in the cart.
		Allocation AdminPostDiscountsReqRuleAllocation `json:"allocation"`

		// Conditions A set of conditions that can be used to limit when the discount can be used. Only one of `products`, `product_types`, `product_collections`, `product_tags`, and `customer_groups` should be provided based on the discount condition's type.
		Conditions *[]struct {
			// CustomerGroups list of customer group IDs if the condition's type is `customer_groups`.
			CustomerGroups *[]string `json:"customer_groups,omitempty"`

			// Operator Operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
			Operator AdminPostDiscountsReqRuleConditionsOperator `json:"operator"`

			// ProductCollections list of product collection IDs if the condition's type is `product_collections`.
			ProductCollections *[]string `json:"product_collections,omitempty"`

			// ProductTags list of product tag IDs if the condition's type is `product_tags`.
			ProductTags *[]string `json:"product_tags,omitempty"`

			// ProductTypes list of product type IDs if the condition's type is `product_types`.
			ProductTypes *[]string `json:"product_types,omitempty"`

			// Products list of product IDs if the condition's type is `products`.
			Products *[]string `json:"products,omitempty"`
		} `json:"conditions,omitempty"`

		// Description A short description of the discount
		Description *string `json:"description,omitempty"`

		// Type The type of the discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
		Type AdminPostDiscountsReqRuleType `json:"type"`

		// Value The value that the discount represents. This will depend on the type of the discount.
		Value float32 `json:"value"`
	} `json:"rule"`

	// StartsAt The date and time at which the discount should be available.
	StartsAt *time.Time `json:"starts_at,omitempty"`

	// UsageLimit Maximum number of times the discount can be used
	UsageLimit *float32 `json:"usage_limit,omitempty"`

	// ValidDuration The duration the discount runs between
	ValidDuration *string `json:"valid_duration,omitempty"`
}

// AdminPostDiscountsReqRuleAllocation The scope that the discount should apply to. `total` indicates that the discount should be applied on the cart total, and `item` indicates that the discount should be applied to each discountable item in the cart.
type AdminPostDiscountsReqRuleAllocation string

// AdminPostDiscountsReqRuleConditionsOperator Operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
type AdminPostDiscountsReqRuleConditionsOperator string

// AdminPostDiscountsReqRuleType The type of the discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
type AdminPostDiscountsReqRuleType string

// AdminPostDraftOrdersDraftOrderLineItemsItemReq The details to update of the line item.
type AdminPostDraftOrdersDraftOrderLineItemsItemReq struct {
	// Metadata The optional key-value map with additional details about the Line Item.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The quantity of the line item.
	Quantity *int `json:"quantity,omitempty"`

	// Title The title of the line item if `variant_id` is not provided.
	Title *string `json:"title,omitempty"`

	// UnitPrice The custom price of the line item. If a `variant_id` is supplied, the price provided here will override the variant's price.
	UnitPrice *int `json:"unit_price,omitempty"`
}

// AdminPostDraftOrdersDraftOrderLineItemsReq The details of the line item to create.
type AdminPostDraftOrdersDraftOrderLineItemsReq struct {
	// Metadata The optional key-value map with additional details about the Line Item.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The quantity of the line item.
	Quantity int `json:"quantity"`

	// Title The title of the line item if `variant_id` is not provided.
	Title *string `json:"title,omitempty"`

	// UnitPrice The custom price of the line item. If a `variant_id` is supplied, the price provided here will override the variant's price.
	UnitPrice *int `json:"unit_price,omitempty"`

	// VariantId The ID of the Product Variant associated with the line item. If the line item is custom, the `variant_id` should be omitted.
	VariantId *string `json:"variant_id,omitempty"`
}

// AdminPostDraftOrdersDraftOrderRegisterPaymentRes The order's details.
type AdminPostDraftOrdersDraftOrderRegisterPaymentRes struct {
	// Order An order is a purchase made by a customer. It holds details about payment and fulfillment of the order. An order may also be created from a draft order, which is created by an admin user.
	Order Order `json:"order"`
}

// AdminPostDraftOrdersDraftOrderReq The details of the draft order to update.
type AdminPostDraftOrdersDraftOrderReq struct {
	// BillingAddress The Address to be used for billing purposes.
	BillingAddress *AdminPostDraftOrdersDraftOrderReq_BillingAddress `json:"billing_address,omitempty"`

	// CountryCode The 2 character ISO code for the Country.
	CountryCode *string `json:"country_code,omitempty"`

	// CustomerId The ID of the customer this draft order is associated with.
	CustomerId *string `json:"customer_id,omitempty"`

	// Discounts An array of Discount codes to add to the Draft Order.
	Discounts *[]struct {
		// Code The code that a Discount is identifed by.
		Code string `json:"code"`
	} `json:"discounts,omitempty"`

	// Email An email to be used in the Draft Order.
	Email *openapi_types.Email `json:"email,omitempty"`

	// NoNotificationOrder An optional flag passed to the resulting order that indicates whether the customer should receive notifications about order updates.
	NoNotificationOrder *bool `json:"no_notification_order,omitempty"`

	// RegionId The ID of the Region to create the Draft Order in.
	RegionId *string `json:"region_id,omitempty"`

	// ShippingAddress The Address to be used for shipping purposes.
	ShippingAddress *AdminPostDraftOrdersDraftOrderReq_ShippingAddress `json:"shipping_address,omitempty"`
}

// AdminPostDraftOrdersDraftOrderReqBillingAddress1 defines model for .
type AdminPostDraftOrdersDraftOrderReqBillingAddress1 = string

// AdminPostDraftOrdersDraftOrderReq_BillingAddress The Address to be used for billing purposes.
type AdminPostDraftOrdersDraftOrderReq_BillingAddress struct {
	union json.RawMessage
}

// AdminPostDraftOrdersDraftOrderReqShippingAddress1 defines model for .
type AdminPostDraftOrdersDraftOrderReqShippingAddress1 = string

// AdminPostDraftOrdersDraftOrderReq_ShippingAddress The Address to be used for shipping purposes.
type AdminPostDraftOrdersDraftOrderReq_ShippingAddress struct {
	union json.RawMessage
}

// AdminPostDraftOrdersReq The details of the draft order to create.
type AdminPostDraftOrdersReq struct {
	// BillingAddress The Address to be used for billing purposes.
	BillingAddress *AdminPostDraftOrdersReq_BillingAddress `json:"billing_address,omitempty"`

	// CustomerId The ID of the customer this draft order is associated with.
	CustomerId *string `json:"customer_id,omitempty"`

	// Discounts The discounts to add to the draft order
	Discounts *[]struct {
		// Code The code of the discount to apply
		Code string `json:"code"`
	} `json:"discounts,omitempty"`

	// Email The email of the customer of the draft order
	Email openapi_types.Email `json:"email"`

	// Items The draft order's line items.
	Items *[]struct {
		// Metadata The optional key-value map with additional details about the line item.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Quantity The quantity of the line item.
		Quantity int `json:"quantity"`

		// Title The title of the line item if `variant_id` is not provided.
		Title *string `json:"title,omitempty"`

		// UnitPrice The custom price of the line item. If a `variant_id` is supplied, the price provided here will override the variant's price.
		UnitPrice *int `json:"unit_price,omitempty"`

		// VariantId The ID of the Product Variant associated with the line item. If the line item is custom, the `variant_id` should be omitted.
		VariantId *string `json:"variant_id,omitempty"`
	} `json:"items,omitempty"`

	// Metadata The optional key-value map with additional details about the Draft Order.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotificationOrder An optional flag passed to the resulting order that indicates whether the customer should receive notifications about order updates.
	NoNotificationOrder *bool `json:"no_notification_order,omitempty"`

	// RegionId The ID of the region for the draft order
	RegionId string `json:"region_id"`

	// ShippingAddress The Address to be used for shipping purposes.
	ShippingAddress *AdminPostDraftOrdersReq_ShippingAddress `json:"shipping_address,omitempty"`

	// ShippingMethods The shipping methods for the draft order
	ShippingMethods []struct {
		// Data The optional additional data needed for the shipping method
		Data *map[string]interface{} `json:"data,omitempty"`

		// OptionId The ID of the shipping option in use
		OptionId string `json:"option_id"`

		// Price The price of the shipping method.
		Price *int `json:"price,omitempty"`
	} `json:"shipping_methods"`

	// Status The status of the draft order. The draft order's default status is `open`. It's changed to `completed` when its payment is marked as paid.
	Status *AdminPostDraftOrdersReqStatus `json:"status,omitempty"`
}

// AdminPostDraftOrdersReqBillingAddress1 defines model for .
type AdminPostDraftOrdersReqBillingAddress1 = string

// AdminPostDraftOrdersReq_BillingAddress The Address to be used for billing purposes.
type AdminPostDraftOrdersReq_BillingAddress struct {
	union json.RawMessage
}

// AdminPostDraftOrdersReqShippingAddress1 defines model for .
type AdminPostDraftOrdersReqShippingAddress1 = string

// AdminPostDraftOrdersReq_ShippingAddress The Address to be used for shipping purposes.
type AdminPostDraftOrdersReq_ShippingAddress struct {
	union json.RawMessage
}

// AdminPostDraftOrdersReqStatus The status of the draft order. The draft order's default status is `open`. It's changed to `completed` when its payment is marked as paid.
type AdminPostDraftOrdersReqStatus string

// AdminPostGiftCardsGiftCardReq The details to update of the gift card.
type AdminPostGiftCardsGiftCardReq struct {
	// Balance The value (excluding VAT) that the Gift Card should represent.
	Balance *int `json:"balance,omitempty"`

	// EndsAt The date and time at which the Gift Card should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// IsDisabled Whether the Gift Card is disabled on creation. If set to `true`, the gift card will not be available for customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// RegionId The ID of the Region in which the Gift Card can be used.
	RegionId *string `json:"region_id,omitempty"`
}

// AdminPostGiftCardsReq The details of the gift card to create.
type AdminPostGiftCardsReq struct {
	// EndsAt The date and time at which the Gift Card should no longer be available.
	EndsAt *time.Time `json:"ends_at,omitempty"`

	// IsDisabled Whether the Gift Card is disabled on creation. If set to `true`, the gift card will not be available for customers.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// RegionId The ID of the Region in which the Gift Card can be used.
	RegionId string `json:"region_id"`

	// Value The value (excluding VAT) that the Gift Card should represent.
	Value *int `json:"value,omitempty"`
}

// AdminPostInventoryItemsInventoryItemReq The attributes to update in an inventory item.
type AdminPostInventoryItemsInventoryItemReq struct {
	// Description The inventory item's description.
	Description *string `json:"description,omitempty"`

	// Height The height of the Inventory Item. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// Length The length of the Inventory Item. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// Material The material and composition that the Inventory Item is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The country in which the Inventory Item was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping *bool `json:"requires_shipping,omitempty"`

	// Thumbnail The inventory item's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The inventory item's title.
	Title *string `json:"title,omitempty"`

	// Weight The weight of the Inventory Item. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Inventory Item. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// AdminPostInventoryItemsItemLocationLevelsLevelReq defines model for AdminPostInventoryItemsItemLocationLevelsLevelReq.
type AdminPostInventoryItemsItemLocationLevelsLevelReq struct {
	// IncomingQuantity the incoming stock quantity of an inventory item at the given location ID
	IncomingQuantity *float32 `json:"incoming_quantity,omitempty"`

	// StockedQuantity the total stock quantity of an inventory item at the given location ID
	StockedQuantity *float32 `json:"stocked_quantity,omitempty"`
}

// AdminPostInventoryItemsItemLocationLevelsReq The details of the location level to create.
type AdminPostInventoryItemsItemLocationLevelsReq struct {
	// IncomingQuantity the incoming stock quantity of the inventory item at this location
	IncomingQuantity *float32 `json:"incoming_quantity,omitempty"`

	// LocationId the ID of the stock location
	LocationId string `json:"location_id"`

	// StockedQuantity the stock quantity of the inventory item at this location
	StockedQuantity float32 `json:"stocked_quantity"`
}

// AdminPostInventoryItemsReq The details of the inventory item to create.
type AdminPostInventoryItemsReq struct {
	// AllowBackorder Whether the associated Product Variant can be purchased when out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode A generic GTIN field for the Product Variant.
	Barcode *string `json:"barcode,omitempty"`

	// Description The inventory item's description.
	Description *string `json:"description,omitempty"`

	// Ean The EAN number of the item.
	Ean *string `json:"ean,omitempty"`

	// Height The height of the Inventory Item. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// InventoryQuantity The amount of stock kept of the associated Product Variant.
	InventoryQuantity *int `json:"inventory_quantity,omitempty"`

	// Length The length of the Inventory Item. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether Medusa should keep track of the inventory for the associated Product Variant.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The material and composition that the Inventory Item is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The country in which the Inventory Item was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Sku The unique SKU of the associated Product Variant.
	Sku *string `json:"sku,omitempty"`

	// Thumbnail The inventory item's thumbnail.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The inventory item's title.
	Title *string `json:"title,omitempty"`

	// Upc The UPC number of the item.
	Upc *string `json:"upc,omitempty"`

	// VariantId The ID of the variant to create the inventory item for.
	VariantId string `json:"variant_id"`

	// Weight The weight of the Inventory Item. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Inventory Item. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// AdminPostInvitesInviteAcceptReq The details of the invite to be accepted.
type AdminPostInvitesInviteAcceptReq struct {
	// Token The token of the invite to accept. This is a unique token generated when the invite was created or resent.
	Token string `json:"token"`

	// User The details of the user to create.
	User struct {
		// FirstName the first name of the User
		FirstName string `json:"first_name"`

		// LastName the last name of the User
		LastName string `json:"last_name"`

		// Password The password for the User
		Password string `json:"password"`
	} `json:"user"`
}

// AdminPostInvitesReq defines model for AdminPostInvitesReq.
type AdminPostInvitesReq struct {
	// Role The role of the user to be created. This does not actually change the privileges of the user that is eventually created.
	Role AdminPostInvitesReqRole `json:"role"`

	// User The email associated with the invite. Once the invite is accepted, the email will be associated with the created user.
	User openapi_types.Email `json:"user"`
}

// AdminPostInvitesReqRole The role of the user to be created. This does not actually change the privileges of the user that is eventually created.
type AdminPostInvitesReqRole string

// AdminPostNotesNoteReq The details to update of the note.
type AdminPostNotesNoteReq struct {
	// Value The description of the Note.
	Value string `json:"value"`
}

// AdminPostNotesReq The details of the note to be created.
type AdminPostNotesReq struct {
	// ResourceId The ID of the resource which the Note relates to. For example, an order ID.
	ResourceId string `json:"resource_id"`

	// ResourceType The type of resource which the Note relates to. For example, `order`.
	ResourceType string `json:"resource_type"`

	// Value The content of the Note to create.
	Value string `json:"value"`
}

// AdminPostNotificationsNotificationResendReq The resend details.
type AdminPostNotificationsNotificationResendReq struct {
	// To A new address or user identifier that the Notification should be sent to. If not provided, the previous `to` field of the notification will be used.
	To *string `json:"to,omitempty"`
}

// AdminPostOrderEditsEditLineItemsLineItemReq The details to create or update of the line item change.
type AdminPostOrderEditsEditLineItemsLineItemReq struct {
	// Quantity The quantity to update
	Quantity float32 `json:"quantity"`
}

// AdminPostOrderEditsEditLineItemsReq The details of the line item change to create.
type AdminPostOrderEditsEditLineItemsReq struct {
	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The quantity of the item.
	Quantity float32 `json:"quantity"`

	// VariantId The ID of the product variant associated with the item.
	VariantId string `json:"variant_id"`
}

// AdminPostOrderEditsOrderEditReq The details to update of the order edit.
type AdminPostOrderEditsOrderEditReq struct {
	// InternalNote An optional note to create or update in the order edit.
	InternalNote *string `json:"internal_note,omitempty"`
}

// AdminPostOrderEditsReq The details of the order edit to create.
type AdminPostOrderEditsReq struct {
	// InternalNote An optional note to associate with the order edit.
	InternalNote *string `json:"internal_note,omitempty"`

	// OrderId The ID of the order to create the edit for.
	OrderId string `json:"order_id"`
}

// AdminPostOrdersOrderClaimsClaimFulfillmentsReq defines model for AdminPostOrdersOrderClaimsClaimFulfillmentsReq.
type AdminPostOrdersOrderClaimsClaimFulfillmentsReq struct {
	// LocationId The ID of the fulfillment's location.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostOrdersOrderClaimsClaimReq defines model for AdminPostOrdersOrderClaimsClaimReq.
type AdminPostOrdersOrderClaimsClaimReq struct {
	// ClaimItems The Claim Items that the Claim will consist of.
	ClaimItems *[]struct {
		// Id The ID of the Claim Item.
		Id string `json:"id"`

		// Images A list of image URL's that will be associated with the Claim
		Images []struct {
			// Id Image ID
			Id *string `json:"id,omitempty"`

			// Url Image URL
			Url *string `json:"url,omitempty"`
		} `json:"images"`

		// ItemId The ID of the Line Item that will be claimed.
		ItemId *string `json:"item_id,omitempty"`

		// Metadata An optional set of key-value pairs to hold additional information.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Note Short text describing the Claim Item in further detail.
		Note *string `json:"note,omitempty"`

		// Quantity The number of items that will be returned
		Quantity *int `json:"quantity,omitempty"`

		// Reason The reason for the Claim
		Reason *AdminPostOrdersOrderClaimsClaimReqClaimItemsReason `json:"reason,omitempty"`

		// Tags A list o tags to add to the Claim Item
		Tags []struct {
			// Id Tag ID
			Id *string `json:"id,omitempty"`

			// Value Tag value
			Value *string `json:"value,omitempty"`
		} `json:"tags"`
	} `json:"claim_items,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification If set to true no notification will be send related to this Swap.
	NoNotification *bool `json:"no_notification,omitempty"`

	// ShippingMethods The Shipping Methods to send the additional Line Items with.
	ShippingMethods *[]struct {
		// Data An optional set of key-value pairs to hold additional information.
		Data *map[string]interface{} `json:"data,omitempty"`

		// Id The ID of an existing Shipping Method
		Id *string `json:"id,omitempty"`

		// OptionId The ID of the Shipping Option to create a Shipping Method from
		OptionId *string `json:"option_id,omitempty"`

		// Price The price to charge for the Shipping Method
		Price *int `json:"price,omitempty"`
	} `json:"shipping_methods,omitempty"`
}

// AdminPostOrdersOrderClaimsClaimReqClaimItemsReason The reason for the Claim
type AdminPostOrdersOrderClaimsClaimReqClaimItemsReason string

// AdminPostOrdersOrderClaimsClaimShipmentsReq defines model for AdminPostOrdersOrderClaimsClaimShipmentsReq.
type AdminPostOrdersOrderClaimsClaimShipmentsReq struct {
	// FulfillmentId The ID of the Fulfillment.
	FulfillmentId string `json:"fulfillment_id"`

	// TrackingNumbers An array of tracking numbers for the shipment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`
}

// AdminPostOrdersOrderClaimsReq The details of the claim to be created.
type AdminPostOrdersOrderClaimsReq struct {
	// AdditionalItems The new items to send to the Customer. This is only used if the claim's type is `replace`.
	AdditionalItems *[]struct {
		// Quantity The quantity of the Product Variant.
		Quantity int `json:"quantity"`

		// VariantId The ID of the Product Variant.
		VariantId string `json:"variant_id"`
	} `json:"additional_items,omitempty"`

	// ClaimItems The Claim Items that the Claim will consist of.
	ClaimItems []struct {
		// Images A list of image URL's that will be associated with the Claim
		Images *interface{} `json:"images,omitempty"`

		// ItemId The ID of the Line Item that will be claimed.
		ItemId string `json:"item_id"`

		// Note Short text describing the Claim Item in further detail.
		Note *string `json:"note,omitempty"`

		// Quantity The number of items that will be returned
		Quantity int `json:"quantity"`

		// Reason The reason for the Claim
		Reason *AdminPostOrdersOrderClaimsReqClaimItemsReason `json:"reason,omitempty"`

		// Tags A list of tags to add to the Claim Item
		Tags *[]string `json:"tags,omitempty"`
	} `json:"claim_items"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification If set to true no notification will be send related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`

	// RefundAmount The amount to refund the customer. This is used when the claim's type is `refund`.
	RefundAmount *int `json:"refund_amount,omitempty"`

	// ReturnLocationId The ID of the location used for the associated return.
	ReturnLocationId *string `json:"return_location_id,omitempty"`

	// ReturnShipping Optional details for the Return Shipping Method, if the items are to be sent back. Providing this field will result in a return being created and associated with the claim.
	ReturnShipping *struct {
		// OptionId The ID of the Shipping Option to create the Shipping Method from.
		OptionId *string `json:"option_id,omitempty"`

		// Price The price to charge for the Shipping Method.
		Price *int `json:"price,omitempty"`
	} `json:"return_shipping,omitempty"`

	// ShippingAddress Address fields used when creating/updating an address.
	ShippingAddress *AddressPayload `json:"shipping_address,omitempty"`

	// ShippingMethods The Shipping Methods to send the additional Line Items with. This is only used if the claim's type is `replace`.
	ShippingMethods *[]struct {
		// Data An optional set of key-value pairs to hold additional information.
		Data *map[string]interface{} `json:"data,omitempty"`

		// Id The ID of an existing Shipping Method
		Id *string `json:"id,omitempty"`

		// OptionId The ID of the Shipping Option to create a Shipping Method from
		OptionId *string `json:"option_id,omitempty"`

		// Price The price to charge for the Shipping Method
		Price *int `json:"price,omitempty"`
	} `json:"shipping_methods,omitempty"`

	// Type The type of the Claim. This will determine how the Claim is treated: `replace` Claims will result in a Fulfillment with new items being created, while a `refund` Claim will refund the amount paid for the claimed items.
	Type AdminPostOrdersOrderClaimsReqType `json:"type"`
}

// AdminPostOrdersOrderClaimsReqClaimItemsReason The reason for the Claim
type AdminPostOrdersOrderClaimsReqClaimItemsReason string

// AdminPostOrdersOrderClaimsReqType The type of the Claim. This will determine how the Claim is treated: `replace` Claims will result in a Fulfillment with new items being created, while a `refund` Claim will refund the amount paid for the claimed items.
type AdminPostOrdersOrderClaimsReqType string

// AdminPostOrdersOrderFulfillmentsReq The details of the fulfillment to be created.
type AdminPostOrdersOrderFulfillmentsReq struct {
	// Items The Line Items to include in the Fulfillment.
	Items []struct {
		// ItemId The ID of the Line Item to fulfill.
		ItemId string `json:"item_id"`

		// Quantity The quantity of the Line Item to fulfill.
		Quantity int `json:"quantity"`
	} `json:"items"`

	// LocationId The ID of the location where the items will be fulfilled from.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this fulfillment.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostOrdersOrderRefundsReq The details of the order refund.
type AdminPostOrdersOrderRefundsReq struct {
	// Amount The amount to refund. It should be less than or equal the `refundable_amount` of the order.
	Amount int `json:"amount"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this Refund.
	NoNotification *bool `json:"no_notification,omitempty"`

	// Note A note with additional details about the Refund.
	Note *string `json:"note,omitempty"`

	// Reason The reason for the Refund.
	Reason string `json:"reason"`
}

// AdminPostOrdersOrderReq The details to update of the order.
type AdminPostOrdersOrderReq struct {
	// BillingAddress Address fields used when creating/updating an address.
	BillingAddress *AddressPayload `json:"billing_address,omitempty"`

	// CustomerId The ID of the customer associated with the order.
	CustomerId *string `json:"customer_id,omitempty"`

	// Discounts The discounts applied to the order
	Discounts *[]Discount `json:"discounts,omitempty"`

	// Email The email associated with the order
	Email *string `json:"email,omitempty"`

	// Items The line items of the order
	Items *[]LineItem `json:"items,omitempty"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this order.
	NoNotification *bool `json:"no_notification,omitempty"`

	// PaymentMethod The payment method chosen for the order.
	PaymentMethod *struct {
		// Data Any data relevant for the given payment method.
		Data *map[string]interface{} `json:"data,omitempty"`

		// ProviderId The ID of the payment provider.
		ProviderId *string `json:"provider_id,omitempty"`
	} `json:"payment_method,omitempty"`

	// Region ID of the region that the order is associated with.
	Region *string `json:"region,omitempty"`

	// ShippingAddress Address fields used when creating/updating an address.
	ShippingAddress *AddressPayload `json:"shipping_address,omitempty"`

	// ShippingMethod The Shipping Method used for shipping the order.
	ShippingMethod *struct {
		// Data Any data relevant to the specific shipping method.
		Data *map[string]interface{} `json:"data,omitempty"`

		// Items Items to ship
		Items *[]LineItem `json:"items,omitempty"`

		// Price The price of the shipping.
		Price *int `json:"price,omitempty"`

		// ProfileId The ID of the shipping profile.
		ProfileId *string `json:"profile_id,omitempty"`

		// ProviderId The ID of the shipping provider.
		ProviderId *string `json:"provider_id,omitempty"`
	} `json:"shipping_method,omitempty"`
}

// AdminPostOrdersOrderReturnsReq The details of the requested return.
type AdminPostOrdersOrderReturnsReq struct {
	// Items The line items that will be returned.
	Items []struct {
		// ItemId The ID of the Line Item.
		ItemId string `json:"item_id"`

		// Note An optional note with information about the Return.
		Note *string `json:"note,omitempty"`

		// Quantity The quantity of the Line Item.
		Quantity int `json:"quantity"`

		// ReasonId The ID of the Return Reason to use.
		ReasonId *string `json:"reason_id,omitempty"`
	} `json:"items"`

	// LocationId The ID of the location used for the return.
	LocationId *string `json:"location_id,omitempty"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this Return.
	NoNotification *bool `json:"no_notification,omitempty"`

	// Note An optional note with information about the Return.
	Note *string `json:"note,omitempty"`

	// ReceiveNow A flag to indicate if the Return should be registerd as received immediately.
	ReceiveNow *bool `json:"receive_now,omitempty"`

	// Refund The amount to refund.
	Refund *int `json:"refund,omitempty"`

	// ReturnShipping The Shipping Method to be used to handle the return shipment.
	ReturnShipping *struct {
		// OptionId The ID of the Shipping Option to create the Shipping Method from.
		OptionId *string `json:"option_id,omitempty"`

		// Price The price to charge for the Shipping Method.
		Price *int `json:"price,omitempty"`
	} `json:"return_shipping,omitempty"`
}

// AdminPostOrdersOrderShipmentReq The details of the shipment to create.
type AdminPostOrdersOrderShipmentReq struct {
	// FulfillmentId The ID of the Fulfillment.
	FulfillmentId string `json:"fulfillment_id"`

	// NoNotification If set to true no notification will be send related to this Shipment.
	NoNotification *bool `json:"no_notification,omitempty"`

	// TrackingNumbers The tracking numbers for the shipment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`
}

// AdminPostOrdersOrderShippingMethodsReq The shipping method's details.
type AdminPostOrdersOrderShippingMethodsReq struct {
	// Data The data required for the Shipping Option to create a Shipping Method. This depends on the Fulfillment Provider.
	Data *map[string]interface{} `json:"data,omitempty"`

	// OptionId The ID of the Shipping Option to create the Shipping Method from.
	OptionId string `json:"option_id"`

	// Price The price (excluding VAT) that should be charged for the Shipping Method
	Price float32 `json:"price"`
}

// AdminPostOrdersOrderSwapsReq The details of the swap to create.
type AdminPostOrdersOrderSwapsReq struct {
	// AdditionalItems The new items to send to the Customer.
	AdditionalItems *[]struct {
		// Quantity The quantity of the Product Variant.
		Quantity int `json:"quantity"`

		// VariantId The ID of the Product Variant.
		VariantId string `json:"variant_id"`
	} `json:"additional_items,omitempty"`

	// AllowBackorder If set to `true`, swaps can be completed with items out of stock
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// CustomShippingOptions An array of custom shipping options to potentially create a Shipping Method from to send the additional items.
	CustomShippingOptions *[]struct {
		// OptionId The ID of the Shipping Option.
		OptionId string `json:"option_id"`

		// Price The custom price of the Shipping Option.
		Price int `json:"price"`
	} `json:"custom_shipping_options,omitempty"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this Swap.
	NoNotification *bool `json:"no_notification,omitempty"`

	// ReturnItems The Line Items to associate with the swap's return.
	ReturnItems []struct {
		// ItemId The ID of the Line Item that will be returned.
		ItemId string `json:"item_id"`

		// Note An optional note with information about the Return.
		Note *string `json:"note,omitempty"`

		// Quantity The number of items that will be returned
		Quantity int `json:"quantity"`

		// ReasonId The ID of the Return Reason to use.
		ReasonId *string `json:"reason_id,omitempty"`
	} `json:"return_items"`

	// ReturnLocationId The ID of the location used for the associated return.
	ReturnLocationId *string `json:"return_location_id,omitempty"`

	// ReturnShipping The shipping method associated with the swap's return.
	ReturnShipping *struct {
		// OptionId The ID of the Shipping Option to create the Shipping Method from.
		OptionId string `json:"option_id"`

		// Price The price to charge for the Shipping Method.
		Price *int `json:"price,omitempty"`
	} `json:"return_shipping,omitempty"`

	// SalesChannelId The ID of the sales channel associated with the swap.
	SalesChannelId *string `json:"sales_channel_id,omitempty"`
}

// AdminPostOrdersOrderSwapsSwapFulfillmentsReq defines model for AdminPostOrdersOrderSwapsSwapFulfillmentsReq.
type AdminPostOrdersOrderSwapsSwapFulfillmentsReq struct {
	// LocationId The ID of the fulfillment's location.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// NoNotification If set to `true`, no notification will be sent to the customer related to this swap.
	NoNotification *bool `json:"no_notification,omitempty"`
}

// AdminPostOrdersOrderSwapsSwapShipmentsReq defines model for AdminPostOrdersOrderSwapsSwapShipmentsReq.
type AdminPostOrdersOrderSwapsSwapShipmentsReq struct {
	// FulfillmentId The ID of the Fulfillment.
	FulfillmentId string `json:"fulfillment_id"`

	// NoNotification If set to true no notification will be sent related to this Claim.
	NoNotification *bool `json:"no_notification,omitempty"`

	// TrackingNumbers The tracking numbers for the shipment.
	TrackingNumbers *[]string `json:"tracking_numbers,omitempty"`
}

// AdminPostPaymentRefundsReq The details of the refund to create.
type AdminPostPaymentRefundsReq struct {
	// Amount The amount to refund.
	Amount int `json:"amount"`

	// Note A note with additional details about the Refund.
	Note *string `json:"note,omitempty"`

	// Reason The reason for the Refund.
	Reason string `json:"reason"`
}

// AdminPostPriceListPricesPricesReq The details of the prices to add.
type AdminPostPriceListPricesPricesReq struct {
	// Override If set to `true`, the prices will replace all existing prices associated with the Price List.
	Override *bool `json:"override,omitempty"`

	// Prices The prices to update or add.
	Prices *[]struct {
		// Amount The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// CurrencyCode The 3 character ISO currency code for which the price will be used. This is only required if `region_id` is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// Id The ID of the price.
		Id *string `json:"id,omitempty"`

		// MaxQuantity The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// RegionId The ID of the Region for which the price is used. This is only required if `currecny_code` is not provided.
		RegionId *string `json:"region_id,omitempty"`

		// VariantId The ID of the Variant for which the price is used.
		VariantId string `json:"variant_id"`
	} `json:"prices,omitempty"`
}

// AdminPostPriceListsPriceListPriceListReq The details to update of the payment collection.
type AdminPostPriceListsPriceListPriceListReq struct {
	// CustomerGroups An array of customer groups that the Price List applies to.
	CustomerGroups *[]struct {
		// Id The ID of a customer group
		Id string `json:"id"`
	} `json:"customer_groups,omitempty"`

	// Description The description of the Price List.
	Description *string `json:"description,omitempty"`

	// EndsAt The date with timezone that the Price List ends being valid.
	EndsAt *openapi_types.Date `json:"ends_at,omitempty"`

	// IncludesTax Tax included in prices of price list
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Name The name of the Price List
	Name *string `json:"name,omitempty"`

	// Prices The prices of the Price List.
	Prices *[]struct {
		// Amount The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// CurrencyCode The 3 character ISO currency code for which the price will be used. This is only required if `region_id` is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// Id The ID of the price.
		Id *string `json:"id,omitempty"`

		// MaxQuantity The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// RegionId The ID of the Region for which the price is used. This is only required if `currecny_code` is not provided.
		RegionId *string `json:"region_id,omitempty"`

		// VariantId The ID of the Variant for which the price is used.
		VariantId string `json:"variant_id"`
	} `json:"prices,omitempty"`

	// StartsAt The date with timezone that the Price List starts being valid.
	StartsAt *openapi_types.Date `json:"starts_at,omitempty"`

	// Status The status of the Price List. If the status is set to `draft`, the prices created in the price list will not be available of the customer.
	Status *AdminPostPriceListsPriceListPriceListReqStatus `json:"status,omitempty"`

	// Type The type of the Price List.
	Type *AdminPostPriceListsPriceListPriceListReqType `json:"type,omitempty"`
}

// AdminPostPriceListsPriceListPriceListReqStatus The status of the Price List. If the status is set to `draft`, the prices created in the price list will not be available of the customer.
type AdminPostPriceListsPriceListPriceListReqStatus string

// AdminPostPriceListsPriceListPriceListReqType The type of the Price List.
type AdminPostPriceListsPriceListPriceListReqType string

// AdminPostPriceListsPriceListReq The details of the price list to create.
type AdminPostPriceListsPriceListReq struct {
	// CustomerGroups An array of customer groups that the Price List applies to.
	CustomerGroups *[]struct {
		// Id The ID of a customer group
		Id string `json:"id"`
	} `json:"customer_groups,omitempty"`

	// Description The description of the Price List.
	Description string `json:"description"`

	// EndsAt The date with timezone that the Price List ends being valid.
	EndsAt *openapi_types.Date `json:"ends_at,omitempty"`

	// IncludesTax Tax included in prices of price list
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Name The name of the Price List.
	Name string `json:"name"`

	// Prices The prices of the Price List.
	Prices []struct {
		// Amount The amount to charge for the Product Variant.
		Amount int `json:"amount"`

		// CurrencyCode The 3 character ISO currency code for which the price will be used. This is only required if `region_id` is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// MaxQuantity The maximum quantity for which the price will be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity for which the price will be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// RegionId The ID of the Region for which the price is used. This is only required if `currecny_code` is not provided.
		RegionId *string `json:"region_id,omitempty"`

		// VariantId The ID of the Variant for which the price is used.
		VariantId string `json:"variant_id"`
	} `json:"prices"`

	// StartsAt The date with timezone that the Price List starts being valid.
	StartsAt *openapi_types.Date `json:"starts_at,omitempty"`

	// Status The status of the Price List. If the status is set to `draft`, the prices created in the price list will not be available of the customer.
	Status *AdminPostPriceListsPriceListReqStatus `json:"status,omitempty"`

	// Type The type of the Price List.
	Type AdminPostPriceListsPriceListReqType `json:"type"`
}

// AdminPostPriceListsPriceListReqStatus The status of the Price List. If the status is set to `draft`, the prices created in the price list will not be available of the customer.
type AdminPostPriceListsPriceListReqStatus string

// AdminPostPriceListsPriceListReqType The type of the Price List.
type AdminPostPriceListsPriceListReqType string

// AdminPostProductCategoriesCategoryProductsBatchReq The details of the products to add to the product category.
type AdminPostProductCategoriesCategoryProductsBatchReq struct {
	// ProductIds The IDs of the products to add to the product category
	ProductIds []struct {
		// Id The ID of the product
		Id string `json:"id"`
	} `json:"product_ids"`
}

// AdminPostProductCategoriesCategoryReq The details to update of the product category.
type AdminPostProductCategoriesCategoryReq struct {
	// Description An optional text field to describe the Product Category by.
	Description *string `json:"description,omitempty"`

	// Handle A handle to be used in slugs.
	Handle *string `json:"handle,omitempty"`

	// IsActive A flag to make product category visible/hidden in the store front
	IsActive *bool `json:"is_active,omitempty"`

	// IsInternal A flag to make product category an internal category for admins
	IsInternal *bool `json:"is_internal,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name to identify the Product Category by.
	Name *string `json:"name,omitempty"`

	// ParentCategoryId The ID of the parent product category
	ParentCategoryId *string `json:"parent_category_id,omitempty"`

	// Rank The rank of the category in the tree node (starting from 0)
	Rank *float32 `json:"rank,omitempty"`
}

// AdminPostProductCategoriesReq The details of the product category to create.
type AdminPostProductCategoriesReq struct {
	// Description The description of the product category.
	Description *string `json:"description,omitempty"`

	// Handle The handle of the product category. If none is provided, the kebab-case version of the name will be used. This field can be used as a slug in URLs.
	Handle *string `json:"handle,omitempty"`

	// IsActive If set to `false`, the product category will not be available in the storefront.
	IsActive *bool `json:"is_active,omitempty"`

	// IsInternal If set to `true`, the product category will only be available to admins.
	IsInternal *bool `json:"is_internal,omitempty"`

	// Metadata An optional set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the product category
	Name string `json:"name"`

	// ParentCategoryId The ID of the parent product category
	ParentCategoryId *string `json:"parent_category_id,omitempty"`
}

// AdminPostProductsProductMetadataReq defines model for AdminPostProductsProductMetadataReq.
type AdminPostProductsProductMetadataReq struct {
	// Key The metadata key
	Key string `json:"key"`

	// Value The metadata value
	Value string `json:"value"`
}

// AdminPostProductsProductOptionsOption defines model for AdminPostProductsProductOptionsOption.
type AdminPostProductsProductOptionsOption struct {
	// Title The title of the Product Option
	Title string `json:"title"`
}

// AdminPostProductsProductOptionsReq The details of the product option to create.
type AdminPostProductsProductOptionsReq struct {
	// Title The title the Product Option.
	Title string `json:"title"`
}

// AdminPostProductsProductReq The details to update of the product.
type AdminPostProductsProductReq struct {
	// Categories Product categories to add the Product to.
	Categories *[]struct {
		// Id The ID of a Product Category.
		Id string `json:"id"`
	} `json:"categories,omitempty"`

	// CollectionId The ID of the Product Collection the Product belongs to.
	CollectionId *string `json:"collection_id,omitempty"`

	// Description The description of the Product.
	Description *string `json:"description,omitempty"`

	// Discountable A flag to indicate if discounts can be applied to the Line Items generated from this Product
	Discountable *bool `json:"discountable,omitempty"`

	// Handle A unique handle to identify the Product by. If not provided, the kebab-case version of the product title will be used. This can be used as a slug in URLs.
	Handle *string `json:"handle,omitempty"`

	// Height The height of the Product.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the product variant.
	HsCode *string `json:"hs_code,omitempty"`

	// Images An array of images of the Product. Each value in the array is a URL to the image. You can use the upload API Routes to upload the image and obtain a URL.
	Images *[]string `json:"images,omitempty"`

	// Length The length of the Product.
	Length *float32 `json:"length,omitempty"`

	// Material The material composition of the Product.
	Material *string `json:"material,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturer Identification code of the Product.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The country of origin of the Product.
	OriginCountry *string `json:"origin_country,omitempty"`

	// SalesChannels Sales channels to associate the Product with.
	SalesChannels *[]struct {
		// Id The ID of an existing Sales channel.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// Status The status of the product. The product is shown to the customer only if its status is `published`.
	Status *AdminPostProductsProductReqStatus `json:"status,omitempty"`

	// Subtitle The subtitle of the Product
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags Product Tags to associate the Product with.
	Tags *[]struct {
		// Id The ID of an existing Product Tag. If not provided, a new product tag will be created.
		Id *string `json:"id,omitempty"`

		// Value The value of the Tag. If the `id` is provided, the value of the existing tag will be updated.
		Value string `json:"value"`
	} `json:"tags,omitempty"`

	// Thumbnail The thumbnail to use for the Product. The value is a URL to the thumbnail. You can use the upload API Routes to upload the thumbnail and obtain a URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The title of the Product
	Title *string `json:"title,omitempty"`

	// Type The Product Type to associate the Product with.
	Type *struct {
		// Id The ID of an existing Product Type. If not provided, a new product type will be created.
		Id *string `json:"id,omitempty"`

		// Value The value of the Product Type.
		Value string `json:"value"`
	} `json:"type,omitempty"`

	// Variants An array of Product Variants to create with the Product. Each product variant must have a unique combination of Product Option values.
	Variants *[]struct {
		// AllowBackorder Whether the product variant can be purchased when out of stock.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// Barcode A generic GTIN field of the product variant.
		Barcode *string `json:"barcode,omitempty"`

		// Ean The EAN number of the product variant.
		Ean *string `json:"ean,omitempty"`

		// Height The height of the product variant.
		Height *float32 `json:"height,omitempty"`

		// HsCode The Harmonized System code of the product variant.
		HsCode *string `json:"hs_code,omitempty"`

		// Id The id of an existing product variant. If provided, the details of the product variant will be updated. If not, a new product variant will be created.
		Id *string `json:"id,omitempty"`

		// InventoryQuantity The amount of stock kept of the product variant.
		InventoryQuantity *int `json:"inventory_quantity,omitempty"`

		// Length The length of the product variant.
		Length *float32 `json:"length,omitempty"`

		// ManageInventory Whether Medusa should keep track of the inventory of this product variant.
		ManageInventory *bool `json:"manage_inventory,omitempty"`

		// Material The material composition of the product variant.
		Material *string `json:"material,omitempty"`

		// Metadata An optional set of key-value pairs with additional information.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// MidCode The Manufacturer Identification code of the product variant.
		MidCode *string `json:"mid_code,omitempty"`

		// Options An array of Product Option values that the variant corresponds to.
		Options *[]struct {
			// OptionId The ID of the Option.
			OptionId string `json:"option_id"`

			// Value The value of the Product Option.
			Value string `json:"value"`
		} `json:"options,omitempty"`

		// OriginCountry The country of origin of the product variant.
		OriginCountry *string `json:"origin_country,omitempty"`

		// Prices An array of product variant prices. A product variant can have different prices for each region or currency code.
		Prices *[]struct {
			// Amount The price amount.
			Amount int `json:"amount"`

			// CurrencyCode The 3 character ISO currency code the price will be used in. This is only required if `region_id` is not provided.
			CurrencyCode *string `json:"currency_code,omitempty"`

			// Id The ID of the Price. If provided, the existing price will be updated. Otherwise, a new price will be created.
			Id *string `json:"id,omitempty"`

			// MaxQuantity The maximum quantity required to be added to the cart for the price to be used.
			MaxQuantity *int `json:"max_quantity,omitempty"`

			// MinQuantity The minimum quantity required to be added to the cart for the price to be used.
			MinQuantity *int `json:"min_quantity,omitempty"`

			// RegionId The ID of the Region the price will be used in. This is only required if `currency_code` is not provided.
			RegionId *string `json:"region_id,omitempty"`
		} `json:"prices,omitempty"`

		// Sku The unique SKU of the product variant.
		Sku *string `json:"sku,omitempty"`

		// Title The title of the product variant.
		Title *string `json:"title,omitempty"`

		// Upc The UPC number of the product variant.
		Upc *string `json:"upc,omitempty"`

		// Weight The weight of the product variant.
		Weight *float32 `json:"weight,omitempty"`

		// Width The width of the product variant.
		Width *float32 `json:"width,omitempty"`
	} `json:"variants,omitempty"`

	// Weight The weight of the Product.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Product.
	Width *float32 `json:"width,omitempty"`
}

// AdminPostProductsProductReqStatus The status of the product. The product is shown to the customer only if its status is `published`.
type AdminPostProductsProductReqStatus string

// AdminPostProductsProductVariantsReq The details of the product variant to create.
type AdminPostProductsProductVariantsReq struct {
	// AllowBackorder Whether the product variant can be purchased when out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode A generic GTIN field of the product variant.
	Barcode *string `json:"barcode,omitempty"`

	// Ean The EAN number of the product variant.
	Ean *string `json:"ean,omitempty"`

	// Height The height of the product variant.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the product variant.
	HsCode *string `json:"hs_code,omitempty"`

	// InventoryQuantity The amount of stock kept of the product variant.
	InventoryQuantity *int `json:"inventory_quantity,omitempty"`

	// Length The length of the product variant.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether Medusa should keep track of the inventory of this product variant.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The material composition of the product variant.
	Material *string `json:"material,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturer Identification code of the product variant.
	MidCode *string `json:"mid_code,omitempty"`

	// Options An array of Product Option values that the variant corresponds to.
	Options []struct {
		// OptionId The ID of the Product Option.
		OptionId string `json:"option_id"`

		// Value A value to give to the Product Option.
		Value string `json:"value"`
	} `json:"options"`

	// OriginCountry The country of origin of the product variant.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Prices An array of product variant prices. A product variant can have different prices for each region or currency code.
	Prices []struct {
		// Amount The price amount.
		Amount int `json:"amount"`

		// CurrencyCode The 3 character ISO currency code the price will be used in. This is only required if `region_id` is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// MaxQuantity The maximum quantity required to be added to the cart for the price to be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity required to be added to the cart for the price to be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// RegionId The ID of the Region the price will be used in. This is only required if `currency_code` is not provided.
		RegionId *string `json:"region_id,omitempty"`
	} `json:"prices"`

	// Sku The unique SKU of the product variant.
	Sku *string `json:"sku,omitempty"`

	// Title The title of the product variant.
	Title string `json:"title"`

	// Upc The UPC number of the product variant.
	Upc *string `json:"upc,omitempty"`

	// Weight The wieght of the product variant.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the product variant.
	Width *float32 `json:"width,omitempty"`
}

// AdminPostProductsProductVariantsVariantReq defines model for AdminPostProductsProductVariantsVariantReq.
type AdminPostProductsProductVariantsVariantReq struct {
	// AllowBackorder Whether the product variant can be purchased when out of stock.
	AllowBackorder *bool `json:"allow_backorder,omitempty"`

	// Barcode A generic GTIN field of the product variant.
	Barcode *string `json:"barcode,omitempty"`

	// Ean The EAN number of the item.
	Ean *string `json:"ean,omitempty"`

	// Height The height of the product variant.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the product variant.
	HsCode *string `json:"hs_code,omitempty"`

	// InventoryQuantity The amount of stock kept of the product variant.
	InventoryQuantity *int `json:"inventory_quantity,omitempty"`

	// Length The length of the product variant.
	Length *float32 `json:"length,omitempty"`

	// ManageInventory Whether Medusa should keep track of the inventory of this product variant.
	ManageInventory *bool `json:"manage_inventory,omitempty"`

	// Material The material composition of the product variant.
	Material *string `json:"material,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturer Identification code of the product variant.
	MidCode *string `json:"mid_code,omitempty"`

	// Options An array of Product Option values that the variant corresponds to.
	Options *[]struct {
		// OptionId The ID of the Product Option.
		OptionId string `json:"option_id"`

		// Value The value of the Product Option.
		Value string `json:"value"`
	} `json:"options,omitempty"`

	// OriginCountry The country of origin of the product variant.
	OriginCountry *string `json:"origin_country,omitempty"`

	// Prices An array of product variant prices. A product variant can have different prices for each region or currency code.
	Prices *[]struct {
		// Amount The price amount.
		Amount int `json:"amount"`

		// CurrencyCode The 3 character ISO currency code the price will be used in. This is only required if `region_id` is not provided.
		CurrencyCode *string `json:"currency_code,omitempty"`

		// Id The ID of the price. If provided, the existing price will be updated. Otherwise, a new price will be created.
		Id *string `json:"id,omitempty"`

		// MaxQuantity The maximum quantity required to be added to the cart for the price to be used.
		MaxQuantity *int `json:"max_quantity,omitempty"`

		// MinQuantity The minimum quantity required to be added to the cart for the price to be used.
		MinQuantity *int `json:"min_quantity,omitempty"`

		// RegionId The ID of the Region the price will be used in. This is only required if `currency_code` is not provided.
		RegionId *string `json:"region_id,omitempty"`
	} `json:"prices,omitempty"`

	// Sku The unique SKU of the product variant.
	Sku *string `json:"sku,omitempty"`

	// Title The title of the product variant.
	Title *string `json:"title,omitempty"`

	// Upc The UPC number of the item.
	Upc *string `json:"upc,omitempty"`

	// Weight The weight of the product variant.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the product variant.
	Width *float32 `json:"width,omitempty"`
}

// AdminPostProductsReq The details of the product to create.
type AdminPostProductsReq struct {
	// Categories Product categories to add the Product to.
	Categories *[]struct {
		// Id The ID of a Product Category.
		Id string `json:"id"`
	} `json:"categories,omitempty"`

	// CollectionId The ID of the Product Collection the Product belongs to.
	CollectionId *string `json:"collection_id,omitempty"`

	// Description The description of the Product.
	Description *string `json:"description,omitempty"`

	// Discountable A flag to indicate if discounts can be applied to the Line Items generated from this Product
	Discountable *bool `json:"discountable,omitempty"`

	// Handle A unique handle to identify the Product by. If not provided, the kebab-case version of the product title will be used. This can be used as a slug in URLs.
	Handle *string `json:"handle,omitempty"`

	// Height The height of the Product.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the Product.
	HsCode *string `json:"hs_code,omitempty"`

	// Images An array of images of the Product. Each value in the array is a URL to the image. You can use the upload API Routes to upload the image and obtain a URL.
	Images *[]string `json:"images,omitempty"`

	// IsGiftcard A flag to indicate if the Product represents a Gift Card. Purchasing Products with this flag set to `true` will result in a Gift Card being created.
	IsGiftcard *bool `json:"is_giftcard,omitempty"`

	// Length The length of the Product.
	Length *float32 `json:"length,omitempty"`

	// Material The material composition of the Product.
	Material *string `json:"material,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturer Identification code of the Product.
	MidCode *string `json:"mid_code,omitempty"`

	// Options The Options that the Product should have. A new product option will be created for every item in the array.
	Options *[]struct {
		// Title The title of the Product Option.
		Title string `json:"title"`
	} `json:"options,omitempty"`

	// OriginCountry The country of origin of the Product.
	OriginCountry *string `json:"origin_country,omitempty"`

	// SalesChannels Sales channels to associate the Product with.
	SalesChannels *[]struct {
		// Id The ID of an existing Sales channel.
		Id string `json:"id"`
	} `json:"sales_channels,omitempty"`

	// Status The status of the product. The product is shown to the customer only if its status is `published`.
	Status *AdminPostProductsReqStatus `json:"status,omitempty"`

	// Subtitle The subtitle of the Product
	Subtitle *string `json:"subtitle,omitempty"`

	// Tags Product Tags to associate the Product with.
	Tags *[]struct {
		// Id The ID of an existing Product Tag. If not provided, a new product tag will be created.
		Id *string `json:"id,omitempty"`

		// Value The value of the Tag. If the `id` is provided, the value of the existing tag will be updated.
		Value string `json:"value"`
	} `json:"tags,omitempty"`

	// Thumbnail The thumbnail to use for the Product. The value is a URL to the thumbnail. You can use the upload API Routes to upload the thumbnail and obtain a URL.
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title The title of the Product
	Title string `json:"title"`

	// Type The Product Type to associate the Product with.
	Type *struct {
		// Id The ID of an existing Product Type. If not provided, a new product type will be created.
		Id *string `json:"id,omitempty"`

		// Value The value of the Product Type.
		Value string `json:"value"`
	} `json:"type,omitempty"`

	// Variants An array of Product Variants to create with the Product. Each product variant must have a unique combination of Product Option values.
	Variants *[]struct {
		// AllowBackorder Whether the Product Variant can be purchased when out of stock.
		AllowBackorder *bool `json:"allow_backorder,omitempty"`

		// Barcode A generic GTIN field of the Product Variant.
		Barcode *string `json:"barcode,omitempty"`

		// Ean The EAN number of the item.
		Ean *string `json:"ean,omitempty"`

		// Height The height of the Product Variant.
		Height *float32 `json:"height,omitempty"`

		// HsCode The Harmonized System code of the Product Variant.
		HsCode *string `json:"hs_code,omitempty"`

		// InventoryQuantity The amount of stock kept of the Product Variant.
		InventoryQuantity *int `json:"inventory_quantity,omitempty"`

		// Length The length of the Product Variant.
		Length *float32 `json:"length,omitempty"`

		// ManageInventory Whether Medusa should keep track of the inventory of this Product Variant.
		ManageInventory *bool `json:"manage_inventory,omitempty"`

		// Material The material composition of the Product Variant.
		Material *string `json:"material,omitempty"`

		// Metadata An optional set of key-value pairs with additional information.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// MidCode The Manufacturer Identification code of the Product Variant.
		MidCode *string `json:"mid_code,omitempty"`

		// Options An array of Product Option values that the variant corresponds to. The option values should be added into the array in the same index as in the `options` field of the product.
		Options *[]struct {
			// Value The value to give for the Product Option at the same index in the Product's `options` field.
			Value string `json:"value"`
		} `json:"options,omitempty"`

		// OriginCountry The country of origin of the Product Variant.
		OriginCountry *string `json:"origin_country,omitempty"`

		// Prices An array of product variant prices. A product variant can have different prices for each region or currency code.
		Prices *[]struct {
			// Amount The price amount.
			Amount int `json:"amount"`

			// CurrencyCode The 3 character ISO currency code the price will be used in. This is only required if `region_id` is not provided.
			CurrencyCode *string `json:"currency_code,omitempty"`

			// MaxQuantity The maximum quantity required to be added to the cart for the price to be used.
			MaxQuantity *int `json:"max_quantity,omitempty"`

			// MinQuantity The minimum quantity required to be added to the cart for the price to be used.
			MinQuantity *int `json:"min_quantity,omitempty"`

			// RegionId The ID of the Region the price will be used in. This is only required if `currency_code` is not provided.
			RegionId *string `json:"region_id,omitempty"`
		} `json:"prices,omitempty"`

		// Sku The unique SKU of the Product Variant.
		Sku *string `json:"sku,omitempty"`

		// Title The title of the Product Variant.
		Title string `json:"title"`

		// Upc The UPC number of the item.
		Upc *string `json:"upc,omitempty"`

		// Weight The wieght of the Product Variant.
		Weight *float32 `json:"weight,omitempty"`

		// Width The width of the Product Variant.
		Width *float32 `json:"width,omitempty"`
	} `json:"variants,omitempty"`

	// Weight The weight of the Product.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Product.
	Width *float32 `json:"width,omitempty"`
}

// AdminPostProductsReqStatus The status of the product. The product is shown to the customer only if its status is `published`.
type AdminPostProductsReqStatus string

// AdminPostProductsToCollectionReq The details of the products to add to the collection.
type AdminPostProductsToCollectionReq struct {
	// ProductIds An array of Product IDs to add to the Product Collection.
	ProductIds []string `json:"product_ids"`
}

// AdminPostPublishableApiKeySalesChannelsBatchReq The details of the sales channels to add to the publishable API key.
type AdminPostPublishableApiKeySalesChannelsBatchReq struct {
	// SalesChannelIds The IDs of the sales channels to add to the publishable API key
	SalesChannelIds []struct {
		// Id The ID of the sales channel
		Id string `json:"id"`
	} `json:"sales_channel_ids"`
}

// AdminPostPublishableApiKeysPublishableApiKeyReq The details to update of the publishable API key.
type AdminPostPublishableApiKeysPublishableApiKeyReq struct {
	// Title The title of the Publishable API Key.
	Title *string `json:"title,omitempty"`
}

// AdminPostPublishableApiKeysReq The details of the publishable API key to create.
type AdminPostPublishableApiKeysReq struct {
	// Title The title of the publishable API key
	Title string `json:"title"`
}

// AdminPostRegionsRegionCountriesReq The details of the country to add to the region.
type AdminPostRegionsRegionCountriesReq struct {
	// CountryCode The 2 character ISO code for the Country.
	CountryCode string `json:"country_code"`
}

// AdminPostRegionsRegionFulfillmentProvidersReq The details of the fulfillment provider to add to the region.
type AdminPostRegionsRegionFulfillmentProvidersReq struct {
	// ProviderId The ID of the Fulfillment Provider.
	ProviderId string `json:"provider_id"`
}

// AdminPostRegionsRegionPaymentProvidersReq The details of the payment provider to add to the region.
type AdminPostRegionsRegionPaymentProvidersReq struct {
	// ProviderId The ID of the Payment Provider.
	ProviderId string `json:"provider_id"`
}

// AdminPostRegionsRegionReq The details to update of the regions.
type AdminPostRegionsRegionReq struct {
	// AutomaticTaxes If set to `true`, the Medusa backend will automatically calculate taxes for carts in this region. If set to `false`, the taxes must be calculated manually.
	AutomaticTaxes *bool `json:"automatic_taxes,omitempty"`

	// Countries A list of countries' 2 ISO characters that should be included in the Region.
	Countries *[]string `json:"countries,omitempty"`

	// CurrencyCode The 3 character ISO currency code to use in the Region.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// FulfillmentProviders A list of Fulfillment Provider IDs that can be used in the Region
	FulfillmentProviders *[]string `json:"fulfillment_providers,omitempty"`

	// GiftCardsTaxable If set to `true`, taxes will be applied on gift cards.
	GiftCardsTaxable *bool `json:"gift_cards_taxable,omitempty"`

	// IncludesTax Whether taxes are included in the prices of the region.
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Name The name of the Region
	Name *string `json:"name,omitempty"`

	// PaymentProviders A list of Payment Provider IDs that can be used in the Region
	PaymentProviders *[]string `json:"payment_providers,omitempty"`

	// TaxCode The tax code of the Region.
	TaxCode *string `json:"tax_code,omitempty"`

	// TaxProviderId The ID of the tax provider to use. If none provided, the system tax provider is used.
	TaxProviderId *string `json:"tax_provider_id,omitempty"`

	// TaxRate The tax rate to use in the Region.
	TaxRate *float32 `json:"tax_rate,omitempty"`
}

// AdminPostRegionsReq The details of the region to create.
type AdminPostRegionsReq struct {
	// Countries A list of countries' 2 ISO characters that should be included in the Region.
	Countries []string `json:"countries"`

	// CurrencyCode The 3 character ISO currency code to use in the Region.
	CurrencyCode string `json:"currency_code"`

	// FulfillmentProviders A list of Fulfillment Provider IDs that can be used in the Region
	FulfillmentProviders []string `json:"fulfillment_providers"`

	// IncludesTax Whether taxes are included in the prices of the region.
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Name The name of the Region
	Name string `json:"name"`

	// PaymentProviders A list of Payment Provider IDs that can be used in the Region
	PaymentProviders []string `json:"payment_providers"`

	// TaxCode The tax code of the Region.
	TaxCode *string `json:"tax_code,omitempty"`

	// TaxRate The tax rate to use in the Region.
	TaxRate float32 `json:"tax_rate"`
}

// AdminPostReservationsReq The details of the reservation to create.
type AdminPostReservationsReq struct {
	// Description The reservation's description.
	Description *string `json:"description,omitempty"`

	// InventoryItemId The ID of the inventory item the reservation is associated with.
	InventoryItemId string `json:"inventory_item_id"`

	// LineItemId The ID of the line item of the reservation.
	LineItemId *string `json:"line_item_id,omitempty"`

	// LocationId The ID of the location of the reservation.
	LocationId string `json:"location_id"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The quantity to reserve.
	Quantity float32 `json:"quantity"`
}

// AdminPostReservationsReservationReq The details to update of the reservation.
type AdminPostReservationsReservationReq struct {
	// Description The reservation's description.
	Description *string `json:"description,omitempty"`

	// LocationId The ID of the location associated with the reservation.
	LocationId *string `json:"location_id,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The quantity to reserve.
	Quantity *float32 `json:"quantity,omitempty"`
}

// AdminPostReturnReasonsReasonReq The details to update of the return reason.
type AdminPostReturnReasonsReasonReq struct {
	// Description The description of the Reason.
	Description *string `json:"description,omitempty"`

	// Label The label to display to the Customer.
	Label *string `json:"label,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Value A unique value of the return reason.
	Value *string `json:"value,omitempty"`
}

// AdminPostReturnReasonsReq The details of the return reason to create.
type AdminPostReturnReasonsReq struct {
	// Description The description of the Reason.
	Description *string `json:"description,omitempty"`

	// Label The label to display to the Customer.
	Label string `json:"label"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ParentReturnReasonId The ID of the parent return reason.
	ParentReturnReasonId *string `json:"parent_return_reason_id,omitempty"`

	// Value A unique value of the return reason.
	Value string `json:"value"`
}

// AdminPostReturnsReturnReceiveReq The details of the received return.
type AdminPostReturnsReturnReceiveReq struct {
	// Items The Line Items that have been received.
	Items []struct {
		// ItemId The ID of the Line Item.
		ItemId string `json:"item_id"`

		// Quantity The quantity of the Line Item.
		Quantity int `json:"quantity"`
	} `json:"items"`

	// LocationId The ID of the location to return items from.
	LocationId *string `json:"location_id,omitempty"`

	// Refund The amount to refund.
	Refund *float32 `json:"refund,omitempty"`
}

// AdminPostSalesChannelsChannelProductsBatchReq The details of the products to add to the sales channel.
type AdminPostSalesChannelsChannelProductsBatchReq struct {
	// ProductIds The IDs of the products to add to the sales channel
	ProductIds []struct {
		// Id The ID of the product
		Id string `json:"id"`
	} `json:"product_ids"`
}

// AdminPostSalesChannelsChannelStockLocationsReq defines model for AdminPostSalesChannelsChannelStockLocationsReq.
type AdminPostSalesChannelsChannelStockLocationsReq struct {
	// LocationId The ID of the stock location
	LocationId string `json:"location_id"`
}

// AdminPostSalesChannelsReq The details of the sales channel to create.
type AdminPostSalesChannelsReq struct {
	// Description The description of the Sales Channel
	Description *string `json:"description,omitempty"`

	// IsDisabled Whether the Sales Channel is disabled.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Name The name of the Sales Channel
	Name string `json:"name"`
}

// AdminPostSalesChannelsSalesChannelReq The details to update of the sales channel.
type AdminPostSalesChannelsSalesChannelReq struct {
	// Description The description of the sales channel.
	Description *string `json:"description,omitempty"`

	// IsDisabled Whether the Sales Channel is disabled.
	IsDisabled *bool `json:"is_disabled,omitempty"`

	// Name The name of the sales channel
	Name *string `json:"name,omitempty"`
}

// AdminPostShippingOptionsOptionReq The details to update of the shipping option.
type AdminPostShippingOptionsOptionReq struct {
	// AdminOnly If set to `true`, the shipping option can only be used when creating draft orders.
	AdminOnly *bool `json:"admin_only,omitempty"`

	// Amount The amount to charge for the Shipping Option. If the `price_type` of the shipping option is `calculated`, this amount will not actually be used.
	Amount *int `json:"amount,omitempty"`

	// IncludesTax Tax included in prices of shipping option
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the Shipping Option
	Name *string `json:"name,omitempty"`

	// Requirements The requirements that must be satisfied for the Shipping Option to be available.
	Requirements []struct {
		// Amount The amount to compare with.
		Amount int `json:"amount"`

		// Id The ID of an existing requirement. If an ID is passed, the existing requirement's details are updated. Otherwise, a new requirement is created.
		Id *string `json:"id,omitempty"`

		// Type The type of the requirement
		Type AdminPostShippingOptionsOptionReqRequirementsType `json:"type"`
	} `json:"requirements"`
}

// AdminPostShippingOptionsOptionReqRequirementsType The type of the requirement
type AdminPostShippingOptionsOptionReqRequirementsType string

// AdminPostShippingOptionsReq The details of the shipping option to create.
type AdminPostShippingOptionsReq struct {
	// AdminOnly If set to `true`, the shipping option can only be used when creating draft orders.
	AdminOnly *bool `json:"admin_only,omitempty"`

	// Amount The amount to charge for the Shipping Option. If the `price_type` is set to `calculated`, this amount will not actually be used.
	Amount *int `json:"amount,omitempty"`

	// Data The data needed for the Fulfillment Provider to handle shipping with this Shipping Option.
	Data map[string]interface{} `json:"data"`

	// IncludesTax Tax included in prices of shipping option
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// IsReturn Whether the Shipping Option can be used for returns or during checkout.
	IsReturn *bool `json:"is_return,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the Shipping Option
	Name string `json:"name"`

	// PriceType The type of the Shipping Option price. `flat_rate` indicates fixed pricing, whereas `calculated` indicates that the price will be calculated each time by the fulfillment provider.
	PriceType AdminPostShippingOptionsReqPriceType `json:"price_type"`

	// ProfileId The ID of the Shipping Profile to add the Shipping Option to.
	ProfileId *float32 `json:"profile_id,omitempty"`

	// ProviderId The ID of the Fulfillment Provider that handles the Shipping Option.
	ProviderId string `json:"provider_id"`

	// RegionId The ID of the Region in which the Shipping Option will be available.
	RegionId string `json:"region_id"`

	// Requirements The requirements that must be satisfied for the Shipping Option to be available.
	Requirements *[]struct {
		// Amount The amount to compare with.
		Amount int `json:"amount"`

		// Type The type of the requirement
		Type AdminPostShippingOptionsReqRequirementsType `json:"type"`
	} `json:"requirements,omitempty"`
}

// AdminPostShippingOptionsReqPriceType The type of the Shipping Option price. `flat_rate` indicates fixed pricing, whereas `calculated` indicates that the price will be calculated each time by the fulfillment provider.
type AdminPostShippingOptionsReqPriceType string

// AdminPostShippingOptionsReqRequirementsType The type of the requirement
type AdminPostShippingOptionsReqRequirementsType string

// AdminPostShippingProfilesProfileReq The detail to update of the shipping profile.
type AdminPostShippingProfilesProfileReq struct {
	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the Shipping Profile
	Name *string `json:"name,omitempty"`

	// Products product IDs to associate with the Shipping Profile
	Products *[]interface{} `json:"products,omitempty"`

	// ShippingOptions Shipping option IDs to associate with the Shipping Profile
	ShippingOptions *[]interface{} `json:"shipping_options,omitempty"`

	// Type The type of the Shipping Profile
	Type *string `json:"type,omitempty"`
}

// AdminPostShippingProfilesReq The details of the shipping profile to create.
type AdminPostShippingProfilesReq struct {
	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the Shipping Profile
	Name string `json:"name"`

	// Type The type of the Shipping Profile
	Type string `json:"type"`
}

// AdminPostStockLocationsLocationReq The details to update of the stock location.
type AdminPostStockLocationsLocationReq struct {
	// Address Represents a Stock Location Address Input
	Address *StockLocationAddressInput `json:"address,omitempty"`

	// AddressId the stock location address ID
	AddressId *string `json:"address_id,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name the name of the stock location
	Name *string `json:"name,omitempty"`
}

// AdminPostStockLocationsReq The details of the stock location to create.
type AdminPostStockLocationsReq struct {
	// Address Represents a Stock Location Address Input
	Address *StockLocationAddressInput `json:"address,omitempty"`

	// AddressId the ID of an existing stock location address to associate with the stock location. Only required if `address` is not provided.
	AddressId *string `json:"address_id,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name the name of the stock location
	Name string `json:"name"`
}

// AdminPostStockLocationsReqAddress defines model for AdminPostStockLocationsReqAddress.
type AdminPostStockLocationsReqAddress struct {
	// Address1 Stock location address
	Address1 string `json:"address_1"`

	// Address2 Stock location address' complement
	Address2 *string `json:"address_2,omitempty"`

	// City Stock location address' city
	City *string `json:"city,omitempty"`

	// Company Stock location address' company
	Company *string `json:"company,omitempty"`

	// CountryCode The two character ISO code for the country.
	CountryCode string `json:"country_code"`

	// Phone Stock location address' phone number
	Phone *string `json:"phone,omitempty"`

	// PostalCode Stock location address' postal code
	PostalCode *string `json:"postal_code,omitempty"`

	// Province Stock location address' province
	Province *string `json:"province,omitempty"`
}

// AdminPostStoreReq The details to update of the store.
type AdminPostStoreReq struct {
	// Currencies Array of available currencies in the store. Each currency is in 3 character ISO code format.
	Currencies *[]string `json:"currencies,omitempty"`

	// DefaultCurrencyCode The default currency code of the Store.
	DefaultCurrencyCode *string `json:"default_currency_code,omitempty"`

	// InviteLinkTemplate A template for invite links - use `{{invite_token}}` to insert the invite token
	InviteLinkTemplate *string `json:"invite_link_template,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the Store
	Name *string `json:"name,omitempty"`

	// PaymentLinkTemplate A template for payment links - use `{{cart_id}}` to insert the Cart ID
	PaymentLinkTemplate *string `json:"payment_link_template,omitempty"`

	// SwapLinkTemplate A template for Swap links - use `{{cart_id}}` to insert the Swap Cart ID
	SwapLinkTemplate *string `json:"swap_link_template,omitempty"`
}

// AdminPostTaxRatesReq The details of the tax rate to create.
type AdminPostTaxRatesReq struct {
	// Code The code of the tax rate.
	Code string `json:"code"`

	// Name The name of the tax rate.
	Name string `json:"name"`

	// ProductTypes The IDs of the types of products associated with this tax rate
	ProductTypes *[]string `json:"product_types,omitempty"`

	// Products The IDs of the products associated with this tax rate.
	Products *[]string `json:"products,omitempty"`

	// Rate The numeric rate to charge.
	Rate *float32 `json:"rate,omitempty"`

	// RegionId The ID of the Region that the tax rate belongs to.
	RegionId string `json:"region_id"`

	// ShippingOptions The IDs of the shipping options associated with this tax rate
	ShippingOptions *[]string `json:"shipping_options,omitempty"`
}

// AdminPostTaxRatesTaxRateProductTypesReq The product types to add to the tax rate.
type AdminPostTaxRatesTaxRateProductTypesReq struct {
	// ProductTypes The IDs of the types of products to associate with this tax rate
	ProductTypes []string `json:"product_types"`
}

// AdminPostTaxRatesTaxRateProductsReq The details of the products to associat with the tax rate.
type AdminPostTaxRatesTaxRateProductsReq struct {
	// Products The IDs of the products to associate with this tax rate
	Products []string `json:"products"`
}

// AdminPostTaxRatesTaxRateReq The details to update of the tax rate.
type AdminPostTaxRatesTaxRateReq struct {
	// Code The code of the tax rate.
	Code *string `json:"code,omitempty"`

	// Name The name of the tax rate.
	Name *string `json:"name,omitempty"`

	// ProductTypes The IDs of the types of product types associated with this tax rate
	ProductTypes *[]string `json:"product_types,omitempty"`

	// Products The IDs of the products associated with this tax rate
	Products *[]string `json:"products,omitempty"`

	// Rate The numeric rate to charge.
	Rate *float32 `json:"rate,omitempty"`

	// RegionId The ID of the Region that the tax rate belongs to.
	RegionId *string `json:"region_id,omitempty"`

	// ShippingOptions The IDs of the shipping options associated with this tax rate
	ShippingOptions *[]string `json:"shipping_options,omitempty"`
}

// AdminPostTaxRatesTaxRateShippingOptionsReq The details of the shipping options to associate with the tax rate.
type AdminPostTaxRatesTaxRateShippingOptionsReq struct {
	// ShippingOptions The IDs of the shipping options to associate with this tax rate
	ShippingOptions []string `json:"shipping_options"`
}

// AdminPostUploadsDownloadUrlReq The details of the file to retrieve its download URL.
type AdminPostUploadsDownloadUrlReq struct {
	// FileKey key of the file to obtain the download link for. This is obtained when you first uploaded the file, or by the file service if you used it directly.
	FileKey string `json:"file_key"`
}

// AdminPriceListDeleteBatchRes The details of deleting a price list.
type AdminPriceListDeleteBatchRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Ids The IDs of the deleted prices.
	Ids []string `json:"ids"`

	// Object The type of the object that was deleted. A price is also named `money-amount`.
	Object string `json:"object"`
}

// AdminPriceListDeleteProductPricesRes defines model for AdminPriceListDeleteProductPricesRes.
type AdminPriceListDeleteProductPricesRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Ids The IDs of the deleted prices.
	Ids []string `json:"ids"`

	// Object The type of the object that was deleted. A price is also named `money-amount`.
	Object string `json:"object"`
}

// AdminPriceListDeleteRes defines model for AdminPriceListDeleteRes.
type AdminPriceListDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Price List.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminPriceListDeleteVariantPricesRes defines model for AdminPriceListDeleteVariantPricesRes.
type AdminPriceListDeleteVariantPricesRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Ids The IDs of the deleted prices.
	Ids []string `json:"ids"`

	// Object The type of the object that was deleted. A price is also named `money-amount`.
	Object string `json:"object"`
}

// AdminPriceListRes The price list's details.
type AdminPriceListRes struct {
	// PriceList A Price List represents a set of prices that override the default price for one or more product variants.
	PriceList PriceList `json:"price_list"`
}

// AdminPriceListsListRes The list of price lists with pagination fields.
type AdminPriceListsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of price lists skipped when retrieving the price lists.
	Offset int `json:"offset"`

	// PriceLists An array of price lists details.
	PriceLists []PriceList `json:"price_lists"`
}

// AdminPriceListsProductsListRes The list of products with pagination fields.
type AdminPriceListsProductsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of price lists skipped when retrieving the price lists.
	Offset int `json:"offset"`

	// Products An array of products details.
	Products []Product `json:"products"`
}

// AdminProductCategoriesCategoryDeleteRes defines model for AdminProductCategoriesCategoryDeleteRes.
type AdminProductCategoriesCategoryDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted product category
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminProductCategoriesCategoryRes The product category's details.
type AdminProductCategoriesCategoryRes struct {
	// ProductCategory A product category can be used to categorize products into a hierarchy of categories.
	ProductCategory ProductCategory `json:"product_category"`
}

// AdminProductCategoriesListRes The list of product categories with pagination fields.
type AdminProductCategoriesListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of product categories skipped when retrieving the product categories.
	Offset int `json:"offset"`

	// ProductCategories An array of product category details.
	ProductCategories []ProductCategory `json:"product_categories"`
}

// AdminProductTagsListRes The list of product tags with pagination fields.
type AdminProductTagsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of product tags skipped when retrieving the product tags.
	Offset int `json:"offset"`

	// ProductTags An array of product tag details.
	ProductTags []ProductTag `json:"product_tags"`
}

// AdminProductTypesListRes The list of product types with pagination fields.
type AdminProductTypesListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of product types skipped when retrieving the product types.
	Offset int `json:"offset"`

	// ProductTypes An array of product types details.
	ProductTypes []ProductType `json:"product_types"`
}

// AdminProductsDeleteOptionRes The details of deleting a product's option.
type AdminProductsDeleteOptionRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`

	// OptionId The ID of the deleted Product Option
	OptionId string        `json:"option_id"`
	Product  PricedProduct `json:"product"`
}

// AdminProductsDeleteRes The details of deleting a product.
type AdminProductsDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Product.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminProductsDeleteVariantRes The details of deleting a product's variant.
type AdminProductsDeleteVariantRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Object The type of the object that was deleted.
	Object  string        `json:"object"`
	Product PricedProduct `json:"product"`

	// VariantId The ID of the deleted Product Variant.
	VariantId string `json:"variant_id"`
}

// AdminProductsListRes The list of products with pagination fields.
type AdminProductsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of products skipped when retrieving the products.
	Offset int `json:"offset"`

	// Products An array of products details.
	Products []PricedProduct `json:"products"`
}

// AdminProductsListTagsRes The usage details of product tags.
type AdminProductsListTagsRes struct {
	// Tags An array of product tags details.
	Tags []struct {
		// Id The ID of the tag.
		Id string `json:"id"`

		// UsageCount The number of products that use this tag.
		UsageCount string `json:"usage_count"`

		// Value The value of the tag.
		Value string `json:"value"`
	} `json:"tags"`
}

// AdminProductsListTypesRes defines model for AdminProductsListTypesRes.
type AdminProductsListTypesRes struct {
	// Types An array of product types details.
	Types []ProductType `json:"types"`
}

// AdminProductsListVariantsRes defines model for AdminProductsListVariantsRes.
type AdminProductsListVariantsRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of product variants skipped when retrieving the product variants.
	Offset int `json:"offset"`

	// Variants An array of product variants details.
	Variants []ProductVariant `json:"variants"`
}

// AdminProductsRes The product's details.
type AdminProductsRes struct {
	Product PricedProduct `json:"product"`
}

// AdminPublishableApiKeyDeleteRes defines model for AdminPublishableApiKeyDeleteRes.
type AdminPublishableApiKeyDeleteRes struct {
	// Deleted Whether the publishable API key was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted publishable API key.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminPublishableApiKeysListRes The list of publishable API keys with pagination fields.
type AdminPublishableApiKeysListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of publishable API keys skipped when retrieving the publishable API keys.
	Offset int `json:"offset"`

	// PublishableApiKeys An array of publishable API keys details.
	PublishableApiKeys []PublishableApiKey `json:"publishable_api_keys"`
}

// AdminPublishableApiKeysListSalesChannelsRes The list of sales channel.
type AdminPublishableApiKeysListSalesChannelsRes struct {
	// SalesChannels An array of sales channels details.
	SalesChannels []SalesChannel `json:"sales_channels"`
}

// AdminPublishableApiKeysRes The publishable API key's details.
type AdminPublishableApiKeysRes struct {
	// PublishableApiKey A Publishable API key defines scopes that resources are available in. Then, it can be used in request to infer the resources without having to directly pass them. For example, a publishable API key can be associated with one or more sales channels. Then, when the publishable API key is passed in the header of a request, it is inferred what sales channel is being used without having to pass the sales channel as a query or body parameter of the request. Publishable API keys can only be used with sales channels, at the moment.
	PublishableApiKey PublishableApiKey `json:"publishable_api_key"`
}

// AdminRefundRes The refund's details.
type AdminRefundRes struct {
	// Refund A refund represents an amount of money transfered back to the customer for a given reason. Refunds may occur in relation to Returns, Swaps and Claims, but can also be initiated by an admin for an order.
	Refund Refund `json:"refund"`
}

// AdminRegionsDeleteRes defines model for AdminRegionsDeleteRes.
type AdminRegionsDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Region.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminRegionsListRes The list of regions with pagination fields.
type AdminRegionsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of regions skipped when retrieving the regions.
	Offset int `json:"offset"`

	// Regions An array of regions details.
	Regions []Region `json:"regions"`
}

// AdminRegionsRes The region's details.
type AdminRegionsRes struct {
	// Region A region holds settings specific to a geographical location, including the currency, tax rates, and fulfillment and payment providers. A Region can consist of multiple countries to accomodate common shopping settings across countries.
	Region Region `json:"region"`
}

// AdminReservationsDeleteRes defines model for AdminReservationsDeleteRes.
type AdminReservationsDeleteRes struct {
	// Deleted Whether or not the Reservation was deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Reservation.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminReservationsListRes The list of reservations with pagination fields.
type AdminReservationsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of reservations skipped when retrieving the reservations.
	Offset int `json:"offset"`

	// Reservations An array of reservations details.
	Reservations []ExtendedReservationItem `json:"reservations"`
}

// AdminReservationsRes The reservation's details.
type AdminReservationsRes struct {
	// Reservation Represents a reservation of an inventory item at a stock location
	Reservation ReservationItemDTO `json:"reservation"`
}

// AdminResetPasswordRequest The details of the password reset request.
type AdminResetPasswordRequest struct {
	// Email The User's email.
	Email *openapi_types.Email `json:"email,omitempty"`

	// Password The User's new password.
	Password string `json:"password"`

	// Token The password-reset token generated when the password reset was requested.
	Token string `json:"token"`
}

// AdminResetPasswordTokenRequest The details of the password reset token request.
type AdminResetPasswordTokenRequest struct {
	// Email The User's email.
	Email openapi_types.Email `json:"email"`
}

// AdminReturnReasonsDeleteRes defines model for AdminReturnReasonsDeleteRes.
type AdminReturnReasonsDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted return reason
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminReturnReasonsListRes The list of return reasons.
type AdminReturnReasonsListRes struct {
	// ReturnReasons The list of return reasons.
	ReturnReasons []ReturnReason `json:"return_reasons"`
}

// AdminReturnReasonsRes The return reason's details.
type AdminReturnReasonsRes struct {
	// ReturnReason A Return Reason is a value defined by an admin. It can be used on Return Items in order to indicate why a Line Item was returned.
	ReturnReason ReturnReason `json:"return_reason"`
}

// AdminReturnsCancelRes The associated order's details.
type AdminReturnsCancelRes struct {
	// Order An order is a purchase made by a customer. It holds details about payment and fulfillment of the order. An order may also be created from a draft order, which is created by an admin user.
	Order Order `json:"order"`
}

// AdminReturnsListRes The list of returns with pagination fields.
type AdminReturnsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of returns skipped when retrieving the returns.
	Offset int `json:"offset"`

	// Returns An array of returns details.
	Returns []Return `json:"returns"`
}

// AdminReturnsRes The return's details.
type AdminReturnsRes struct {
	// Return A Return holds information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can also be used as part of a Swap or a Claim.
	Return Return `json:"return"`
}

// AdminSalesChannelsDeleteLocationRes defines model for AdminSalesChannelsDeleteLocationRes.
type AdminSalesChannelsDeleteLocationRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the removed stock location from a sales channel
	Id string `json:"id"`

	// Object The type of the object that was removed.
	Object string `json:"object"`
}

// AdminSalesChannelsDeleteRes defines model for AdminSalesChannelsDeleteRes.
type AdminSalesChannelsDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted sales channel
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminSalesChannelsListRes The list of sales channels with pagination fields.
type AdminSalesChannelsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of items skipped before the returned results
	Offset int `json:"offset"`

	// SalesChannels An array of sales channels details.
	SalesChannels []SalesChannel `json:"sales_channels"`
}

// AdminSalesChannelsRes The sales channel's details.
type AdminSalesChannelsRes struct {
	// SalesChannel A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
	SalesChannel SalesChannel `json:"sales_channel"`
}

// AdminShippingOptionsDeleteRes defines model for AdminShippingOptionsDeleteRes.
type AdminShippingOptionsDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Shipping Option.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminShippingOptionsListRes The list of shipping options with pagination fields.
type AdminShippingOptionsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of shipping options skipped when retrieving the shipping options.
	Offset int `json:"offset"`

	// ShippingOptions An array of shipping options details.
	ShippingOptions []ShippingOption `json:"shipping_options"`
}

// AdminShippingOptionsRes The shipping option's details.
type AdminShippingOptionsRes struct {
	// ShippingOption A Shipping Option represents a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
	ShippingOption ShippingOption `json:"shipping_option"`
}

// AdminShippingProfilesListRes The list of shipping profiles.
type AdminShippingProfilesListRes struct {
	// ShippingProfiles An array of shipping profiles details.
	ShippingProfiles []ShippingProfile `json:"shipping_profiles"`
}

// AdminShippingProfilesRes The shipping profile's details.
type AdminShippingProfilesRes struct {
	// ShippingProfile A Shipping Profile has a set of defined Shipping Options that can be used to fulfill a given set of Products. For example, gift cards are shipped differently than physical products, so a shipping profile with the type `gift_card` groups together the shipping options that can only be used for gift cards.
	ShippingProfile ShippingProfile `json:"shipping_profile"`
}

// AdminStockLocationsDeleteRes defines model for AdminStockLocationsDeleteRes.
type AdminStockLocationsDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Stock Location.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminStockLocationsListRes The list of stock locations with pagination fields.
type AdminStockLocationsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of stock locations skipped when retrieving the stock locations.
	Offset int `json:"offset"`

	// StockLocations The list of stock locations.
	StockLocations []StockLocationExpandedDTO `json:"stock_locations"`
}

// AdminStockLocationsRes The stock location's details.
type AdminStockLocationsRes struct {
	StockLocation StockLocationExpandedDTO `json:"stock_location"`
}

// AdminStoresRes The store's details.
type AdminStoresRes struct {
	// Store A store holds the main settings of the commerce shop. By default, only one store is created and used within the Medusa backend. It holds settings related to the name of the store, available currencies, and more.
	Store Store `json:"store"`
}

// AdminSwapsListRes The list of swaps with pagination fields.
type AdminSwapsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of swaps skipped when retrieving the swaps.
	Offset int `json:"offset"`

	// Swaps An array of swaps details.
	Swaps []Swap `json:"swaps"`
}

// AdminSwapsRes The swap's details.
type AdminSwapsRes struct {
	// Swap A swap can be created when a Customer wishes to exchange Products that they have purchased with different Products. It consists of a Return of previously purchased Products and a Fulfillment of new Products. It also includes information on any additional payment or refund required based on the difference between the exchanged products.
	Swap Swap `json:"swap"`
}

// AdminTaxProvidersList The list of tax providers in a store.
type AdminTaxProvidersList struct {
	// TaxProviders An array of tax providers details.
	TaxProviders []TaxProvider `json:"tax_providers"`
}

// AdminTaxRatesDeleteRes defines model for AdminTaxRatesDeleteRes.
type AdminTaxRatesDeleteRes struct {
	// Deleted Whether or not the items were deleted.
	Deleted bool `json:"deleted"`

	// Id The ID of the deleted Shipping Option.
	Id string `json:"id"`

	// Object The type of the object that was deleted.
	Object string `json:"object"`
}

// AdminTaxRatesListRes The list of tax rates with pagination fields.
type AdminTaxRatesListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of tax rates to skip when retrieving the tax rates.
	Offset int `json:"offset"`

	// TaxRates An array of tax rate details.
	TaxRates []TaxRate `json:"tax_rates"`
}

// AdminTaxRatesRes The tax rate's details.
type AdminTaxRatesRes struct {
	// TaxRate A Tax Rate can be used to define a custom rate to charge on specified products, product types, and shipping options within a given region.
	TaxRate TaxRate `json:"tax_rate"`
}

// AdminUpdatePaymentCollectionsReq The details to update of the payment collection.
type AdminUpdatePaymentCollectionsReq struct {
	// Description A description to create or update the payment collection.
	Description *string `json:"description,omitempty"`

	// Metadata A set of key-value pairs to hold additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// AdminUpdateUserRequest defines model for AdminUpdateUserRequest.
type AdminUpdateUserRequest struct {
	// ApiToken The API token of the User.
	ApiToken *string `json:"api_token,omitempty"`

	// FirstName The first name of the User.
	FirstName *string `json:"first_name,omitempty"`

	// LastName The last name of the User.
	LastName *string `json:"last_name,omitempty"`

	// Metadata An optional set of key-value pairs with additional information.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Role The role assigned to the user. These roles don't provide any different privileges.
	Role *AdminUpdateUserRequestRole `json:"role,omitempty"`
}

// AdminUpdateUserRequestRole The role assigned to the user. These roles don't provide any different privileges.
type AdminUpdateUserRequestRole string

// AdminUploadsDownloadUrlRes The download URL details.
type AdminUploadsDownloadUrlRes struct {
	// DownloadUrl The Download URL of the file
	DownloadUrl string `json:"download_url"`
}

// AdminUploadsRes The list of uploaded files.
type AdminUploadsRes struct {
	// Uploads Uploaded files details.
	Uploads []struct {
		// Key The key of the file that is identifiable by the file service. It can be used later to retrieve or manipulate the file.
		Key string `json:"key"`

		// Url The URL of the uploaded file.
		Url string `json:"url"`
	} `json:"uploads"`
}

// AdminUserRes The user's details.
type AdminUserRes struct {
	// User A User is an administrator who can manage store settings and data.
	User User `json:"user"`
}

// AdminUsersListRes The list of users.
type AdminUsersListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of users skipped when retrieving the users.
	Offset int `json:"offset"`

	// Users An array of users details.
	Users []User `json:"users"`
}

// AdminVariantsListRes The list of variants with pagination fields.
type AdminVariantsListRes struct {
	// Count The total number of items available
	Count int `json:"count"`

	// Limit The number of items per page
	Limit int `json:"limit"`

	// Offset The number of product variants skipped when retrieving the product variants.
	Offset int `json:"offset"`

	// Variants An array of product variant details.
	Variants []PricedVariant `json:"variants"`
}

// AdminVariantsRes The product variant's details.
type AdminVariantsRes struct {
	Variant PricedVariant `json:"variant"`
}

// BatchJob A Batch Job indicates an asynchronus task stored in the Medusa backend. Its status determines whether it has been executed or not.
type BatchJob struct {
	// CanceledAt The date of the concellation.
	CanceledAt *time.Time `json:"canceled_at"`

	// CompletedAt The date of the completion.
	CompletedAt *time.Time `json:"completed_at"`

	// ConfirmedAt The date when the confirmation has been done.
	ConfirmedAt *time.Time `json:"confirmed_at"`

	// Context The context of the batch job, the type of the batch job determines what the context should contain.
	Context *map[string]interface{} `json:"context"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The unique identifier of the user that created the batch job.
	CreatedBy *string `json:"created_by"`

	// CreatedByUser A User is an administrator who can manage store settings and data.
	CreatedByUser *User `json:"created_by_user,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// DryRun Specify if the job must apply the modifications or not.
	DryRun bool `json:"dry_run"`

	// FailedAt The date when the job failed.
	FailedAt *time.Time `json:"failed_at"`

	// Id The unique identifier for the batch job.
	Id string `json:"id"`

	// PreProcessedAt The date from which the job has been pre-processed.
	PreProcessedAt *time.Time `json:"pre_processed_at"`

	// ProcessingAt The date the job is processing at.
	ProcessingAt *time.Time `json:"processing_at"`

	// Result The result of the batch job.
	Result *struct {
		AdvancementCount *float32 `json:"advancement_count,omitempty"`
		Count            *float32 `json:"count,omitempty"`
		Errors           *struct {
			Code    *BatchJob_Result_Errors_Code `json:"code,omitempty"`
			Err     *[]interface{}               `json:"err,omitempty"`
			Message *string                      `json:"message,omitempty"`
		} `json:"errors,omitempty"`
		FileKey         *string  `json:"file_key,omitempty"`
		FileSize        *float32 `json:"file_size,omitempty"`
		Progress        *float32 `json:"progress,omitempty"`
		StatDescriptors *struct {
			Key     *string `json:"key,omitempty"`
			Message *string `json:"message,omitempty"`
			Name    *string `json:"name,omitempty"`
		} `json:"stat_descriptors,omitempty"`
	} `json:"result"`

	// Status The status of the batch job.
	Status BatchJobStatus `json:"status"`

	// Type The type of batch job.
	Type BatchJobType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// BatchJobResultErrorsCode0 defines model for .
type BatchJobResultErrorsCode0 = string

// BatchJobResultErrorsCode1 defines model for .
type BatchJobResultErrorsCode1 = float32

// BatchJob_Result_Errors_Code defines model for BatchJob.Result.Errors.Code.
type BatchJob_Result_Errors_Code struct {
	union json.RawMessage
}

// BatchJobStatus The status of the batch job.
type BatchJobStatus string

// BatchJobType The type of batch job.
type BatchJobType string

// Cart A cart represents a virtual shopping bag. It can be used to complete an order, a swap, or a claim.
type Cart struct {
	// BillingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// BillingAddressId The billing address's ID
	BillingAddressId *string `json:"billing_address_id"`

	// CompletedAt The date with timezone at which the cart was completed.
	CompletedAt *time.Time `json:"completed_at"`

	// Context The context of the cart which can include info like IP or user agent.
	Context *map[string]interface{} `json:"context"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Customer The details of the customer the cart belongs to.
	Customer *map[string]interface{} `json:"customer"`

	// CustomerId The customer's ID
	CustomerId *string `json:"customer_id"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// DiscountTotal The total of discount rounded
	DiscountTotal *int `json:"discount_total,omitempty"`

	// Discounts An array of details of all discounts applied to the cart.
	Discounts *[]Discount `json:"discounts,omitempty"`

	// Email The email associated with the cart
	Email *openapi_types.Email `json:"email"`

	// GiftCardTaxTotal The total of gift cards with taxes
	GiftCardTaxTotal *int `json:"gift_card_tax_total,omitempty"`

	// GiftCardTotal The total of gift cards
	GiftCardTotal *int `json:"gift_card_total,omitempty"`

	// GiftCards An array of details of all gift cards applied to the cart.
	GiftCards *[]GiftCard `json:"gift_cards,omitempty"`

	// Id The cart's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of a cart in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// ItemTaxTotal The total of items with taxes
	ItemTaxTotal *int `json:"item_tax_total,omitempty"`

	// Items The line items added to the cart.
	Items *[]LineItem `json:"items,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Payment The details of the payment associated with the cart.
	Payment *map[string]interface{} `json:"payment"`

	// PaymentAuthorizedAt The date with timezone at which the payment was authorized.
	PaymentAuthorizedAt *time.Time `json:"payment_authorized_at"`

	// PaymentId The payment's ID if available
	PaymentId *string `json:"payment_id"`

	// PaymentSession The details of the selected payment session in the cart.
	PaymentSession *map[string]interface{} `json:"payment_session"`

	// PaymentSessions The details of all payment sessions created on the cart.
	PaymentSessions *[]map[string]interface{} `json:"payment_sessions,omitempty"`

	// RawDiscountTotal The total of discount
	RawDiscountTotal *int `json:"raw_discount_total,omitempty"`

	// RefundableAmount The amount that can be refunded
	RefundableAmount *int `json:"refundable_amount,omitempty"`

	// RefundedTotal The total amount refunded if the order associated with this cart is returned.
	RefundedTotal *int `json:"refunded_total,omitempty"`

	// Region A region holds settings specific to a geographical location, including the currency, tax rates, and fulfillment and payment providers. A Region can consist of multiple countries to accomodate common shopping settings across countries.
	Region *Region `json:"region,omitempty"`

	// RegionId The region's ID
	RegionId string `json:"region_id"`

	// SalesChannel A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
	SalesChannel *SalesChannel `json:"sales_channel,omitempty"`

	// SalesChannelId The sales channel ID the cart is associated with.
	SalesChannelId *string `json:"sales_channel_id"`

	// SalesChannels The associated sales channels.
	SalesChannels *[]SalesChannel `json:"sales_channels"`

	// ShippingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// ShippingAddressId The shipping address's ID
	ShippingAddressId *string `json:"shipping_address_id"`

	// ShippingMethods The details of the shipping methods added to the cart.
	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

	// ShippingTaxTotal The total of shipping with taxes
	ShippingTaxTotal *int `json:"shipping_tax_total,omitempty"`

	// ShippingTotal The total of shipping
	ShippingTotal *int `json:"shipping_total,omitempty"`

	// Subtotal The subtotal of the cart
	Subtotal *int `json:"subtotal,omitempty"`

	// TaxTotal The total of tax
	TaxTotal *int `json:"tax_total,omitempty"`

	// Total The total amount of the cart
	Total *int `json:"total,omitempty"`

	// Type The cart's type.
	Type CartType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// CartType The cart's type.
type CartType string

// ClaimImage The details of an image attached to a claim.
type ClaimImage struct {
	// ClaimItem The details of the claim item this image is associated with.
	ClaimItem *map[string]interface{} `json:"claim_item"`

	// ClaimItemId The ID of the claim item associated with the image
	ClaimItemId string `json:"claim_item_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The claim image's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Url The URL of the image
	Url string `json:"url"`
}

// ClaimItem A claim item is an item created as part of a claim. It references an item in the order that should be exchanged or refunded.
type ClaimItem struct {
	// ClaimOrder The details of the claim this item belongs to.
	ClaimOrder *map[string]interface{} `json:"claim_order"`

	// ClaimOrderId The ID of the claim this item is associated with.
	ClaimOrderId string `json:"claim_order_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The claim item's ID
	Id string `json:"id"`

	// Images The claim images that are attached to the claim item.
	Images *[]ClaimImage `json:"images,omitempty"`

	// Item Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
	Item *LineItem `json:"item,omitempty"`

	// ItemId The ID of the line item that the claim item refers to.
	ItemId string `json:"item_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Note An optional note about the claim, for additional information
	Note *string `json:"note"`

	// Quantity The quantity of the item that is being claimed; must be less than or equal to the amount purchased in the original order.
	Quantity int `json:"quantity"`

	// Reason The reason for the claim
	Reason ClaimItemReason `json:"reason"`

	// Tags User defined tags for easy filtering and grouping.
	Tags *[]ClaimTag `json:"tags,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variant A Product Variant represents a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations. A product must at least have one product variant.
	Variant *ProductVariant `json:"variant,omitempty"`

	// VariantId The ID of the product variant that is claimed.
	VariantId string `json:"variant_id"`
}

// ClaimItemReason The reason for the claim
type ClaimItemReason string

// ClaimOrder A Claim represents a group of faulty or missing items. It consists of claim items that refer to items in the original order that should be replaced or refunded. It also includes details related to shipping and fulfillment.
type ClaimOrder struct {
	// AdditionalItems The details of the new items to be shipped when the claim's type is `replace`
	AdditionalItems *[]LineItem `json:"additional_items,omitempty"`

	// CanceledAt The date with timezone at which the claim was canceled.
	CanceledAt *time.Time `json:"canceled_at"`

	// ClaimItems The details of the items that should be replaced or refunded.
	ClaimItems *[]ClaimItem `json:"claim_items,omitempty"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// FulfillmentStatus The claim's fulfillment status
	FulfillmentStatus ClaimOrderFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The fulfillments of the new items to be shipped
	Fulfillments *[]map[string]interface{} `json:"fulfillments,omitempty"`

	// Id The claim's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of the cart associated with the claim in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// NoNotification Flag for describing whether or not notifications related to this should be send.
	NoNotification *bool `json:"no_notification"`

	// Order The details of the order that this claim was created for.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the claim comes from.
	OrderId string `json:"order_id"`

	// PaymentStatus The status of the claim's payment
	PaymentStatus ClaimOrderPaymentStatus `json:"payment_status"`

	// RefundAmount The amount that will be refunded in conjunction with the claim
	RefundAmount *int `json:"refund_amount"`

	// ReturnOrder The details of the return associated with the claim if the claim's type is `replace`.
	ReturnOrder *map[string]interface{} `json:"return_order"`

	// ShippingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// ShippingAddressId The ID of the address that the new items should be shipped to
	ShippingAddressId *string `json:"shipping_address_id"`

	// ShippingMethods The details of the shipping methods that the claim order will be shipped with.
	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

	// Type The claim's type
	Type ClaimOrderType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ClaimOrderFulfillmentStatus The claim's fulfillment status
type ClaimOrderFulfillmentStatus string

// ClaimOrderPaymentStatus The status of the claim's payment
type ClaimOrderPaymentStatus string

// ClaimOrderType The claim's type
type ClaimOrderType string

// ClaimTag Claim Tags are user defined tags that can be assigned to claim items for easy filtering and grouping.
type ClaimTag struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The claim tag's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value that the claim tag holds
	Value string `json:"value"`
}

// Country Country details
type Country struct {
	// DisplayName The country name appropriate for display.
	DisplayName string `json:"display_name"`

	// Id The country's ID
	Id int `json:"id"`

	// Iso2 The 2 character ISO code of the country in lower case
	Iso2 string `json:"iso_2"`

	// Iso3 The 2 character ISO code of the country in lower case
	Iso3 string `json:"iso_3"`

	// Name The normalized country name in upper case.
	Name string `json:"name"`

	// NumCode The numerical ISO code for the country.
	NumCode int `json:"num_code"`

	// Region The details of the region the country is associated with.
	Region *map[string]interface{} `json:"region"`

	// RegionId The region ID this country is associated with.
	RegionId *string `json:"region_id"`
}

// CreateStockLocationInput Represents the Input to create a Stock Location
type CreateStockLocationInput struct {
	// Address Stock location address object
	Address *struct {
		// Address1 Stock location address
		Address1 string `json:"address_1"`

		// Address2 Stock location address' complement
		Address2 *string `json:"address_2,omitempty"`

		// City Stock location address' city
		City *string `json:"city,omitempty"`

		// CountryCode Stock location address' country
		CountryCode string `json:"country_code"`

		// Metadata An optional key-value map with additional details
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Phone Stock location address' phone number
		Phone *string `json:"phone,omitempty"`

		// PostalCode Stock location address' postal code
		PostalCode *string `json:"postal_code,omitempty"`

		// Province Stock location address' province
		Province *string `json:"province,omitempty"`
	} `json:"address,omitempty"`

	// AddressId The Stock location address ID
	AddressId *string `json:"address_id,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The stock location name
	Name string `json:"name"`
}

// Currency Currency
type Currency struct {
	// Code The 3 character ISO code for the currency.
	Code string `json:"code"`

	// IncludesTax Whether the currency prices include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Name The written name of the currency
	Name string `json:"name"`

	// Symbol The symbol used to indicate the currency.
	Symbol string `json:"symbol"`

	// SymbolNative The native symbol used to indicate the currency.
	SymbolNative string `json:"symbol_native"`
}

// CustomShippingOption Custom Shipping Options are overridden Shipping Options. Admins can attach a Custom Shipping Option to a cart in order to set a custom price for a particular Shipping Option.
type CustomShippingOption struct {
	// Cart A cart represents a virtual shopping bag. It can be used to complete an order, a swap, or a claim.
	Cart *Cart `json:"cart,omitempty"`

	// CartId The ID of the Cart that the custom shipping option is attached to
	CartId *string `json:"cart_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The custom shipping option's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Price The custom price set that will override the shipping option's original price
	Price int `json:"price"`

	// ShippingOption A Shipping Option represents a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

	// ShippingOptionId The ID of the Shipping Option that the custom shipping option overrides
	ShippingOptionId string `json:"shipping_option_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// Customer A customer can make purchases in your store and manage their profile.
type Customer struct {
	// BillingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// BillingAddressId The customer's billing address ID
	BillingAddressId *string `json:"billing_address_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Email The customer's email
	Email openapi_types.Email `json:"email"`

	// FirstName The customer's first name
	FirstName *string `json:"first_name"`

	// Groups The customer groups the customer belongs to.
	Groups *[]CustomerGroup `json:"groups,omitempty"`

	// HasAccount Whether the customer has an account or not
	HasAccount bool `json:"has_account"`

	// Id The customer's ID
	Id string `json:"id"`

	// LastName The customer's last name
	LastName *string `json:"last_name"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Orders The details of the orders this customer placed.
	Orders *[]map[string]interface{} `json:"orders,omitempty"`

	// Phone The customer's phone number
	Phone *string `json:"phone"`

	// ShippingAddresses The details of the shipping addresses associated with the customer.
	ShippingAddresses *[]Address `json:"shipping_addresses,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// CustomerGroup A customer group that can be used to organize customers into groups of similar traits.
type CustomerGroup struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Customers The details of the customers that belong to the customer group.
	Customers *[]map[string]interface{} `json:"customers,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The customer group's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the customer group
	Name string `json:"name"`

	// PriceLists The price lists that are associated with the customer group.
	PriceLists *[]map[string]interface{} `json:"price_lists,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DecoratedInventoryItemDTO defines model for DecoratedInventoryItemDTO.
type DecoratedInventoryItemDTO struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Description Description of the inventory item
	Description *string `json:"description,omitempty"`

	// Height The height of the Inventory Item. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// Id The inventory item's ID.
	Id *string `json:"id,omitempty"`

	// Length The length of the Inventory Item. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// LocationLevels An array of location level details
	LocationLevels *[]InventoryLevelDTO `json:"location_levels,omitempty"`

	// Material The material and composition that the Inventory Item is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The country in which the Inventory Item was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping *bool `json:"requires_shipping,omitempty"`

	// ReservedQuantity The total quantity of the item available across levels
	ReservedQuantity float32 `json:"reserved_quantity"`

	// Sku The Stock Keeping Unit (SKU) code of the Inventory Item.
	Sku string `json:"sku"`

	// StockedQuantity The total quantity of the item in stock across levels
	StockedQuantity float32 `json:"stocked_quantity"`

	// Thumbnail Thumbnail for the inventory item
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title Title of the inventory item
	Title *string `json:"title,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Variants An array of product variant details
	Variants *[]ProductVariant `json:"variants,omitempty"`

	// Weight The weight of the Inventory Item. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Inventory Item. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// Discount A discount can be applied to a cart for promotional purposes.
type Discount struct {
	// Code A unique code for the discount - this will be used by the customer to apply the discount
	Code string `json:"code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// EndsAt The time at which the discount can no longer be used.
	EndsAt *time.Time `json:"ends_at"`

	// Id The discount's ID
	Id string `json:"id"`

	// IsDisabled Whether the Discount has been disabled. Disabled discounts cannot be applied to carts
	IsDisabled bool `json:"is_disabled"`

	// IsDynamic A flag to indicate if multiple instances of the discount can be generated. I.e. for newsletter discounts
	IsDynamic bool `json:"is_dynamic"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ParentDiscount The details of the parent discount that this discount was created from.
	ParentDiscount *map[string]interface{} `json:"parent_discount"`

	// ParentDiscountId The Discount that the discount was created from. This will always be a dynamic discount
	ParentDiscountId *string `json:"parent_discount_id"`

	// Regions The details of the regions in which the Discount can be used.
	Regions *[]Region `json:"regions,omitempty"`

	// Rule A discount rule defines how a Discount is calculated when applied to a Cart.
	Rule *DiscountRule `json:"rule,omitempty"`

	// RuleId The ID of the discount rule that defines how the discount will be applied to a cart.
	RuleId *string `json:"rule_id"`

	// StartsAt The time at which the discount can be used.
	StartsAt time.Time `json:"starts_at"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// UsageCount The number of times a discount has been used.
	UsageCount int `json:"usage_count"`

	// UsageLimit The maximum number of times that a discount can be used.
	UsageLimit *int `json:"usage_limit"`

	// ValidDuration Duration the discount runs between
	ValidDuration *string `json:"valid_duration"`
}

// DiscountCondition Holds rule conditions for when a discount is applicable
type DiscountCondition struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerGroups Customer groups associated with this condition if `type` is `customer_groups`.
	CustomerGroups *[]CustomerGroup `json:"customer_groups,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// DiscountRule A discount rule defines how a Discount is calculated when applied to a Cart.
	DiscountRule *DiscountRule `json:"discount_rule,omitempty"`

	// DiscountRuleId The ID of the discount rule associated with the condition
	DiscountRuleId string `json:"discount_rule_id"`

	// Id The discount condition's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Operator The operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
	Operator DiscountConditionOperator `json:"operator"`

	// ProductCollections Product collections associated with this condition if `type` is `product_collections`.
	ProductCollections *[]ProductCollection `json:"product_collections,omitempty"`

	// ProductTags Product tags associated with this condition if `type` is `product_tags`.
	ProductTags *[]ProductTag `json:"product_tags,omitempty"`

	// ProductTypes Product types associated with this condition if `type` is `product_types`.
	ProductTypes *[]ProductType `json:"product_types,omitempty"`

	// Products products associated with this condition if `type` is `products`.
	Products *[]Product `json:"products,omitempty"`

	// Type The type of the condition. The type affects the available resources associated with the condition. For example, if the type is `products`, that means the `products` relation will hold the products associated with this condition and other relations will be empty.
	Type DiscountConditionType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DiscountConditionOperator The operator of the condition. `in` indicates that discountable resources are within the specified resources. `not_in` indicates that discountable resources are everything but the specified resources.
type DiscountConditionOperator string

// DiscountConditionType The type of the condition. The type affects the available resources associated with the condition. For example, if the type is `products`, that means the `products` relation will hold the products associated with this condition and other relations will be empty.
type DiscountConditionType string

// DiscountConditionCustomerGroup Associates a discount condition with a customer group
type DiscountConditionCustomerGroup struct {
	// ConditionId The ID of the Discount Condition
	ConditionId string `json:"condition_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerGroup A customer group that can be used to organize customers into groups of similar traits.
	CustomerGroup *CustomerGroup `json:"customer_group,omitempty"`

	// CustomerGroupId The ID of the Product Tag
	CustomerGroupId string `json:"customer_group_id"`

	// DiscountCondition Holds rule conditions for when a discount is applicable
	DiscountCondition *DiscountCondition `json:"discount_condition,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DiscountConditionProduct This represents the association between a discount condition and a product
type DiscountConditionProduct struct {
	// ConditionId The ID of the Discount Condition
	ConditionId string `json:"condition_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DiscountCondition Holds rule conditions for when a discount is applicable
	DiscountCondition *DiscountCondition `json:"discount_condition,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Product A product is a saleable item that holds general information such as name or description. It must include at least one Product Variant, where each product variant defines different options to purchase the product with (for example, different sizes or colors). The prices and inventory of the product are defined on the variant level.
	Product *Product `json:"product,omitempty"`

	// ProductId The ID of the Product Tag
	ProductId string `json:"product_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DiscountConditionProductCollection This represents the association between a discount condition and a product collection
type DiscountConditionProductCollection struct {
	// ConditionId The ID of the Discount Condition
	ConditionId string `json:"condition_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DiscountCondition Holds rule conditions for when a discount is applicable
	DiscountCondition *DiscountCondition `json:"discount_condition,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ProductCollection A Product Collection allows grouping together products for promotional purposes. For example, an admin can create a Summer collection, add products to it, and showcase it on the storefront.
	ProductCollection *ProductCollection `json:"product_collection,omitempty"`

	// ProductCollectionId The ID of the Product Collection
	ProductCollectionId string `json:"product_collection_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DiscountConditionProductTag This represents the association between a discount condition and a product tag
type DiscountConditionProductTag struct {
	// ConditionId The ID of the Discount Condition
	ConditionId string `json:"condition_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DiscountCondition Holds rule conditions for when a discount is applicable
	DiscountCondition *DiscountCondition `json:"discount_condition,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ProductTag A Product Tag can be added to Products for easy filtering and grouping.
	ProductTag *ProductTag `json:"product_tag,omitempty"`

	// ProductTagId The ID of the Product Tag
	ProductTagId string `json:"product_tag_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DiscountConditionProductType This represents the association between a discount condition and a product type
type DiscountConditionProductType struct {
	// ConditionId The ID of the Discount Condition
	ConditionId string `json:"condition_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DiscountCondition Holds rule conditions for when a discount is applicable
	DiscountCondition *DiscountCondition `json:"discount_condition,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ProductType A Product Type can be added to Products for filtering and reporting purposes.
	ProductType *ProductType `json:"product_type,omitempty"`

	// ProductTypeId The ID of the Product Tag
	ProductTypeId string `json:"product_type_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DiscountRule A discount rule defines how a Discount is calculated when applied to a Cart.
type DiscountRule struct {
	// Allocation The scope that the discount should apply to.
	Allocation *DiscountRuleAllocation `json:"allocation"`

	// Conditions The details of the discount conditions associated with the rule. They can be used to limit when the discount can be used.
	Conditions *[]map[string]interface{} `json:"conditions,omitempty"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description A short description of the discount
	Description *string `json:"description"`

	// Id The discount rule's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Type The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
	Type DiscountRuleType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value that the discount represents; this will depend on the type of the discount
	Value int `json:"value"`
}

// DiscountRuleAllocation The scope that the discount should apply to.
type DiscountRuleAllocation string

// DiscountRuleType The type of the Discount, can be `fixed` for discounts that reduce the price by a fixed amount, `percentage` for percentage reductions or `free_shipping` for shipping vouchers.
type DiscountRuleType string

// DraftOrder A draft order is created by an admin without direct involvement of the customer. Once its payment is marked as captured, it is transformed into an order.
type DraftOrder struct {
	// CanceledAt The date the draft order was canceled at.
	CanceledAt *time.Time `json:"canceled_at"`

	// Cart The details of the cart associated with the draft order.
	Cart *map[string]interface{} `json:"cart"`

	// CartId The ID of the cart associated with the draft order.
	CartId *string `json:"cart_id"`

	// CompletedAt The date the draft order was completed at.
	CompletedAt *time.Time `json:"completed_at"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DisplayId The draft order's display ID
	DisplayId string `json:"display_id"`

	// Id The draft order's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of the cart associated with the draft order in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// NoNotificationOrder Whether to send the customer notifications regarding order updates.
	NoNotificationOrder *bool `json:"no_notification_order"`

	// Order The details of the order created from the draft order when its payment is captured.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order created from the draft order when its payment is captured.
	OrderId *string `json:"order_id"`

	// Status The status of the draft order. It's changed to `completed` when it's transformed to an order.
	Status DraftOrderStatus `json:"status"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// DraftOrderStatus The status of the draft order. It's changed to `completed` when it's transformed to an order.
type DraftOrderStatus string

// Error defines model for Error.
type Error struct {
	// Code A slug code to indicate the type of the error.
	Code *ErrorCode `json:"code,omitempty"`

	// Message Description of the error that occurred.
	Message *string `json:"message,omitempty"`

	// Type A slug indicating the type of the error.
	Type *ErrorType `json:"type,omitempty"`
}

// ErrorCode A slug code to indicate the type of the error.
type ErrorCode string

// ErrorType A slug indicating the type of the error.
type ErrorType string

// ExtendedReservationItem defines model for ExtendedReservationItem.
type ExtendedReservationItem struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatedBy UserId of user who created the reservation item
	CreatedBy *string `json:"created_by,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Description Description of the reservation item
	Description *string `json:"description,omitempty"`

	// Id The id of the reservation item
	Id            string            `json:"id"`
	InventoryItem *InventoryItemDTO `json:"inventory_item,omitempty"`

	// InventoryItemId The id of the inventory item the reservation relates to
	InventoryItemId string `json:"inventory_item_id"`

	// LineItem Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
	LineItem *LineItem `json:"line_item,omitempty"`

	// LocationId The id of the location of the reservation
	LocationId string `json:"location_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The id of the reservation item
	Quantity float32 `json:"quantity"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ExtendedStoreDTO defines model for ExtendedStoreDTO.
type ExtendedStoreDTO struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Currencies The details of the enabled currencies in the store.
	Currencies *[]Currency `json:"currencies,omitempty"`

	// DefaultCurrency Currency
	DefaultCurrency *Currency `json:"default_currency,omitempty"`

	// DefaultCurrencyCode The three character currency code that is the default of the store.
	DefaultCurrencyCode string `json:"default_currency_code"`

	// DefaultLocationId The location ID the store is associated with.
	DefaultLocationId *string `json:"default_location_id"`

	// DefaultSalesChannel A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
	DefaultSalesChannel *SalesChannel `json:"default_sales_channel,omitempty"`

	// DefaultSalesChannelId The ID of the store's default sales channel.
	DefaultSalesChannelId *string              `json:"default_sales_channel_id"`
	FeatureFlags          FeatureFlagsResponse `json:"feature_flags"`

	// FulfillmentProviders The store's fulfillment providers.
	FulfillmentProviders []FulfillmentProvider `json:"fulfillment_providers"`

	// Id The store's ID
	Id string `json:"id"`

	// InviteLinkTemplate A template to generate Invite links from
	InviteLinkTemplate *string `json:"invite_link_template"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`
	Modules  ModulesResponse         `json:"modules"`

	// Name The name of the Store - this may be displayed to the Customer.
	Name string `json:"name"`

	// PaymentLinkTemplate A template to generate Payment links from. Use {{cart_id}} to include the payment's `cart_id` in the link.
	PaymentLinkTemplate *string `json:"payment_link_template"`

	// PaymentProviders The store's payment providers.
	PaymentProviders []PaymentProvider `json:"payment_providers"`

	// SwapLinkTemplate A template to generate Swap links from. Use {{cart_id}} to include the Swap's `cart_id` in the link.
	SwapLinkTemplate *string `json:"swap_link_template"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// FeatureFlagsResponse defines model for FeatureFlagsResponse.
type FeatureFlagsResponse = []struct {
	// Key The key of the feature flag.
	Key string `json:"key"`

	// Value The value of the feature flag.
	Value bool `json:"value"`
}

// Fulfillment A Fulfillment is created once an admin can prepare the purchased goods. Fulfillments will eventually be shipped and hold information about how to track shipments. Fulfillments are created through a fulfillment provider, which typically integrates a third-party shipping service. Fulfillments can be associated with orders, claims, swaps, and returns.
type Fulfillment struct {
	// CanceledAt The date with timezone at which the Fulfillment was canceled.
	CanceledAt *time.Time `json:"canceled_at"`

	// ClaimOrder The details of the claim that the fulfillment may belong to.
	ClaimOrder *map[string]interface{} `json:"claim_order"`

	// ClaimOrderId The ID of the Claim that the Fulfillment belongs to.
	ClaimOrderId *string `json:"claim_order_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Data This contains all the data necessary for the Fulfillment provider to handle the fulfillment.
	Data map[string]interface{} `json:"data"`

	// Id The fulfillment's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of the fulfillment in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Items The Fulfillment Items in the Fulfillment. These hold information about how many of each Line Item has been fulfilled.
	Items *[]FulfillmentItem `json:"items,omitempty"`

	// LocationId The ID of the stock location the fulfillment will be shipped from
	LocationId *string `json:"location_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// NoNotification Flag for describing whether or not notifications related to this should be sent.
	NoNotification *bool `json:"no_notification"`

	// Order The details of the order that the fulfillment may belong to.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the Order that the Fulfillment belongs to.
	OrderId *string `json:"order_id"`

	// Provider A fulfillment provider represents a fulfillment service installed in the Medusa backend, either through a plugin or backend customizations. It holds the fulfillment service's installation status.
	Provider *FulfillmentProvider `json:"provider,omitempty"`

	// ProviderId The ID of the Fulfillment Provider responsible for handling the fulfillment.
	ProviderId string `json:"provider_id"`

	// ShippedAt The date with timezone at which the Fulfillment was shipped.
	ShippedAt *time.Time `json:"shipped_at"`

	// Swap The details of the swap that the fulfillment may belong to.
	Swap *map[string]interface{} `json:"swap"`

	// SwapId The ID of the Swap that the Fulfillment belongs to.
	SwapId *string `json:"swap_id"`

	// TrackingLinks The Tracking Links that can be used to track the status of the Fulfillment. These will usually be provided by the Fulfillment Provider.
	TrackingLinks *[]TrackingLink `json:"tracking_links,omitempty"`

	// TrackingNumbers The tracking numbers that can be used to track the status of the fulfillment.
	// Deprecated:
	TrackingNumbers []string `json:"tracking_numbers"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// FulfillmentItem This represents the association between a Line Item and a Fulfillment.
type FulfillmentItem struct {
	// Fulfillment The details of the fulfillment.
	Fulfillment *map[string]interface{} `json:"fulfillment"`

	// FulfillmentId The ID of the Fulfillment that the Fulfillment Item belongs to.
	FulfillmentId string `json:"fulfillment_id"`

	// Item Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
	Item *LineItem `json:"item,omitempty"`

	// ItemId The ID of the Line Item that the Fulfillment Item references.
	ItemId string `json:"item_id"`

	// Quantity The quantity of the Line Item that is included in the Fulfillment.
	Quantity int `json:"quantity"`
}

// FulfillmentProvider A fulfillment provider represents a fulfillment service installed in the Medusa backend, either through a plugin or backend customizations. It holds the fulfillment service's installation status.
type FulfillmentProvider struct {
	// Id The ID of the fulfillment provider as given by the fulfillment service.
	Id string `json:"id"`

	// IsInstalled Whether the fulfillment service is installed in the current version. If a fulfillment service is no longer installed, the `is_installed` attribute is set to `false`.
	IsInstalled bool `json:"is_installed"`
}

// GiftCard Gift Cards are redeemable and represent a value that can be used towards the payment of an Order.
type GiftCard struct {
	// Balance The remaining value on the Gift Card.
	Balance int `json:"balance"`

	// Code The unique code that identifies the Gift Card. This is used by the Customer to redeem the value of the Gift Card.
	Code string `json:"code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// EndsAt The time at which the Gift Card can no longer be used.
	EndsAt *time.Time `json:"ends_at"`

	// Id The gift card's ID
	Id string `json:"id"`

	// IsDisabled Whether the Gift Card has been disabled. Disabled Gift Cards cannot be applied to carts.
	IsDisabled bool `json:"is_disabled"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Order The details of the order that the gift card was purchased in.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the gift card was purchased in.
	OrderId *string `json:"order_id"`

	// Region A region holds settings specific to a geographical location, including the currency, tax rates, and fulfillment and payment providers. A Region can consist of multiple countries to accomodate common shopping settings across countries.
	Region *Region `json:"region,omitempty"`

	// RegionId The ID of the region this gift card is available in.
	RegionId string `json:"region_id"`

	// TaxRate The gift card's tax rate that will be applied on calculating totals
	TaxRate *float32 `json:"tax_rate"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value that the Gift Card represents.
	Value int `json:"value"`
}

// GiftCardTransaction Gift Card Transactions are created once a Customer uses a Gift Card to pay for their Order.
type GiftCardTransaction struct {
	// Amount The amount that was used from the Gift Card.
	Amount int `json:"amount"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// GiftCard The details of the gift card associated used in this transaction.
	GiftCard *map[string]interface{} `json:"gift_card"`

	// GiftCardId The ID of the Gift Card that was used in the transaction.
	GiftCardId string `json:"gift_card_id"`

	// Id The gift card transaction's ID
	Id string `json:"id"`

	// IsTaxable Whether the transaction is taxable or not.
	IsTaxable *bool `json:"is_taxable"`

	// Order The details of the order that the gift card was used for payment.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the gift card was used for payment.
	OrderId string `json:"order_id"`

	// TaxRate The tax rate of the transaction
	TaxRate *float32 `json:"tax_rate"`
}

// IdempotencyKey Idempotency Key is used to continue a process in case of any failure that might occur.
type IdempotencyKey struct {
	// CreatedAt Date which the idempotency key was locked.
	CreatedAt time.Time `json:"created_at"`

	// Id The idempotency key's ID
	Id string `json:"id"`

	// IdempotencyKey The unique randomly generated key used to determine the state of a process.
	IdempotencyKey string `json:"idempotency_key"`

	// LockedAt Date which the idempotency key was locked.
	LockedAt *time.Time `json:"locked_at"`

	// RecoveryPoint Where to continue from.
	RecoveryPoint string `json:"recovery_point"`

	// RequestMethod The method of the request
	RequestMethod *string `json:"request_method"`

	// RequestParams The parameters passed to the request
	RequestParams *map[string]interface{} `json:"request_params"`

	// RequestPath The request's path
	RequestPath *string `json:"request_path"`

	// ResponseBody The response's body
	ResponseBody *map[string]interface{} `json:"response_body"`

	// ResponseCode The response's code.
	ResponseCode *string `json:"response_code"`
}

// Image An Image is used to store details about uploaded images. Images are uploaded by the File Service, and the URL is provided by the File Service.
type Image struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The image's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Url The URL at which the image file can be found.
	Url string `json:"url"`
}

// InventoryItemDTO defines model for InventoryItemDTO.
type InventoryItemDTO struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Description Description of the inventory item
	Description *string `json:"description,omitempty"`

	// Height The height of the Inventory Item. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// Id The inventory item's ID.
	Id *string `json:"id,omitempty"`

	// Length The length of the Inventory Item. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// Material The material and composition that the Inventory Item is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The country in which the Inventory Item was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping *bool `json:"requires_shipping,omitempty"`

	// Sku The Stock Keeping Unit (SKU) code of the Inventory Item.
	Sku string `json:"sku"`

	// Thumbnail Thumbnail for the inventory item
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title Title of the inventory item
	Title *string `json:"title,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Weight The weight of the Inventory Item. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Inventory Item. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// InventoryLevelDTO defines model for InventoryLevelDTO.
type InventoryLevelDTO struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// IncomingQuantity the incoming stock quantity of an inventory item at the given location ID
	IncomingQuantity float32 `json:"incoming_quantity"`

	// LocationId the item location ID
	LocationId string `json:"location_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// ReservedQuantity the reserved stock quantity of an inventory item at the given location ID
	ReservedQuantity float32 `json:"reserved_quantity"`

	// StockedQuantity the total stock quantity of an inventory item at the given location ID
	StockedQuantity float32 `json:"stocked_quantity"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Invite An invite is created when an admin user invites a new user to join the store's team. Once the invite is accepted, it's deleted.
type Invite struct {
	// Accepted Whether the invite was accepted or not.
	Accepted bool `json:"accepted"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// ExpiresAt The date the invite expires at.
	ExpiresAt time.Time `json:"expires_at"`

	// Id The invite's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Role The user's role. These roles don't change the privileges of the user.
	Role *InviteRole `json:"role"`

	// Token The token used to accept the invite.
	Token string `json:"token"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// UserEmail The email of the user being invited.
	UserEmail openapi_types.Email `json:"user_email"`
}

// InviteRole The user's role. These roles don't change the privileges of the user.
type InviteRole string

// LineItem Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
type LineItem struct {
	// Adjustments The details of the item's adjustments, which are available when a discount is applied on the item.
	Adjustments *[]LineItemAdjustment `json:"adjustments,omitempty"`

	// AllowDiscounts Flag to indicate if the Line Item should be included when doing discount calculations.
	AllowDiscounts bool `json:"allow_discounts"`

	// Cart The details of the cart that the line item may belongs to.
	Cart *map[string]interface{} `json:"cart"`

	// CartId The ID of the cart that the line item may belongs to.
	CartId *string `json:"cart_id"`

	// ClaimOrder The details of the claim that the line item may belong to.
	ClaimOrder *map[string]interface{} `json:"claim_order"`

	// ClaimOrderId The ID of the claim that the line item may belong to.
	ClaimOrderId *string `json:"claim_order_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Description A more detailed description of the contents of the Line Item.
	Description *string `json:"description"`

	// DiscountTotal The total of discount of the line item rounded
	DiscountTotal *int `json:"discount_total,omitempty"`

	// FulfilledQuantity The quantity of the Line Item that has been fulfilled.
	FulfilledQuantity *int `json:"fulfilled_quantity"`

	// GiftCardTotal The total of the gift card of the line item
	GiftCardTotal *int `json:"gift_card_total,omitempty"`

	// HasShipping Flag to indicate if the Line Item has fulfillment associated with it.
	HasShipping *bool `json:"has_shipping"`

	// Id The line item's ID
	Id string `json:"id"`

	// IncludesTax Indicates if the line item unit_price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// IsGiftcard Flag to indicate if the Line Item is a Gift Card.
	IsGiftcard bool `json:"is_giftcard"`

	// IsReturn Is the item being returned
	IsReturn bool `json:"is_return"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Order The details of the order that the line item may belongs to.
	Order *map[string]interface{} `json:"order"`

	// OrderEdit The details of the order edit.
	OrderEdit *map[string]interface{} `json:"order_edit"`

	// OrderEditId The ID of the order edit that the item may belong to.
	OrderEditId *string `json:"order_edit_id"`

	// OrderId The ID of the order that the line item may belongs to.
	OrderId *string `json:"order_id"`

	// OriginalItemId The ID of the original line item. This is useful if the line item belongs to a resource that references an order, such as a return or an order edit.
	OriginalItemId *string `json:"original_item_id"`

	// OriginalTaxTotal The original tax total amount of the line item
	OriginalTaxTotal *int `json:"original_tax_total,omitempty"`

	// OriginalTotal The original total amount of the line item
	OriginalTotal *int `json:"original_total,omitempty"`

	// Quantity The quantity of the content in the Line Item.
	Quantity int `json:"quantity"`

	// RawDiscountTotal The total of discount of the line item
	RawDiscountTotal *int `json:"raw_discount_total,omitempty"`

	// Refundable The amount that can be refunded from the given Line Item. Takes taxes and discounts into consideration.
	Refundable *int `json:"refundable,omitempty"`

	// ReturnedQuantity The quantity of the Line Item that has been returned.
	ReturnedQuantity *int `json:"returned_quantity"`

	// ShippedQuantity The quantity of the Line Item that has been shipped.
	ShippedQuantity *int `json:"shipped_quantity"`

	// ShouldMerge Flag to indicate if new Line Items with the same variant should be merged or added as an additional Line Item.
	ShouldMerge bool `json:"should_merge"`

	// Subtotal The subtotal of the line item
	Subtotal *int `json:"subtotal,omitempty"`

	// Swap The details of the swap that the line item may belong to.
	Swap *map[string]interface{} `json:"swap"`

	// SwapId The ID of the swap that the line item may belong to.
	SwapId *string `json:"swap_id"`

	// TaxLines The details of the item's tax lines.
	TaxLines *[]LineItemTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The total of tax of the line item
	TaxTotal *int `json:"tax_total,omitempty"`

	// Thumbnail A URL string to a small image of the contents of the Line Item.
	Thumbnail *string `json:"thumbnail"`

	// Title The title of the Line Item.
	Title string `json:"title"`

	// Total The total amount of the line item
	Total *int `json:"total,omitempty"`

	// UnitPrice The price of one unit of the content in the Line Item. This should be in the currency defined by the Cart/Order/Swap/Claim that the Line Item belongs to.
	UnitPrice int `json:"unit_price"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variant A Product Variant represents a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations. A product must at least have one product variant.
	Variant *ProductVariant `json:"variant,omitempty"`

	// VariantId The id of the Product Variant contained in the Line Item.
	VariantId *string `json:"variant_id"`
}

// LineItemAdjustment A Line Item Adjustment includes details on discounts applied on a line item.
type LineItemAdjustment struct {
	// Amount The adjustment amount
	Amount float32 `json:"amount"`

	// Description The line item's adjustment description
	Description string `json:"description"`

	// Discount A discount can be applied to a cart for promotional purposes.
	Discount *Discount `json:"discount,omitempty"`

	// DiscountId The ID of the discount associated with the adjustment
	DiscountId *string `json:"discount_id"`

	// Id The Line Item Adjustment's ID
	Id string `json:"id"`

	// Item The details of the line item.
	Item *map[string]interface{} `json:"item"`

	// ItemId The ID of the line item
	ItemId string `json:"item_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`
}

// LineItemTaxLine A Line Item Tax Line represents the taxes applied on a line item.
type LineItemTaxLine struct {
	// Code A code to identify the tax type by
	Code *string `json:"code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The line item tax line's ID
	Id string `json:"id"`

	// Item The details of the line item.
	Item *map[string]interface{} `json:"item"`

	// ItemId The ID of the line item
	ItemId string `json:"item_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name A human friendly name for the tax
	Name string `json:"name"`

	// Rate The numeric rate to charge tax by
	Rate float32 `json:"rate"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ModulesResponse defines model for ModulesResponse.
type ModulesResponse = []struct {
	// Module The key of the module.
	Module string `json:"module"`

	// Resolution The resolution path of the module or false if module is not installed.
	Resolution string `json:"resolution"`
}

// MoneyAmount A Money Amount represent a price amount, for example, a product variant's price or a price in a price list. Each Money Amount either has a Currency or Region associated with it to indicate the pricing in a given Currency or, for fully region-based pricing, the given price in a specific Region. If region-based pricing is used, the amount will be in the currency defined for the Region.
type MoneyAmount struct {
	// Amount The amount in the smallest currecny unit (e.g. cents 100 cents to charge $1) that the Product Variant will cost.
	Amount int `json:"amount"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Currency Currency
	Currency *Currency `json:"currency,omitempty"`

	// CurrencyCode The 3 character currency code that the money amount may belong to.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The money amount's ID
	Id string `json:"id"`

	// MaxQuantity The maximum quantity that the Money Amount applies to. If this value is not set, the Money Amount applies to all quantities.
	MaxQuantity *int `json:"max_quantity"`

	// MinQuantity The minimum quantity that the Money Amount applies to. If this value is not set, the Money Amount applies to all quantities.
	MinQuantity *int `json:"min_quantity"`

	// PriceList The details of the price list that the money amount may belong to.
	PriceList *map[string]interface{} `json:"price_list"`

	// PriceListId The ID of the price list that the money amount may belong to.
	PriceListId *string `json:"price_list_id"`

	// Region The details of the region that the money amount may belong to.
	Region *map[string]interface{} `json:"region"`

	// RegionId The region's ID
	RegionId *string `json:"region_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variant The details of the product variant that the money amount may belong to.
	Variant *map[string]interface{} `json:"variant"`

	// VariantId The ID of the Product Variant contained in the Line Item.
	VariantId *string `json:"variant_id"`
}

// MultipleErrors defines model for MultipleErrors.
type MultipleErrors struct {
	// Errors Array of errors
	Errors  *[]Error `json:"errors,omitempty"`
	Message *string  `json:"message,omitempty"`
}

// Note A Note is an element that can be used in association with different resources to allow admin users to describe additional information. For example, they can be used to add additional information about orders.
type Note struct {
	// Author A User is an administrator who can manage store settings and data.
	Author *User `json:"author,omitempty"`

	// AuthorId The ID of the user that created the note.
	AuthorId *string `json:"author_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The note's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ResourceId The ID of the resource that the Note refers to.
	ResourceId string `json:"resource_id"`

	// ResourceType The type of resource that the Note refers to.
	ResourceType string `json:"resource_type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The contents of the note.
	Value string `json:"value"`
}

// Notification A notification is an alert sent, typically to customers, using the installed Notification Provider as a reaction to internal events such as `order.placed`. Notifications can be resent.
type Notification struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Customer A customer can make purchases in your store and manage their profile.
	Customer *Customer `json:"customer,omitempty"`

	// CustomerId The ID of the customer that this notification was sent to.
	CustomerId *string `json:"customer_id"`

	// Data The data that the Notification was sent with. This contains all the data necessary for the Notification Provider to initiate a resend.
	Data map[string]interface{} `json:"data"`

	// EventName The name of the event that the notification was sent for.
	EventName *string `json:"event_name"`

	// Id The notification's ID
	Id string `json:"id"`

	// ParentId The notification's parent ID
	ParentId *string `json:"parent_id"`

	// ParentNotification The details of the parent notification.
	ParentNotification *map[string]interface{} `json:"parent_notification"`

	// Provider A notification provider represents a notification service installed in the Medusa backend, either through a plugin or backend customizations. It holds the notification service's installation status.
	Provider *NotificationProvider `json:"provider,omitempty"`

	// ProviderId The ID of the notification provider used to send the notification.
	ProviderId *string `json:"provider_id"`

	// Resends The details of all resends of the notification.
	Resends *[]map[string]interface{} `json:"resends,omitempty"`

	// ResourceId The ID of the resource that the Notification refers to.
	ResourceId string `json:"resource_id"`

	// ResourceType The type of resource that the Notification refers to.
	ResourceType string `json:"resource_type"`

	// To The address that the Notification was sent to. This will usually be an email address, but can represent other addresses such as a chat bot user ID.
	To string `json:"to"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// NotificationProvider A notification provider represents a notification service installed in the Medusa backend, either through a plugin or backend customizations. It holds the notification service's installation status.
type NotificationProvider struct {
	// Id The ID of the notification provider as given by the notification service.
	Id string `json:"id"`

	// IsInstalled Whether the notification service is installed in the current version. If a notification service is no longer installed, the `is_installed` attribute is set to `false`.
	IsInstalled bool `json:"is_installed"`
}

// OAuth An Oauth app is typically created by a plugin to handle authentication to third-party services.
type OAuth struct {
	// ApplicationName The app's name
	ApplicationName string `json:"application_name"`

	// Data Any data necessary to the app.
	Data *map[string]interface{} `json:"data"`

	// DisplayName The app's display name
	DisplayName string `json:"display_name"`

	// Id The app's ID
	Id string `json:"id"`

	// InstallUrl The URL to install the app
	InstallUrl *string `json:"install_url"`

	// UninstallUrl The URL to uninstall the app
	UninstallUrl *string `json:"uninstall_url"`
}

// Order An order is a purchase made by a customer. It holds details about payment and fulfillment of the order. An order may also be created from a draft order, which is created by an admin user.
type Order struct {
	// BillingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	BillingAddress *Address `json:"billing_address,omitempty"`

	// BillingAddressId The ID of the billing address associated with the order
	BillingAddressId *string `json:"billing_address_id"`

	// CanceledAt The date the order was canceled on.
	CanceledAt *time.Time `json:"canceled_at"`

	// Cart The details of the cart associated with the order.
	Cart *map[string]interface{} `json:"cart"`

	// CartId The ID of the cart associated with the order
	CartId *string `json:"cart_id"`

	// Claims The details of the claims created for the order.
	Claims *[]map[string]interface{} `json:"claims,omitempty"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Currency Currency
	Currency *Currency `json:"currency,omitempty"`

	// CurrencyCode The 3 character currency code that is used in the order
	CurrencyCode string `json:"currency_code"`

	// Customer The details of the customer associated with the order.
	Customer *map[string]interface{} `json:"customer"`

	// CustomerId The ID of the customer associated with the order
	CustomerId string `json:"customer_id"`

	// DiscountTotal The total of discount rounded
	DiscountTotal *int `json:"discount_total,omitempty"`

	// Discounts The details of the discounts applied on the order.
	Discounts *[]Discount `json:"discounts,omitempty"`

	// DisplayId The order's display ID
	DisplayId int `json:"display_id"`

	// DraftOrder The details of the draft order this order was created from.
	DraftOrder *map[string]interface{} `json:"draft_order"`

	// DraftOrderId The ID of the draft order this order was created from.
	DraftOrderId *string `json:"draft_order_id"`

	// Edits The details of the order edits done on the order.
	Edits *[]map[string]interface{} `json:"edits,omitempty"`

	// Email The email associated with the order
	Email openapi_types.Email `json:"email"`

	// ExternalId The ID of an external order.
	ExternalId *string `json:"external_id"`

	// FulfillmentStatus The order's fulfillment status
	FulfillmentStatus OrderFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The details of the fulfillments created for the order.
	Fulfillments *[]map[string]interface{} `json:"fulfillments,omitempty"`

	// GiftCardTaxTotal The total of gift cards with taxes
	GiftCardTaxTotal *int `json:"gift_card_tax_total,omitempty"`

	// GiftCardTotal The total of gift cards
	GiftCardTotal *int `json:"gift_card_total,omitempty"`

	// GiftCardTransactions The gift card transactions made in the order.
	GiftCardTransactions *[]GiftCardTransaction `json:"gift_card_transactions,omitempty"`

	// GiftCards The details of the gift card used in the order.
	GiftCards *[]GiftCard `json:"gift_cards,omitempty"`

	// Id The order's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the processing of the order in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// ItemTaxTotal The tax total applied on items
	ItemTaxTotal *int `json:"item_tax_total"`

	// Items The details of the line items that belong to the order.
	Items *[]LineItem `json:"items,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// NoNotification Flag for describing whether or not notifications related to this should be send.
	NoNotification *bool `json:"no_notification"`

	// PaidTotal The total amount paid
	PaidTotal *int `json:"paid_total,omitempty"`

	// PaymentStatus The order's payment status
	PaymentStatus OrderPaymentStatus `json:"payment_status"`

	// Payments The details of the payments used in the order.
	Payments *[]map[string]interface{} `json:"payments,omitempty"`

	// RawDiscountTotal The total of discount
	RawDiscountTotal *int `json:"raw_discount_total,omitempty"`

	// RefundableAmount The amount that can be refunded
	RefundableAmount *int `json:"refundable_amount,omitempty"`

	// RefundedTotal The total amount refunded if the order is returned.
	RefundedTotal *int `json:"refunded_total,omitempty"`

	// Refunds The details of the refunds created for the order.
	Refunds *[]map[string]interface{} `json:"refunds,omitempty"`

	// Region A region holds settings specific to a geographical location, including the currency, tax rates, and fulfillment and payment providers. A Region can consist of multiple countries to accomodate common shopping settings across countries.
	Region *Region `json:"region,omitempty"`

	// RegionId The ID of the region this order was created in.
	RegionId string `json:"region_id"`

	// ReturnableItems The details of the line items that are returnable as part of the order, swaps, or claims
	ReturnableItems *[]LineItem `json:"returnable_items,omitempty"`

	// Returns The details of the returns created for the order.
	Returns *[]map[string]interface{} `json:"returns,omitempty"`

	// SalesChannel A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
	SalesChannel *SalesChannel `json:"sales_channel,omitempty"`

	// SalesChannelId The ID of the sales channel this order belongs to.
	SalesChannelId *string `json:"sales_channel_id"`

	// SalesChannels The associated sales channels.
	SalesChannels *[]SalesChannel `json:"sales_channels"`

	// ShippingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// ShippingAddressId The ID of the shipping address associated with the order
	ShippingAddressId *string `json:"shipping_address_id"`

	// ShippingMethods The details of the shipping methods used in the order.
	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

	// ShippingTaxTotal The tax total applied on shipping
	ShippingTaxTotal *int `json:"shipping_tax_total,omitempty"`

	// ShippingTotal The total of shipping
	ShippingTotal *int `json:"shipping_total"`

	// Status The order's status
	Status OrderStatus `json:"status"`

	// Subtotal The subtotal of the order
	Subtotal *int `json:"subtotal,omitempty"`

	// Swaps The details of the swaps created for the order.
	Swaps *[]map[string]interface{} `json:"swaps,omitempty"`

	// TaxRate The order's tax rate
	TaxRate *float32 `json:"tax_rate"`

	// TaxTotal The total of tax
	TaxTotal *int `json:"tax_total,omitempty"`

	// Total The total amount of the order
	Total *int `json:"total,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderFulfillmentStatus The order's fulfillment status
type OrderFulfillmentStatus string

// OrderPaymentStatus The order's payment status
type OrderPaymentStatus string

// OrderStatus The order's status
type OrderStatus string

// OrderEdit Order edit allows modifying items in an order, such as adding, updating, or deleting items from the original order. Once the order edit is confirmed, the changes are reflected on the original order.
type OrderEdit struct {
	// CanceledAt The date with timezone at which the edit was cancelled.
	CanceledAt *time.Time `json:"canceled_at"`

	// CanceledBy The unique identifier of the user or customer who cancelled the order edit.
	CanceledBy *string `json:"canceled_by"`

	// Changes The details of all the changes on the original order's line items.
	Changes *[]OrderItemChange `json:"changes,omitempty"`

	// ConfirmedAt The date with timezone at which the edit was confirmed.
	ConfirmedAt *time.Time `json:"confirmed_at"`

	// ConfirmedBy The unique identifier of the user or customer who confirmed the order edit.
	ConfirmedBy *string `json:"confirmed_by"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The unique identifier of the user or customer who created the order edit.
	CreatedBy string `json:"created_by"`

	// DeclinedAt The date with timezone at which the edit was declined.
	DeclinedAt *time.Time `json:"declined_at"`

	// DeclinedBy The unique identifier of the user or customer who declined the order edit.
	DeclinedBy *string `json:"declined_by"`

	// DeclinedReason An optional note why  the order edit is declined.
	DeclinedReason *string `json:"declined_reason"`

	// DifferenceDue The difference between the total amount of the order and total amount of edited order.
	DifferenceDue *int `json:"difference_due,omitempty"`

	// DiscountTotal The total of discount
	DiscountTotal *int `json:"discount_total,omitempty"`

	// GiftCardTaxTotal The total of the gift card tax amount
	GiftCardTaxTotal *int `json:"gift_card_tax_total,omitempty"`

	// GiftCardTotal The total of the gift card amount
	GiftCardTotal *int `json:"gift_card_total,omitempty"`

	// Id The order edit's ID
	Id string `json:"id"`

	// InternalNote An optional note with additional details about the order edit.
	InternalNote *string `json:"internal_note"`

	// Items The details of the cloned items from the original order with the new changes. Once the order edit is confirmed, these line items are associated with the original order.
	Items *[]LineItem `json:"items,omitempty"`

	// Order The details of the order that this order edit was created for.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that is edited
	OrderId string `json:"order_id"`

	// PaymentCollection A payment collection allows grouping and managing a list of payments at one. This can be helpful when making additional payment for order edits or integrating installment payments.
	PaymentCollection *PaymentCollection `json:"payment_collection,omitempty"`

	// PaymentCollectionId The ID of the payment collection
	PaymentCollectionId *string `json:"payment_collection_id"`

	// RequestedAt The date with timezone at which the edit was requested.
	RequestedAt *time.Time `json:"requested_at"`

	// RequestedBy The unique identifier of the user or customer who requested the order edit.
	RequestedBy *string `json:"requested_by"`

	// ShippingTotal The total of the shipping amount
	ShippingTotal *int `json:"shipping_total,omitempty"`

	// Status The status of the order edit.
	Status OrderEditStatus `json:"status"`

	// Subtotal The total of subtotal
	Subtotal *int `json:"subtotal,omitempty"`

	// TaxTotal The total of tax
	TaxTotal *int `json:"tax_total,omitempty"`

	// Total The total amount of the edited order.
	Total *int `json:"total,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderEditStatus The status of the order edit.
type OrderEditStatus string

// OrderItemChange An order item change is a change made within an order edit to an order's items. These changes are not reflected on the original order until the order edit is confirmed.
type OrderItemChange struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The order item change's ID
	Id string `json:"id"`

	// LineItem Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
	LineItem *LineItem `json:"line_item,omitempty"`

	// LineItemId The ID of the cloned line item.
	LineItemId *string `json:"line_item_id"`

	// OrderEdit The details of the order edit the item change is associated with.
	OrderEdit *map[string]interface{} `json:"order_edit"`

	// OrderEditId The ID of the order edit
	OrderEditId string `json:"order_edit_id"`

	// OriginalLineItem Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
	OriginalLineItem *LineItem `json:"original_line_item,omitempty"`

	// OriginalLineItemId The ID of the original line item in the order
	OriginalLineItemId *string `json:"original_line_item_id"`

	// Type The order item change's status
	Type OrderItemChangeType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// OrderItemChangeType The order item change's status
type OrderItemChangeType string

// Payment A payment is originally created from a payment session. Once a payment session is authorized, the payment is created to represent the authorized amount with a given payment method. Payments can be captured, canceled or refunded. Payments can be made towards orders, swaps, order edits, or other resources.
type Payment struct {
	// Amount The amount that the Payment has been authorized for.
	Amount int `json:"amount"`

	// AmountRefunded The amount of the original Payment amount that has been refunded back to the Customer.
	AmountRefunded int `json:"amount_refunded"`

	// CanceledAt The date with timezone at which the Payment was canceled.
	CanceledAt *time.Time `json:"canceled_at"`

	// CapturedAt The date with timezone at which the Payment was captured.
	CapturedAt *time.Time `json:"captured_at"`

	// Cart The details of the cart that the payment session was potentially created for.
	Cart *map[string]interface{} `json:"cart"`

	// CartId The ID of the cart that the payment session was potentially created for.
	CartId *string `json:"cart_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Currency Currency
	Currency *Currency `json:"currency,omitempty"`

	// CurrencyCode The 3 character ISO currency code of the payment.
	CurrencyCode string `json:"currency_code"`

	// Data The data required for the Payment Provider to identify, modify and process the Payment. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn't hold any state.
	Data map[string]interface{} `json:"data"`

	// Id The payment's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of a payment in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Order The details of the order that the payment session was potentially created for.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the payment session was potentially created for.
	OrderId *string `json:"order_id"`

	// ProviderId The id of the Payment Provider that is responsible for the Payment
	ProviderId string `json:"provider_id"`

	// Swap The details of the swap that this payment was potentially created for.
	Swap *map[string]interface{} `json:"swap"`

	// SwapId The ID of the swap that this payment was potentially created for.
	SwapId *string `json:"swap_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// PaymentCollection A payment collection allows grouping and managing a list of payments at one. This can be helpful when making additional payment for order edits or integrating installment payments.
type PaymentCollection struct {
	// Amount Amount of the payment collection.
	Amount int `json:"amount"`

	// AuthorizedAmount Authorized amount of the payment collection.
	AuthorizedAmount *int `json:"authorized_amount"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The ID of the user that created the payment collection.
	CreatedBy string `json:"created_by"`

	// Currency Currency
	Currency *Currency `json:"currency,omitempty"`

	// CurrencyCode The three character ISO code for the currency this payment collection is associated with.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description Description of the payment collection
	Description *string `json:"description"`

	// Id The payment collection's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// PaymentSessions The details of the payment sessions created as part of the payment collection.
	PaymentSessions *[]PaymentSession `json:"payment_sessions,omitempty"`

	// Payments The details of the payments created as part of the payment collection.
	Payments *[]Payment `json:"payments,omitempty"`

	// Region A region holds settings specific to a geographical location, including the currency, tax rates, and fulfillment and payment providers. A Region can consist of multiple countries to accomodate common shopping settings across countries.
	Region *Region `json:"region,omitempty"`

	// RegionId The ID of the region this payment collection is associated with.
	RegionId string `json:"region_id"`

	// Status The type of the payment collection
	Status PaymentCollectionStatus `json:"status"`

	// Type The type of the payment collection
	Type PaymentCollectionType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// PaymentCollectionStatus The type of the payment collection
type PaymentCollectionStatus string

// PaymentCollectionType The type of the payment collection
type PaymentCollectionType string

// PaymentProvider A payment provider represents a payment service installed in the Medusa backend, either through a plugin or backend customizations. It holds the payment service's installation status.
type PaymentProvider struct {
	// Id The ID of the payment provider as given by the payment service.
	Id string `json:"id"`

	// IsInstalled Whether the payment service is installed in the current version. If a payment service is no longer installed, the `is_installed` attribute is set to `false`.
	IsInstalled bool `json:"is_installed"`
}

// PaymentSession A Payment Session is created when a Customer initilizes the checkout flow, and can be used to hold the state of a payment flow. Each Payment Session is controlled by a Payment Provider, which is responsible for the communication with external payment services. Authorized Payment Sessions will eventually get promoted to Payments to indicate that they are authorized for payment processing such as capture or refund. Payment sessions can also be used as part of payment collections.
type PaymentSession struct {
	// Amount The amount that the Payment Session has been authorized for.
	Amount *int `json:"amount"`

	// Cart A cart represents a virtual shopping bag. It can be used to complete an order, a swap, or a claim.
	Cart *Cart `json:"cart,omitempty"`

	// CartId The ID of the cart that the payment session was created for.
	CartId *string `json:"cart_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The data required for the Payment Provider to identify, modify and process the Payment Session. Typically this will be an object that holds an id to the external payment session, but can be an empty object if the Payment Provider doesn't hold any state.
	Data map[string]interface{} `json:"data"`

	// Id The payment session's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of a cart in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// IsInitiated A flag to indicate if a communication with the third party provider has been initiated.
	IsInitiated bool `json:"is_initiated"`

	// IsSelected A flag to indicate if the Payment Session has been selected as the method that will be used to complete the purchase.
	IsSelected *bool `json:"is_selected"`

	// PaymentAuthorizedAt The date with timezone at which the Payment Session was authorized.
	PaymentAuthorizedAt *time.Time `json:"payment_authorized_at"`

	// ProviderId The ID of the Payment Provider that is responsible for the Payment Session
	ProviderId string `json:"provider_id"`

	// Status Indicates the status of the Payment Session. Will default to `pending`, and will eventually become `authorized`. Payment Sessions may have the status of `requires_more` to indicate that further actions are to be completed by the Customer.
	Status PaymentSessionStatus `json:"status"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// PaymentSessionStatus Indicates the status of the Payment Session. Will default to `pending`, and will eventually become `authorized`. Payment Sessions may have the status of `requires_more` to indicate that further actions are to be completed by the Customer.
type PaymentSessionStatus string

// PriceList A Price List represents a set of prices that override the default price for one or more product variants.
type PriceList struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CustomerGroups The details of the customer groups that the Price List can apply to.
	CustomerGroups *[]CustomerGroup `json:"customer_groups,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description The price list's description
	Description string `json:"description"`

	// EndsAt The date with timezone that the Price List stops being valid.
	EndsAt *time.Time `json:"ends_at"`

	// Id The price list's ID
	Id string `json:"id"`

	// IncludesTax Whether the price list prices include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Name The price list's name
	Name string `json:"name"`

	// Prices The prices that belong to the price list, represented as a Money Amount.
	Prices *[]MoneyAmount `json:"prices,omitempty"`

	// StartsAt The date with timezone that the Price List starts being valid.
	StartsAt *time.Time `json:"starts_at"`

	// Status The status of the Price List
	Status PriceListStatus `json:"status"`

	// Type The type of Price List. This can be one of either `sale` or `override`.
	Type PriceListType `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// PriceListStatus The status of the Price List
type PriceListStatus string

// PriceListType The type of Price List. This can be one of either `sale` or `override`.
type PriceListType string

// PricedProduct defines model for PricedProduct.
type PricedProduct struct {
	// Categories The details of the product categories that this product belongs to.
	Categories *[]ProductCategory `json:"categories,omitempty"`

	// Collection A Product Collection allows grouping together products for promotional purposes. For example, an admin can create a Summer collection, add products to it, and showcase it on the storefront.
	Collection *ProductCollection `json:"collection,omitempty"`

	// CollectionId The ID of the product collection that the product belongs to.
	CollectionId *string `json:"collection_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description A short description of the Product.
	Description *string `json:"description"`

	// Discountable Whether the Product can be discounted. Discounts will not apply to Line Items of this Product when this flag is set to `false`.
	Discountable bool `json:"discountable"`

	// ExternalId The external ID of the product
	ExternalId *string `json:"external_id"`

	// Handle A unique identifier for the Product (e.g. for slug structure).
	Handle *string `json:"handle"`

	// Height The height of the Product Variant. May be used in shipping rate calculations.
	Height *float32 `json:"height"`

	// HsCode The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code"`

	// Id The product's ID
	Id string `json:"id"`

	// Images The details of the product's images.
	Images *[]Image `json:"images,omitempty"`

	// IsGiftcard Whether the Product represents a Gift Card. Products that represent Gift Cards will automatically generate a redeemable Gift Card code once they are purchased.
	IsGiftcard bool `json:"is_giftcard"`

	// Length The length of the Product Variant. May be used in shipping rate calculations.
	Length *float32 `json:"length"`

	// Material The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code"`

	// Options The details of the Product Options that are defined for the Product. The product's variants will have a unique combination of values of the product's options.
	Options *[]ProductOption `json:"options,omitempty"`

	// OriginCountry The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country"`

	// Profile A Shipping Profile has a set of defined Shipping Options that can be used to fulfill a given set of Products. For example, gift cards are shipped differently than physical products, so a shipping profile with the type `gift_card` groups together the shipping options that can only be used for gift cards.
	Profile *ShippingProfile `json:"profile,omitempty"`

	// ProfileId The ID of the shipping profile that the product belongs to. The shipping profile has a set of defined shipping options that can be used to fulfill the product.
	ProfileId string `json:"profile_id"`

	// Profiles Available if the relation `profiles` is expanded.
	Profiles *[]ShippingProfile `json:"profiles"`

	// SalesChannels The details of the sales channels this product is available in.
	SalesChannels *[]SalesChannel `json:"sales_channels,omitempty"`

	// Status The status of the product
	Status PricedProductStatus `json:"status"`

	// Subtitle An optional subtitle that can be used to further specify the Product.
	Subtitle *string `json:"subtitle"`

	// Tags The details of the product tags used in this product.
	Tags *[]ProductTag `json:"tags,omitempty"`

	// Thumbnail A URL to an image file that can be used to identify the Product.
	Thumbnail *string `json:"thumbnail"`

	// Title A title that can be displayed for easy identification of the Product.
	Title string `json:"title"`

	// Type A Product Type can be added to Products for filtering and reporting purposes.
	Type *ProductType `json:"type,omitempty"`

	// TypeId The ID of the product type that the product belongs to.
	TypeId *string `json:"type_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variants The product variants and their prices.
	Variants *[]PricedVariant `json:"variants,omitempty"`

	// Weight The weight of the Product Variant. May be used in shipping rate calculations.
	Weight *float32 `json:"weight"`

	// Width The width of the Product Variant. May be used in shipping rate calculations.
	Width *float32 `json:"width"`
}

// PricedProductStatus The status of the product
type PricedProductStatus string

// PricedShippingOption defines model for PricedShippingOption.
type PricedShippingOption struct {
	// AdminOnly Flag to indicate if the Shipping Option usage is restricted to admin users.
	AdminOnly bool `json:"admin_only"`

	// Amount The amount to charge for shipping when the Shipping Option price type is `flat_rate`.
	Amount *int `json:"amount"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The data needed for the Fulfillment Provider to identify the Shipping Option.
	Data map[string]interface{} `json:"data"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The shipping option's ID
	Id string `json:"id"`

	// IncludesTax Whether the shipping option price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// IsReturn Flag to indicate if the Shipping Option can be used for Return shipments.
	IsReturn bool `json:"is_return"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name given to the Shipping Option - this may be displayed to the Customer.
	Name string `json:"name"`

	// PriceInclTax Price including taxes
	PriceInclTax *float32 `json:"price_incl_tax,omitempty"`

	// PriceType The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
	PriceType PricedShippingOptionPriceType `json:"price_type"`

	// Profile A Shipping Profile has a set of defined Shipping Options that can be used to fulfill a given set of Products. For example, gift cards are shipped differently than physical products, so a shipping profile with the type `gift_card` groups together the shipping options that can only be used for gift cards.
	Profile *ShippingProfile `json:"profile,omitempty"`

	// ProfileId The ID of the Shipping Profile that the shipping option belongs to.
	ProfileId string `json:"profile_id"`

	// Provider A fulfillment provider represents a fulfillment service installed in the Medusa backend, either through a plugin or backend customizations. It holds the fulfillment service's installation status.
	Provider *FulfillmentProvider `json:"provider,omitempty"`

	// ProviderId The ID of the fulfillment provider that will be used to later to process the shipping method created from this shipping option and its fulfillments.
	ProviderId string `json:"provider_id"`

	// Region The details of the region this shipping option can be used in.
	Region *map[string]interface{} `json:"region"`

	// RegionId The ID of the region this shipping option can be used in.
	RegionId string `json:"region_id"`

	// Requirements The details of the requirements that must be satisfied for the Shipping Option to be available for usage in a Cart.
	Requirements *[]ShippingOptionRequirement `json:"requirements,omitempty"`

	// TaxAmount The taxes applied.
	TaxAmount *float32 `json:"tax_amount,omitempty"`

	// TaxRates An array of applied tax rates
	TaxRates *[]struct {
		// Code The code of the tax rate
		Code *string `json:"code,omitempty"`

		// Name The name of the tax rate
		Name *string `json:"name,omitempty"`

		// Rate The tax rate value
		Rate *float32 `json:"rate,omitempty"`
	} `json:"tax_rates,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// PricedShippingOptionPriceType The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
type PricedShippingOptionPriceType string

// PricedVariant defines model for PricedVariant.
type PricedVariant struct {
	// AllowBackorder Whether the Product Variant should be purchasable when `inventory_quantity` is 0.
	AllowBackorder bool `json:"allow_backorder"`

	// Barcode A generic field for a GTIN number that can be used to identify the Product Variant.
	Barcode *string `json:"barcode"`

	// CalculatedPrice The calculated price of the variant. Can be a discounted price.
	CalculatedPrice *float32 `json:"calculated_price,omitempty"`

	// CalculatedPriceInclTax The calculated price of the variant including taxes.
	CalculatedPriceInclTax *float32 `json:"calculated_price_incl_tax,omitempty"`

	// CalculatedTax The taxes applied on the calculated price.
	CalculatedTax *float32 `json:"calculated_tax,omitempty"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Ean An EAN barcode number that can be used to identify the Product Variant.
	Ean *string `json:"ean"`

	// Height The height of the Product Variant. May be used in shipping rate calculations.
	Height *float32 `json:"height"`

	// HsCode The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code"`

	// Id The product variant's ID
	Id string `json:"id"`

	// InventoryItems The details inventory items of the product variant.
	InventoryItems *[]ProductVariantInventoryItem `json:"inventory_items,omitempty"`

	// InventoryQuantity The current quantity of the item that is stocked.
	InventoryQuantity int `json:"inventory_quantity"`

	// Length The length of the Product Variant. May be used in shipping rate calculations.
	Length *float32 `json:"length"`

	// ManageInventory Whether Medusa should manage inventory for the Product Variant.
	ManageInventory bool `json:"manage_inventory"`

	// Material The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code"`

	// Options The details of the product options that this product variant defines values for.
	Options *[]ProductOptionValue `json:"options,omitempty"`

	// OriginCountry The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country"`

	// OriginalPrice The original price of the variant without any discounted prices applied.
	OriginalPrice *float32 `json:"original_price,omitempty"`

	// OriginalPriceInclTax The original price of the variant including taxes.
	OriginalPriceInclTax *float32 `json:"original_price_incl_tax,omitempty"`

	// OriginalTax The taxes applied on the original price.
	OriginalTax *float32 `json:"original_tax,omitempty"`

	// Prices The details of the prices of the Product Variant, each represented as a Money Amount. Each Money Amount represents a price in a given currency or a specific Region.
	Prices *[]MoneyAmount `json:"prices,omitempty"`

	// Product The details of the product that the product variant belongs to.
	Product *map[string]interface{} `json:"product"`

	// ProductId The ID of the product that the product variant belongs to.
	ProductId string `json:"product_id"`

	// Purchasable Only used with the inventory modules.
	// A boolean value indicating whether the Product Variant is purchasable.
	// A variant is purchasable if:
	//   - inventory is not managed
	//   - it has no inventory items
	//   - it is in stock
	//   - it is backorderable.
	Purchasable *bool `json:"purchasable,omitempty"`

	// Sku The unique stock keeping unit used to identify the Product Variant. This will usually be a unique identifer for the item that is to be shipped, and can be referenced across multiple systems.
	Sku *string `json:"sku"`

	// TaxRates An array of applied tax rates
	TaxRates *[]struct {
		// Code The code of the tax rate
		Code *string `json:"code,omitempty"`

		// Name The name of the tax rate
		Name *string `json:"name,omitempty"`

		// Rate The tax rate value
		Rate *float32 `json:"rate,omitempty"`
	} `json:"tax_rates,omitempty"`

	// Title A title that can be displayed for easy identification of the Product Variant.
	Title string `json:"title"`

	// Upc A UPC barcode number that can be used to identify the Product Variant.
	Upc *string `json:"upc"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantRank The ranking of this variant
	VariantRank *float32 `json:"variant_rank"`

	// Weight The weight of the Product Variant. May be used in shipping rate calculations.
	Weight *float32 `json:"weight"`

	// Width The width of the Product Variant. May be used in shipping rate calculations.
	Width *float32 `json:"width"`
}

// Product A product is a saleable item that holds general information such as name or description. It must include at least one Product Variant, where each product variant defines different options to purchase the product with (for example, different sizes or colors). The prices and inventory of the product are defined on the variant level.
type Product struct {
	// Categories The details of the product categories that this product belongs to.
	Categories *[]ProductCategory `json:"categories,omitempty"`

	// Collection A Product Collection allows grouping together products for promotional purposes. For example, an admin can create a Summer collection, add products to it, and showcase it on the storefront.
	Collection *ProductCollection `json:"collection,omitempty"`

	// CollectionId The ID of the product collection that the product belongs to.
	CollectionId *string `json:"collection_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description A short description of the Product.
	Description *string `json:"description"`

	// Discountable Whether the Product can be discounted. Discounts will not apply to Line Items of this Product when this flag is set to `false`.
	Discountable bool `json:"discountable"`

	// ExternalId The external ID of the product
	ExternalId *string `json:"external_id"`

	// Handle A unique identifier for the Product (e.g. for slug structure).
	Handle *string `json:"handle"`

	// Height The height of the Product Variant. May be used in shipping rate calculations.
	Height *float32 `json:"height"`

	// HsCode The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code"`

	// Id The product's ID
	Id string `json:"id"`

	// Images The details of the product's images.
	Images *[]Image `json:"images,omitempty"`

	// IsGiftcard Whether the Product represents a Gift Card. Products that represent Gift Cards will automatically generate a redeemable Gift Card code once they are purchased.
	IsGiftcard bool `json:"is_giftcard"`

	// Length The length of the Product Variant. May be used in shipping rate calculations.
	Length *float32 `json:"length"`

	// Material The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code"`

	// Options The details of the Product Options that are defined for the Product. The product's variants will have a unique combination of values of the product's options.
	Options *[]ProductOption `json:"options,omitempty"`

	// OriginCountry The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country"`

	// Profile A Shipping Profile has a set of defined Shipping Options that can be used to fulfill a given set of Products. For example, gift cards are shipped differently than physical products, so a shipping profile with the type `gift_card` groups together the shipping options that can only be used for gift cards.
	Profile *ShippingProfile `json:"profile,omitempty"`

	// ProfileId The ID of the shipping profile that the product belongs to. The shipping profile has a set of defined shipping options that can be used to fulfill the product.
	ProfileId string `json:"profile_id"`

	// Profiles Available if the relation `profiles` is expanded.
	Profiles *[]ShippingProfile `json:"profiles"`

	// SalesChannels The details of the sales channels this product is available in.
	SalesChannels *[]SalesChannel `json:"sales_channels,omitempty"`

	// Status The status of the product
	Status ProductStatus `json:"status"`

	// Subtitle An optional subtitle that can be used to further specify the Product.
	Subtitle *string `json:"subtitle"`

	// Tags The details of the product tags used in this product.
	Tags *[]ProductTag `json:"tags,omitempty"`

	// Thumbnail A URL to an image file that can be used to identify the Product.
	Thumbnail *string `json:"thumbnail"`

	// Title A title that can be displayed for easy identification of the Product.
	Title string `json:"title"`

	// Type A Product Type can be added to Products for filtering and reporting purposes.
	Type *ProductType `json:"type,omitempty"`

	// TypeId The ID of the product type that the product belongs to.
	TypeId *string `json:"type_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variants The details of the Product Variants that belong to the Product. Each will have a unique combination of values of the product's options.
	Variants *[]ProductVariant `json:"variants,omitempty"`

	// Weight The weight of the Product Variant. May be used in shipping rate calculations.
	Weight *float32 `json:"weight"`

	// Width The width of the Product Variant. May be used in shipping rate calculations.
	Width *float32 `json:"width"`
}

// ProductStatus The status of the product
type ProductStatus string

// ProductCategory A product category can be used to categorize products into a hierarchy of categories.
type ProductCategory struct {
	// CategoryChildren The details of the category's children.
	CategoryChildren []map[string]interface{} `json:"category_children"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Description The product category's description.
	Description *string `json:"description,omitempty"`

	// Handle A unique string that identifies the Product Category - can for example be used in slug structures.
	Handle string `json:"handle"`

	// Id The product category's ID
	Id string `json:"id"`

	// IsActive A flag to make product category visible/hidden in the store front
	IsActive bool `json:"is_active"`

	// IsInternal A flag to make product category an internal category for admins
	IsInternal bool `json:"is_internal"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Mpath A string for Materialized Paths - used for finding ancestors and descendents
	Mpath *string `json:"mpath"`

	// Name The product category's name
	Name string `json:"name"`

	// ParentCategory The details of the parent of this category.
	ParentCategory *map[string]interface{} `json:"parent_category"`

	// ParentCategoryId The ID of the parent category.
	ParentCategoryId *string `json:"parent_category_id"`

	// Products The details of the products that belong to this category.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// Rank An integer that depicts the rank of category in a tree node
	Rank *int `json:"rank,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ProductCollection A Product Collection allows grouping together products for promotional purposes. For example, an admin can create a Summer collection, add products to it, and showcase it on the storefront.
type ProductCollection struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Handle A unique string that identifies the Product Collection - can for example be used in slug structures.
	Handle *string `json:"handle"`

	// Id The product collection's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Products The details of the products that belong to this product collection.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// Title The title that the Product Collection is identified by.
	Title string `json:"title"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ProductOption A Product Option defines properties that may vary between different variants of a Product. Common Product Options are "Size" and "Color". Admins are free to create any product options.
type ProductOption struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The product option's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Product The details of the product that this product option belongs to.
	Product *map[string]interface{} `json:"product"`

	// ProductId The ID of the product that this product option belongs to.
	ProductId string `json:"product_id"`

	// Title The title that the Product Option is defined by (e.g. `Size`).
	Title string `json:"title"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Values The details of the values of the product option.
	Values *[]ProductOptionValue `json:"values,omitempty"`
}

// ProductOptionValue An option value is one of the possible values of a Product Option. Product Variants specify a unique combination of product option values.
type ProductOptionValue struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The product option value's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Option The details of the product option that the Product Option Value belongs to.
	Option *map[string]interface{} `json:"option"`

	// OptionId The ID of the Product Option that the Product Option Value belongs to.
	OptionId string `json:"option_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value that the Product Variant has defined for the specific Product Option (e.g. if the Product Option is "Size" this value could be `Small`, `Medium` or `Large`).
	Value string `json:"value"`

	// Variant The details of the product variant that uses this product option value.
	Variant *map[string]interface{} `json:"variant"`

	// VariantId The ID of the product variant that uses this product option value.
	VariantId string `json:"variant_id"`
}

// ProductTag A Product Tag can be added to Products for easy filtering and grouping.
type ProductTag struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The product tag's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value that the Product Tag represents
	Value string `json:"value"`
}

// ProductTaxRate This represents the association between a tax rate and a product to indicate that the product is taxed in a way different than the default.
type ProductTaxRate struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Product A product is a saleable item that holds general information such as name or description. It must include at least one Product Variant, where each product variant defines different options to purchase the product with (for example, different sizes or colors). The prices and inventory of the product are defined on the variant level.
	Product *Product `json:"product,omitempty"`

	// ProductId The ID of the Product
	ProductId string `json:"product_id"`

	// RateId The ID of the Tax Rate
	RateId string `json:"rate_id"`

	// TaxRate A Tax Rate can be used to define a custom rate to charge on specified products, product types, and shipping options within a given region.
	TaxRate *TaxRate `json:"tax_rate,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ProductType A Product Type can be added to Products for filtering and reporting purposes.
type ProductType struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The product type's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value that the Product Type represents.
	Value string `json:"value"`
}

// ProductTypeTaxRate This represents the association between a tax rate and a product type to indicate that the product type is taxed in a different way than the default.
type ProductTypeTaxRate struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ProductType A Product Type can be added to Products for filtering and reporting purposes.
	ProductType *ProductType `json:"product_type,omitempty"`

	// ProductTypeId The ID of the Product type
	ProductTypeId string `json:"product_type_id"`

	// RateId The id of the Tax Rate
	RateId string `json:"rate_id"`

	// TaxRate A Tax Rate can be used to define a custom rate to charge on specified products, product types, and shipping options within a given region.
	TaxRate *TaxRate `json:"tax_rate,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ProductVariant A Product Variant represents a Product with a specific set of Product Option configurations. The maximum number of Product Variants that a Product can have is given by the number of available Product Option combinations. A product must at least have one product variant.
type ProductVariant struct {
	// AllowBackorder Whether the Product Variant should be purchasable when `inventory_quantity` is 0.
	AllowBackorder bool `json:"allow_backorder"`

	// Barcode A generic field for a GTIN number that can be used to identify the Product Variant.
	Barcode *string `json:"barcode"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Ean An EAN barcode number that can be used to identify the Product Variant.
	Ean *string `json:"ean"`

	// Height The height of the Product Variant. May be used in shipping rate calculations.
	Height *float32 `json:"height"`

	// HsCode The Harmonized System code of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code"`

	// Id The product variant's ID
	Id string `json:"id"`

	// InventoryItems The details inventory items of the product variant.
	InventoryItems *[]ProductVariantInventoryItem `json:"inventory_items,omitempty"`

	// InventoryQuantity The current quantity of the item that is stocked.
	InventoryQuantity int `json:"inventory_quantity"`

	// Length The length of the Product Variant. May be used in shipping rate calculations.
	Length *float32 `json:"length"`

	// ManageInventory Whether Medusa should manage inventory for the Product Variant.
	ManageInventory bool `json:"manage_inventory"`

	// Material The material and composition that the Product Variant is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Product Variant. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code"`

	// Options The details of the product options that this product variant defines values for.
	Options *[]ProductOptionValue `json:"options,omitempty"`

	// OriginCountry The country in which the Product Variant was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country"`

	// Prices The details of the prices of the Product Variant, each represented as a Money Amount. Each Money Amount represents a price in a given currency or a specific Region.
	Prices *[]MoneyAmount `json:"prices,omitempty"`

	// Product The details of the product that the product variant belongs to.
	Product *map[string]interface{} `json:"product"`

	// ProductId The ID of the product that the product variant belongs to.
	ProductId string `json:"product_id"`

	// Purchasable Only used with the inventory modules.
	// A boolean value indicating whether the Product Variant is purchasable.
	// A variant is purchasable if:
	//   - inventory is not managed
	//   - it has no inventory items
	//   - it is in stock
	//   - it is backorderable.
	Purchasable *bool `json:"purchasable,omitempty"`

	// Sku The unique stock keeping unit used to identify the Product Variant. This will usually be a unique identifer for the item that is to be shipped, and can be referenced across multiple systems.
	Sku *string `json:"sku"`

	// Title A title that can be displayed for easy identification of the Product Variant.
	Title string `json:"title"`

	// Upc A UPC barcode number that can be used to identify the Product Variant.
	Upc *string `json:"upc"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// VariantRank The ranking of this variant
	VariantRank *float32 `json:"variant_rank"`

	// Weight The weight of the Product Variant. May be used in shipping rate calculations.
	Weight *float32 `json:"weight"`

	// Width The width of the Product Variant. May be used in shipping rate calculations.
	Width *float32 `json:"width"`
}

// ProductVariantInventoryItem A Product Variant Inventory Item links variants with inventory items and denotes the required quantity of the variant.
type ProductVariantInventoryItem struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The product variant inventory item's ID
	Id string `json:"id"`

	// InventoryItemId The id of the inventory item
	InventoryItemId string `json:"inventory_item_id"`

	// RequiredQuantity The quantity of an inventory item required for the variant.
	RequiredQuantity int `json:"required_quantity"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Variant The details of the product variant.
	Variant *map[string]interface{} `json:"variant"`

	// VariantId The id of the variant.
	VariantId string `json:"variant_id"`
}

// PublishableApiKey A Publishable API key defines scopes that resources are available in. Then, it can be used in request to infer the resources without having to directly pass them. For example, a publishable API key can be associated with one or more sales channels. Then, when the publishable API key is passed in the header of a request, it is inferred what sales channel is being used without having to pass the sales channel as a query or body parameter of the request. Publishable API keys can only be used with sales channels, at the moment.
type PublishableApiKey struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The unique identifier of the user that created the key.
	CreatedBy *string `json:"created_by"`

	// Id The key's ID
	Id string `json:"id"`

	// RevokedAt The date with timezone at which the key was revoked.
	RevokedAt *time.Time `json:"revoked_at"`

	// RevokedBy The unique identifier of the user that revoked the key.
	RevokedBy *string `json:"revoked_by"`

	// Title The key's title.
	Title string `json:"title"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// PublishableApiKeySalesChannel This represents the association between the Publishable API keys and Sales Channels
type PublishableApiKeySalesChannel struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The relation's ID
	Id *string `json:"id,omitempty"`

	// PublishableKeyId The publishable API key's ID
	PublishableKeyId string `json:"publishable_key_id"`

	// SalesChannelId The sales channel's ID
	SalesChannelId string `json:"sales_channel_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// Refund A refund represents an amount of money transfered back to the customer for a given reason. Refunds may occur in relation to Returns, Swaps and Claims, but can also be initiated by an admin for an order.
type Refund struct {
	// Amount The amount that has be refunded to the Customer.
	Amount int `json:"amount"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The refund's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of the refund in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Note An optional note explaining why the amount was refunded.
	Note *string `json:"note"`

	// Order The details of the order this refund was created for.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order this refund was created for.
	OrderId *string `json:"order_id"`

	// Payment The details of the payment associated with the refund.
	Payment *map[string]interface{} `json:"payment"`

	// PaymentId The payment's ID, if available.
	PaymentId *string `json:"payment_id"`

	// Reason The reason given for the Refund, will automatically be set when processed as part of a Swap, Claim or Return.
	Reason RefundReason `json:"reason"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// RefundReason The reason given for the Refund, will automatically be set when processed as part of a Swap, Claim or Return.
type RefundReason string

// Region A region holds settings specific to a geographical location, including the currency, tax rates, and fulfillment and payment providers. A Region can consist of multiple countries to accomodate common shopping settings across countries.
type Region struct {
	// AutomaticTaxes Whether taxes should be automated in this region.
	AutomaticTaxes bool `json:"automatic_taxes"`

	// Countries The details of the countries included in this region.
	Countries *[]Country `json:"countries,omitempty"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Currency Currency
	Currency *Currency `json:"currency,omitempty"`

	// CurrencyCode The three character currency code used in the region.
	CurrencyCode string `json:"currency_code"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// FulfillmentProviders The details of the fulfillment providers that can be used to fulfill items of orders and similar resources in the region.
	FulfillmentProviders *[]FulfillmentProvider `json:"fulfillment_providers,omitempty"`

	// GiftCardsTaxable Whether the gift cards are taxable or not in this region.
	GiftCardsTaxable bool `json:"gift_cards_taxable"`

	// Id The region's ID
	Id string `json:"id"`

	// IncludesTax Whether the prices for the region include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the region as displayed to the customer. If the Region only has one country it is recommended to write the country name.
	Name string `json:"name"`

	// PaymentProviders The details of the payment providers that can be used to process payments in the region.
	PaymentProviders *[]PaymentProvider `json:"payment_providers,omitempty"`

	// TaxCode The tax code used on purchases in the Region. This may be used by other systems for accounting purposes.
	TaxCode *string `json:"tax_code"`

	// TaxProvider A tax provider represents a tax service installed in the Medusa backend, either through a plugin or backend customizations. It holds the tax service's installation status.
	TaxProvider *TaxProvider `json:"tax_provider,omitempty"`

	// TaxProviderId The ID of the tax provider used in this region
	TaxProviderId *string `json:"tax_provider_id"`

	// TaxRate The tax rate that should be charged on purchases in the Region.
	TaxRate float32 `json:"tax_rate"`

	// TaxRates The details of the tax rates used in the region, aside from the default rate.
	TaxRates *[]TaxRate `json:"tax_rates,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReservationItemDTO Represents a reservation of an inventory item at a stock location
type ReservationItemDTO struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatedBy UserId of user who created the reservation item
	CreatedBy *string `json:"created_by,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Description Description of the reservation item
	Description *string `json:"description,omitempty"`

	// Id The id of the reservation item
	Id string `json:"id"`

	// InventoryItemId The id of the inventory item the reservation relates to
	InventoryItemId string `json:"inventory_item_id"`

	// LocationId The id of the location of the reservation
	LocationId string `json:"location_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Quantity The id of the reservation item
	Quantity float32 `json:"quantity"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ResponseInventoryItem defines model for ResponseInventoryItem.
type ResponseInventoryItem struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Description Description of the inventory item
	Description *string `json:"description,omitempty"`

	// Height The height of the Inventory Item. May be used in shipping rate calculations.
	Height *float32 `json:"height,omitempty"`

	// HsCode The Harmonized System code of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	HsCode *string `json:"hs_code,omitempty"`

	// Id The inventory item's ID.
	Id *string `json:"id,omitempty"`

	// Length The length of the Inventory Item. May be used in shipping rate calculations.
	Length *float32 `json:"length,omitempty"`

	// LocationLevels The inventory's location levels.
	LocationLevels *[]struct {
		// AvailableQuantity The available quantity in the inventory location.
		AvailableQuantity float32 `json:"available_quantity"`

		// CreatedAt The date with timezone at which the resource was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// DeletedAt The date with timezone at which the resource was deleted.
		DeletedAt *time.Time `json:"deleted_at,omitempty"`

		// Description Description of the inventory item
		Description *string `json:"description,omitempty"`

		// Height The height of the Inventory Item. May be used in shipping rate calculations.
		Height *float32 `json:"height,omitempty"`

		// HsCode The Harmonized System code of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
		HsCode *string `json:"hs_code,omitempty"`

		// Id The inventory item's ID.
		Id *string `json:"id,omitempty"`

		// Length The length of the Inventory Item. May be used in shipping rate calculations.
		Length *float32 `json:"length,omitempty"`

		// Material The material and composition that the Inventory Item is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
		Material *string `json:"material,omitempty"`

		// Metadata An optional key-value map with additional details
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// MidCode The Manufacturers Identification code that identifies the manufacturer of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
		MidCode *string `json:"mid_code,omitempty"`

		// OriginCountry The country in which the Inventory Item was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
		OriginCountry *string `json:"origin_country,omitempty"`

		// RequiresShipping Whether the item requires shipping.
		RequiresShipping *bool `json:"requires_shipping,omitempty"`

		// Sku The Stock Keeping Unit (SKU) code of the Inventory Item.
		Sku string `json:"sku"`

		// Thumbnail Thumbnail for the inventory item
		Thumbnail *string `json:"thumbnail,omitempty"`

		// Title Title of the inventory item
		Title *string `json:"title,omitempty"`

		// UpdatedAt The date with timezone at which the resource was updated.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`

		// Weight The weight of the Inventory Item. May be used in shipping rate calculations.
		Weight *float32 `json:"weight,omitempty"`

		// Width The width of the Inventory Item. May be used in shipping rate calculations.
		Width *float32 `json:"width,omitempty"`
	} `json:"location_levels,omitempty"`

	// Material The material and composition that the Inventory Item is made of, May be used by Fulfillment Providers to pass customs information to shipping carriers.
	Material *string `json:"material,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// MidCode The Manufacturers Identification code that identifies the manufacturer of the Inventory Item. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	MidCode *string `json:"mid_code,omitempty"`

	// OriginCountry The country in which the Inventory Item was produced. May be used by Fulfillment Providers to pass customs information to shipping carriers.
	OriginCountry *string `json:"origin_country,omitempty"`

	// RequiresShipping Whether the item requires shipping.
	RequiresShipping *bool `json:"requires_shipping,omitempty"`

	// Sku The Stock Keeping Unit (SKU) code of the Inventory Item.
	Sku string `json:"sku"`

	// Thumbnail Thumbnail for the inventory item
	Thumbnail *string `json:"thumbnail,omitempty"`

	// Title Title of the inventory item
	Title *string `json:"title,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Weight The weight of the Inventory Item. May be used in shipping rate calculations.
	Weight *float32 `json:"weight,omitempty"`

	// Width The width of the Inventory Item. May be used in shipping rate calculations.
	Width *float32 `json:"width,omitempty"`
}

// Return A Return holds information about Line Items that a Customer wishes to send back, along with how the items will be returned. Returns can also be used as part of a Swap or a Claim.
type Return struct {
	// ClaimOrder The details of the claim that the return may belong to.
	ClaimOrder *map[string]interface{} `json:"claim_order"`

	// ClaimOrderId The ID of the claim that the return may belong to.
	ClaimOrderId *string `json:"claim_order_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The return's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of the return in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Items The details of the items that the customer is returning.
	Items *[]ReturnItem `json:"items,omitempty"`

	// LocationId The ID of the stock location the return will be added back.
	LocationId *string `json:"location_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// NoNotification When set to true, no notification will be sent related to this return.
	NoNotification *bool `json:"no_notification"`

	// Order The details of the order that the return was created for.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the return was created for.
	OrderId *string `json:"order_id"`

	// ReceivedAt The date with timezone at which the return was received.
	ReceivedAt *time.Time `json:"received_at"`

	// RefundAmount The amount that should be refunded as a result of the return.
	RefundAmount int `json:"refund_amount"`

	// ShippingData Data about the return shipment as provided by the Fulfilment Provider that handles the return shipment.
	ShippingData *map[string]interface{} `json:"shipping_data"`

	// ShippingMethod A Shipping Method represents a way in which an Order or Return can be shipped. Shipping Methods are created from a Shipping Option, but may contain additional details that can be necessary for the Fulfillment Provider to handle the shipment. If the shipping method is created for a return, it may be associated with a claim or a swap that the return is part of.
	ShippingMethod *ShippingMethod `json:"shipping_method,omitempty"`

	// Status Status of the Return.
	Status ReturnStatus `json:"status"`

	// Swap The details of the swap that the return may belong to.
	Swap *map[string]interface{} `json:"swap"`

	// SwapId The ID of the swap that the return may belong to.
	SwapId *string `json:"swap_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ReturnStatus Status of the Return.
type ReturnStatus string

// ReturnItem A return item represents a line item in an order that is to be returned. It includes details related to the return and the reason behind it.
type ReturnItem struct {
	// IsRequested Whether the Return Item was requested initially or received unexpectedly in the warehouse.
	IsRequested bool `json:"is_requested"`

	// Item Line Items are created when a product is added to a Cart. When Line Items are purchased they will get copied to the resulting order, swap, or claim, and can eventually be referenced in Fulfillments and Returns. Line items may also be used for order edits.
	Item *LineItem `json:"item,omitempty"`

	// ItemId The ID of the Line Item that the Return Item references.
	ItemId string `json:"item_id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Note An optional note with additional details about the Return.
	Note *string `json:"note"`

	// Quantity The quantity of the Line Item to be returned.
	Quantity int `json:"quantity"`

	// Reason A Return Reason is a value defined by an admin. It can be used on Return Items in order to indicate why a Line Item was returned.
	Reason *ReturnReason `json:"reason,omitempty"`

	// ReasonId The ID of the reason for returning the item.
	ReasonId *string `json:"reason_id"`

	// ReceivedQuantity The quantity that was received in the warehouse.
	ReceivedQuantity *int `json:"received_quantity"`

	// RequestedQuantity The quantity that was originally requested to be returned.
	RequestedQuantity *int `json:"requested_quantity"`

	// ReturnId The ID of the Return that the Return Item belongs to.
	ReturnId string `json:"return_id"`

	// ReturnOrder Details of the Return that the Return Item belongs to.
	ReturnOrder *map[string]interface{} `json:"return_order"`
}

// ReturnReason A Return Reason is a value defined by an admin. It can be used on Return Items in order to indicate why a Line Item was returned.
type ReturnReason struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description A description of the Reason.
	Description *string `json:"description"`

	// Id The return reason's ID
	Id string `json:"id"`

	// Label A text that can be displayed to the Customer as a reason.
	Label string `json:"label"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// ParentReturnReason The details of the parent reason.
	ParentReturnReason *map[string]interface{} `json:"parent_return_reason"`

	// ParentReturnReasonId The ID of the parent reason.
	ParentReturnReasonId *string `json:"parent_return_reason_id"`

	// ReturnReasonChildren The details of the child reasons.
	ReturnReasonChildren *map[string]interface{} `json:"return_reason_children,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Value The value to identify the reason by.
	Value string `json:"value"`
}

// SalesChannel A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
type SalesChannel struct {
	// Carts The associated carts.
	Carts *[]map[string]interface{} `json:"carts"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Description The description of the sales channel.
	Description *string `json:"description"`

	// Id The sales channel's ID
	Id string `json:"id"`

	// IsDisabled Specify if the sales channel is enabled or disabled.
	IsDisabled bool `json:"is_disabled"`

	// Locations The details of the stock locations related to the sales channel.
	Locations *[]SalesChannelLocation `json:"locations,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the sales channel.
	Name string `json:"name"`

	// Orders The associated orders.
	Orders *[]map[string]interface{} `json:"orders"`

	// PublishableKeys The associated publishable API keys.
	PublishableKeys *[]map[string]interface{} `json:"publishableKeys"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// SalesChannelLocation This represents the association between a sales channel and a stock locations.
type SalesChannelLocation struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The Sales Channel Stock Location's ID
	Id string `json:"id"`

	// LocationId The ID of the Location Stock.
	LocationId string `json:"location_id"`

	// SalesChannel The details of the sales channel the location is associated with.
	SalesChannel *map[string]interface{} `json:"sales_channel"`

	// SalesChannelId The ID of the Sales Channel
	SalesChannelId string `json:"sales_channel_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ShippingMethod A Shipping Method represents a way in which an Order or Return can be shipped. Shipping Methods are created from a Shipping Option, but may contain additional details that can be necessary for the Fulfillment Provider to handle the shipment. If the shipping method is created for a return, it may be associated with a claim or a swap that the return is part of.
type ShippingMethod struct {
	// Cart The details of the cart that the shipping method is used in.
	Cart *map[string]interface{} `json:"cart"`

	// CartId The ID of the cart that the shipping method is used in.
	CartId *string `json:"cart_id"`

	// ClaimOrder The details of the claim that the shipping method is used in.
	ClaimOrder *map[string]interface{} `json:"claim_order"`

	// ClaimOrderId The ID of the claim that the shipping method is used in.
	ClaimOrderId *string `json:"claim_order_id"`

	// Data Additional data that the Fulfillment Provider needs to fulfill the shipment. This is used in combination with the Shipping Options data, and may contain information such as a drop point id.
	Data map[string]interface{} `json:"data"`

	// Id The shipping method's ID
	Id string `json:"id"`

	// IncludesTax Whether the shipping method price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// Order The details of the order that the shipping method is used in.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the shipping method is used in.
	OrderId *string `json:"order_id"`

	// Price The amount to charge for the Shipping Method. The currency of the price is defined by the Region that the Order that the Shipping Method belongs to is a part of.
	Price int `json:"price"`

	// ReturnId The ID of the return that the shipping method is used in.
	ReturnId *string `json:"return_id"`

	// ReturnOrder The details of the return that the shipping method is used in.
	ReturnOrder *map[string]interface{} `json:"return_order"`

	// ShippingOption A Shipping Option represents a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

	// ShippingOptionId The ID of the Shipping Option that the Shipping Method is built from.
	ShippingOptionId string `json:"shipping_option_id"`

	// Subtotal The subtotal of the shipping
	Subtotal *int `json:"subtotal,omitempty"`

	// Swap The details of the swap that the shipping method is used in.
	Swap *map[string]interface{} `json:"swap"`

	// SwapId The ID of the swap that the shipping method is used in.
	SwapId *string `json:"swap_id"`

	// TaxLines The details of the tax lines applied on the shipping method.
	TaxLines *[]ShippingMethodTaxLine `json:"tax_lines,omitempty"`

	// TaxTotal The total of tax
	TaxTotal *int `json:"tax_total,omitempty"`

	// Total The total amount of the shipping
	Total *int `json:"total,omitempty"`
}

// ShippingMethodTaxLine A Shipping Method Tax Line represents the taxes applied on a shipping method in a cart.
type ShippingMethodTaxLine struct {
	// Code A code to identify the tax type by
	Code *string `json:"code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The line item tax line's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name A human friendly name for the tax
	Name string `json:"name"`

	// Rate The numeric rate to charge tax by
	Rate float32 `json:"rate"`

	// ShippingMethod The details of the associated shipping method.
	ShippingMethod *map[string]interface{} `json:"shipping_method"`

	// ShippingMethodId The ID of the line item
	ShippingMethodId string `json:"shipping_method_id"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ShippingOption A Shipping Option represents a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
type ShippingOption struct {
	// AdminOnly Flag to indicate if the Shipping Option usage is restricted to admin users.
	AdminOnly bool `json:"admin_only"`

	// Amount The amount to charge for shipping when the Shipping Option price type is `flat_rate`.
	Amount *int `json:"amount"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Data The data needed for the Fulfillment Provider to identify the Shipping Option.
	Data map[string]interface{} `json:"data"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The shipping option's ID
	Id string `json:"id"`

	// IncludesTax Whether the shipping option price include tax
	IncludesTax *bool `json:"includes_tax,omitempty"`

	// IsReturn Flag to indicate if the Shipping Option can be used for Return shipments.
	IsReturn bool `json:"is_return"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name given to the Shipping Option - this may be displayed to the Customer.
	Name string `json:"name"`

	// PriceType The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
	PriceType ShippingOptionPriceType `json:"price_type"`

	// Profile A Shipping Profile has a set of defined Shipping Options that can be used to fulfill a given set of Products. For example, gift cards are shipped differently than physical products, so a shipping profile with the type `gift_card` groups together the shipping options that can only be used for gift cards.
	Profile *ShippingProfile `json:"profile,omitempty"`

	// ProfileId The ID of the Shipping Profile that the shipping option belongs to.
	ProfileId string `json:"profile_id"`

	// Provider A fulfillment provider represents a fulfillment service installed in the Medusa backend, either through a plugin or backend customizations. It holds the fulfillment service's installation status.
	Provider *FulfillmentProvider `json:"provider,omitempty"`

	// ProviderId The ID of the fulfillment provider that will be used to later to process the shipping method created from this shipping option and its fulfillments.
	ProviderId string `json:"provider_id"`

	// Region The details of the region this shipping option can be used in.
	Region *map[string]interface{} `json:"region"`

	// RegionId The ID of the region this shipping option can be used in.
	RegionId string `json:"region_id"`

	// Requirements The details of the requirements that must be satisfied for the Shipping Option to be available for usage in a Cart.
	Requirements *[]ShippingOptionRequirement `json:"requirements,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ShippingOptionPriceType The type of pricing calculation that is used when creatin Shipping Methods from the Shipping Option. Can be `flat_rate` for fixed prices or `calculated` if the Fulfillment Provider can provide price calulations.
type ShippingOptionPriceType string

// ShippingOptionRequirement A shipping option requirement defines conditions that a Cart must satisfy for the Shipping Option to be available for usage in the Cart.
type ShippingOptionRequirement struct {
	// Amount The amount to compare the Cart subtotal to.
	Amount int `json:"amount"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The shipping option requirement's ID
	Id string `json:"id"`

	// ShippingOption The details of the shipping option that the requirements belong to.
	ShippingOption *map[string]interface{} `json:"shipping_option"`

	// ShippingOptionId The ID of the shipping option that the requirements belong to.
	ShippingOptionId string `json:"shipping_option_id"`

	// Type The type of the requirement, this defines how the value will be compared to the Cart's total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
	Type ShippingOptionRequirementType `json:"type"`
}

// ShippingOptionRequirementType The type of the requirement, this defines how the value will be compared to the Cart's total. `min_subtotal` requirements define the minimum subtotal that is needed for the Shipping Option to be available, while the `max_subtotal` defines the maximum subtotal that the Cart can have for the Shipping Option to be available.
type ShippingOptionRequirementType string

// ShippingProfile A Shipping Profile has a set of defined Shipping Options that can be used to fulfill a given set of Products. For example, gift cards are shipped differently than physical products, so a shipping profile with the type `gift_card` groups together the shipping options that can only be used for gift cards.
type ShippingProfile struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Id The shipping profile's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name given to the Shipping profile - this may be displayed to the Customer.
	Name string `json:"name"`

	// Products The details of the products that the Shipping Profile defines Shipping Options for. Available if the relation `products` is expanded.
	Products *[]map[string]interface{} `json:"products,omitempty"`

	// ShippingOptions The details of the shipping options that can be used to create shipping methods for the Products in the Shipping Profile.
	ShippingOptions *[]map[string]interface{} `json:"shipping_options,omitempty"`

	// Type The type of the Shipping Profile, may be `default`, `gift_card` or `custom`.
	Type string `json:"type"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// ShippingTaxRate This represents the tax rates applied on a shipping option.
type ShippingTaxRate struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// RateId The ID of the associated tax rate.
	RateId string `json:"rate_id"`

	// ShippingOption A Shipping Option represents a way in which an Order or Return can be shipped. Shipping Options have an associated Fulfillment Provider that will be used when the fulfillment of an Order is initiated. Shipping Options themselves cannot be added to Carts, but serve as a template for Shipping Methods. This distinction makes it possible to customize individual Shipping Methods with additional information.
	ShippingOption *ShippingOption `json:"shipping_option,omitempty"`

	// ShippingOptionId The ID of the shipping option.
	ShippingOptionId string `json:"shipping_option_id"`

	// TaxRate A Tax Rate can be used to define a custom rate to charge on specified products, product types, and shipping options within a given region.
	TaxRate *TaxRate `json:"tax_rate,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StagedJob A staged job resource
type StagedJob struct {
	// Data Data necessary for the job
	Data map[string]interface{} `json:"data"`

	// EventName The name of the event
	EventName string `json:"event_name"`

	// Id The staged job's ID
	Id string `json:"id"`

	// Option The staged job's option
	Option *map[string]interface{} `json:"option,omitempty"`
}

// StockLocationAddressDTO Represents a Stock Location Address
type StockLocationAddressDTO struct {
	// Address1 Stock location address
	Address1 string `json:"address_1"`

	// Address2 Stock location address' complement
	Address2 *string `json:"address_2,omitempty"`

	// City Stock location address' city
	City *string `json:"city,omitempty"`

	// Company Stock location company' name
	Company *string `json:"company,omitempty"`

	// CountryCode Stock location address' country
	CountryCode string `json:"country_code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The stock location address' ID
	Id *string `json:"id,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone Stock location address' phone number
	Phone *string `json:"phone,omitempty"`

	// PostalCode Stock location address' postal code
	PostalCode *string `json:"postal_code,omitempty"`

	// Province Stock location address' province
	Province *string `json:"province,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StockLocationAddressInput Represents a Stock Location Address Input
type StockLocationAddressInput struct {
	// Address1 Stock location address
	Address1 string `json:"address_1"`

	// Address2 Stock location address' complement
	Address2 *string `json:"address_2,omitempty"`

	// City Stock location address' city
	City *string `json:"city,omitempty"`

	// CountryCode Stock location address' country
	CountryCode string `json:"country_code"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Phone Stock location address' phone number
	Phone *string `json:"phone,omitempty"`

	// PostalCode Stock location address' postal code
	PostalCode *string `json:"postal_code,omitempty"`

	// Province Stock location address' province
	Province *string `json:"province,omitempty"`
}

// StockLocationDTO Represents a Stock Location
type StockLocationDTO struct {
	// Address The Address of the Stock Location
	Address *struct {
		// Address1 Stock location address
		Address1 string `json:"address_1"`

		// Address2 Stock location address' complement
		Address2 *string `json:"address_2,omitempty"`

		// City Stock location address' city
		City *string `json:"city,omitempty"`

		// Company Stock location company' name
		Company *string `json:"company,omitempty"`

		// CountryCode Stock location address' country
		CountryCode string `json:"country_code"`

		// CreatedAt The date with timezone at which the resource was created.
		CreatedAt time.Time `json:"created_at"`

		// DeletedAt The date with timezone at which the resource was deleted.
		DeletedAt *time.Time `json:"deleted_at,omitempty"`

		// Id The stock location address' ID
		Id *string `json:"id,omitempty"`

		// Metadata An optional key-value map with additional details
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Phone Stock location address' phone number
		Phone *string `json:"phone,omitempty"`

		// PostalCode Stock location address' postal code
		PostalCode *string `json:"postal_code,omitempty"`

		// Province Stock location address' province
		Province *string `json:"province,omitempty"`

		// UpdatedAt The date with timezone at which the resource was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"address,omitempty"`

	// AddressId Stock location address' ID
	AddressId string `json:"address_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The stock location's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the stock location
	Name string `json:"name"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// StockLocationExpandedDTO defines model for StockLocationExpandedDTO.
type StockLocationExpandedDTO struct {
	// Address The Address of the Stock Location
	Address *struct {
		// Address1 Stock location address
		Address1 string `json:"address_1"`

		// Address2 Stock location address' complement
		Address2 *string `json:"address_2,omitempty"`

		// City Stock location address' city
		City *string `json:"city,omitempty"`

		// Company Stock location company' name
		Company *string `json:"company,omitempty"`

		// CountryCode Stock location address' country
		CountryCode string `json:"country_code"`

		// CreatedAt The date with timezone at which the resource was created.
		CreatedAt time.Time `json:"created_at"`

		// DeletedAt The date with timezone at which the resource was deleted.
		DeletedAt *time.Time `json:"deleted_at,omitempty"`

		// Id The stock location address' ID
		Id *string `json:"id,omitempty"`

		// Metadata An optional key-value map with additional details
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Phone Stock location address' phone number
		Phone *string `json:"phone,omitempty"`

		// PostalCode Stock location address' postal code
		PostalCode *string `json:"postal_code,omitempty"`

		// Province Stock location address' province
		Province *string `json:"province,omitempty"`

		// UpdatedAt The date with timezone at which the resource was updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"address,omitempty"`

	// AddressId Stock location address' ID
	AddressId string `json:"address_id"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Id The stock location's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The name of the stock location
	Name string `json:"name"`

	// SalesChannels A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
	SalesChannels *SalesChannel `json:"sales_channels,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// Store A store holds the main settings of the commerce shop. By default, only one store is created and used within the Medusa backend. It holds settings related to the name of the store, available currencies, and more.
type Store struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Currencies The details of the enabled currencies in the store.
	Currencies *[]Currency `json:"currencies,omitempty"`

	// DefaultCurrency Currency
	DefaultCurrency *Currency `json:"default_currency,omitempty"`

	// DefaultCurrencyCode The three character currency code that is the default of the store.
	DefaultCurrencyCode string `json:"default_currency_code"`

	// DefaultLocationId The location ID the store is associated with.
	DefaultLocationId *string `json:"default_location_id"`

	// DefaultSalesChannel A Sales Channel is a method a business offers its products for purchase for the customers. For example, a Webshop can be a sales channel, and a mobile app can be another.
	DefaultSalesChannel *SalesChannel `json:"default_sales_channel,omitempty"`

	// DefaultSalesChannelId The ID of the store's default sales channel.
	DefaultSalesChannelId *string `json:"default_sales_channel_id"`

	// Id The store's ID
	Id string `json:"id"`

	// InviteLinkTemplate A template to generate Invite links from
	InviteLinkTemplate *string `json:"invite_link_template"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the Store - this may be displayed to the Customer.
	Name string `json:"name"`

	// PaymentLinkTemplate A template to generate Payment links from. Use {{cart_id}} to include the payment's `cart_id` in the link.
	PaymentLinkTemplate *string `json:"payment_link_template"`

	// SwapLinkTemplate A template to generate Swap links from. Use {{cart_id}} to include the Swap's `cart_id` in the link.
	SwapLinkTemplate *string `json:"swap_link_template"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// Swap A swap can be created when a Customer wishes to exchange Products that they have purchased with different Products. It consists of a Return of previously purchased Products and a Fulfillment of new Products. It also includes information on any additional payment or refund required based on the difference between the exchanged products.
type Swap struct {
	// AdditionalItems The details of the new products to send to the customer, represented as line items.
	AdditionalItems *[]LineItem `json:"additional_items,omitempty"`

	// AllowBackorder If true, swaps can be completed with items out of stock
	AllowBackorder bool `json:"allow_backorder"`

	// CanceledAt The date with timezone at which the Swap was canceled.
	CanceledAt *time.Time `json:"canceled_at"`

	// Cart The details of the cart that the customer uses to complete the swap.
	Cart *map[string]interface{} `json:"cart"`

	// CartId The ID of the cart that the customer uses to complete the swap.
	CartId *string `json:"cart_id"`

	// ConfirmedAt The date with timezone at which the Swap was confirmed by the Customer.
	ConfirmedAt *time.Time `json:"confirmed_at"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// DifferenceDue The difference amount between the order’s original total and the new total imposed by the swap. If its value is negative, a refund must be issues to the customer. If it's positive, additional payment must be authorized by the customer. Otherwise, no payment processing is required.
	DifferenceDue *int `json:"difference_due"`

	// FulfillmentStatus The status of the Fulfillment of the Swap.
	FulfillmentStatus SwapFulfillmentStatus `json:"fulfillment_status"`

	// Fulfillments The details of the fulfillments that are used to send the new items to the customer.
	Fulfillments *[]map[string]interface{} `json:"fulfillments,omitempty"`

	// Id The swap's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of the swap in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// NoNotification If set to true, no notification will be sent related to this swap
	NoNotification *bool `json:"no_notification"`

	// Order The details of the order that the swap belongs to.
	Order *map[string]interface{} `json:"order"`

	// OrderId The ID of the order that the swap belongs to.
	OrderId string `json:"order_id"`

	// Payment The details of the additional payment authorized by the customer when `difference_due` is positive.
	Payment *map[string]interface{} `json:"payment"`

	// PaymentStatus The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
	PaymentStatus SwapPaymentStatus `json:"payment_status"`

	// ReturnOrder The details of the return that belongs to the swap, which holds the details on the items being returned.
	ReturnOrder *map[string]interface{} `json:"return_order"`

	// ShippingAddress An address is used across the Medusa backend within other schemas and object types. For example, a customer's billing and shipping addresses both use the Address entity.
	ShippingAddress *Address `json:"shipping_address,omitempty"`

	// ShippingAddressId The Address to send the new Line Items to - in most cases this will be the same as the shipping address on the Order.
	ShippingAddressId *string `json:"shipping_address_id"`

	// ShippingMethods The details of the shipping methods used to fulfill the additional items purchased.
	ShippingMethods *[]ShippingMethod `json:"shipping_methods,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// SwapFulfillmentStatus The status of the Fulfillment of the Swap.
type SwapFulfillmentStatus string

// SwapPaymentStatus The status of the Payment of the Swap. The payment may either refer to the refund of an amount or the authorization of a new amount.
type SwapPaymentStatus string

// TaxLine A tax line represents the taxes amount applied to a line item.
type TaxLine struct {
	// Code A code to identify the tax type by
	Code *string `json:"code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The tax line's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name A human friendly name for the tax
	Name string `json:"name"`

	// Rate The numeric rate to charge tax by
	Rate float32 `json:"rate"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// TaxProvider A tax provider represents a tax service installed in the Medusa backend, either through a plugin or backend customizations. It holds the tax service's installation status.
type TaxProvider struct {
	// Id The ID of the tax provider as given by the tax service.
	Id string `json:"id"`

	// IsInstalled Whether the tax service is installed in the current version. If a tax service is no longer installed, the `is_installed` attribute is set to `false`.
	IsInstalled bool `json:"is_installed"`
}

// TaxRate A Tax Rate can be used to define a custom rate to charge on specified products, product types, and shipping options within a given region.
type TaxRate struct {
	// Code A code to identify the tax type by
	Code *string `json:"code"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The tax rate's ID
	Id string `json:"id"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Name A human friendly name for the tax
	Name string `json:"name"`

	// ProductCount The count of products
	ProductCount *int `json:"product_count,omitempty"`

	// ProductTypeCount The count of product types
	ProductTypeCount *int `json:"product_type_count,omitempty"`

	// ProductTypes The details of the product types that belong to this tax rate.
	ProductTypes *[]ProductType `json:"product_types,omitempty"`

	// Products The details of the products that belong to this tax rate.
	Products *[]Product `json:"products,omitempty"`

	// Rate The numeric rate to charge
	Rate *float32 `json:"rate"`

	// Region The details of the region that the rate belongs to.
	Region *map[string]interface{} `json:"region"`

	// RegionId The ID of the region that the rate belongs to.
	RegionId string `json:"region_id"`

	// ShippingOptionCount The count of shipping options
	ShippingOptionCount *int `json:"shipping_option_count,omitempty"`

	// ShippingOptions The details of the shipping options that belong to this tax rate.
	ShippingOptions *[]ShippingOption `json:"shipping_options,omitempty"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// TrackingLink A tracking link holds information about tracking numbers for a Fulfillment. Tracking Links can optionally contain a URL that can be visited to see the status of the shipment. Typically, the tracking link is provided from the third-party service integrated through the used fulfillment provider.
type TrackingLink struct {
	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Fulfillment The details of the fulfillment that the tracking link belongs to.
	Fulfillment *map[string]interface{} `json:"fulfillment"`

	// FulfillmentId The ID of the fulfillment that the tracking link belongs to.
	FulfillmentId string `json:"fulfillment_id"`

	// Id The tracking link's ID
	Id string `json:"id"`

	// IdempotencyKey Randomly generated key used to continue the completion of a process in case of failure.
	IdempotencyKey *string `json:"idempotency_key"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// TrackingNumber The tracking number given by the shipping carrier.
	TrackingNumber string `json:"tracking_number"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Url The URL at which the status of the shipment can be tracked.
	Url *string `json:"url"`
}

// UpdateStockLocationInput Represents the Input to update a Stock Location
type UpdateStockLocationInput struct {
	// Address Stock location address object
	Address *struct {
		// Address1 Stock location address
		Address1 string `json:"address_1"`

		// Address2 Stock location address' complement
		Address2 *string `json:"address_2,omitempty"`

		// City Stock location address' city
		City *string `json:"city,omitempty"`

		// CountryCode Stock location address' country
		CountryCode string `json:"country_code"`

		// Metadata An optional key-value map with additional details
		Metadata *map[string]interface{} `json:"metadata,omitempty"`

		// Phone Stock location address' phone number
		Phone *string `json:"phone,omitempty"`

		// PostalCode Stock location address' postal code
		PostalCode *string `json:"postal_code,omitempty"`

		// Province Stock location address' province
		Province *string `json:"province,omitempty"`
	} `json:"address,omitempty"`

	// AddressId The Stock location address ID
	AddressId *string `json:"address_id,omitempty"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name The stock location name
	Name *string `json:"name,omitempty"`
}

// User A User is an administrator who can manage store settings and data.
type User struct {
	// ApiToken An API token associated with the user.
	ApiToken *string `json:"api_token"`

	// CreatedAt The date with timezone at which the resource was created.
	CreatedAt time.Time `json:"created_at"`

	// DeletedAt The date with timezone at which the resource was deleted.
	DeletedAt *time.Time `json:"deleted_at"`

	// Email The email of the User
	Email openapi_types.Email `json:"email"`

	// FirstName The first name of the User
	FirstName *string `json:"first_name"`

	// Id The user's ID
	Id string `json:"id"`

	// LastName The last name of the User
	LastName *string `json:"last_name"`

	// Metadata An optional key-value map with additional details
	Metadata *map[string]interface{} `json:"metadata"`

	// Role The user's role. These roles don't provide any different privileges.
	Role UserRole `json:"role"`

	// UpdatedAt The date with timezone at which the resource was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// UserRole The user's role. These roles don't provide any different privileges.
type UserRole string

// VariantInventory defines model for VariantInventory.
type VariantInventory struct {
	// Id the ID of the variant
	Id        string                `json:"id"`
	Inventory ResponseInventoryItem `json:"inventory"`

	// SalesChannelAvailability Details about the variant's inventory availability in sales channels.
	SalesChannelAvailability []struct {
		// AvailableQuantity Available quantity in the sales channel
		AvailableQuantity float32 `json:"available_quantity"`

		// ChannelId Sales channel's ID
		ChannelId string `json:"channel_id"`

		// ChannelName Sales channel's name
		ChannelName string `json:"channel_name"`
	} `json:"sales_channel_availability"`
}

// N400Error defines model for 400_error.
type N400Error struct {
	union json.RawMessage
}

// N500Error defines model for 500_error.
type N500Error = Error

// DefaultError defines model for default_error.
type DefaultError = Error

// InvalidRequestError defines model for invalid_request_error.
type InvalidRequestError = Error

// InvalidStateError defines model for invalid_state_error.
type InvalidStateError = Error

// NotFoundError defines model for not_found_error.
type NotFoundError = Error

// GetBatchJobsParams defines parameters for GetBatchJobs.
type GetBatchJobsParams struct {
	// Limit Limit the number of batch jobs returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of batch jobs to skip when retrieving the batch jobs.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Id Filter by the batch ID
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Type Filter by the batch type
	Type *[]string `form:"type,omitempty" json:"type,omitempty"`

	// ConfirmedAt Filter by a confirmation date range.
	ConfirmedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"confirmed_at,omitempty" json:"confirmed_at,omitempty"`

	// PreProcessedAt Filter by a pre-processing date range.
	PreProcessedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"pre_processed_at,omitempty" json:"pre_processed_at,omitempty"`

	// CompletedAt Filter by a completion date range.
	CompletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"completed_at,omitempty" json:"completed_at,omitempty"`

	// FailedAt Filter by a failure date range.
	FailedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"failed_at,omitempty" json:"failed_at,omitempty"`

	// CanceledAt Filter by a cancelation date range.
	CanceledAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"canceled_at,omitempty" json:"canceled_at,omitempty"`

	// Order A batch-job field to sort-order the retrieved batch jobs by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned batch jobs.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned batch jobs.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetBatchJobsParamsId0 defines parameters for GetBatchJobs.
type GetBatchJobsParamsId0 = string

// GetBatchJobsParamsId1 defines parameters for GetBatchJobs.
type GetBatchJobsParamsId1 = []string

// GetCollectionsParams defines parameters for GetCollections.
type GetCollectionsParams struct {
	// Limit The number of collections to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of collections to skip when retrieving the collections.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Title Filter collections by their title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// Handle Filter collections by their handle.
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// Q a term to search collections by their title or handle.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A field to sort-order the retrieved collections by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DiscountConditionId Filter collections by a discount condition ID associated with them.
	DiscountConditionId *string `form:"discount_condition_id,omitempty" json:"discount_condition_id,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// GetCurrenciesParams defines parameters for GetCurrencies.
type GetCurrenciesParams struct {
	// Code filter by currency code.
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// IncludesTax filter currencies by whether they include taxes or not.
	IncludesTax *bool `form:"includes_tax,omitempty" json:"includes_tax,omitempty"`

	// Order A field to sort order the retrieved currencies by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Q Term used to search currencies' name and code.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Offset The number of currencies to skip when retrieving the currencies.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of currencies to return.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetCustomerGroupsParams defines parameters for GetCustomerGroups.
type GetCustomerGroupsParams struct {
	// Q term to search customer groups by name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Offset The number of customer groups to skip when retrieving the customer groups.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Order A field to sort order the retrieved customer groups by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DiscountConditionId Filter by discount condition ID.
	DiscountConditionId *string `form:"discount_condition_id,omitempty" json:"discount_condition_id,omitempty"`

	// Id Filter by the customer group ID
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Name Filter by the customer group name
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Limit The number of customer groups to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned customer groups.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned customer groups.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomerGroupsParamsId0 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsId0 = string

// GetCustomerGroupsParamsId1 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsId1 = []string

// GetCustomerGroupsParamsId2 defines parameters for GetCustomerGroups.
type GetCustomerGroupsParamsId2 struct {
	// Gt filter by IDs greater than this ID
	Gt *string `json:"gt,omitempty"`

	// Gte filter by IDs greater than or equal to this ID
	Gte *string `json:"gte,omitempty"`

	// Lt filter by IDs less than this ID
	Lt *string `json:"lt,omitempty"`

	// Lte filter by IDs less than or equal to this ID
	Lte *string `json:"lte,omitempty"`
}

// GetCustomerGroupsGroupParams defines parameters for GetCustomerGroupsGroup.
type GetCustomerGroupsGroupParams struct {
	// Expand Comma-separated relations that should be expanded in the returned customer group.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned customer group.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetCustomerGroupsGroupCustomersParams defines parameters for GetCustomerGroupsGroupCustomers.
type GetCustomerGroupsGroupCustomersParams struct {
	// Limit The number of customers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of customers to skip when retrieving the customers.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned customers.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Q a term to search customers by email, first_name, and last_name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// GetCustomersParams defines parameters for GetCustomers.
type GetCustomersParams struct {
	// Limit The number of customers to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of customers to skip when retrieving the customers.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned customers.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned customers.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Q term to search customers' email, first_name, and last_name fields.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// HasAccount Filter customers by whether they have an account.
	HasAccount *bool `form:"has_account,omitempty" json:"has_account,omitempty"`

	// Order A field to sort-order the retrieved customers by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Groups Filter by customer group IDs.
	Groups *[]string `form:"groups,omitempty" json:"groups,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetCustomersCustomerParams defines parameters for GetCustomersCustomer.
type GetCustomersCustomerParams struct {
	// Expand Comma-separated relations that should be expanded in the returned customer.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned customer.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostCustomersCustomerParams defines parameters for PostCustomersCustomer.
type PostCustomersCustomerParams struct {
	// Expand Comma-separated relations that should be expanded in the returned customer.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be retrieved in the returned customer.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsParams defines parameters for GetDiscounts.
type GetDiscountsParams struct {
	// Q term to search discounts' code field.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Rule Filter discounts by rule fields.
	Rule *struct {
		// Allocation Filter discounts by allocation type.
		Allocation *GetDiscountsParamsRuleAllocation `json:"allocation,omitempty"`

		// Type Filter discounts by type.
		Type *GetDiscountsParamsRuleType `json:"type,omitempty"`
	} `form:"rule,omitempty" json:"rule,omitempty"`

	// IsDynamic Filter discounts by whether they're dynamic or not.
	IsDynamic *bool `form:"is_dynamic,omitempty" json:"is_dynamic,omitempty"`

	// IsDisabled Filter discounts by whether they're disabled or not.
	IsDisabled *bool `form:"is_disabled,omitempty" json:"is_disabled,omitempty"`

	// Limit The number of discounts to return
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of discounts to skip when retrieving the discounts.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Expand Comma-separated relations that should be expanded in each returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Order A discount field to sort-order the retrieved discounts by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetDiscountsParamsRuleAllocation defines parameters for GetDiscounts.
type GetDiscountsParamsRuleAllocation string

// GetDiscountsParamsRuleType defines parameters for GetDiscounts.
type GetDiscountsParamsRuleType string

// PostDiscountsParams defines parameters for PostDiscounts.
type PostDiscountsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be retrieved in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsDiscountCodeParams defines parameters for GetDiscountsDiscountCode.
type GetDiscountsDiscountCodeParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountConditionsParams defines parameters for PostDiscountsDiscountConditions.
type PostDiscountsDiscountConditionsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteDiscountsDiscountConditionsConditionParams defines parameters for DeleteDiscountsDiscountConditionsCondition.
type DeleteDiscountsDiscountConditionsConditionParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsDiscountConditionsConditionParams defines parameters for GetDiscountsDiscountConditionsCondition.
type GetDiscountsDiscountConditionsConditionParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount condition.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount condition.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountConditionsConditionParams defines parameters for PostDiscountsDiscountConditionsCondition.
type PostDiscountsDiscountConditionsConditionParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteDiscountsDiscountConditionsConditionBatchParams defines parameters for DeleteDiscountsDiscountConditionsConditionBatch.
type DeleteDiscountsDiscountConditionsConditionBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountConditionsConditionBatchParams defines parameters for PostDiscountsDiscountConditionsConditionBatch.
type PostDiscountsDiscountConditionsConditionBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDiscountsDiscountParams defines parameters for GetDiscountsDiscount.
type GetDiscountsDiscountParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostDiscountsDiscountParams defines parameters for PostDiscountsDiscount.
type PostDiscountsDiscountParams struct {
	// Expand Comma-separated relations that should be expanded in the returned discount.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be retrieved in the returned discount.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetDraftOrdersParams defines parameters for GetDraftOrders.
type GetDraftOrdersParams struct {
	// Offset The number of draft orders to skip when retrieving the draft orders.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of draft orders returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Q a term to search draft orders' display IDs and emails in the draft order's cart
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order Field to sort retrieved draft orders by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Expand A comma-separated list of fields to expand.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields A comma-separated list of fields to include in the response.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// Status Filter by status
	Status *[]GetDraftOrdersParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetDraftOrdersParamsStatus defines parameters for GetDraftOrders.
type GetDraftOrdersParamsStatus string

// GetGiftCardsParams defines parameters for GetGiftCards.
type GetGiftCardsParams struct {
	// Offset The number of gift cards to skip when retrieving the gift cards.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of gift cards returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Q a term to search gift cards' code or display ID
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A gift card field to sort-order the retrieved gift cards by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetInventoryItemsParams defines parameters for GetInventoryItems.
type GetInventoryItemsParams struct {
	// Offset The number of inventory items to skip when retrieving the inventory items.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of inventory items returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in each returned inventory item.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned inventory item.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Q term to search inventory item's sku, title, and description.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order Field to sort-order inventory items by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// LocationId Filter by location IDs.
	LocationId *[]string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// Id Filter by the inventory ID
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Sku Filter by SKU
	Sku *string `form:"sku,omitempty" json:"sku,omitempty"`

	// OriginCountry Filter by origin country
	OriginCountry *string `form:"origin_country,omitempty" json:"origin_country,omitempty"`

	// MidCode Filter by MID code
	MidCode *string `form:"mid_code,omitempty" json:"mid_code,omitempty"`

	// Material Filter by material
	Material *string `form:"material,omitempty" json:"material,omitempty"`

	// HsCode Filter by HS Code
	HsCode *string `form:"hs_code,omitempty" json:"hs_code,omitempty"`

	// Weight Filter by weight
	Weight *string `form:"weight,omitempty" json:"weight,omitempty"`

	// Length Filter by length
	Length *string `form:"length,omitempty" json:"length,omitempty"`

	// Height Filter by height
	Height *string `form:"height,omitempty" json:"height,omitempty"`

	// Width Filter by width
	Width *string `form:"width,omitempty" json:"width,omitempty"`

	// RequiresShipping Filter by whether the item requires shipping
	RequiresShipping *string `form:"requires_shipping,omitempty" json:"requires_shipping,omitempty"`
}

// GetInventoryItemsParamsId0 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsId0 = string

// GetInventoryItemsParamsId1 defines parameters for GetInventoryItems.
type GetInventoryItemsParamsId1 = []string

// PostInventoryItemsParams defines parameters for PostInventoryItems.
type PostInventoryItemsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned inventory item.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned inventory item.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetInventoryItemsInventoryItemParams defines parameters for GetInventoryItemsInventoryItem.
type GetInventoryItemsInventoryItemParams struct {
	// Expand Comma-separated relations that should be expanded in the returned inventory item.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned inventory item.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInventoryItemsInventoryItemParams defines parameters for PostInventoryItemsInventoryItem.
type PostInventoryItemsInventoryItemParams struct {
	// Expand Comma-separated relations that should be expanded in the returned inventory level.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned inventory level.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetInventoryItemsInventoryItemLocationLevelsParams defines parameters for GetInventoryItemsInventoryItemLocationLevels.
type GetInventoryItemsInventoryItemLocationLevelsParams struct {
	// LocationId Filter by location IDs.
	LocationId *[]string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned inventory levels.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned inventory levels.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInventoryItemsInventoryItemLocationLevelsParams defines parameters for PostInventoryItemsInventoryItemLocationLevels.
type PostInventoryItemsInventoryItemLocationLevelsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned inventory item.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned inventory item.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams defines parameters for PostInventoryItemsInventoryItemLocationLevelsLocationLevel.
type PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned location level.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned location level.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetNotesParams defines parameters for GetNotes.
type GetNotesParams struct {
	// Limit Limit the number of notes returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of notes to skip when retrieving the notes.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// ResourceId Filter by resource ID
	ResourceId *string `form:"resource_id,omitempty" json:"resource_id,omitempty"`
}

// GetNotificationsParams defines parameters for GetNotifications.
type GetNotificationsParams struct {
	// Offset The number of inventory items to skip when retrieving the inventory items.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of notifications returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma-separated fields that should be included in each returned notification.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in each returned notification.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// EventName Filter by the name of the event that triggered sending this notification.
	EventName *string `form:"event_name,omitempty" json:"event_name,omitempty"`

	// ResourceType Filter by the resource type.
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// ResourceId Filter by the resource ID.
	ResourceId *string `form:"resource_id,omitempty" json:"resource_id,omitempty"`

	// To Filter by the address that the Notification was sent to. This will usually be an email address, but it can also represent other addresses such as a chat bot user id.
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// IncludeResends A boolean indicating whether the result set should include resent notifications or not
	IncludeResends *string `form:"include_resends,omitempty" json:"include_resends,omitempty"`
}

// GetOrderEditsParams defines parameters for GetOrderEdits.
type GetOrderEditsParams struct {
	// Q term to search order edits' internal note.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// OrderId Filter by order ID
	OrderId *string `form:"order_id,omitempty" json:"order_id,omitempty"`

	// Limit Limit the number of order edits returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of order edits to skip when retrieving the order edits.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Expand Comma-separated relations that should be expanded in each returned order edit.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in each returned order edit.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetOrderEditsOrderEditParams defines parameters for GetOrderEditsOrderEdit.
type GetOrderEditsOrderEditParams struct {
	// Expand Comma-separated relations that should be expanded in each returned order edit.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order edit.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// Q term to search orders' shipping address, first name, email, and display ID
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Id Filter by ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Status Filter by status
	Status *[]GetOrdersParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// FulfillmentStatus Filter by fulfillment status
	FulfillmentStatus *[]GetOrdersParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// PaymentStatus Filter by payment status
	PaymentStatus *[]GetOrdersParamsPaymentStatus `form:"payment_status,omitempty" json:"payment_status,omitempty"`

	// DisplayId Filter by display ID
	DisplayId *string `form:"display_id,omitempty" json:"display_id,omitempty"`

	// CartId Filter by cart ID
	CartId *string `form:"cart_id,omitempty" json:"cart_id,omitempty"`

	// CustomerId Filter by customer ID
	CustomerId *string `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// Email Filter by email
	Email *string `form:"email,omitempty" json:"email,omitempty"`

	// RegionId Filter by region IDs.
	RegionId *struct {
		union json.RawMessage
	} `form:"region_id,omitempty" json:"region_id,omitempty"`

	// CurrencyCode Filter by currency codes.
	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`

	// TaxRate Filter by tax rate.
	TaxRate *string `form:"tax_rate,omitempty" json:"tax_rate,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// CanceledAt Filter by a cancelation date range.
	CanceledAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"canceled_at,omitempty" json:"canceled_at,omitempty"`

	// SalesChannelId Filter by Sales Channel IDs
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// Offset The number of orders to skip when retrieving the orders.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of orders returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order Field to sort retrieved orders by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetOrdersParamsStatus defines parameters for GetOrders.
type GetOrdersParamsStatus string

// GetOrdersParamsFulfillmentStatus defines parameters for GetOrders.
type GetOrdersParamsFulfillmentStatus string

// GetOrdersParamsPaymentStatus defines parameters for GetOrders.
type GetOrdersParamsPaymentStatus string

// GetOrdersParamsRegionId0 defines parameters for GetOrders.
type GetOrdersParamsRegionId0 = string

// GetOrdersParamsRegionId1 defines parameters for GetOrders.
type GetOrdersParamsRegionId1 = []string

// GetOrdersOrderParams defines parameters for GetOrdersOrder.
type GetOrdersOrderParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderParams defines parameters for PostOrdersOrder.
type PostOrdersOrderParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderArchiveParams defines parameters for PostOrdersOrderArchive.
type PostOrdersOrderArchiveParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderCancelParams defines parameters for PostOrdersOrderCancel.
type PostOrdersOrderCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderCaptureParams defines parameters for PostOrdersOrderCapture.
type PostOrdersOrderCaptureParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderClaimsParams defines parameters for PostOrdersOrderClaims.
type PostOrdersOrderClaimsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderClaimsClaimParams defines parameters for PostOrdersOrderClaimsClaim.
type PostOrdersOrderClaimsClaimParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersClaimCancelParams defines parameters for PostOrdersClaimCancel.
type PostOrdersClaimCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderClaimsClaimFulfillmentsParams defines parameters for PostOrdersOrderClaimsClaimFulfillments.
type PostOrdersOrderClaimsClaimFulfillmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersClaimFulfillmentsCancelParams defines parameters for PostOrdersClaimFulfillmentsCancel.
type PostOrdersClaimFulfillmentsCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderClaimsClaimShipmentsParams defines parameters for PostOrdersOrderClaimsClaimShipments.
type PostOrdersOrderClaimsClaimShipmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderCompleteParams defines parameters for PostOrdersOrderComplete.
type PostOrdersOrderCompleteParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderFulfillmentsParams defines parameters for PostOrdersOrderFulfillments.
type PostOrdersOrderFulfillmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderFulfillmentsCancelParams defines parameters for PostOrdersOrderFulfillmentsCancel.
type PostOrdersOrderFulfillmentsCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderRefundsParams defines parameters for PostOrdersOrderRefunds.
type PostOrdersOrderRefundsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetOrdersOrderReservationsParams defines parameters for GetOrdersOrderReservations.
type GetOrdersOrderReservationsParams struct {
	// Offset The number of reservations to skip when retrieving the reservations.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of reservations returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostOrdersOrderReturnsParams defines parameters for PostOrdersOrderReturns.
type PostOrdersOrderReturnsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderShipmentParams defines parameters for PostOrdersOrderShipment.
type PostOrdersOrderShipmentParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderShippingMethodsParams defines parameters for PostOrdersOrderShippingMethods.
type PostOrdersOrderShippingMethodsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderSwapsParams defines parameters for PostOrdersOrderSwaps.
type PostOrdersOrderSwapsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersSwapCancelParams defines parameters for PostOrdersSwapCancel.
type PostOrdersSwapCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderSwapsSwapFulfillmentsParams defines parameters for PostOrdersOrderSwapsSwapFulfillments.
type PostOrdersOrderSwapsSwapFulfillmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersSwapFulfillmentsCancelParams defines parameters for PostOrdersSwapFulfillmentsCancel.
type PostOrdersSwapFulfillmentsCancelParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderSwapsSwapProcessPaymentParams defines parameters for PostOrdersOrderSwapsSwapProcessPayment.
type PostOrdersOrderSwapsSwapProcessPaymentParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostOrdersOrderSwapsSwapShipmentsParams defines parameters for PostOrdersOrderSwapsSwapShipments.
type PostOrdersOrderSwapsSwapShipmentsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned order.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned order.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPaymentCollectionsPaymentCollectionParams defines parameters for GetPaymentCollectionsPaymentCollection.
type GetPaymentCollectionsPaymentCollectionParams struct {
	// Expand Comma-separated relations that should be expanded in the returned payment collection.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned payment collection.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPriceListsParams defines parameters for GetPriceLists.
type GetPriceListsParams struct {
	// Limit Limit the number of price lists returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of price lists to skip when retrieving the price lists.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned price lists.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned price lists.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order A price-list field to sort-order the retrieved price lists by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Id Filter by ID
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Q term to search price lists' description, name, and customer group's name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Status Filter by status.
	Status *[]GetPriceListsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Name Filter by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// CustomerGroups Filter by customer-group IDs.
	CustomerGroups *[]string `form:"customer_groups,omitempty" json:"customer_groups,omitempty"`

	// Type Filter by type.
	Type *[]GetPriceListsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// GetPriceListsParamsStatus defines parameters for GetPriceLists.
type GetPriceListsParamsStatus string

// GetPriceListsParamsType defines parameters for GetPriceLists.
type GetPriceListsParamsType string

// GetPriceListsPriceListProductsParams defines parameters for GetPriceListsPriceListProducts.
type GetPriceListsPriceListProductsParams struct {
	// Q term used to search products' title, description, product variant's title and sku, and product collection's title.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Id Filter by product IDs.
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Status Filter by product status
	Status *[]GetPriceListsPriceListProductsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// CollectionId Filter by product collection ID. Only products in the specified collections are retrieved.
	CollectionId *[]string `form:"collection_id,omitempty" json:"collection_id,omitempty"`

	// Tags Filter by tag IDs. Only products having the specified tags are retrieved.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// Title Filter by title
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// Description Filter by description
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Handle Filter by handle
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// IsGiftcard A boolean value to filter by whether the product is a gift card or not.
	IsGiftcard *bool `form:"is_giftcard,omitempty" json:"is_giftcard,omitempty"`

	// Type Filter product type.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Order A product field to sort-order the retrieved products by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Offset The number of products to skip when retrieving the products.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of products returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned products.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned products.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetPriceListsPriceListProductsParamsId0 defines parameters for GetPriceListsPriceListProducts.
type GetPriceListsPriceListProductsParamsId0 = string

// GetPriceListsPriceListProductsParamsId1 defines parameters for GetPriceListsPriceListProducts.
type GetPriceListsPriceListProductsParamsId1 = []string

// GetPriceListsPriceListProductsParamsStatus defines parameters for GetPriceListsPriceListProducts.
type GetPriceListsPriceListProductsParamsStatus string

// GetProductCategoriesParams defines parameters for GetProductCategories.
type GetProductCategoriesParams struct {
	// Q term to search product categories' names and handles.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Handle Filter by handle.
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// IsInternal Filter by whether the category is internal or not.
	IsInternal *bool `form:"is_internal,omitempty" json:"is_internal,omitempty"`

	// IsActive Filter by whether the category is active or not.
	IsActive *bool `form:"is_active,omitempty" json:"is_active,omitempty"`

	// IncludeDescendantsTree If set to `true`, all nested descendants of a category are included in the response.
	IncludeDescendantsTree *bool `form:"include_descendants_tree,omitempty" json:"include_descendants_tree,omitempty"`

	// ParentCategoryId Filter by the ID of a parent category.
	ParentCategoryId *string `form:"parent_category_id,omitempty" json:"parent_category_id,omitempty"`

	// Offset The number of product categories to skip when retrieving the product categories.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of product categories returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned product categories.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned product categories.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductCategoriesParams defines parameters for PostProductCategories.
type PostProductCategoriesParams struct {
	// Expand Comma-separated relations that should be expanded in the returned product category.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned product category.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductCategoriesCategoryParams defines parameters for GetProductCategoriesCategory.
type GetProductCategoriesCategoryParams struct {
	// Expand Comma-separated relations that should be expanded in the returned product category.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned product category.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductCategoriesCategoryParams defines parameters for PostProductCategoriesCategory.
type PostProductCategoriesCategoryParams struct {
	// Expand (Comma separated) Which fields should be expanded in each product category.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields (Comma separated) Which fields should be retrieved in each product category.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// DeleteProductCategoriesCategoryProductsBatchParams defines parameters for DeleteProductCategoriesCategoryProductsBatch.
type DeleteProductCategoriesCategoryProductsBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned product category.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned product category.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostProductCategoriesCategoryProductsBatchParams defines parameters for PostProductCategoriesCategoryProductsBatch.
type PostProductCategoriesCategoryProductsBatchParams struct {
	// Expand Comma-separated relations that should be expanded in the returned product category.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned product category.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetProductTagsParams defines parameters for GetProductTags.
type GetProductTagsParams struct {
	// Limit Limit the number of product tags returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of product tags to skip when retrieving the product tags.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Order A product tag field to sort-order the retrieved product tags by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DiscountConditionId Filter by the ID of a discount condition. Only product tags that this discount condition is applied to will be retrieved.
	DiscountConditionId *string `form:"discount_condition_id,omitempty" json:"discount_condition_id,omitempty"`

	// Value Filter by tag value.
	Value *[]string `form:"value,omitempty" json:"value,omitempty"`

	// Q term to search product tags' values.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Id Filter by tag IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetProductTypesParams defines parameters for GetProductTypes.
type GetProductTypesParams struct {
	// Limit Limit the number of product types returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of product types to skip when retrieving the product types.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Order A product type field to sort-order the retrieved product types by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// DiscountConditionId Filter by the ID of a discount condition. Only product types that this discount condition is applied to will be retrieved.
	DiscountConditionId *string `form:"discount_condition_id,omitempty" json:"discount_condition_id,omitempty"`

	// Value Filter by value.
	Value *[]string `form:"value,omitempty" json:"value,omitempty"`

	// Id Filter by product type IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Q term to search product types' values.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetProductsParams defines parameters for GetProducts.
type GetProductsParams struct {
	// Q term to search products' title, description, variants' title and sku, and collections' title.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// DiscountConditionId Filter by the ID of a discount condition. Only products that this discount condition is applied to will be retrieved.
	DiscountConditionId *string `form:"discount_condition_id,omitempty" json:"discount_condition_id,omitempty"`

	// Id Filter by product IDs.
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Status Filter by status.
	Status *[]GetProductsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// CollectionId Filter by product collection IDs. Only products that are associated with the specified collections will be retrieved.
	CollectionId *[]string `form:"collection_id,omitempty" json:"collection_id,omitempty"`

	// Tags Filter by product tag IDs. Only products that are associated with the specified tags will be retrieved.
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`

	// PriceListId Filter by IDs of price lists. Only products that these price lists are applied to will be retrieved.
	PriceListId *[]string `form:"price_list_id,omitempty" json:"price_list_id,omitempty"`

	// SalesChannelId Filter by sales channel IDs. Only products that are available in the specified sales channels will be retrieved.
	SalesChannelId *[]string `form:"sales_channel_id,omitempty" json:"sales_channel_id,omitempty"`

	// TypeId Filter by product type IDs. Only products that are associated with the specified types will be retrieved.
	TypeId *[]string `form:"type_id,omitempty" json:"type_id,omitempty"`

	// CategoryId Filter by product category IDs. Only products that are associated with the specified categories will be retrieved.
	CategoryId *[]string `form:"category_id,omitempty" json:"category_id,omitempty"`

	// IncludeCategoryChildren whether to include product category children when filtering by `category_id`
	IncludeCategoryChildren *bool `form:"include_category_children,omitempty" json:"include_category_children,omitempty"`

	// Title Filter by title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// Description Filter by description.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Handle Filter by handle.
	Handle *string `form:"handle,omitempty" json:"handle,omitempty"`

	// IsGiftcard Whether to retrieve gift cards or regular products.
	IsGiftcard *bool `form:"is_giftcard,omitempty" json:"is_giftcard,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Offset The number of products to skip when retrieving the products.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of products returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned products.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned products.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order A product field to sort-order the retrieved products by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetProductsParamsId0 defines parameters for GetProducts.
type GetProductsParamsId0 = string

// GetProductsParamsId1 defines parameters for GetProducts.
type GetProductsParamsId1 = []string

// GetProductsParamsStatus defines parameters for GetProducts.
type GetProductsParamsStatus string

// GetProductsProductVariantsParams defines parameters for GetProductsProductVariants.
type GetProductsProductVariantsParams struct {
	// Id IDs to filter product variants by.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Fields Comma-separated fields that should be included in the returned product variants.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned product variants.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Offset The number of product variants to skip when retrieving the product variants.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of product variants returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Q Search term to search product variants' title, sku, and products' title.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// ManageInventory Filter product variants by whether their inventory is managed or not.
	ManageInventory *bool `form:"manage_inventory,omitempty" json:"manage_inventory,omitempty"`

	// AllowBackorder Filter product variants by whether they are allowed to be backordered or not.
	AllowBackorder *bool `form:"allow_backorder,omitempty" json:"allow_backorder,omitempty"`

	// InventoryQuantity Filter by available inventory quantity
	InventoryQuantity *struct {
		union json.RawMessage
	} `form:"inventory_quantity,omitempty" json:"inventory_quantity,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`
}

// GetProductsProductVariantsParamsInventoryQuantity0 defines parameters for GetProductsProductVariants.
type GetProductsProductVariantsParamsInventoryQuantity0 = float32

// GetProductsProductVariantsParamsInventoryQuantity1 defines parameters for GetProductsProductVariants.
type GetProductsProductVariantsParamsInventoryQuantity1 struct {
	// Gt filter by inventory quantity greater than this number
	Gt *float32 `json:"gt,omitempty"`

	// Gte filter by inventory quantity greater than or equal to this number
	Gte *float32 `json:"gte,omitempty"`

	// Lt filter by inventory quantity less than this number
	Lt *float32 `json:"lt,omitempty"`

	// Lte filter by inventory quantity less than or equal to this number
	Lte *float32 `json:"lte,omitempty"`
}

// GetPublishableApiKeysParams defines parameters for GetPublishableApiKeys.
type GetPublishableApiKeysParams struct {
	// Q term to search publishable API keys' titles.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Limit Limit the number of publishable API keys returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of publishable API keys to skip when retrieving the publishable API keys.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned publishable API keys.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned publishable API keys.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Order A field to sort-order the retrieved publishable API keys by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by a update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// RevokedAt Filter by a revocation date range.
	RevokedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"revoked_at,omitempty" json:"revoked_at,omitempty"`
}

// GetPublishableApiKeySalesChannelsParams defines parameters for GetPublishableApiKeySalesChannels.
type GetPublishableApiKeySalesChannelsParams struct {
	// Q query to search sales channels' names and descriptions.
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// GetRegionsParams defines parameters for GetRegions.
type GetRegionsParams struct {
	// Q Term used to search regions' name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A field to sort-order the retrieved regions by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Limit Limit the number of regions returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of regions to skip when retrieving the regions.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`
}

// GetReservationsParams defines parameters for GetReservations.
type GetReservationsParams struct {
	// LocationId Filter by location ID
	LocationId *[]string `form:"location_id,omitempty" json:"location_id,omitempty"`

	// InventoryItemId Filter by inventory item ID.
	InventoryItemId *[]string `form:"inventory_item_id,omitempty" json:"inventory_item_id,omitempty"`

	// LineItemId Filter by line item ID.
	LineItemId *[]string `form:"line_item_id,omitempty" json:"line_item_id,omitempty"`

	// Quantity Filter by reservation quantity
	Quantity *struct {
		// Gt filter by reservation quantity greater than this number
		Gt *float32 `json:"gt,omitempty"`

		// Gte filter by reservation quantity greater than or equal to this number
		Gte *float32 `json:"gte,omitempty"`

		// Lt filter by reservation quantity less than this number
		Lt *float32 `json:"lt,omitempty"`

		// Lte filter by reservation quantity less than or equal to this number
		Lte *float32 `json:"lte,omitempty"`
	} `form:"quantity,omitempty" json:"quantity,omitempty"`

	// Description Filter by description.
	Description *struct {
		union json.RawMessage
	} `form:"description,omitempty" json:"description,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// Offset The number of reservations to skip when retrieving the reservations.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of reservations returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned reservations.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned reservations.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetReservationsParamsDescription0 defines parameters for GetReservations.
type GetReservationsParamsDescription0 = string

// GetReservationsParamsDescription1 defines parameters for GetReservations.
type GetReservationsParamsDescription1 struct {
	// Contains filter by reservation description containing search string.
	Contains *string `json:"contains,omitempty"`

	// EndsWith filter by reservation description ending with search string.
	EndsWith *string `json:"ends_with,omitempty"`

	// StartsWith filter by reservation description starting with search string.
	StartsWith *string `json:"starts_with,omitempty"`
}

// GetReturnsParams defines parameters for GetReturns.
type GetReturnsParams struct {
	// Limit Limit the number of Returns returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of Returns to skip when retrieving the Returns.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetSalesChannelsParams defines parameters for GetSalesChannels.
type GetSalesChannelsParams struct {
	// Id Filter by a sales channel ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name Filter by name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Description Filter by description.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Q term used to search sales channels' names and descriptions.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A sales-channel field to sort-order the retrieved sales channels by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Offset The number of sales channels to skip when retrieving the sales channels.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of sales channels returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned sales channels.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned sales channels.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetShippingOptionsParams defines parameters for GetShippingOptions.
type GetShippingOptionsParams struct {
	// Name Filter by name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// RegionId Filter by the ID of the region the shipping options belong to.
	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`

	// IsReturn Filter by whether the shipping options are return shipping options.
	IsReturn *bool `form:"is_return,omitempty" json:"is_return,omitempty"`

	// AdminOnly Filter by whether the shipping options are available for admin users only.
	AdminOnly *bool `form:"admin_only,omitempty" json:"admin_only,omitempty"`

	// Q Term used to search shipping options' name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A shipping option field to sort-order the retrieved shipping options by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Id Filter by shipping option IDs.
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Offset The number of users to skip when retrieving the shipping options.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of shipping options returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned shipping options.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned shipping options.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetShippingOptionsParamsId0 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsId0 = string

// GetShippingOptionsParamsId1 defines parameters for GetShippingOptions.
type GetShippingOptionsParamsId1 = []string

// GetStockLocationsParams defines parameters for GetStockLocations.
type GetStockLocationsParams struct {
	// Id Filter by ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name Filter by name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Order A stock-location field to sort-order the retrieved stock locations by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Offset The number of stock locations to skip when retrieving the stock locations.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of stock locations returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned stock locations.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned stock locations.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStockLocationsParams defines parameters for PostStockLocations.
type PostStockLocationsParams struct {
	// Expand Comma-separated relations that should be expanded in the returned stock location.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned stock location.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetStockLocationsStockLocationParams defines parameters for GetStockLocationsStockLocation.
type GetStockLocationsStockLocationParams struct {
	// Expand Comma-separated relations that should be expanded in the returned stock location.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned stock location.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostStockLocationsStockLocationParams defines parameters for PostStockLocationsStockLocation.
type PostStockLocationsStockLocationParams struct {
	// Expand Comma-separated relations that should be expanded in the returned stock location.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields Comma-separated fields that should be included in the returned stock location.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetSwapsParams defines parameters for GetSwaps.
type GetSwapsParams struct {
	// Limit Limit the number of swaps returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The number of swaps to skip when retrieving the swaps.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetTaxRatesParams defines parameters for GetTaxRates.
type GetTaxRatesParams struct {
	// Name Filter by name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// RegionId Filter by Region IDs
	RegionId *struct {
		union json.RawMessage
	} `form:"region_id,omitempty" json:"region_id,omitempty"`

	// Code Filter by code.
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Rate Filter by Rate
	Rate *struct {
		union json.RawMessage
	} `form:"rate,omitempty" json:"rate,omitempty"`

	// Q Term used to search tax rates by name.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A tax rate field to sort-order the retrieved tax rates by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Offset The number of tax rates to skip when retrieving the tax rates.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of tax rates returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetTaxRatesParamsRegionId0 defines parameters for GetTaxRates.
type GetTaxRatesParamsRegionId0 = string

// GetTaxRatesParamsRegionId1 defines parameters for GetTaxRates.
type GetTaxRatesParamsRegionId1 = []string

// GetTaxRatesParamsRate0 defines parameters for GetTaxRates.
type GetTaxRatesParamsRate0 = float32

// GetTaxRatesParamsRate1 defines parameters for GetTaxRates.
type GetTaxRatesParamsRate1 struct {
	// Gt filter by rates greater than this number
	Gt *float32 `json:"gt,omitempty"`

	// Gte filter by rates greater than or equal to this number
	Gte *float32 `json:"gte,omitempty"`

	// Lt filter by rates less than this number
	Lt *float32 `json:"lt,omitempty"`

	// Lte filter by rates less than or equal to this number
	Lte *float32 `json:"lte,omitempty"`
}

// PostTaxRatesParams defines parameters for PostTaxRates.
type PostTaxRatesParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetTaxRatesTaxRateParams defines parameters for GetTaxRatesTaxRate.
type GetTaxRatesTaxRateParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateParams defines parameters for PostTaxRatesTaxRate.
type PostTaxRatesTaxRateParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTaxRatesTaxRateProductTypesParams defines parameters for DeleteTaxRatesTaxRateProductTypes.
type DeleteTaxRatesTaxRateProductTypesParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateProductTypesParams defines parameters for PostTaxRatesTaxRateProductTypes.
type PostTaxRatesTaxRateProductTypesParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTaxRatesTaxRateProductsParams defines parameters for DeleteTaxRatesTaxRateProducts.
type DeleteTaxRatesTaxRateProductsParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateProductsParams defines parameters for PostTaxRatesTaxRateProducts.
type PostTaxRatesTaxRateProductsParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// DeleteTaxRatesTaxRateShippingOptionsParams defines parameters for DeleteTaxRatesTaxRateShippingOptions.
type DeleteTaxRatesTaxRateShippingOptionsParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostTaxRatesTaxRateShippingOptionsParams defines parameters for PostTaxRatesTaxRateShippingOptions.
type PostTaxRatesTaxRateShippingOptionsParams struct {
	// Fields Comma-separated fields that should be included in the returned tax rate.
	Fields *[]string `form:"fields,omitempty" json:"fields,omitempty"`

	// Expand Comma-separated relations that should be expanded in the returned tax rate.
	Expand *[]string `form:"expand,omitempty" json:"expand,omitempty"`
}

// PostUploadsMultipartBody defines parameters for PostUploads.
type PostUploadsMultipartBody struct {
	Files *openapi_types.File `json:"files,omitempty"`
}

// PostUploadsProtectedMultipartBody defines parameters for PostUploadsProtected.
type PostUploadsProtectedMultipartBody struct {
	Files *openapi_types.File `json:"files,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Email Filter by email.
	Email *string `form:"email,omitempty" json:"email,omitempty"`

	// FirstName Filter by first name.
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty"`

	// LastName Filter by last name.
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty"`

	// Q Term used to search users' first name, last name, and email.
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Order A user field to sort-order the retrieved users by.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Id Filter by user IDs.
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// CreatedAt Filter by a creation date range.
	CreatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"created_at,omitempty" json:"created_at,omitempty"`

	// UpdatedAt Filter by an update date range.
	UpdatedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"updated_at,omitempty" json:"updated_at,omitempty"`

	// DeletedAt Filter by a deletion date range.
	DeletedAt *struct {
		// Gt filter by dates greater than this date
		Gt *openapi_types.Date `json:"gt,omitempty"`

		// Gte filter by dates greater than or equal to this date
		Gte *openapi_types.Date `json:"gte,omitempty"`

		// Lt filter by dates less than this date
		Lt *openapi_types.Date `json:"lt,omitempty"`

		// Lte filter by dates less than or equal to this date
		Lte *openapi_types.Date `json:"lte,omitempty"`
	} `form:"deleted_at,omitempty" json:"deleted_at,omitempty"`

	// Offset The number of users to skip when retrieving the users.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of users returned.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Fields Comma-separated fields that should be included in the returned users.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// GetUsersParamsId0 defines parameters for GetUsers.
type GetUsersParamsId0 = string

// GetUsersParamsId1 defines parameters for GetUsers.
type GetUsersParamsId1 = []string

// GetVariantsParams defines parameters for GetVariants.
type GetVariantsParams struct {
	// Id Filter by product variant IDs.
	Id *struct {
		union json.RawMessage
	} `form:"id,omitempty" json:"id,omitempty"`

	// Expand "Comma-separated relations that should be expanded in the returned product variants."
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields "Comma-separated fields that should be included in the returned product variants."
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Offset The number of product variants to skip when retrieving the product variants.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of product variants returned.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order The field to sort the data by. By default, the sort order is ascending. To change the order to descending, prefix the field name with `-`.
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// ManageInventory Filter product variants by whether their inventory is managed or not.
	ManageInventory *bool `form:"manage_inventory,omitempty" json:"manage_inventory,omitempty"`

	// AllowBackorder Filter product variants by whether they are allowed to be backordered or not.
	AllowBackorder *bool `form:"allow_backorder,omitempty" json:"allow_backorder,omitempty"`

	// CartId The ID of the cart to use for the price selection context.
	CartId *string `form:"cart_id,omitempty" json:"cart_id,omitempty"`

	// RegionId The ID of the region to use for the price selection context.
	RegionId *string `form:"region_id,omitempty" json:"region_id,omitempty"`

	// CurrencyCode The 3 character ISO currency code to use for the price selection context.
	CurrencyCode *string `form:"currency_code,omitempty" json:"currency_code,omitempty"`

	// CustomerId The ID of the customer to use for the price selection context.
	CustomerId *string `form:"customer_id,omitempty" json:"customer_id,omitempty"`

	// Title Filter by title.
	Title *struct {
		union json.RawMessage
	} `form:"title,omitempty" json:"title,omitempty"`

	// InventoryQuantity Filter by available inventory quantity
	InventoryQuantity *struct {
		union json.RawMessage
	} `form:"inventory_quantity,omitempty" json:"inventory_quantity,omitempty"`
}

// GetVariantsParamsId0 defines parameters for GetVariants.
type GetVariantsParamsId0 = string

// GetVariantsParamsId1 defines parameters for GetVariants.
type GetVariantsParamsId1 = []string

// GetVariantsParamsTitle0 defines parameters for GetVariants.
type GetVariantsParamsTitle0 = string

// GetVariantsParamsTitle1 defines parameters for GetVariants.
type GetVariantsParamsTitle1 = []string

// GetVariantsParamsInventoryQuantity0 defines parameters for GetVariants.
type GetVariantsParamsInventoryQuantity0 = float32

// GetVariantsParamsInventoryQuantity1 defines parameters for GetVariants.
type GetVariantsParamsInventoryQuantity1 struct {
	// Gt filter by inventory quantity greater than this number
	Gt *float32 `json:"gt,omitempty"`

	// Gte filter by inventory quantity greater than or equal to this number
	Gte *float32 `json:"gte,omitempty"`

	// Lt filter by inventory quantity less than this number
	Lt *float32 `json:"lt,omitempty"`

	// Lte filter by inventory quantity less than or equal to this number
	Lte *float32 `json:"lte,omitempty"`
}

// GetVariantsVariantParams defines parameters for GetVariantsVariant.
type GetVariantsVariantParams struct {
	// Expand "Comma-separated relations that should be expanded in the returned product variant."
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Fields "Comma-separated fields that should be included in the returned product variant."
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`
}

// PostAppsJSONRequestBody defines body for PostApps for application/json ContentType.
type PostAppsJSONRequestBody = AdminPostAppsReq

// PostAuthJSONRequestBody defines body for PostAuth for application/json ContentType.
type PostAuthJSONRequestBody = AdminPostAuthReq

// PostTokenJSONRequestBody defines body for PostToken for application/json ContentType.
type PostTokenJSONRequestBody = AdminPostAuthReq

// PostBatchJobsJSONRequestBody defines body for PostBatchJobs for application/json ContentType.
type PostBatchJobsJSONRequestBody = AdminPostBatchesReq

// PostCollectionsJSONRequestBody defines body for PostCollections for application/json ContentType.
type PostCollectionsJSONRequestBody = AdminPostCollectionsReq

// PostCollectionsCollectionJSONRequestBody defines body for PostCollectionsCollection for application/json ContentType.
type PostCollectionsCollectionJSONRequestBody = AdminPostCollectionsCollectionReq

// DeleteProductsFromCollectionJSONRequestBody defines body for DeleteProductsFromCollection for application/json ContentType.
type DeleteProductsFromCollectionJSONRequestBody = AdminDeleteProductsFromCollectionReq

// PostProductsToCollectionJSONRequestBody defines body for PostProductsToCollection for application/json ContentType.
type PostProductsToCollectionJSONRequestBody = AdminPostProductsToCollectionReq

// PostCurrenciesCurrencyJSONRequestBody defines body for PostCurrenciesCurrency for application/json ContentType.
type PostCurrenciesCurrencyJSONRequestBody = AdminPostCurrenciesCurrencyReq

// PostCustomerGroupsJSONRequestBody defines body for PostCustomerGroups for application/json ContentType.
type PostCustomerGroupsJSONRequestBody = AdminPostCustomerGroupsReq

// PostCustomerGroupsGroupJSONRequestBody defines body for PostCustomerGroupsGroup for application/json ContentType.
type PostCustomerGroupsGroupJSONRequestBody = AdminPostCustomerGroupsGroupReq

// DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody defines body for DeleteCustomerGroupsGroupCustomerBatch for application/json ContentType.
type DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody = AdminDeleteCustomerGroupsGroupCustomerBatchReq

// PostCustomerGroupsGroupCustomersBatchJSONRequestBody defines body for PostCustomerGroupsGroupCustomersBatch for application/json ContentType.
type PostCustomerGroupsGroupCustomersBatchJSONRequestBody = AdminPostCustomerGroupsGroupCustomersBatchReq

// PostCustomersJSONRequestBody defines body for PostCustomers for application/json ContentType.
type PostCustomersJSONRequestBody = AdminPostCustomersReq

// PostCustomersCustomerJSONRequestBody defines body for PostCustomersCustomer for application/json ContentType.
type PostCustomersCustomerJSONRequestBody = AdminPostCustomersCustomerReq

// PostDiscountsJSONRequestBody defines body for PostDiscounts for application/json ContentType.
type PostDiscountsJSONRequestBody = AdminPostDiscountsReq

// PostDiscountsDiscountConditionsJSONRequestBody defines body for PostDiscountsDiscountConditions for application/json ContentType.
type PostDiscountsDiscountConditionsJSONRequestBody = AdminPostDiscountsDiscountConditions

// PostDiscountsDiscountConditionsConditionJSONRequestBody defines body for PostDiscountsDiscountConditionsCondition for application/json ContentType.
type PostDiscountsDiscountConditionsConditionJSONRequestBody = AdminPostDiscountsDiscountConditionsCondition

// DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody defines body for DeleteDiscountsDiscountConditionsConditionBatch for application/json ContentType.
type DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody = AdminDeleteDiscountsDiscountConditionsConditionBatchReq

// PostDiscountsDiscountConditionsConditionBatchJSONRequestBody defines body for PostDiscountsDiscountConditionsConditionBatch for application/json ContentType.
type PostDiscountsDiscountConditionsConditionBatchJSONRequestBody = AdminPostDiscountsDiscountConditionsConditionBatchReq

// PostDiscountsDiscountJSONRequestBody defines body for PostDiscountsDiscount for application/json ContentType.
type PostDiscountsDiscountJSONRequestBody = AdminPostDiscountsDiscountReq

// PostDiscountsDiscountDynamicCodesJSONRequestBody defines body for PostDiscountsDiscountDynamicCodes for application/json ContentType.
type PostDiscountsDiscountDynamicCodesJSONRequestBody = AdminPostDiscountsDiscountDynamicCodesReq

// PostDraftOrdersJSONRequestBody defines body for PostDraftOrders for application/json ContentType.
type PostDraftOrdersJSONRequestBody = AdminPostDraftOrdersReq

// PostDraftOrdersDraftOrderJSONRequestBody defines body for PostDraftOrdersDraftOrder for application/json ContentType.
type PostDraftOrdersDraftOrderJSONRequestBody = AdminPostDraftOrdersDraftOrderReq

// PostDraftOrdersDraftOrderLineItemsJSONRequestBody defines body for PostDraftOrdersDraftOrderLineItems for application/json ContentType.
type PostDraftOrdersDraftOrderLineItemsJSONRequestBody = AdminPostDraftOrdersDraftOrderLineItemsReq

// PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody defines body for PostDraftOrdersDraftOrderLineItemsItem for application/json ContentType.
type PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody = AdminPostDraftOrdersDraftOrderLineItemsItemReq

// PostGiftCardsJSONRequestBody defines body for PostGiftCards for application/json ContentType.
type PostGiftCardsJSONRequestBody = AdminPostGiftCardsReq

// PostGiftCardsGiftCardJSONRequestBody defines body for PostGiftCardsGiftCard for application/json ContentType.
type PostGiftCardsGiftCardJSONRequestBody = AdminPostGiftCardsGiftCardReq

// PostInventoryItemsJSONRequestBody defines body for PostInventoryItems for application/json ContentType.
type PostInventoryItemsJSONRequestBody = AdminPostInventoryItemsReq

// PostInventoryItemsInventoryItemJSONRequestBody defines body for PostInventoryItemsInventoryItem for application/json ContentType.
type PostInventoryItemsInventoryItemJSONRequestBody = AdminPostInventoryItemsInventoryItemReq

// PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody defines body for PostInventoryItemsInventoryItemLocationLevels for application/json ContentType.
type PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody = AdminPostInventoryItemsItemLocationLevelsReq

// PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody defines body for PostInventoryItemsInventoryItemLocationLevelsLocationLevel for application/json ContentType.
type PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody = AdminPostInventoryItemsItemLocationLevelsLevelReq

// PostInvitesJSONRequestBody defines body for PostInvites for application/json ContentType.
type PostInvitesJSONRequestBody = AdminPostInvitesReq

// PostInvitesInviteAcceptJSONRequestBody defines body for PostInvitesInviteAccept for application/json ContentType.
type PostInvitesInviteAcceptJSONRequestBody = AdminPostInvitesInviteAcceptReq

// PostNotesJSONRequestBody defines body for PostNotes for application/json ContentType.
type PostNotesJSONRequestBody = AdminPostNotesReq

// PostNotesNoteJSONRequestBody defines body for PostNotesNote for application/json ContentType.
type PostNotesNoteJSONRequestBody = AdminPostNotesNoteReq

// PostNotificationsNotificationResendJSONRequestBody defines body for PostNotificationsNotificationResend for application/json ContentType.
type PostNotificationsNotificationResendJSONRequestBody = AdminPostNotificationsNotificationResendReq

// PostOrderEditsJSONRequestBody defines body for PostOrderEdits for application/json ContentType.
type PostOrderEditsJSONRequestBody = AdminPostOrderEditsReq

// PostOrderEditsOrderEditJSONRequestBody defines body for PostOrderEditsOrderEdit for application/json ContentType.
type PostOrderEditsOrderEditJSONRequestBody = AdminPostOrderEditsOrderEditReq

// PostOrderEditsEditLineItemsJSONRequestBody defines body for PostOrderEditsEditLineItems for application/json ContentType.
type PostOrderEditsEditLineItemsJSONRequestBody = AdminPostOrderEditsEditLineItemsReq

// PostOrderEditsEditLineItemsLineItemJSONRequestBody defines body for PostOrderEditsEditLineItemsLineItem for application/json ContentType.
type PostOrderEditsEditLineItemsLineItemJSONRequestBody = AdminPostOrderEditsEditLineItemsLineItemReq

// PostOrdersOrderJSONRequestBody defines body for PostOrdersOrder for application/json ContentType.
type PostOrdersOrderJSONRequestBody = AdminPostOrdersOrderReq

// PostOrdersOrderClaimsJSONRequestBody defines body for PostOrdersOrderClaims for application/json ContentType.
type PostOrdersOrderClaimsJSONRequestBody = AdminPostOrdersOrderClaimsReq

// PostOrdersOrderClaimsClaimJSONRequestBody defines body for PostOrdersOrderClaimsClaim for application/json ContentType.
type PostOrdersOrderClaimsClaimJSONRequestBody = AdminPostOrdersOrderClaimsClaimReq

// PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody defines body for PostOrdersOrderClaimsClaimFulfillments for application/json ContentType.
type PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody = AdminPostOrdersOrderClaimsClaimFulfillmentsReq

// PostOrdersOrderClaimsClaimShipmentsJSONRequestBody defines body for PostOrdersOrderClaimsClaimShipments for application/json ContentType.
type PostOrdersOrderClaimsClaimShipmentsJSONRequestBody = AdminPostOrdersOrderClaimsClaimShipmentsReq

// PostOrdersOrderFulfillmentsJSONRequestBody defines body for PostOrdersOrderFulfillments for application/json ContentType.
type PostOrdersOrderFulfillmentsJSONRequestBody = AdminPostOrdersOrderFulfillmentsReq

// PostOrdersOrderLineItemReservationsJSONRequestBody defines body for PostOrdersOrderLineItemReservations for application/json ContentType.
type PostOrdersOrderLineItemReservationsJSONRequestBody = AdminOrdersOrderLineItemReservationReq

// PostOrdersOrderRefundsJSONRequestBody defines body for PostOrdersOrderRefunds for application/json ContentType.
type PostOrdersOrderRefundsJSONRequestBody = AdminPostOrdersOrderRefundsReq

// PostOrdersOrderReturnsJSONRequestBody defines body for PostOrdersOrderReturns for application/json ContentType.
type PostOrdersOrderReturnsJSONRequestBody = AdminPostOrdersOrderReturnsReq

// PostOrdersOrderShipmentJSONRequestBody defines body for PostOrdersOrderShipment for application/json ContentType.
type PostOrdersOrderShipmentJSONRequestBody = AdminPostOrdersOrderShipmentReq

// PostOrdersOrderShippingMethodsJSONRequestBody defines body for PostOrdersOrderShippingMethods for application/json ContentType.
type PostOrdersOrderShippingMethodsJSONRequestBody = AdminPostOrdersOrderShippingMethodsReq

// PostOrdersOrderSwapsJSONRequestBody defines body for PostOrdersOrderSwaps for application/json ContentType.
type PostOrdersOrderSwapsJSONRequestBody = AdminPostOrdersOrderSwapsReq

// PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody defines body for PostOrdersOrderSwapsSwapFulfillments for application/json ContentType.
type PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody = AdminPostOrdersOrderSwapsSwapFulfillmentsReq

// PostOrdersOrderSwapsSwapShipmentsJSONRequestBody defines body for PostOrdersOrderSwapsSwapShipments for application/json ContentType.
type PostOrdersOrderSwapsSwapShipmentsJSONRequestBody = AdminPostOrdersOrderSwapsSwapShipmentsReq

// PostPaymentCollectionsPaymentCollectionJSONRequestBody defines body for PostPaymentCollectionsPaymentCollection for application/json ContentType.
type PostPaymentCollectionsPaymentCollectionJSONRequestBody = AdminUpdatePaymentCollectionsReq

// PostPaymentsPaymentRefundsJSONRequestBody defines body for PostPaymentsPaymentRefunds for application/json ContentType.
type PostPaymentsPaymentRefundsJSONRequestBody = AdminPostPaymentRefundsReq

// PostPriceListsPriceListJSONRequestBody defines body for PostPriceListsPriceList for application/json ContentType.
type PostPriceListsPriceListJSONRequestBody = AdminPostPriceListsPriceListReq

// PostPriceListsPriceListPriceListJSONRequestBody defines body for PostPriceListsPriceListPriceList for application/json ContentType.
type PostPriceListsPriceListPriceListJSONRequestBody = AdminPostPriceListsPriceListPriceListReq

// DeletePriceListsPriceListPricesBatchJSONRequestBody defines body for DeletePriceListsPriceListPricesBatch for application/json ContentType.
type DeletePriceListsPriceListPricesBatchJSONRequestBody = AdminDeletePriceListPricesPricesReq

// PostPriceListsPriceListPricesBatchJSONRequestBody defines body for PostPriceListsPriceListPricesBatch for application/json ContentType.
type PostPriceListsPriceListPricesBatchJSONRequestBody = AdminPostPriceListPricesPricesReq

// PostProductCategoriesJSONRequestBody defines body for PostProductCategories for application/json ContentType.
type PostProductCategoriesJSONRequestBody = AdminPostProductCategoriesReq

// PostProductCategoriesCategoryJSONRequestBody defines body for PostProductCategoriesCategory for application/json ContentType.
type PostProductCategoriesCategoryJSONRequestBody = AdminPostProductCategoriesCategoryReq

// DeleteProductCategoriesCategoryProductsBatchJSONRequestBody defines body for DeleteProductCategoriesCategoryProductsBatch for application/json ContentType.
type DeleteProductCategoriesCategoryProductsBatchJSONRequestBody = AdminDeleteProductCategoriesCategoryProductsBatchReq

// PostProductCategoriesCategoryProductsBatchJSONRequestBody defines body for PostProductCategoriesCategoryProductsBatch for application/json ContentType.
type PostProductCategoriesCategoryProductsBatchJSONRequestBody = AdminPostProductCategoriesCategoryProductsBatchReq

// PostProductsJSONRequestBody defines body for PostProducts for application/json ContentType.
type PostProductsJSONRequestBody = AdminPostProductsReq

// PostProductsProductJSONRequestBody defines body for PostProductsProduct for application/json ContentType.
type PostProductsProductJSONRequestBody = AdminPostProductsProductReq

// PostProductsProductMetadataJSONRequestBody defines body for PostProductsProductMetadata for application/json ContentType.
type PostProductsProductMetadataJSONRequestBody = AdminPostProductsProductMetadataReq

// PostProductsProductOptionsJSONRequestBody defines body for PostProductsProductOptions for application/json ContentType.
type PostProductsProductOptionsJSONRequestBody = AdminPostProductsProductOptionsReq

// PostProductsProductOptionsOptionJSONRequestBody defines body for PostProductsProductOptionsOption for application/json ContentType.
type PostProductsProductOptionsOptionJSONRequestBody = AdminPostProductsProductOptionsOption

// PostProductsProductVariantsJSONRequestBody defines body for PostProductsProductVariants for application/json ContentType.
type PostProductsProductVariantsJSONRequestBody = AdminPostProductsProductVariantsReq

// PostProductsProductVariantsVariantJSONRequestBody defines body for PostProductsProductVariantsVariant for application/json ContentType.
type PostProductsProductVariantsVariantJSONRequestBody = AdminPostProductsProductVariantsVariantReq

// PostPublishableApiKeysJSONRequestBody defines body for PostPublishableApiKeys for application/json ContentType.
type PostPublishableApiKeysJSONRequestBody = AdminPostPublishableApiKeysReq

// PostPublishableApiKysPublishableApiKeyJSONRequestBody defines body for PostPublishableApiKysPublishableApiKey for application/json ContentType.
type PostPublishableApiKysPublishableApiKeyJSONRequestBody = AdminPostPublishableApiKeysPublishableApiKeyReq

// DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody defines body for DeletePublishableApiKeySalesChannelsChannelsBatch for application/json ContentType.
type DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody = AdminDeletePublishableApiKeySalesChannelsBatchReq

// PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody defines body for PostPublishableApiKeySalesChannelsChannelsBatch for application/json ContentType.
type PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody = AdminPostPublishableApiKeySalesChannelsBatchReq

// PostRegionsJSONRequestBody defines body for PostRegions for application/json ContentType.
type PostRegionsJSONRequestBody = AdminPostRegionsReq

// PostRegionsRegionJSONRequestBody defines body for PostRegionsRegion for application/json ContentType.
type PostRegionsRegionJSONRequestBody = AdminPostRegionsRegionReq

// PostRegionsRegionCountriesJSONRequestBody defines body for PostRegionsRegionCountries for application/json ContentType.
type PostRegionsRegionCountriesJSONRequestBody = AdminPostRegionsRegionCountriesReq

// PostRegionsRegionFulfillmentProvidersJSONRequestBody defines body for PostRegionsRegionFulfillmentProviders for application/json ContentType.
type PostRegionsRegionFulfillmentProvidersJSONRequestBody = AdminPostRegionsRegionFulfillmentProvidersReq

// PostRegionsRegionPaymentProvidersJSONRequestBody defines body for PostRegionsRegionPaymentProviders for application/json ContentType.
type PostRegionsRegionPaymentProvidersJSONRequestBody = AdminPostRegionsRegionPaymentProvidersReq

// PostReservationsJSONRequestBody defines body for PostReservations for application/json ContentType.
type PostReservationsJSONRequestBody = AdminPostReservationsReq

// PostReservationsReservationJSONRequestBody defines body for PostReservationsReservation for application/json ContentType.
type PostReservationsReservationJSONRequestBody = AdminPostReservationsReservationReq

// PostReturnReasonsJSONRequestBody defines body for PostReturnReasons for application/json ContentType.
type PostReturnReasonsJSONRequestBody = AdminPostReturnReasonsReq

// PostReturnReasonsReasonJSONRequestBody defines body for PostReturnReasonsReason for application/json ContentType.
type PostReturnReasonsReasonJSONRequestBody = AdminPostReturnReasonsReasonReq

// PostReturnsReturnReceiveJSONRequestBody defines body for PostReturnsReturnReceive for application/json ContentType.
type PostReturnsReturnReceiveJSONRequestBody = AdminPostReturnsReturnReceiveReq

// PostSalesChannelsJSONRequestBody defines body for PostSalesChannels for application/json ContentType.
type PostSalesChannelsJSONRequestBody = AdminPostSalesChannelsReq

// PostSalesChannelsSalesChannelJSONRequestBody defines body for PostSalesChannelsSalesChannel for application/json ContentType.
type PostSalesChannelsSalesChannelJSONRequestBody = AdminPostSalesChannelsSalesChannelReq

// DeleteSalesChannelsChannelProductsBatchJSONRequestBody defines body for DeleteSalesChannelsChannelProductsBatch for application/json ContentType.
type DeleteSalesChannelsChannelProductsBatchJSONRequestBody = AdminDeleteSalesChannelsChannelProductsBatchReq

// PostSalesChannelsChannelProductsBatchJSONRequestBody defines body for PostSalesChannelsChannelProductsBatch for application/json ContentType.
type PostSalesChannelsChannelProductsBatchJSONRequestBody = AdminPostSalesChannelsChannelProductsBatchReq

// DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody defines body for DeleteSalesChannelsSalesChannelStockLocation for application/json ContentType.
type DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody = AdminDeleteSalesChannelsChannelStockLocationsReq

// PostSalesChannelsSalesChannelStockLocationJSONRequestBody defines body for PostSalesChannelsSalesChannelStockLocation for application/json ContentType.
type PostSalesChannelsSalesChannelStockLocationJSONRequestBody = AdminPostSalesChannelsChannelStockLocationsReq

// PostShippingOptionsJSONRequestBody defines body for PostShippingOptions for application/json ContentType.
type PostShippingOptionsJSONRequestBody = AdminPostShippingOptionsReq

// PostShippingOptionsOptionJSONRequestBody defines body for PostShippingOptionsOption for application/json ContentType.
type PostShippingOptionsOptionJSONRequestBody = AdminPostShippingOptionsOptionReq

// PostShippingProfilesJSONRequestBody defines body for PostShippingProfiles for application/json ContentType.
type PostShippingProfilesJSONRequestBody = AdminPostShippingProfilesReq

// PostShippingProfilesProfileJSONRequestBody defines body for PostShippingProfilesProfile for application/json ContentType.
type PostShippingProfilesProfileJSONRequestBody = AdminPostShippingProfilesProfileReq

// PostStockLocationsJSONRequestBody defines body for PostStockLocations for application/json ContentType.
type PostStockLocationsJSONRequestBody = AdminPostStockLocationsReq

// PostStockLocationsStockLocationJSONRequestBody defines body for PostStockLocationsStockLocation for application/json ContentType.
type PostStockLocationsStockLocationJSONRequestBody = AdminPostStockLocationsLocationReq

// PostStoreJSONRequestBody defines body for PostStore for application/json ContentType.
type PostStoreJSONRequestBody = AdminPostStoreReq

// PostTaxRatesJSONRequestBody defines body for PostTaxRates for application/json ContentType.
type PostTaxRatesJSONRequestBody = AdminPostTaxRatesReq

// PostTaxRatesTaxRateJSONRequestBody defines body for PostTaxRatesTaxRate for application/json ContentType.
type PostTaxRatesTaxRateJSONRequestBody = AdminPostTaxRatesTaxRateReq

// DeleteTaxRatesTaxRateProductTypesJSONRequestBody defines body for DeleteTaxRatesTaxRateProductTypes for application/json ContentType.
type DeleteTaxRatesTaxRateProductTypesJSONRequestBody = AdminDeleteTaxRatesTaxRateProductTypesReq

// PostTaxRatesTaxRateProductTypesJSONRequestBody defines body for PostTaxRatesTaxRateProductTypes for application/json ContentType.
type PostTaxRatesTaxRateProductTypesJSONRequestBody = AdminPostTaxRatesTaxRateProductTypesReq

// DeleteTaxRatesTaxRateProductsJSONRequestBody defines body for DeleteTaxRatesTaxRateProducts for application/json ContentType.
type DeleteTaxRatesTaxRateProductsJSONRequestBody = AdminDeleteTaxRatesTaxRateProductsReq

// PostTaxRatesTaxRateProductsJSONRequestBody defines body for PostTaxRatesTaxRateProducts for application/json ContentType.
type PostTaxRatesTaxRateProductsJSONRequestBody = AdminPostTaxRatesTaxRateProductsReq

// DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody defines body for DeleteTaxRatesTaxRateShippingOptions for application/json ContentType.
type DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody = AdminDeleteTaxRatesTaxRateShippingOptionsReq

// PostTaxRatesTaxRateShippingOptionsJSONRequestBody defines body for PostTaxRatesTaxRateShippingOptions for application/json ContentType.
type PostTaxRatesTaxRateShippingOptionsJSONRequestBody = AdminPostTaxRatesTaxRateShippingOptionsReq

// DeleteUploadsJSONRequestBody defines body for DeleteUploads for application/json ContentType.
type DeleteUploadsJSONRequestBody = AdminDeleteUploadsReq

// PostUploadsMultipartRequestBody defines body for PostUploads for multipart/form-data ContentType.
type PostUploadsMultipartRequestBody PostUploadsMultipartBody

// PostUploadsDownloadUrlJSONRequestBody defines body for PostUploadsDownloadUrl for application/json ContentType.
type PostUploadsDownloadUrlJSONRequestBody = AdminPostUploadsDownloadUrlReq

// PostUploadsProtectedMultipartRequestBody defines body for PostUploadsProtected for multipart/form-data ContentType.
type PostUploadsProtectedMultipartRequestBody PostUploadsProtectedMultipartBody

// PostUsersJSONRequestBody defines body for PostUsers for application/json ContentType.
type PostUsersJSONRequestBody = AdminCreateUserRequest

// PostUsersUserPasswordTokenJSONRequestBody defines body for PostUsersUserPasswordToken for application/json ContentType.
type PostUsersUserPasswordTokenJSONRequestBody = AdminResetPasswordTokenRequest

// PostUsersUserPasswordJSONRequestBody defines body for PostUsersUserPassword for application/json ContentType.
type PostUsersUserPasswordJSONRequestBody = AdminResetPasswordRequest

// PostUsersUserJSONRequestBody defines body for PostUsersUser for application/json ContentType.
type PostUsersUserJSONRequestBody = AdminUpdateUserRequest

// AsAddressPayload returns the union data inside the AdminPostDraftOrdersDraftOrderReq_BillingAddress as a AddressPayload
func (t AdminPostDraftOrdersDraftOrderReq_BillingAddress) AsAddressPayload() (AddressPayload, error) {
	var body AddressPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddressPayload overwrites any union data inside the AdminPostDraftOrdersDraftOrderReq_BillingAddress as the provided AddressPayload
func (t *AdminPostDraftOrdersDraftOrderReq_BillingAddress) FromAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddressPayload performs a merge with any union data inside the AdminPostDraftOrdersDraftOrderReq_BillingAddress, using the provided AddressPayload
func (t *AdminPostDraftOrdersDraftOrderReq_BillingAddress) MergeAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminPostDraftOrdersDraftOrderReqBillingAddress1 returns the union data inside the AdminPostDraftOrdersDraftOrderReq_BillingAddress as a AdminPostDraftOrdersDraftOrderReqBillingAddress1
func (t AdminPostDraftOrdersDraftOrderReq_BillingAddress) AsAdminPostDraftOrdersDraftOrderReqBillingAddress1() (AdminPostDraftOrdersDraftOrderReqBillingAddress1, error) {
	var body AdminPostDraftOrdersDraftOrderReqBillingAddress1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminPostDraftOrdersDraftOrderReqBillingAddress1 overwrites any union data inside the AdminPostDraftOrdersDraftOrderReq_BillingAddress as the provided AdminPostDraftOrdersDraftOrderReqBillingAddress1
func (t *AdminPostDraftOrdersDraftOrderReq_BillingAddress) FromAdminPostDraftOrdersDraftOrderReqBillingAddress1(v AdminPostDraftOrdersDraftOrderReqBillingAddress1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminPostDraftOrdersDraftOrderReqBillingAddress1 performs a merge with any union data inside the AdminPostDraftOrdersDraftOrderReq_BillingAddress, using the provided AdminPostDraftOrdersDraftOrderReqBillingAddress1
func (t *AdminPostDraftOrdersDraftOrderReq_BillingAddress) MergeAdminPostDraftOrdersDraftOrderReqBillingAddress1(v AdminPostDraftOrdersDraftOrderReqBillingAddress1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminPostDraftOrdersDraftOrderReq_BillingAddress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminPostDraftOrdersDraftOrderReq_BillingAddress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAddressPayload returns the union data inside the AdminPostDraftOrdersDraftOrderReq_ShippingAddress as a AddressPayload
func (t AdminPostDraftOrdersDraftOrderReq_ShippingAddress) AsAddressPayload() (AddressPayload, error) {
	var body AddressPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddressPayload overwrites any union data inside the AdminPostDraftOrdersDraftOrderReq_ShippingAddress as the provided AddressPayload
func (t *AdminPostDraftOrdersDraftOrderReq_ShippingAddress) FromAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddressPayload performs a merge with any union data inside the AdminPostDraftOrdersDraftOrderReq_ShippingAddress, using the provided AddressPayload
func (t *AdminPostDraftOrdersDraftOrderReq_ShippingAddress) MergeAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminPostDraftOrdersDraftOrderReqShippingAddress1 returns the union data inside the AdminPostDraftOrdersDraftOrderReq_ShippingAddress as a AdminPostDraftOrdersDraftOrderReqShippingAddress1
func (t AdminPostDraftOrdersDraftOrderReq_ShippingAddress) AsAdminPostDraftOrdersDraftOrderReqShippingAddress1() (AdminPostDraftOrdersDraftOrderReqShippingAddress1, error) {
	var body AdminPostDraftOrdersDraftOrderReqShippingAddress1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminPostDraftOrdersDraftOrderReqShippingAddress1 overwrites any union data inside the AdminPostDraftOrdersDraftOrderReq_ShippingAddress as the provided AdminPostDraftOrdersDraftOrderReqShippingAddress1
func (t *AdminPostDraftOrdersDraftOrderReq_ShippingAddress) FromAdminPostDraftOrdersDraftOrderReqShippingAddress1(v AdminPostDraftOrdersDraftOrderReqShippingAddress1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminPostDraftOrdersDraftOrderReqShippingAddress1 performs a merge with any union data inside the AdminPostDraftOrdersDraftOrderReq_ShippingAddress, using the provided AdminPostDraftOrdersDraftOrderReqShippingAddress1
func (t *AdminPostDraftOrdersDraftOrderReq_ShippingAddress) MergeAdminPostDraftOrdersDraftOrderReqShippingAddress1(v AdminPostDraftOrdersDraftOrderReqShippingAddress1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminPostDraftOrdersDraftOrderReq_ShippingAddress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminPostDraftOrdersDraftOrderReq_ShippingAddress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAddressPayload returns the union data inside the AdminPostDraftOrdersReq_BillingAddress as a AddressPayload
func (t AdminPostDraftOrdersReq_BillingAddress) AsAddressPayload() (AddressPayload, error) {
	var body AddressPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddressPayload overwrites any union data inside the AdminPostDraftOrdersReq_BillingAddress as the provided AddressPayload
func (t *AdminPostDraftOrdersReq_BillingAddress) FromAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddressPayload performs a merge with any union data inside the AdminPostDraftOrdersReq_BillingAddress, using the provided AddressPayload
func (t *AdminPostDraftOrdersReq_BillingAddress) MergeAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminPostDraftOrdersReqBillingAddress1 returns the union data inside the AdminPostDraftOrdersReq_BillingAddress as a AdminPostDraftOrdersReqBillingAddress1
func (t AdminPostDraftOrdersReq_BillingAddress) AsAdminPostDraftOrdersReqBillingAddress1() (AdminPostDraftOrdersReqBillingAddress1, error) {
	var body AdminPostDraftOrdersReqBillingAddress1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminPostDraftOrdersReqBillingAddress1 overwrites any union data inside the AdminPostDraftOrdersReq_BillingAddress as the provided AdminPostDraftOrdersReqBillingAddress1
func (t *AdminPostDraftOrdersReq_BillingAddress) FromAdminPostDraftOrdersReqBillingAddress1(v AdminPostDraftOrdersReqBillingAddress1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminPostDraftOrdersReqBillingAddress1 performs a merge with any union data inside the AdminPostDraftOrdersReq_BillingAddress, using the provided AdminPostDraftOrdersReqBillingAddress1
func (t *AdminPostDraftOrdersReq_BillingAddress) MergeAdminPostDraftOrdersReqBillingAddress1(v AdminPostDraftOrdersReqBillingAddress1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminPostDraftOrdersReq_BillingAddress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminPostDraftOrdersReq_BillingAddress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAddressPayload returns the union data inside the AdminPostDraftOrdersReq_ShippingAddress as a AddressPayload
func (t AdminPostDraftOrdersReq_ShippingAddress) AsAddressPayload() (AddressPayload, error) {
	var body AddressPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddressPayload overwrites any union data inside the AdminPostDraftOrdersReq_ShippingAddress as the provided AddressPayload
func (t *AdminPostDraftOrdersReq_ShippingAddress) FromAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddressPayload performs a merge with any union data inside the AdminPostDraftOrdersReq_ShippingAddress, using the provided AddressPayload
func (t *AdminPostDraftOrdersReq_ShippingAddress) MergeAddressPayload(v AddressPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAdminPostDraftOrdersReqShippingAddress1 returns the union data inside the AdminPostDraftOrdersReq_ShippingAddress as a AdminPostDraftOrdersReqShippingAddress1
func (t AdminPostDraftOrdersReq_ShippingAddress) AsAdminPostDraftOrdersReqShippingAddress1() (AdminPostDraftOrdersReqShippingAddress1, error) {
	var body AdminPostDraftOrdersReqShippingAddress1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAdminPostDraftOrdersReqShippingAddress1 overwrites any union data inside the AdminPostDraftOrdersReq_ShippingAddress as the provided AdminPostDraftOrdersReqShippingAddress1
func (t *AdminPostDraftOrdersReq_ShippingAddress) FromAdminPostDraftOrdersReqShippingAddress1(v AdminPostDraftOrdersReqShippingAddress1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAdminPostDraftOrdersReqShippingAddress1 performs a merge with any union data inside the AdminPostDraftOrdersReq_ShippingAddress, using the provided AdminPostDraftOrdersReqShippingAddress1
func (t *AdminPostDraftOrdersReq_ShippingAddress) MergeAdminPostDraftOrdersReqShippingAddress1(v AdminPostDraftOrdersReqShippingAddress1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AdminPostDraftOrdersReq_ShippingAddress) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AdminPostDraftOrdersReq_ShippingAddress) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBatchJobResultErrorsCode0 returns the union data inside the BatchJob_Result_Errors_Code as a BatchJobResultErrorsCode0
func (t BatchJob_Result_Errors_Code) AsBatchJobResultErrorsCode0() (BatchJobResultErrorsCode0, error) {
	var body BatchJobResultErrorsCode0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchJobResultErrorsCode0 overwrites any union data inside the BatchJob_Result_Errors_Code as the provided BatchJobResultErrorsCode0
func (t *BatchJob_Result_Errors_Code) FromBatchJobResultErrorsCode0(v BatchJobResultErrorsCode0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchJobResultErrorsCode0 performs a merge with any union data inside the BatchJob_Result_Errors_Code, using the provided BatchJobResultErrorsCode0
func (t *BatchJob_Result_Errors_Code) MergeBatchJobResultErrorsCode0(v BatchJobResultErrorsCode0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBatchJobResultErrorsCode1 returns the union data inside the BatchJob_Result_Errors_Code as a BatchJobResultErrorsCode1
func (t BatchJob_Result_Errors_Code) AsBatchJobResultErrorsCode1() (BatchJobResultErrorsCode1, error) {
	var body BatchJobResultErrorsCode1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatchJobResultErrorsCode1 overwrites any union data inside the BatchJob_Result_Errors_Code as the provided BatchJobResultErrorsCode1
func (t *BatchJob_Result_Errors_Code) FromBatchJobResultErrorsCode1(v BatchJobResultErrorsCode1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatchJobResultErrorsCode1 performs a merge with any union data inside the BatchJob_Result_Errors_Code, using the provided BatchJobResultErrorsCode1
func (t *BatchJob_Result_Errors_Code) MergeBatchJobResultErrorsCode1(v BatchJobResultErrorsCode1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchJob_Result_Errors_Code) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchJob_Result_Errors_Code) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsError returns the union data inside the N400Error as a Error
func (t N400Error) AsError() (Error, error) {
	var body Error
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromError overwrites any union data inside the N400Error as the provided Error
func (t *N400Error) FromError(v Error) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeError performs a merge with any union data inside the N400Error, using the provided Error
func (t *N400Error) MergeError(v Error) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultipleErrors returns the union data inside the N400Error as a MultipleErrors
func (t N400Error) AsMultipleErrors() (MultipleErrors, error) {
	var body MultipleErrors
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultipleErrors overwrites any union data inside the N400Error as the provided MultipleErrors
func (t *N400Error) FromMultipleErrors(v MultipleErrors) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultipleErrors performs a merge with any union data inside the N400Error, using the provided MultipleErrors
func (t *N400Error) MergeMultipleErrors(v MultipleErrors) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t N400Error) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *N400Error) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetApps request
	GetApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAppsWithBody request with any body
	PostAppsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApps(ctx context.Context, body PostAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuth request
	DeleteAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuth request
	GetAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthWithBody request with any body
	PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTokenWithBody request with any body
	PostTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostToken(ctx context.Context, body PostTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchJobs request
	GetBatchJobs(ctx context.Context, params *GetBatchJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBatchJobsWithBody request with any body
	PostBatchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBatchJobs(ctx context.Context, body PostBatchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchJobsBatchJob request
	GetBatchJobsBatchJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBatchJobsBatchJobCancel request
	PostBatchJobsBatchJobCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBatchJobsBatchJobConfirmProcessing request
	PostBatchJobsBatchJobConfirmProcessing(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollections request
	GetCollections(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollectionsWithBody request with any body
	PostCollectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollections(ctx context.Context, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollectionsCollection request
	DeleteCollectionsCollection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectionsCollection request
	GetCollectionsCollection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCollectionsCollectionWithBody request with any body
	PostCollectionsCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCollectionsCollection(ctx context.Context, id string, body PostCollectionsCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsFromCollectionWithBody request with any body
	DeleteProductsFromCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteProductsFromCollection(ctx context.Context, id string, body DeleteProductsFromCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsToCollectionWithBody request with any body
	PostProductsToCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsToCollection(ctx context.Context, id string, body PostProductsToCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencies request
	GetCurrencies(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCurrenciesCurrencyWithBody request with any body
	PostCurrenciesCurrencyWithBody(ctx context.Context, code string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCurrenciesCurrency(ctx context.Context, code string, body PostCurrenciesCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerGroups request
	GetCustomerGroups(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerGroupsWithBody request with any body
	PostCustomerGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerGroups(ctx context.Context, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomerGroupsCustomerGroup request
	DeleteCustomerGroupsCustomerGroup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerGroupsGroup request
	GetCustomerGroupsGroup(ctx context.Context, id string, params *GetCustomerGroupsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerGroupsGroupWithBody request with any body
	PostCustomerGroupsGroupWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerGroupsGroup(ctx context.Context, id string, body PostCustomerGroupsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerGroupsGroupCustomers request
	GetCustomerGroupsGroupCustomers(ctx context.Context, id string, params *GetCustomerGroupsGroupCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomerGroupsGroupCustomerBatchWithBody request with any body
	DeleteCustomerGroupsGroupCustomerBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCustomerGroupsGroupCustomerBatch(ctx context.Context, id string, body DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomerGroupsGroupCustomersBatchWithBody request with any body
	PostCustomerGroupsGroupCustomersBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomerGroupsGroupCustomersBatch(ctx context.Context, id string, body PostCustomerGroupsGroupCustomersBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomers request
	GetCustomers(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersWithBody request with any body
	PostCustomersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomers(ctx context.Context, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomersCustomer request
	GetCustomersCustomer(ctx context.Context, id string, params *GetCustomersCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCustomersCustomerWithBody request with any body
	PostCustomersCustomerWithBody(ctx context.Context, id string, params *PostCustomersCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCustomersCustomer(ctx context.Context, id string, params *PostCustomersCustomerParams, body PostCustomersCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscounts request
	GetDiscounts(ctx context.Context, params *GetDiscountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsWithBody request with any body
	PostDiscountsWithBody(ctx context.Context, params *PostDiscountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDiscounts(ctx context.Context, params *PostDiscountsParams, body PostDiscountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscountsDiscountCode request
	GetDiscountsDiscountCode(ctx context.Context, code string, params *GetDiscountsDiscountCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsDiscountConditionsWithBody request with any body
	PostDiscountsDiscountConditionsWithBody(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDiscountsDiscountConditions(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, body PostDiscountsDiscountConditionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDiscountsDiscountConditionsCondition request
	DeleteDiscountsDiscountConditionsCondition(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscountsDiscountConditionsCondition request
	GetDiscountsDiscountConditionsCondition(ctx context.Context, discountId string, conditionId string, params *GetDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsDiscountConditionsConditionWithBody request with any body
	PostDiscountsDiscountConditionsConditionWithBody(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDiscountsDiscountConditionsCondition(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, body PostDiscountsDiscountConditionsConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDiscountsDiscountConditionsConditionBatchWithBody request with any body
	DeleteDiscountsDiscountConditionsConditionBatchWithBody(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteDiscountsDiscountConditionsConditionBatch(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, body DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsDiscountConditionsConditionBatchWithBody request with any body
	PostDiscountsDiscountConditionsConditionBatchWithBody(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDiscountsDiscountConditionsConditionBatch(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, body PostDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDiscountsDiscount request
	DeleteDiscountsDiscount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiscountsDiscount request
	GetDiscountsDiscount(ctx context.Context, id string, params *GetDiscountsDiscountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsDiscountWithBody request with any body
	PostDiscountsDiscountWithBody(ctx context.Context, id string, params *PostDiscountsDiscountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDiscountsDiscount(ctx context.Context, id string, params *PostDiscountsDiscountParams, body PostDiscountsDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsDiscountDynamicCodesWithBody request with any body
	PostDiscountsDiscountDynamicCodesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDiscountsDiscountDynamicCodes(ctx context.Context, id string, body PostDiscountsDiscountDynamicCodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDiscountsDiscountDynamicCodesCode request
	DeleteDiscountsDiscountDynamicCodesCode(ctx context.Context, id string, code string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDiscountsDiscountRegionsRegion request
	DeleteDiscountsDiscountRegionsRegion(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDiscountsDiscountRegionsRegion request
	PostDiscountsDiscountRegionsRegion(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDraftOrders request
	GetDraftOrders(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDraftOrdersWithBody request with any body
	PostDraftOrdersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDraftOrders(ctx context.Context, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDraftOrdersDraftOrder request
	DeleteDraftOrdersDraftOrder(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDraftOrdersDraftOrder request
	GetDraftOrdersDraftOrder(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDraftOrdersDraftOrderWithBody request with any body
	PostDraftOrdersDraftOrderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDraftOrdersDraftOrder(ctx context.Context, id string, body PostDraftOrdersDraftOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDraftOrdersDraftOrderLineItemsWithBody request with any body
	PostDraftOrdersDraftOrderLineItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDraftOrdersDraftOrderLineItems(ctx context.Context, id string, body PostDraftOrdersDraftOrderLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDraftOrdersDraftOrderLineItemsItem request
	DeleteDraftOrdersDraftOrderLineItemsItem(ctx context.Context, id string, lineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDraftOrdersDraftOrderLineItemsItemWithBody request with any body
	PostDraftOrdersDraftOrderLineItemsItemWithBody(ctx context.Context, id string, lineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDraftOrdersDraftOrderLineItemsItem(ctx context.Context, id string, lineId string, body PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDraftOrdersDraftOrderRegisterPayment request
	PostDraftOrdersDraftOrderRegisterPayment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGiftCards request
	GetGiftCards(ctx context.Context, params *GetGiftCardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGiftCardsWithBody request with any body
	PostGiftCardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGiftCards(ctx context.Context, body PostGiftCardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGiftCardsGiftCard request
	DeleteGiftCardsGiftCard(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGiftCardsGiftCard request
	GetGiftCardsGiftCard(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGiftCardsGiftCardWithBody request with any body
	PostGiftCardsGiftCardWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGiftCardsGiftCard(ctx context.Context, id string, body PostGiftCardsGiftCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItems request
	GetInventoryItems(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsWithBody request with any body
	PostInventoryItemsWithBody(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItems(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInventoryItemsInventoryItem request
	DeleteInventoryItemsInventoryItem(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItemsInventoryItem request
	GetInventoryItemsInventoryItem(ctx context.Context, id string, params *GetInventoryItemsInventoryItemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsInventoryItemWithBody request with any body
	PostInventoryItemsInventoryItemWithBody(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsInventoryItem(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, body PostInventoryItemsInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInventoryItemsInventoryItemLocationLevels request
	GetInventoryItemsInventoryItemLocationLevels(ctx context.Context, id string, params *GetInventoryItemsInventoryItemLocationLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsInventoryItemLocationLevelsWithBody request with any body
	PostInventoryItemsInventoryItemLocationLevelsWithBody(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsInventoryItemLocationLevels(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, body PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInventoryItemsInventoryIteLocationLevelsLocation request
	DeleteInventoryItemsInventoryIteLocationLevelsLocation(ctx context.Context, id string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBody request with any body
	PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBody(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInventoryItemsInventoryItemLocationLevelsLocationLevel(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, body PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvites request
	GetInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInvitesWithBody request with any body
	PostInvitesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInvites(ctx context.Context, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInvitesInviteAcceptWithBody request with any body
	PostInvitesInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInvitesInviteAccept(ctx context.Context, body PostInvitesInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvitesInvite request
	DeleteInvitesInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInvitesInviteResend request
	PostInvitesInviteResend(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotes request
	GetNotes(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNotesWithBody request with any body
	PostNotesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNotes(ctx context.Context, body PostNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotesNote request
	DeleteNotesNote(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotesNote request
	GetNotesNote(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNotesNoteWithBody request with any body
	PostNotesNoteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNotesNote(ctx context.Context, id string, body PostNotesNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotifications request
	GetNotifications(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNotificationsNotificationResendWithBody request with any body
	PostNotificationsNotificationResendWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNotificationsNotificationResend(ctx context.Context, id string, body PostNotificationsNotificationResendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderEdits request
	GetOrderEdits(ctx context.Context, params *GetOrderEditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsWithBody request with any body
	PostOrderEditsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEdits(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderEditsOrderEdit request
	DeleteOrderEditsOrderEdit(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderEditsOrderEdit request
	GetOrderEditsOrderEdit(ctx context.Context, id string, params *GetOrderEditsOrderEditParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsOrderEditWithBody request with any body
	PostOrderEditsOrderEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsOrderEdit(ctx context.Context, id string, body PostOrderEditsOrderEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsOrderEditCancel request
	PostOrderEditsOrderEditCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderEditsOrderEditItemChange request
	DeleteOrderEditsOrderEditItemChange(ctx context.Context, id string, changeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsOrderEditConfirm request
	PostOrderEditsOrderEditConfirm(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsEditLineItemsWithBody request with any body
	PostOrderEditsEditLineItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsEditLineItems(ctx context.Context, id string, body PostOrderEditsEditLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrderEditsOrderEditLineItemsLineItem request
	DeleteOrderEditsOrderEditLineItemsLineItem(ctx context.Context, id string, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsEditLineItemsLineItemWithBody request with any body
	PostOrderEditsEditLineItemsLineItemWithBody(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrderEditsEditLineItemsLineItem(ctx context.Context, id string, itemId string, body PostOrderEditsEditLineItemsLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrderEditsOrderEditRequest request
	PostOrderEditsOrderEditRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrdersOrder request
	GetOrdersOrder(ctx context.Context, id string, params *GetOrdersOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderWithBody request with any body
	PostOrdersOrderWithBody(ctx context.Context, id string, params *PostOrdersOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrder(ctx context.Context, id string, params *PostOrdersOrderParams, body PostOrdersOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderArchive request
	PostOrdersOrderArchive(ctx context.Context, id string, params *PostOrdersOrderArchiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderCancel request
	PostOrdersOrderCancel(ctx context.Context, id string, params *PostOrdersOrderCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderCapture request
	PostOrdersOrderCapture(ctx context.Context, id string, params *PostOrdersOrderCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderClaimsWithBody request with any body
	PostOrdersOrderClaimsWithBody(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderClaims(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, body PostOrdersOrderClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderClaimsClaimWithBody request with any body
	PostOrdersOrderClaimsClaimWithBody(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderClaimsClaim(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, body PostOrdersOrderClaimsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersClaimCancel request
	PostOrdersClaimCancel(ctx context.Context, id string, claimId string, params *PostOrdersClaimCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderClaimsClaimFulfillmentsWithBody request with any body
	PostOrdersOrderClaimsClaimFulfillmentsWithBody(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderClaimsClaimFulfillments(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, body PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersClaimFulfillmentsCancel request
	PostOrdersClaimFulfillmentsCancel(ctx context.Context, id string, claimId string, fulfillmentId string, params *PostOrdersClaimFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderClaimsClaimShipmentsWithBody request with any body
	PostOrdersOrderClaimsClaimShipmentsWithBody(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderClaimsClaimShipments(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, body PostOrdersOrderClaimsClaimShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderComplete request
	PostOrdersOrderComplete(ctx context.Context, id string, params *PostOrdersOrderCompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderFulfillmentsWithBody request with any body
	PostOrdersOrderFulfillmentsWithBody(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderFulfillments(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, body PostOrdersOrderFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderFulfillmentsCancel request
	PostOrdersOrderFulfillmentsCancel(ctx context.Context, id string, fulfillmentId string, params *PostOrdersOrderFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderLineItemReservationsWithBody request with any body
	PostOrdersOrderLineItemReservationsWithBody(ctx context.Context, id string, lineItemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderLineItemReservations(ctx context.Context, id string, lineItemId string, body PostOrdersOrderLineItemReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderRefundsWithBody request with any body
	PostOrdersOrderRefundsWithBody(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderRefunds(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, body PostOrdersOrderRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrdersOrderReservations request
	GetOrdersOrderReservations(ctx context.Context, id string, params *GetOrdersOrderReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderReturnsWithBody request with any body
	PostOrdersOrderReturnsWithBody(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderReturns(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, body PostOrdersOrderReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderShipmentWithBody request with any body
	PostOrdersOrderShipmentWithBody(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderShipment(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, body PostOrdersOrderShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderShippingMethodsWithBody request with any body
	PostOrdersOrderShippingMethodsWithBody(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderShippingMethods(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, body PostOrdersOrderShippingMethodsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderSwapsWithBody request with any body
	PostOrdersOrderSwapsWithBody(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderSwaps(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, body PostOrdersOrderSwapsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersSwapCancel request
	PostOrdersSwapCancel(ctx context.Context, id string, swapId string, params *PostOrdersSwapCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderSwapsSwapFulfillmentsWithBody request with any body
	PostOrdersOrderSwapsSwapFulfillmentsWithBody(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderSwapsSwapFulfillments(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, body PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersSwapFulfillmentsCancel request
	PostOrdersSwapFulfillmentsCancel(ctx context.Context, id string, swapId string, fulfillmentId string, params *PostOrdersSwapFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderSwapsSwapProcessPayment request
	PostOrdersOrderSwapsSwapProcessPayment(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapProcessPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOrdersOrderSwapsSwapShipmentsWithBody request with any body
	PostOrdersOrderSwapsSwapShipmentsWithBody(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOrdersOrderSwapsSwapShipments(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, body PostOrdersOrderSwapsSwapShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePaymentCollectionsPaymentCollection request
	DeletePaymentCollectionsPaymentCollection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentCollectionsPaymentCollection request
	GetPaymentCollectionsPaymentCollection(ctx context.Context, id string, params *GetPaymentCollectionsPaymentCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentCollectionsPaymentCollectionWithBody request with any body
	PostPaymentCollectionsPaymentCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPaymentCollectionsPaymentCollection(ctx context.Context, id string, body PostPaymentCollectionsPaymentCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentCollectionsPaymentCollectionAuthorize request
	PostPaymentCollectionsPaymentCollectionAuthorize(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentsPayment request
	GetPaymentsPayment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentsPaymentCapture request
	PostPaymentsPaymentCapture(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPaymentsPaymentRefundsWithBody request with any body
	PostPaymentsPaymentRefundsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPaymentsPaymentRefunds(ctx context.Context, id string, body PostPaymentsPaymentRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPriceLists request
	GetPriceLists(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsPriceListWithBody request with any body
	PostPriceListsPriceListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceListsPriceList(ctx context.Context, body PostPriceListsPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePriceListsPriceList request
	DeletePriceListsPriceList(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPriceListsPriceList request
	GetPriceListsPriceList(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsPriceListPriceListWithBody request with any body
	PostPriceListsPriceListPriceListWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceListsPriceListPriceList(ctx context.Context, id string, body PostPriceListsPriceListPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePriceListsPriceListPricesBatchWithBody request with any body
	DeletePriceListsPriceListPricesBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePriceListsPriceListPricesBatch(ctx context.Context, id string, body DeletePriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPriceListsPriceListPricesBatchWithBody request with any body
	PostPriceListsPriceListPricesBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPriceListsPriceListPricesBatch(ctx context.Context, id string, body PostPriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPriceListsPriceListProducts request
	GetPriceListsPriceListProducts(ctx context.Context, id string, params *GetPriceListsPriceListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePriceListsPriceListProductsPricesBatch request
	DeletePriceListsPriceListProductsPricesBatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePriceListsPriceListProductsProductPrices request
	DeletePriceListsPriceListProductsProductPrices(ctx context.Context, id string, productId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePriceListsPriceListVariantsVariantPrices request
	DeletePriceListsPriceListVariantsVariantPrices(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductCategories request
	GetProductCategories(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductCategoriesWithBody request with any body
	PostProductCategoriesWithBody(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductCategories(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductCategoriesCategory request
	DeleteProductCategoriesCategory(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductCategoriesCategory request
	GetProductCategoriesCategory(ctx context.Context, id string, params *GetProductCategoriesCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductCategoriesCategoryWithBody request with any body
	PostProductCategoriesCategoryWithBody(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductCategoriesCategory(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, body PostProductCategoriesCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductCategoriesCategoryProductsBatchWithBody request with any body
	DeleteProductCategoriesCategoryProductsBatchWithBody(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteProductCategoriesCategoryProductsBatch(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, body DeleteProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductCategoriesCategoryProductsBatchWithBody request with any body
	PostProductCategoriesCategoryProductsBatchWithBody(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductCategoriesCategoryProductsBatch(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, body PostProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductTags request
	GetProductTags(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductTypes request
	GetProductTypes(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducts request
	GetProducts(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsWithBody request with any body
	PostProductsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProducts(ctx context.Context, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsTagUsage request
	GetProductsTagUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsTypes request
	GetProductsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsProduct request
	DeleteProductsProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsProduct request
	GetProductsProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductWithBody request with any body
	PostProductsProductWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProduct(ctx context.Context, id string, body PostProductsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductMetadataWithBody request with any body
	PostProductsProductMetadataWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProductMetadata(ctx context.Context, id string, body PostProductsProductMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductOptionsWithBody request with any body
	PostProductsProductOptionsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProductOptions(ctx context.Context, id string, body PostProductsProductOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsProductOptionsOption request
	DeleteProductsProductOptionsOption(ctx context.Context, id string, optionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductOptionsOptionWithBody request with any body
	PostProductsProductOptionsOptionWithBody(ctx context.Context, id string, optionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProductOptionsOption(ctx context.Context, id string, optionId string, body PostProductsProductOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductsProductVariants request
	GetProductsProductVariants(ctx context.Context, id string, params *GetProductsProductVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductVariantsWithBody request with any body
	PostProductsProductVariantsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProductVariants(ctx context.Context, id string, body PostProductsProductVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductsProductVariantsVariant request
	DeleteProductsProductVariantsVariant(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostProductsProductVariantsVariantWithBody request with any body
	PostProductsProductVariantsVariantWithBody(ctx context.Context, id string, variantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostProductsProductVariantsVariant(ctx context.Context, id string, variantId string, body PostProductsProductVariantsVariantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublishableApiKeys request
	GetPublishableApiKeys(ctx context.Context, params *GetPublishableApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPublishableApiKeysWithBody request with any body
	PostPublishableApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPublishableApiKeys(ctx context.Context, body PostPublishableApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublishableApiKeysPublishableApiKey request
	DeletePublishableApiKeysPublishableApiKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublishableApiKeysPublishableApiKey request
	GetPublishableApiKeysPublishableApiKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPublishableApiKysPublishableApiKeyWithBody request with any body
	PostPublishableApiKysPublishableApiKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPublishableApiKysPublishableApiKey(ctx context.Context, id string, body PostPublishableApiKysPublishableApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPublishableApiKeysPublishableApiKeyRevoke request
	PostPublishableApiKeysPublishableApiKeyRevoke(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublishableApiKeySalesChannels request
	GetPublishableApiKeySalesChannels(ctx context.Context, id string, params *GetPublishableApiKeySalesChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePublishableApiKeySalesChannelsChannelsBatchWithBody request with any body
	DeletePublishableApiKeySalesChannelsChannelsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePublishableApiKeySalesChannelsChannelsBatch(ctx context.Context, id string, body DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPublishableApiKeySalesChannelsChannelsBatchWithBody request with any body
	PostPublishableApiKeySalesChannelsChannelsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPublishableApiKeySalesChannelsChannelsBatch(ctx context.Context, id string, body PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegions request
	GetRegions(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsWithBody request with any body
	PostRegionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegions(ctx context.Context, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRegionsRegion request
	DeleteRegionsRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegionsRegion request
	GetRegionsRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionWithBody request with any body
	PostRegionsRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegionsRegion(ctx context.Context, id string, body PostRegionsRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionCountriesWithBody request with any body
	PostRegionsRegionCountriesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegionsRegionCountries(ctx context.Context, id string, body PostRegionsRegionCountriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionCountriesCountry request
	PostRegionsRegionCountriesCountry(ctx context.Context, id string, countryCode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegionsRegionFulfillmentOptions request
	GetRegionsRegionFulfillmentOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionFulfillmentProvidersWithBody request with any body
	PostRegionsRegionFulfillmentProvidersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegionsRegionFulfillmentProviders(ctx context.Context, id string, body PostRegionsRegionFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionFulfillmentProvidersProvider request
	PostRegionsRegionFulfillmentProvidersProvider(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionPaymentProvidersWithBody request with any body
	PostRegionsRegionPaymentProvidersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegionsRegionPaymentProviders(ctx context.Context, id string, body PostRegionsRegionPaymentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegionsRegionPaymentProvidersProvider request
	PostRegionsRegionPaymentProvidersProvider(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservations request
	GetReservations(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservationsWithBody request with any body
	PostReservationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReservations(ctx context.Context, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservationsReservation request
	DeleteReservationsReservation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservationsReservation request
	GetReservationsReservation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservationsReservationWithBody request with any body
	PostReservationsReservationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReservationsReservation(ctx context.Context, id string, body PostReservationsReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturnReasons request
	GetReturnReasons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnReasonsWithBody request with any body
	PostReturnReasonsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnReasons(ctx context.Context, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReturnReason request
	DeleteReturnReason(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturnReasonsReason request
	GetReturnReasonsReason(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnReasonsReasonWithBody request with any body
	PostReturnReasonsReasonWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnReasonsReason(ctx context.Context, id string, body PostReturnReasonsReasonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReturns request
	GetReturns(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsReturnCancel request
	PostReturnsReturnCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReturnsReturnReceiveWithBody request with any body
	PostReturnsReturnReceiveWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReturnsReturnReceive(ctx context.Context, id string, body PostReturnsReturnReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSalesChannels request
	GetSalesChannels(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsWithBody request with any body
	PostSalesChannelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannels(ctx context.Context, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSalesChannelsSalesChannel request
	DeleteSalesChannelsSalesChannel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSalesChannelsSalesChannel request
	GetSalesChannelsSalesChannel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsSalesChannelWithBody request with any body
	PostSalesChannelsSalesChannelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannelsSalesChannel(ctx context.Context, id string, body PostSalesChannelsSalesChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSalesChannelsChannelProductsBatchWithBody request with any body
	DeleteSalesChannelsChannelProductsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSalesChannelsChannelProductsBatch(ctx context.Context, id string, body DeleteSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsChannelProductsBatchWithBody request with any body
	PostSalesChannelsChannelProductsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannelsChannelProductsBatch(ctx context.Context, id string, body PostSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSalesChannelsSalesChannelStockLocationWithBody request with any body
	DeleteSalesChannelsSalesChannelStockLocationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSalesChannelsSalesChannelStockLocation(ctx context.Context, id string, body DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSalesChannelsSalesChannelStockLocationWithBody request with any body
	PostSalesChannelsSalesChannelStockLocationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSalesChannelsSalesChannelStockLocation(ctx context.Context, id string, body PostSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingOptions request
	GetShippingOptions(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingOptionsWithBody request with any body
	PostShippingOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingOptions(ctx context.Context, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShippingOptionsOption request
	DeleteShippingOptionsOption(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingOptionsOption request
	GetShippingOptionsOption(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingOptionsOptionWithBody request with any body
	PostShippingOptionsOptionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingOptionsOption(ctx context.Context, id string, body PostShippingOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingProfiles request
	GetShippingProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingProfilesWithBody request with any body
	PostShippingProfilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingProfiles(ctx context.Context, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteShippingProfilesProfile request
	DeleteShippingProfilesProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShippingProfilesProfile request
	GetShippingProfilesProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostShippingProfilesProfileWithBody request with any body
	PostShippingProfilesProfileWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostShippingProfilesProfile(ctx context.Context, id string, body PostShippingProfilesProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStockLocations request
	GetStockLocations(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsWithBody request with any body
	PostStockLocationsWithBody(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocations(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStockLocationsStockLocation request
	DeleteStockLocationsStockLocation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStockLocationsStockLocation request
	GetStockLocationsStockLocation(ctx context.Context, id string, params *GetStockLocationsStockLocationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStockLocationsStockLocationWithBody request with any body
	PostStockLocationsStockLocationWithBody(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStockLocationsStockLocation(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, body PostStockLocationsStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStore request
	GetStore(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStoreWithBody request with any body
	PostStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStore(ctx context.Context, body PostStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoreCurrenciesCode request
	DeleteStoreCurrenciesCode(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStoreCurrenciesCode request
	PostStoreCurrenciesCode(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorePaymentProviders request
	GetStorePaymentProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoreTaxProviders request
	GetStoreTaxProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwaps request
	GetSwaps(ctx context.Context, params *GetSwapsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwapsSwap request
	GetSwapsSwap(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxRates request
	GetTaxRates(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesWithBody request with any body
	PostTaxRatesWithBody(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRates(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRatesTaxRate request
	DeleteTaxRatesTaxRate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTaxRatesTaxRate request
	GetTaxRatesTaxRate(ctx context.Context, id string, params *GetTaxRatesTaxRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesTaxRateWithBody request with any body
	PostTaxRatesTaxRateWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRatesTaxRate(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, body PostTaxRatesTaxRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRatesTaxRateProductTypesWithBody request with any body
	DeleteTaxRatesTaxRateProductTypesWithBody(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTaxRatesTaxRateProductTypes(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, body DeleteTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesTaxRateProductTypesWithBody request with any body
	PostTaxRatesTaxRateProductTypesWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRatesTaxRateProductTypes(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, body PostTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRatesTaxRateProductsWithBody request with any body
	DeleteTaxRatesTaxRateProductsWithBody(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTaxRatesTaxRateProducts(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, body DeleteTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesTaxRateProductsWithBody request with any body
	PostTaxRatesTaxRateProductsWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRatesTaxRateProducts(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, body PostTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTaxRatesTaxRateShippingOptionsWithBody request with any body
	DeleteTaxRatesTaxRateShippingOptionsWithBody(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTaxRatesTaxRateShippingOptions(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, body DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTaxRatesTaxRateShippingOptionsWithBody request with any body
	PostTaxRatesTaxRateShippingOptionsWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTaxRatesTaxRateShippingOptions(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, body PostTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUploadsWithBody request with any body
	DeleteUploadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUploads(ctx context.Context, body DeleteUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUploadsWithBody request with any body
	PostUploadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUploadsDownloadUrlWithBody request with any body
	PostUploadsDownloadUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUploadsDownloadUrl(ctx context.Context, body PostUploadsDownloadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUploadsProtectedWithBody request with any body
	PostUploadsProtectedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersWithBody request with any body
	PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsers(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersUserPasswordTokenWithBody request with any body
	PostUsersUserPasswordTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersUserPasswordToken(ctx context.Context, body PostUsersUserPasswordTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersUserPasswordWithBody request with any body
	PostUsersUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersUserPassword(ctx context.Context, body PostUsersUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUsersUser request
	DeleteUsersUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUser request
	GetUsersUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUsersUserWithBody request with any body
	PostUsersUserWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostUsersUser(ctx context.Context, id string, body PostUsersUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariants request
	GetVariants(ctx context.Context, params *GetVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariantsVariant request
	GetVariantsVariant(ctx context.Context, id string, params *GetVariantsVariantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariantsVariantInventory request
	GetVariantsVariantInventory(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAppsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApps(ctx context.Context, body PostAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAppsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuth(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostToken(ctx context.Context, body PostTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchJobs(ctx context.Context, params *GetBatchJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBatchJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBatchJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBatchJobs(ctx context.Context, body PostBatchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBatchJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchJobsBatchJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchJobsBatchJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBatchJobsBatchJobCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBatchJobsBatchJobCancelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBatchJobsBatchJobConfirmProcessing(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBatchJobsBatchJobConfirmProcessingRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollections(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollections(ctx context.Context, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollectionsCollection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionsCollectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectionsCollection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionsCollectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsCollectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCollectionsCollection(ctx context.Context, id string, body PostCollectionsCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCollectionsCollectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsFromCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsFromCollectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsFromCollection(ctx context.Context, id string, body DeleteProductsFromCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsFromCollectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsToCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsToCollectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsToCollection(ctx context.Context, id string, body PostProductsToCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsToCollectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencies(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCurrenciesCurrencyWithBody(ctx context.Context, code string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCurrenciesCurrencyRequestWithBody(c.Server, code, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCurrenciesCurrency(ctx context.Context, code string, body PostCurrenciesCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCurrenciesCurrencyRequest(c.Server, code, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerGroups(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroups(ctx context.Context, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomerGroupsCustomerGroup(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerGroupsCustomerGroupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerGroupsGroup(ctx context.Context, id string, params *GetCustomerGroupsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerGroupsGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsGroupWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsGroup(ctx context.Context, id string, body PostCustomerGroupsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerGroupsGroupCustomers(ctx context.Context, id string, params *GetCustomerGroupsGroupCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerGroupsGroupCustomersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomerGroupsGroupCustomerBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerGroupsGroupCustomerBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomerGroupsGroupCustomerBatch(ctx context.Context, id string, body DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomerGroupsGroupCustomerBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsGroupCustomersBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsGroupCustomersBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomerGroupsGroupCustomersBatch(ctx context.Context, id string, body PostCustomerGroupsGroupCustomersBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomerGroupsGroupCustomersBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomers(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomers(ctx context.Context, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomersCustomer(ctx context.Context, id string, params *GetCustomersCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomersCustomerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersCustomerWithBody(ctx context.Context, id string, params *PostCustomersCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersCustomerRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersCustomer(ctx context.Context, id string, params *PostCustomersCustomerParams, body PostCustomersCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCustomersCustomerRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscounts(ctx context.Context, params *GetDiscountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsWithBody(ctx context.Context, params *PostDiscountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscounts(ctx context.Context, params *PostDiscountsParams, body PostDiscountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscountsDiscountCode(ctx context.Context, code string, params *GetDiscountsDiscountCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscountsDiscountCodeRequest(c.Server, code, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountConditionsWithBody(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountConditionsRequestWithBody(c.Server, discountId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountConditions(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, body PostDiscountsDiscountConditionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountConditionsRequest(c.Server, discountId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDiscountsDiscountConditionsCondition(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiscountsDiscountConditionsConditionRequest(c.Server, discountId, conditionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscountsDiscountConditionsCondition(ctx context.Context, discountId string, conditionId string, params *GetDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscountsDiscountConditionsConditionRequest(c.Server, discountId, conditionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountConditionsConditionWithBody(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountConditionsConditionRequestWithBody(c.Server, discountId, conditionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountConditionsCondition(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, body PostDiscountsDiscountConditionsConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountConditionsConditionRequest(c.Server, discountId, conditionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDiscountsDiscountConditionsConditionBatchWithBody(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiscountsDiscountConditionsConditionBatchRequestWithBody(c.Server, discountId, conditionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDiscountsDiscountConditionsConditionBatch(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, body DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiscountsDiscountConditionsConditionBatchRequest(c.Server, discountId, conditionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountConditionsConditionBatchWithBody(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountConditionsConditionBatchRequestWithBody(c.Server, discountId, conditionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountConditionsConditionBatch(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, body PostDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountConditionsConditionBatchRequest(c.Server, discountId, conditionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDiscountsDiscount(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiscountsDiscountRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiscountsDiscount(ctx context.Context, id string, params *GetDiscountsDiscountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiscountsDiscountRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountWithBody(ctx context.Context, id string, params *PostDiscountsDiscountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscount(ctx context.Context, id string, params *PostDiscountsDiscountParams, body PostDiscountsDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountDynamicCodesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountDynamicCodesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountDynamicCodes(ctx context.Context, id string, body PostDiscountsDiscountDynamicCodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountDynamicCodesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDiscountsDiscountDynamicCodesCode(ctx context.Context, id string, code string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiscountsDiscountDynamicCodesCodeRequest(c.Server, id, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDiscountsDiscountRegionsRegion(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiscountsDiscountRegionsRegionRequest(c.Server, id, regionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDiscountsDiscountRegionsRegion(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDiscountsDiscountRegionsRegionRequest(c.Server, id, regionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDraftOrders(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDraftOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrders(ctx context.Context, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDraftOrdersDraftOrder(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDraftOrdersDraftOrderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDraftOrdersDraftOrder(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDraftOrdersDraftOrderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrder(ctx context.Context, id string, body PostDraftOrdersDraftOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrderLineItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderLineItemsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrderLineItems(ctx context.Context, id string, body PostDraftOrdersDraftOrderLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderLineItemsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDraftOrdersDraftOrderLineItemsItem(ctx context.Context, id string, lineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDraftOrdersDraftOrderLineItemsItemRequest(c.Server, id, lineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrderLineItemsItemWithBody(ctx context.Context, id string, lineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderLineItemsItemRequestWithBody(c.Server, id, lineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrderLineItemsItem(ctx context.Context, id string, lineId string, body PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderLineItemsItemRequest(c.Server, id, lineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDraftOrdersDraftOrderRegisterPayment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDraftOrdersDraftOrderRegisterPaymentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGiftCards(ctx context.Context, params *GetGiftCardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGiftCardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGiftCardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGiftCardsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGiftCards(ctx context.Context, body PostGiftCardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGiftCardsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGiftCardsGiftCard(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGiftCardsGiftCardRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGiftCardsGiftCard(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGiftCardsGiftCardRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGiftCardsGiftCardWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGiftCardsGiftCardRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGiftCardsGiftCard(ctx context.Context, id string, body PostGiftCardsGiftCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGiftCardsGiftCardRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItems(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsWithBody(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItems(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInventoryItemsInventoryItem(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInventoryItemsInventoryItemRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItemsInventoryItem(ctx context.Context, id string, params *GetInventoryItemsInventoryItemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemsInventoryItemRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsInventoryItemWithBody(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsInventoryItemRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsInventoryItem(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, body PostInventoryItemsInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsInventoryItemRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInventoryItemsInventoryItemLocationLevels(ctx context.Context, id string, params *GetInventoryItemsInventoryItemLocationLevelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInventoryItemsInventoryItemLocationLevelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsInventoryItemLocationLevelsWithBody(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsInventoryItemLocationLevelsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsInventoryItemLocationLevels(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, body PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsInventoryItemLocationLevelsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInventoryItemsInventoryIteLocationLevelsLocation(ctx context.Context, id string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInventoryItemsInventoryIteLocationLevelsLocationRequest(c.Server, id, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBody(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequestWithBody(c.Server, id, locationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInventoryItemsInventoryItemLocationLevelsLocationLevel(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, body PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequest(c.Server, id, locationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvites(ctx context.Context, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesInviteAcceptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesInviteAcceptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesInviteAccept(ctx context.Context, body PostInvitesInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesInviteAcceptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvitesInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInvitesInviteRequest(c.Server, inviteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvitesInviteResend(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInvitesInviteResendRequest(c.Server, inviteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotes(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotes(ctx context.Context, body PostNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotesNote(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotesNoteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotesNote(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotesNoteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotesNoteWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotesNoteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotesNote(ctx context.Context, id string, body PostNotesNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotesNoteRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotifications(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotificationsNotificationResendWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotificationsNotificationResendRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNotificationsNotificationResend(ctx context.Context, id string, body PostNotificationsNotificationResendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNotificationsNotificationResendRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderEdits(ctx context.Context, params *GetOrderEditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderEditsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEdits(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderEditsOrderEdit(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderEditsOrderEditRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderEditsOrderEdit(ctx context.Context, id string, params *GetOrderEditsOrderEditParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderEditsOrderEditRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsOrderEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsOrderEditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsOrderEdit(ctx context.Context, id string, body PostOrderEditsOrderEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsOrderEditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsOrderEditCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsOrderEditCancelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderEditsOrderEditItemChange(ctx context.Context, id string, changeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderEditsOrderEditItemChangeRequest(c.Server, id, changeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsOrderEditConfirm(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsOrderEditConfirmRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsEditLineItemsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsEditLineItemsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsEditLineItems(ctx context.Context, id string, body PostOrderEditsEditLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsEditLineItemsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrderEditsOrderEditLineItemsLineItem(ctx context.Context, id string, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrderEditsOrderEditLineItemsLineItemRequest(c.Server, id, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsEditLineItemsLineItemWithBody(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsEditLineItemsLineItemRequestWithBody(c.Server, id, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsEditLineItemsLineItem(ctx context.Context, id string, itemId string, body PostOrderEditsEditLineItemsLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsEditLineItemsLineItemRequest(c.Server, id, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrderEditsOrderEditRequest(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrderEditsOrderEditRequestRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrdersOrder(ctx context.Context, id string, params *GetOrdersOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersOrderRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderWithBody(ctx context.Context, id string, params *PostOrdersOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrder(ctx context.Context, id string, params *PostOrdersOrderParams, body PostOrdersOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderArchive(ctx context.Context, id string, params *PostOrdersOrderArchiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderArchiveRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderCancel(ctx context.Context, id string, params *PostOrdersOrderCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderCancelRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderCapture(ctx context.Context, id string, params *PostOrdersOrderCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderCaptureRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsWithBody(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaims(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, body PostOrdersOrderClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsClaimWithBody(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsClaimRequestWithBody(c.Server, id, claimId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsClaim(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, body PostOrdersOrderClaimsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsClaimRequest(c.Server, id, claimId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersClaimCancel(ctx context.Context, id string, claimId string, params *PostOrdersClaimCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersClaimCancelRequest(c.Server, id, claimId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsClaimFulfillmentsWithBody(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsClaimFulfillmentsRequestWithBody(c.Server, id, claimId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsClaimFulfillments(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, body PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsClaimFulfillmentsRequest(c.Server, id, claimId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersClaimFulfillmentsCancel(ctx context.Context, id string, claimId string, fulfillmentId string, params *PostOrdersClaimFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersClaimFulfillmentsCancelRequest(c.Server, id, claimId, fulfillmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsClaimShipmentsWithBody(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsClaimShipmentsRequestWithBody(c.Server, id, claimId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderClaimsClaimShipments(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, body PostOrdersOrderClaimsClaimShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderClaimsClaimShipmentsRequest(c.Server, id, claimId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderComplete(ctx context.Context, id string, params *PostOrdersOrderCompleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderCompleteRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderFulfillmentsWithBody(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderFulfillmentsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderFulfillments(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, body PostOrdersOrderFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderFulfillmentsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderFulfillmentsCancel(ctx context.Context, id string, fulfillmentId string, params *PostOrdersOrderFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderFulfillmentsCancelRequest(c.Server, id, fulfillmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderLineItemReservationsWithBody(ctx context.Context, id string, lineItemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderLineItemReservationsRequestWithBody(c.Server, id, lineItemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderLineItemReservations(ctx context.Context, id string, lineItemId string, body PostOrdersOrderLineItemReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderLineItemReservationsRequest(c.Server, id, lineItemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderRefundsWithBody(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderRefundsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderRefunds(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, body PostOrdersOrderRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderRefundsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrdersOrderReservations(ctx context.Context, id string, params *GetOrdersOrderReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersOrderReservationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderReturnsWithBody(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderReturnsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderReturns(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, body PostOrdersOrderReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderReturnsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderShipmentWithBody(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderShipmentRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderShipment(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, body PostOrdersOrderShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderShipmentRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderShippingMethodsWithBody(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderShippingMethodsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderShippingMethods(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, body PostOrdersOrderShippingMethodsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderShippingMethodsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwapsWithBody(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwaps(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, body PostOrdersOrderSwapsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersSwapCancel(ctx context.Context, id string, swapId string, params *PostOrdersSwapCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersSwapCancelRequest(c.Server, id, swapId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwapsSwapFulfillmentsWithBody(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsSwapFulfillmentsRequestWithBody(c.Server, id, swapId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwapsSwapFulfillments(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, body PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsSwapFulfillmentsRequest(c.Server, id, swapId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersSwapFulfillmentsCancel(ctx context.Context, id string, swapId string, fulfillmentId string, params *PostOrdersSwapFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersSwapFulfillmentsCancelRequest(c.Server, id, swapId, fulfillmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwapsSwapProcessPayment(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapProcessPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsSwapProcessPaymentRequest(c.Server, id, swapId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwapsSwapShipmentsWithBody(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsSwapShipmentsRequestWithBody(c.Server, id, swapId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOrdersOrderSwapsSwapShipments(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, body PostOrdersOrderSwapsSwapShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOrdersOrderSwapsSwapShipmentsRequest(c.Server, id, swapId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePaymentCollectionsPaymentCollection(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePaymentCollectionsPaymentCollectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentCollectionsPaymentCollection(ctx context.Context, id string, params *GetPaymentCollectionsPaymentCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentCollectionsPaymentCollectionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollectionsPaymentCollectionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsPaymentCollectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollectionsPaymentCollection(ctx context.Context, id string, body PostPaymentCollectionsPaymentCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsPaymentCollectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentCollectionsPaymentCollectionAuthorize(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentCollectionsPaymentCollectionAuthorizeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentsPayment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentsPaymentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsPaymentCapture(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsPaymentCaptureRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsPaymentRefundsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsPaymentRefundsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPaymentsPaymentRefunds(ctx context.Context, id string, body PostPaymentsPaymentRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPaymentsPaymentRefundsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPriceLists(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPriceListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsPriceListWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsPriceListRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsPriceList(ctx context.Context, body PostPriceListsPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsPriceListRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsPriceList(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsPriceListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPriceListsPriceList(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPriceListsPriceListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsPriceListPriceListWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsPriceListPriceListRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsPriceListPriceList(ctx context.Context, id string, body PostPriceListsPriceListPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsPriceListPriceListRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsPriceListPricesBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsPriceListPricesBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsPriceListPricesBatch(ctx context.Context, id string, body DeletePriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsPriceListPricesBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsPriceListPricesBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsPriceListPricesBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPriceListsPriceListPricesBatch(ctx context.Context, id string, body PostPriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPriceListsPriceListPricesBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPriceListsPriceListProducts(ctx context.Context, id string, params *GetPriceListsPriceListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPriceListsPriceListProductsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsPriceListProductsPricesBatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsPriceListProductsPricesBatchRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsPriceListProductsProductPrices(ctx context.Context, id string, productId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsPriceListProductsProductPricesRequest(c.Server, id, productId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePriceListsPriceListVariantsVariantPrices(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePriceListsPriceListVariantsVariantPricesRequest(c.Server, id, variantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductCategories(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesWithBody(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategories(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductCategoriesCategory(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductCategoriesCategoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductCategoriesCategory(ctx context.Context, id string, params *GetProductCategoriesCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductCategoriesCategoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesCategoryWithBody(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesCategoryRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesCategory(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, body PostProductCategoriesCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesCategoryRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductCategoriesCategoryProductsBatchWithBody(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductCategoriesCategoryProductsBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductCategoriesCategoryProductsBatch(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, body DeleteProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductCategoriesCategoryProductsBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesCategoryProductsBatchWithBody(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesCategoryProductsBatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductCategoriesCategoryProductsBatch(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, body PostProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductCategoriesCategoryProductsBatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductTags(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductTypes(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducts(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProducts(ctx context.Context, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsTagUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsTagUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProduct(ctx context.Context, id string, body PostProductsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductMetadataWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductMetadataRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductMetadata(ctx context.Context, id string, body PostProductsProductMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductMetadataRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductOptionsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductOptionsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductOptions(ctx context.Context, id string, body PostProductsProductOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductOptionsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsProductOptionsOption(ctx context.Context, id string, optionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsProductOptionsOptionRequest(c.Server, id, optionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductOptionsOptionWithBody(ctx context.Context, id string, optionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductOptionsOptionRequestWithBody(c.Server, id, optionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductOptionsOption(ctx context.Context, id string, optionId string, body PostProductsProductOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductOptionsOptionRequest(c.Server, id, optionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductsProductVariants(ctx context.Context, id string, params *GetProductsProductVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductsProductVariantsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductVariantsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductVariantsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductVariants(ctx context.Context, id string, body PostProductsProductVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductVariantsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductsProductVariantsVariant(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductsProductVariantsVariantRequest(c.Server, id, variantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductVariantsVariantWithBody(ctx context.Context, id string, variantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductVariantsVariantRequestWithBody(c.Server, id, variantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostProductsProductVariantsVariant(ctx context.Context, id string, variantId string, body PostProductsProductVariantsVariantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostProductsProductVariantsVariantRequest(c.Server, id, variantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublishableApiKeys(ctx context.Context, params *GetPublishableApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublishableApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKeys(ctx context.Context, body PostPublishableApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublishableApiKeysPublishableApiKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublishableApiKeysPublishableApiKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublishableApiKeysPublishableApiKey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublishableApiKeysPublishableApiKeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKysPublishableApiKeyWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKysPublishableApiKeyRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKysPublishableApiKey(ctx context.Context, id string, body PostPublishableApiKysPublishableApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKysPublishableApiKeyRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKeysPublishableApiKeyRevoke(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKeysPublishableApiKeyRevokeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublishableApiKeySalesChannels(ctx context.Context, id string, params *GetPublishableApiKeySalesChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublishableApiKeySalesChannelsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublishableApiKeySalesChannelsChannelsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublishableApiKeySalesChannelsChannelsBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePublishableApiKeySalesChannelsChannelsBatch(ctx context.Context, id string, body DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePublishableApiKeySalesChannelsChannelsBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKeySalesChannelsChannelsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKeySalesChannelsChannelsBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPublishableApiKeySalesChannelsChannelsBatch(ctx context.Context, id string, body PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPublishableApiKeySalesChannelsChannelsBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegions(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegions(ctx context.Context, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRegionsRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRegionsRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegionsRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionsRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegion(ctx context.Context, id string, body PostRegionsRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionCountriesWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionCountriesRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionCountries(ctx context.Context, id string, body PostRegionsRegionCountriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionCountriesRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionCountriesCountry(ctx context.Context, id string, countryCode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionCountriesCountryRequest(c.Server, id, countryCode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegionsRegionFulfillmentOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionsRegionFulfillmentOptionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionFulfillmentProvidersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionFulfillmentProvidersRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionFulfillmentProviders(ctx context.Context, id string, body PostRegionsRegionFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionFulfillmentProvidersRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionFulfillmentProvidersProvider(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionFulfillmentProvidersProviderRequest(c.Server, id, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionPaymentProvidersWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionPaymentProvidersRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionPaymentProviders(ctx context.Context, id string, body PostRegionsRegionPaymentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionPaymentProvidersRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegionsRegionPaymentProvidersProvider(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegionsRegionPaymentProvidersProviderRequest(c.Server, id, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservations(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservations(ctx context.Context, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservationsReservation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservationsReservationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservationsReservation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservationsReservationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservationsReservationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsReservationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservationsReservation(ctx context.Context, id string, body PostReservationsReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservationsReservationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturnReasons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnReasonsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasonsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasons(ctx context.Context, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReturnReason(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReturnReasonRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturnReasonsReason(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnReasonsReasonRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasonsReasonWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsReasonRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnReasonsReason(ctx context.Context, id string, body PostReturnReasonsReasonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnReasonsReasonRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReturns(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReturnsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsReturnCancel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsReturnCancelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsReturnReceiveWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsReturnReceiveRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReturnsReturnReceive(ctx context.Context, id string, body PostReturnsReturnReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReturnsReturnReceiveRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSalesChannels(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSalesChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannels(ctx context.Context, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSalesChannelsSalesChannel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSalesChannelsSalesChannelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSalesChannelsSalesChannel(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSalesChannelsSalesChannelRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsSalesChannelWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsSalesChannelRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsSalesChannel(ctx context.Context, id string, body PostSalesChannelsSalesChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsSalesChannelRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSalesChannelsChannelProductsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSalesChannelsChannelProductsBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSalesChannelsChannelProductsBatch(ctx context.Context, id string, body DeleteSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSalesChannelsChannelProductsBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsChannelProductsBatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsChannelProductsBatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsChannelProductsBatch(ctx context.Context, id string, body PostSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsChannelProductsBatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSalesChannelsSalesChannelStockLocationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSalesChannelsSalesChannelStockLocationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSalesChannelsSalesChannelStockLocation(ctx context.Context, id string, body DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSalesChannelsSalesChannelStockLocationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsSalesChannelStockLocationWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsSalesChannelStockLocationRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSalesChannelsSalesChannelStockLocation(ctx context.Context, id string, body PostSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSalesChannelsSalesChannelStockLocationRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingOptions(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptions(ctx context.Context, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShippingOptionsOption(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShippingOptionsOptionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingOptionsOption(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingOptionsOptionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsOptionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsOptionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingOptionsOption(ctx context.Context, id string, body PostShippingOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingOptionsOptionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingProfiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingProfilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfiles(ctx context.Context, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteShippingProfilesProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteShippingProfilesProfileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShippingProfilesProfile(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShippingProfilesProfileRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfilesProfileWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesProfileRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostShippingProfilesProfile(ctx context.Context, id string, body PostShippingProfilesProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostShippingProfilesProfileRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStockLocations(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStockLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsWithBody(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocations(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStockLocationsStockLocation(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStockLocationsStockLocationRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStockLocationsStockLocation(ctx context.Context, id string, params *GetStockLocationsStockLocationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStockLocationsStockLocationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsStockLocationWithBody(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsStockLocationRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStockLocationsStockLocation(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, body PostStockLocationsStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStockLocationsStockLocationRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStore(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoreRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStore(ctx context.Context, body PostStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoreCurrenciesCode(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoreCurrenciesCodeRequest(c.Server, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStoreCurrenciesCode(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStoreCurrenciesCodeRequest(c.Server, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorePaymentProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorePaymentProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoreTaxProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoreTaxProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwaps(ctx context.Context, params *GetSwapsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapsSwap(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapsSwapRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxRates(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxRatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesWithBody(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRates(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTaxRatesTaxRate(ctx context.Context, id string, params *GetTaxRatesTaxRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaxRatesTaxRateRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRate(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, body PostTaxRatesTaxRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRateProductTypesWithBody(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateProductTypesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRateProductTypes(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, body DeleteTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateProductTypesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateProductTypesWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateProductTypesRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateProductTypes(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, body PostTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateProductTypesRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRateProductsWithBody(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateProductsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRateProducts(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, body DeleteTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateProductsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateProductsWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateProductsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateProducts(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, body PostTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateProductsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRateShippingOptionsWithBody(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateShippingOptionsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTaxRatesTaxRateShippingOptions(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, body DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTaxRatesTaxRateShippingOptionsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateShippingOptionsWithBody(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateShippingOptionsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTaxRatesTaxRateShippingOptions(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, body PostTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTaxRatesTaxRateShippingOptionsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUploadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUploadsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUploads(ctx context.Context, body DeleteUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUploadsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploadsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploadsDownloadUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadsDownloadUrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploadsDownloadUrl(ctx context.Context, body PostUploadsDownloadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadsDownloadUrlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUploadsProtectedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUploadsProtectedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsers(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersUserPasswordTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersUserPasswordTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersUserPasswordToken(ctx context.Context, body PostUsersUserPasswordTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersUserPasswordTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersUserPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersUserPassword(ctx context.Context, body PostUsersUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersUserPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUsersUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUsersUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersUserWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersUserRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUsersUser(ctx context.Context, id string, body PostUsersUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUsersUserRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariants(ctx context.Context, params *GetVariantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariantsVariant(ctx context.Context, id string, params *GetVariantsVariantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariantsVariantRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariantsVariantInventory(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariantsVariantInventoryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAppsRequest generates requests for GetApps
func NewGetAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAppsRequest calls the generic PostApps builder with application/json body
func NewPostAppsRequest(server string, body PostAppsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAppsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAppsRequestWithBody generates requests for PostApps with any type of body
func NewPostAppsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/apps/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAuthRequest generates requests for DeleteAuth
func NewDeleteAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthRequest generates requests for GetAuth
func NewGetAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthRequest calls the generic PostAuth builder with application/json body
func NewPostAuthRequest(server string, body PostAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAuthRequestWithBody generates requests for PostAuth with any type of body
func NewPostAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTokenRequest calls the generic PostToken builder with application/json body
func NewPostTokenRequest(server string, body PostTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTokenRequestWithBody generates requests for PostToken with any type of body
func NewPostTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/auth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchJobsRequest generates requests for GetBatchJobs
func NewGetBatchJobsRequest(server string, params *GetBatchJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/batch-jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfirmedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "confirmed_at", runtime.ParamLocationQuery, *params.ConfirmedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreProcessedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pre_processed_at", runtime.ParamLocationQuery, *params.PreProcessedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "completed_at", runtime.ParamLocationQuery, *params.CompletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FailedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "failed_at", runtime.ParamLocationQuery, *params.FailedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CanceledAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "canceled_at", runtime.ParamLocationQuery, *params.CanceledAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBatchJobsRequest calls the generic PostBatchJobs builder with application/json body
func NewPostBatchJobsRequest(server string, body PostBatchJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBatchJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBatchJobsRequestWithBody generates requests for PostBatchJobs with any type of body
func NewPostBatchJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/batch-jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchJobsBatchJobRequest generates requests for GetBatchJobsBatchJob
func NewGetBatchJobsBatchJobRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/batch-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBatchJobsBatchJobCancelRequest generates requests for PostBatchJobsBatchJobCancel
func NewPostBatchJobsBatchJobCancelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/batch-jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBatchJobsBatchJobConfirmProcessingRequest generates requests for PostBatchJobsBatchJobConfirmProcessing
func NewPostBatchJobsBatchJobConfirmProcessingRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/batch-jobs/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionsRequest generates requests for GetCollections
func NewGetCollectionsRequest(server string, params *GetCollectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscountConditionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discount_condition_id", runtime.ParamLocationQuery, *params.DiscountConditionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCollectionsRequest calls the generic PostCollections builder with application/json body
func NewPostCollectionsRequest(server string, body PostCollectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCollectionsRequestWithBody generates requests for PostCollections with any type of body
func NewPostCollectionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionsCollectionRequest generates requests for DeleteCollectionsCollection
func NewDeleteCollectionsCollectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionsCollectionRequest generates requests for GetCollectionsCollection
func NewGetCollectionsCollectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCollectionsCollectionRequest calls the generic PostCollectionsCollection builder with application/json body
func NewPostCollectionsCollectionRequest(server string, id string, body PostCollectionsCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCollectionsCollectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostCollectionsCollectionRequestWithBody generates requests for PostCollectionsCollection with any type of body
func NewPostCollectionsCollectionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsFromCollectionRequest calls the generic DeleteProductsFromCollection builder with application/json body
func NewDeleteProductsFromCollectionRequest(server string, id string, body DeleteProductsFromCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteProductsFromCollectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteProductsFromCollectionRequestWithBody generates requests for DeleteProductsFromCollection with any type of body
func NewDeleteProductsFromCollectionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsToCollectionRequest calls the generic PostProductsToCollection builder with application/json body
func NewPostProductsToCollectionRequest(server string, id string, body PostProductsToCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsToCollectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProductsToCollectionRequestWithBody generates requests for PostProductsToCollection with any type of body
func NewPostProductsToCollectionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/collections/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCurrenciesRequest generates requests for GetCurrencies
func NewGetCurrenciesRequest(server string, params *GetCurrenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludesTax != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes_tax", runtime.ParamLocationQuery, *params.IncludesTax); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCurrenciesCurrencyRequest calls the generic PostCurrenciesCurrency builder with application/json body
func NewPostCurrenciesCurrencyRequest(server string, code string, body PostCurrenciesCurrencyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCurrenciesCurrencyRequestWithBody(server, code, "application/json", bodyReader)
}

// NewPostCurrenciesCurrencyRequestWithBody generates requests for PostCurrenciesCurrency with any type of body
func NewPostCurrenciesCurrencyRequestWithBody(server string, code string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerGroupsRequest generates requests for GetCustomerGroups
func NewGetCustomerGroupsRequest(server string, params *GetCustomerGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscountConditionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discount_condition_id", runtime.ParamLocationQuery, *params.DiscountConditionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomerGroupsRequest calls the generic PostCustomerGroups builder with application/json body
func NewPostCustomerGroupsRequest(server string, body PostCustomerGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomerGroupsRequestWithBody generates requests for PostCustomerGroups with any type of body
func NewPostCustomerGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomerGroupsCustomerGroupRequest generates requests for DeleteCustomerGroupsCustomerGroup
func NewDeleteCustomerGroupsCustomerGroupRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomerGroupsGroupRequest generates requests for GetCustomerGroupsGroup
func NewGetCustomerGroupsGroupRequest(server string, id string, params *GetCustomerGroupsGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomerGroupsGroupRequest calls the generic PostCustomerGroupsGroup builder with application/json body
func NewPostCustomerGroupsGroupRequest(server string, id string, body PostCustomerGroupsGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerGroupsGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostCustomerGroupsGroupRequestWithBody generates requests for PostCustomerGroupsGroup with any type of body
func NewPostCustomerGroupsGroupRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerGroupsGroupCustomersRequest generates requests for GetCustomerGroupsGroupCustomers
func NewGetCustomerGroupsGroupCustomersRequest(server string, id string, params *GetCustomerGroupsGroupCustomersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s/customers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomerGroupsGroupCustomerBatchRequest calls the generic DeleteCustomerGroupsGroupCustomerBatch builder with application/json body
func NewDeleteCustomerGroupsGroupCustomerBatchRequest(server string, id string, body DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCustomerGroupsGroupCustomerBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteCustomerGroupsGroupCustomerBatchRequestWithBody generates requests for DeleteCustomerGroupsGroupCustomerBatch with any type of body
func NewDeleteCustomerGroupsGroupCustomerBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s/customers/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostCustomerGroupsGroupCustomersBatchRequest calls the generic PostCustomerGroupsGroupCustomersBatch builder with application/json body
func NewPostCustomerGroupsGroupCustomersBatchRequest(server string, id string, body PostCustomerGroupsGroupCustomersBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomerGroupsGroupCustomersBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostCustomerGroupsGroupCustomersBatchRequestWithBody generates requests for PostCustomerGroupsGroupCustomersBatch with any type of body
func NewPostCustomerGroupsGroupCustomersBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customer-groups/%s/customers/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomersRequest generates requests for GetCustomers
func NewGetCustomersRequest(server string, params *GetCustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_account", runtime.ParamLocationQuery, *params.HasAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersRequest calls the generic PostCustomers builder with application/json body
func NewPostCustomersRequest(server string, body PostCustomersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCustomersRequestWithBody generates requests for PostCustomers with any type of body
func NewPostCustomersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomersCustomerRequest generates requests for GetCustomersCustomer
func NewGetCustomersCustomerRequest(server string, id string, params *GetCustomersCustomerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersCustomerRequest calls the generic PostCustomersCustomer builder with application/json body
func NewPostCustomersCustomerRequest(server string, id string, params *PostCustomersCustomerParams, body PostCustomersCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersCustomerRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostCustomersCustomerRequestWithBody generates requests for PostCustomersCustomer with any type of body
func NewPostCustomersCustomerRequestWithBody(server string, id string, params *PostCustomersCustomerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDiscountsRequest generates requests for GetDiscounts
func NewGetDiscountsRequest(server string, params *GetDiscountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rule != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rule", runtime.ParamLocationQuery, *params.Rule); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDynamic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_dynamic", runtime.ParamLocationQuery, *params.IsDynamic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsDisabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_disabled", runtime.ParamLocationQuery, *params.IsDisabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDiscountsRequest calls the generic PostDiscounts builder with application/json body
func NewPostDiscountsRequest(server string, params *PostDiscountsParams, body PostDiscountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDiscountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostDiscountsRequestWithBody generates requests for PostDiscounts with any type of body
func NewPostDiscountsRequestWithBody(server string, params *PostDiscountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDiscountsDiscountCodeRequest generates requests for GetDiscountsDiscountCode
func NewGetDiscountsDiscountCodeRequest(server string, code string, params *GetDiscountsDiscountCodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/code/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDiscountsDiscountConditionsRequest calls the generic PostDiscountsDiscountConditions builder with application/json body
func NewPostDiscountsDiscountConditionsRequest(server string, discountId string, params *PostDiscountsDiscountConditionsParams, body PostDiscountsDiscountConditionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDiscountsDiscountConditionsRequestWithBody(server, discountId, params, "application/json", bodyReader)
}

// NewPostDiscountsDiscountConditionsRequestWithBody generates requests for PostDiscountsDiscountConditions with any type of body
func NewPostDiscountsDiscountConditionsRequestWithBody(server string, discountId string, params *PostDiscountsDiscountConditionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/conditions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDiscountsDiscountConditionsConditionRequest generates requests for DeleteDiscountsDiscountConditionsCondition
func NewDeleteDiscountsDiscountConditionsConditionRequest(server string, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, conditionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/conditions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiscountsDiscountConditionsConditionRequest generates requests for GetDiscountsDiscountConditionsCondition
func NewGetDiscountsDiscountConditionsConditionRequest(server string, discountId string, conditionId string, params *GetDiscountsDiscountConditionsConditionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, conditionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/conditions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDiscountsDiscountConditionsConditionRequest calls the generic PostDiscountsDiscountConditionsCondition builder with application/json body
func NewPostDiscountsDiscountConditionsConditionRequest(server string, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, body PostDiscountsDiscountConditionsConditionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDiscountsDiscountConditionsConditionRequestWithBody(server, discountId, conditionId, params, "application/json", bodyReader)
}

// NewPostDiscountsDiscountConditionsConditionRequestWithBody generates requests for PostDiscountsDiscountConditionsCondition with any type of body
func NewPostDiscountsDiscountConditionsConditionRequestWithBody(server string, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, conditionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/conditions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDiscountsDiscountConditionsConditionBatchRequest calls the generic DeleteDiscountsDiscountConditionsConditionBatch builder with application/json body
func NewDeleteDiscountsDiscountConditionsConditionBatchRequest(server string, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, body DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteDiscountsDiscountConditionsConditionBatchRequestWithBody(server, discountId, conditionId, params, "application/json", bodyReader)
}

// NewDeleteDiscountsDiscountConditionsConditionBatchRequestWithBody generates requests for DeleteDiscountsDiscountConditionsConditionBatch with any type of body
func NewDeleteDiscountsDiscountConditionsConditionBatchRequestWithBody(server string, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, conditionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/conditions/%s/batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDiscountsDiscountConditionsConditionBatchRequest calls the generic PostDiscountsDiscountConditionsConditionBatch builder with application/json body
func NewPostDiscountsDiscountConditionsConditionBatchRequest(server string, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, body PostDiscountsDiscountConditionsConditionBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDiscountsDiscountConditionsConditionBatchRequestWithBody(server, discountId, conditionId, params, "application/json", bodyReader)
}

// NewPostDiscountsDiscountConditionsConditionBatchRequestWithBody generates requests for PostDiscountsDiscountConditionsConditionBatch with any type of body
func NewPostDiscountsDiscountConditionsConditionBatchRequestWithBody(server string, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "discount_id", runtime.ParamLocationPath, discountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "condition_id", runtime.ParamLocationPath, conditionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/conditions/%s/batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDiscountsDiscountRequest generates requests for DeleteDiscountsDiscount
func NewDeleteDiscountsDiscountRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiscountsDiscountRequest generates requests for GetDiscountsDiscount
func NewGetDiscountsDiscountRequest(server string, id string, params *GetDiscountsDiscountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDiscountsDiscountRequest calls the generic PostDiscountsDiscount builder with application/json body
func NewPostDiscountsDiscountRequest(server string, id string, params *PostDiscountsDiscountParams, body PostDiscountsDiscountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDiscountsDiscountRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostDiscountsDiscountRequestWithBody generates requests for PostDiscountsDiscount with any type of body
func NewPostDiscountsDiscountRequestWithBody(server string, id string, params *PostDiscountsDiscountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDiscountsDiscountDynamicCodesRequest calls the generic PostDiscountsDiscountDynamicCodes builder with application/json body
func NewPostDiscountsDiscountDynamicCodesRequest(server string, id string, body PostDiscountsDiscountDynamicCodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDiscountsDiscountDynamicCodesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostDiscountsDiscountDynamicCodesRequestWithBody generates requests for PostDiscountsDiscountDynamicCodes with any type of body
func NewPostDiscountsDiscountDynamicCodesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/dynamic-codes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDiscountsDiscountDynamicCodesCodeRequest generates requests for DeleteDiscountsDiscountDynamicCodesCode
func NewDeleteDiscountsDiscountDynamicCodesCodeRequest(server string, id string, code string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/dynamic-codes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDiscountsDiscountRegionsRegionRequest generates requests for DeleteDiscountsDiscountRegionsRegion
func NewDeleteDiscountsDiscountRegionsRegionRequest(server string, id string, regionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "region_id", runtime.ParamLocationPath, regionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/regions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDiscountsDiscountRegionsRegionRequest generates requests for PostDiscountsDiscountRegionsRegion
func NewPostDiscountsDiscountRegionsRegionRequest(server string, id string, regionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "region_id", runtime.ParamLocationPath, regionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/discounts/%s/regions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDraftOrdersRequest generates requests for GetDraftOrders
func NewGetDraftOrdersRequest(server string, params *GetDraftOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDraftOrdersRequest calls the generic PostDraftOrders builder with application/json body
func NewPostDraftOrdersRequest(server string, body PostDraftOrdersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDraftOrdersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDraftOrdersRequestWithBody generates requests for PostDraftOrders with any type of body
func NewPostDraftOrdersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDraftOrdersDraftOrderRequest generates requests for DeleteDraftOrdersDraftOrder
func NewDeleteDraftOrdersDraftOrderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDraftOrdersDraftOrderRequest generates requests for GetDraftOrdersDraftOrder
func NewGetDraftOrdersDraftOrderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDraftOrdersDraftOrderRequest calls the generic PostDraftOrdersDraftOrder builder with application/json body
func NewPostDraftOrdersDraftOrderRequest(server string, id string, body PostDraftOrdersDraftOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDraftOrdersDraftOrderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostDraftOrdersDraftOrderRequestWithBody generates requests for PostDraftOrdersDraftOrder with any type of body
func NewPostDraftOrdersDraftOrderRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDraftOrdersDraftOrderLineItemsRequest calls the generic PostDraftOrdersDraftOrderLineItems builder with application/json body
func NewPostDraftOrdersDraftOrderLineItemsRequest(server string, id string, body PostDraftOrdersDraftOrderLineItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDraftOrdersDraftOrderLineItemsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostDraftOrdersDraftOrderLineItemsRequestWithBody generates requests for PostDraftOrdersDraftOrderLineItems with any type of body
func NewPostDraftOrdersDraftOrderLineItemsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s/line-items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDraftOrdersDraftOrderLineItemsItemRequest generates requests for DeleteDraftOrdersDraftOrderLineItemsItem
func NewDeleteDraftOrdersDraftOrderLineItemsItemRequest(server string, id string, lineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "line_id", runtime.ParamLocationPath, lineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s/line-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDraftOrdersDraftOrderLineItemsItemRequest calls the generic PostDraftOrdersDraftOrderLineItemsItem builder with application/json body
func NewPostDraftOrdersDraftOrderLineItemsItemRequest(server string, id string, lineId string, body PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDraftOrdersDraftOrderLineItemsItemRequestWithBody(server, id, lineId, "application/json", bodyReader)
}

// NewPostDraftOrdersDraftOrderLineItemsItemRequestWithBody generates requests for PostDraftOrdersDraftOrderLineItemsItem with any type of body
func NewPostDraftOrdersDraftOrderLineItemsItemRequestWithBody(server string, id string, lineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "line_id", runtime.ParamLocationPath, lineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s/line-items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDraftOrdersDraftOrderRegisterPaymentRequest generates requests for PostDraftOrdersDraftOrderRegisterPayment
func NewPostDraftOrdersDraftOrderRegisterPaymentRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/draft-orders/%s/pay", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGiftCardsRequest generates requests for GetGiftCards
func NewGetGiftCardsRequest(server string, params *GetGiftCardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/gift-cards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGiftCardsRequest calls the generic PostGiftCards builder with application/json body
func NewPostGiftCardsRequest(server string, body PostGiftCardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGiftCardsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostGiftCardsRequestWithBody generates requests for PostGiftCards with any type of body
func NewPostGiftCardsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/gift-cards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGiftCardsGiftCardRequest generates requests for DeleteGiftCardsGiftCard
func NewDeleteGiftCardsGiftCardRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/gift-cards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGiftCardsGiftCardRequest generates requests for GetGiftCardsGiftCard
func NewGetGiftCardsGiftCardRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/gift-cards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGiftCardsGiftCardRequest calls the generic PostGiftCardsGiftCard builder with application/json body
func NewPostGiftCardsGiftCardRequest(server string, id string, body PostGiftCardsGiftCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGiftCardsGiftCardRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostGiftCardsGiftCardRequestWithBody generates requests for PostGiftCardsGiftCard with any type of body
func NewPostGiftCardsGiftCardRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/gift-cards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInventoryItemsRequest generates requests for GetInventoryItems
func NewGetInventoryItemsRequest(server string, params *GetInventoryItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sku != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sku", runtime.ParamLocationQuery, *params.Sku); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "origin_country", runtime.ParamLocationQuery, *params.OriginCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MidCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mid_code", runtime.ParamLocationQuery, *params.MidCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Material != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "material", runtime.ParamLocationQuery, *params.Material); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HsCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hs_code", runtime.ParamLocationQuery, *params.HsCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Weight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "weight", runtime.ParamLocationQuery, *params.Weight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Length != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "length", runtime.ParamLocationQuery, *params.Length); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Height != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "height", runtime.ParamLocationQuery, *params.Height); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Width != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequiresShipping != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requires_shipping", runtime.ParamLocationQuery, *params.RequiresShipping); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsRequest calls the generic PostInventoryItems builder with application/json body
func NewPostInventoryItemsRequest(server string, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostInventoryItemsRequestWithBody generates requests for PostInventoryItems with any type of body
func NewPostInventoryItemsRequestWithBody(server string, params *PostInventoryItemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInventoryItemsInventoryItemRequest generates requests for DeleteInventoryItemsInventoryItem
func NewDeleteInventoryItemsInventoryItemRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInventoryItemsInventoryItemRequest generates requests for GetInventoryItemsInventoryItem
func NewGetInventoryItemsInventoryItemRequest(server string, id string, params *GetInventoryItemsInventoryItemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsInventoryItemRequest calls the generic PostInventoryItemsInventoryItem builder with application/json body
func NewPostInventoryItemsInventoryItemRequest(server string, id string, params *PostInventoryItemsInventoryItemParams, body PostInventoryItemsInventoryItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsInventoryItemRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostInventoryItemsInventoryItemRequestWithBody generates requests for PostInventoryItemsInventoryItem with any type of body
func NewPostInventoryItemsInventoryItemRequestWithBody(server string, id string, params *PostInventoryItemsInventoryItemParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInventoryItemsInventoryItemLocationLevelsRequest generates requests for GetInventoryItemsInventoryItemLocationLevels
func NewGetInventoryItemsInventoryItemLocationLevelsRequest(server string, id string, params *GetInventoryItemsInventoryItemLocationLevelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsInventoryItemLocationLevelsRequest calls the generic PostInventoryItemsInventoryItemLocationLevels builder with application/json body
func NewPostInventoryItemsInventoryItemLocationLevelsRequest(server string, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, body PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsInventoryItemLocationLevelsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostInventoryItemsInventoryItemLocationLevelsRequestWithBody generates requests for PostInventoryItemsInventoryItemLocationLevels with any type of body
func NewPostInventoryItemsInventoryItemLocationLevelsRequestWithBody(server string, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInventoryItemsInventoryIteLocationLevelsLocationRequest generates requests for DeleteInventoryItemsInventoryIteLocationLevelsLocation
func NewDeleteInventoryItemsInventoryIteLocationLevelsLocationRequest(server string, id string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "location_id", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequest calls the generic PostInventoryItemsInventoryItemLocationLevelsLocationLevel builder with application/json body
func NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequest(server string, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, body PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequestWithBody(server, id, locationId, params, "application/json", bodyReader)
}

// NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequestWithBody generates requests for PostInventoryItemsInventoryItemLocationLevelsLocationLevel with any type of body
func NewPostInventoryItemsInventoryItemLocationLevelsLocationLevelRequestWithBody(server string, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "location_id", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/inventory-items/%s/location-levels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInvitesRequest generates requests for GetInvites
func NewGetInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInvitesRequest calls the generic PostInvites builder with application/json body
func NewPostInvitesRequest(server string, body PostInvitesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInvitesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostInvitesRequestWithBody generates requests for PostInvites with any type of body
func NewPostInvitesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInvitesInviteAcceptRequest calls the generic PostInvitesInviteAccept builder with application/json body
func NewPostInvitesInviteAcceptRequest(server string, body PostInvitesInviteAcceptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInvitesInviteAcceptRequestWithBody(server, "application/json", bodyReader)
}

// NewPostInvitesInviteAcceptRequestWithBody generates requests for PostInvitesInviteAccept with any type of body
func NewPostInvitesInviteAcceptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/accept")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInvitesInviteRequest generates requests for DeleteInvitesInvite
func NewDeleteInvitesInviteRequest(server string, inviteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInvitesInviteResendRequest generates requests for PostInvitesInviteResend
func NewPostInvitesInviteResendRequest(server string, inviteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/invites/%s/resend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotesRequest generates requests for GetNotes
func NewGetNotesRequest(server string, params *GetNotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_id", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNotesRequest calls the generic PostNotes builder with application/json body
func NewPostNotesRequest(server string, body PostNotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNotesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNotesRequestWithBody generates requests for PostNotes with any type of body
func NewPostNotesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotesNoteRequest generates requests for DeleteNotesNote
func NewDeleteNotesNoteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotesNoteRequest generates requests for GetNotesNote
func NewGetNotesNoteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNotesNoteRequest calls the generic PostNotesNote builder with application/json body
func NewPostNotesNoteRequest(server string, id string, body PostNotesNoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNotesNoteRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostNotesNoteRequestWithBody generates requests for PostNotesNote with any type of body
func NewPostNotesNoteRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationsRequest generates requests for GetNotifications
func NewGetNotificationsRequest(server string, params *GetNotificationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_name", runtime.ParamLocationQuery, *params.EventName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_id", runtime.ParamLocationQuery, *params.ResourceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeResends != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_resends", runtime.ParamLocationQuery, *params.IncludeResends); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNotificationsNotificationResendRequest calls the generic PostNotificationsNotificationResend builder with application/json body
func NewPostNotificationsNotificationResendRequest(server string, id string, body PostNotificationsNotificationResendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNotificationsNotificationResendRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostNotificationsNotificationResendRequestWithBody generates requests for PostNotificationsNotificationResend with any type of body
func NewPostNotificationsNotificationResendRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/notifications/%s/resend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrderEditsRequest generates requests for GetOrderEdits
func NewGetOrderEditsRequest(server string, params *GetOrderEditsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, *params.OrderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsRequest calls the generic PostOrderEdits builder with application/json body
func NewPostOrderEditsRequest(server string, body PostOrderEditsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostOrderEditsRequestWithBody generates requests for PostOrderEdits with any type of body
func NewPostOrderEditsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrderEditsOrderEditRequest generates requests for DeleteOrderEditsOrderEdit
func NewDeleteOrderEditsOrderEditRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrderEditsOrderEditRequest generates requests for GetOrderEditsOrderEdit
func NewGetOrderEditsOrderEditRequest(server string, id string, params *GetOrderEditsOrderEditParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsOrderEditRequest calls the generic PostOrderEditsOrderEdit builder with application/json body
func NewPostOrderEditsOrderEditRequest(server string, id string, body PostOrderEditsOrderEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsOrderEditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostOrderEditsOrderEditRequestWithBody generates requests for PostOrderEditsOrderEdit with any type of body
func NewPostOrderEditsOrderEditRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrderEditsOrderEditCancelRequest generates requests for PostOrderEditsOrderEditCancel
func NewPostOrderEditsOrderEditCancelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOrderEditsOrderEditItemChangeRequest generates requests for DeleteOrderEditsOrderEditItemChange
func NewDeleteOrderEditsOrderEditItemChangeRequest(server string, id string, changeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "change_id", runtime.ParamLocationPath, changeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/changes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsOrderEditConfirmRequest generates requests for PostOrderEditsOrderEditConfirm
func NewPostOrderEditsOrderEditConfirmRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsEditLineItemsRequest calls the generic PostOrderEditsEditLineItems builder with application/json body
func NewPostOrderEditsEditLineItemsRequest(server string, id string, body PostOrderEditsEditLineItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsEditLineItemsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostOrderEditsEditLineItemsRequestWithBody generates requests for PostOrderEditsEditLineItems with any type of body
func NewPostOrderEditsEditLineItemsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrderEditsOrderEditLineItemsLineItemRequest generates requests for DeleteOrderEditsOrderEditLineItemsLineItem
func NewDeleteOrderEditsOrderEditLineItemsLineItemRequest(server string, id string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "item_id", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrderEditsEditLineItemsLineItemRequest calls the generic PostOrderEditsEditLineItemsLineItem builder with application/json body
func NewPostOrderEditsEditLineItemsLineItemRequest(server string, id string, itemId string, body PostOrderEditsEditLineItemsLineItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrderEditsEditLineItemsLineItemRequestWithBody(server, id, itemId, "application/json", bodyReader)
}

// NewPostOrderEditsEditLineItemsLineItemRequestWithBody generates requests for PostOrderEditsEditLineItemsLineItem with any type of body
func NewPostOrderEditsEditLineItemsLineItemRequestWithBody(server string, id string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "item_id", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/items/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrderEditsOrderEditRequestRequest generates requests for PostOrderEditsOrderEditRequest
func NewPostOrderEditsOrderEditRequestRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/order-edits/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FulfillmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fulfillment_status", runtime.ParamLocationQuery, *params.FulfillmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaymentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "payment_status", runtime.ParamLocationQuery, *params.PaymentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "display_id", runtime.ParamLocationQuery, *params.DisplayId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CartId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cart_id", runtime.ParamLocationQuery, *params.CartId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_id", runtime.ParamLocationQuery, *params.CustomerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrencyCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "currency_code", runtime.ParamLocationQuery, *params.CurrencyCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tax_rate", runtime.ParamLocationQuery, *params.TaxRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CanceledAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "canceled_at", runtime.ParamLocationQuery, *params.CanceledAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrdersOrderRequest generates requests for GetOrdersOrder
func NewGetOrdersOrderRequest(server string, id string, params *GetOrdersOrderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderRequest calls the generic PostOrdersOrder builder with application/json body
func NewPostOrdersOrderRequest(server string, id string, params *PostOrdersOrderParams, body PostOrdersOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderRequestWithBody generates requests for PostOrdersOrder with any type of body
func NewPostOrdersOrderRequestWithBody(server string, id string, params *PostOrdersOrderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderArchiveRequest generates requests for PostOrdersOrderArchive
func NewPostOrdersOrderArchiveRequest(server string, id string, params *PostOrdersOrderArchiveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderCancelRequest generates requests for PostOrdersOrderCancel
func NewPostOrdersOrderCancelRequest(server string, id string, params *PostOrdersOrderCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderCaptureRequest generates requests for PostOrdersOrderCapture
func NewPostOrdersOrderCaptureRequest(server string, id string, params *PostOrdersOrderCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderClaimsRequest calls the generic PostOrdersOrderClaims builder with application/json body
func NewPostOrdersOrderClaimsRequest(server string, id string, params *PostOrdersOrderClaimsParams, body PostOrdersOrderClaimsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderClaimsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderClaimsRequestWithBody generates requests for PostOrdersOrderClaims with any type of body
func NewPostOrdersOrderClaimsRequestWithBody(server string, id string, params *PostOrdersOrderClaimsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/claims", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderClaimsClaimRequest calls the generic PostOrdersOrderClaimsClaim builder with application/json body
func NewPostOrdersOrderClaimsClaimRequest(server string, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, body PostOrdersOrderClaimsClaimJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderClaimsClaimRequestWithBody(server, id, claimId, params, "application/json", bodyReader)
}

// NewPostOrdersOrderClaimsClaimRequestWithBody generates requests for PostOrdersOrderClaimsClaim with any type of body
func NewPostOrdersOrderClaimsClaimRequestWithBody(server string, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/claims/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersClaimCancelRequest generates requests for PostOrdersClaimCancel
func NewPostOrdersClaimCancelRequest(server string, id string, claimId string, params *PostOrdersClaimCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/claims/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderClaimsClaimFulfillmentsRequest calls the generic PostOrdersOrderClaimsClaimFulfillments builder with application/json body
func NewPostOrdersOrderClaimsClaimFulfillmentsRequest(server string, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, body PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderClaimsClaimFulfillmentsRequestWithBody(server, id, claimId, params, "application/json", bodyReader)
}

// NewPostOrdersOrderClaimsClaimFulfillmentsRequestWithBody generates requests for PostOrdersOrderClaimsClaimFulfillments with any type of body
func NewPostOrdersOrderClaimsClaimFulfillmentsRequestWithBody(server string, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/claims/%s/fulfillments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersClaimFulfillmentsCancelRequest generates requests for PostOrdersClaimFulfillmentsCancel
func NewPostOrdersClaimFulfillmentsCancelRequest(server string, id string, claimId string, fulfillmentId string, params *PostOrdersClaimFulfillmentsCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, fulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/claims/%s/fulfillments/%s/cancel", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderClaimsClaimShipmentsRequest calls the generic PostOrdersOrderClaimsClaimShipments builder with application/json body
func NewPostOrdersOrderClaimsClaimShipmentsRequest(server string, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, body PostOrdersOrderClaimsClaimShipmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderClaimsClaimShipmentsRequestWithBody(server, id, claimId, params, "application/json", bodyReader)
}

// NewPostOrdersOrderClaimsClaimShipmentsRequestWithBody generates requests for PostOrdersOrderClaimsClaimShipments with any type of body
func NewPostOrdersOrderClaimsClaimShipmentsRequestWithBody(server string, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "claim_id", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/claims/%s/shipments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderCompleteRequest generates requests for PostOrdersOrderComplete
func NewPostOrdersOrderCompleteRequest(server string, id string, params *PostOrdersOrderCompleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderFulfillmentsRequest calls the generic PostOrdersOrderFulfillments builder with application/json body
func NewPostOrdersOrderFulfillmentsRequest(server string, id string, params *PostOrdersOrderFulfillmentsParams, body PostOrdersOrderFulfillmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderFulfillmentsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderFulfillmentsRequestWithBody generates requests for PostOrdersOrderFulfillments with any type of body
func NewPostOrdersOrderFulfillmentsRequestWithBody(server string, id string, params *PostOrdersOrderFulfillmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/fulfillment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderFulfillmentsCancelRequest generates requests for PostOrdersOrderFulfillmentsCancel
func NewPostOrdersOrderFulfillmentsCancelRequest(server string, id string, fulfillmentId string, params *PostOrdersOrderFulfillmentsCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, fulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/fulfillments/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderLineItemReservationsRequest calls the generic PostOrdersOrderLineItemReservations builder with application/json body
func NewPostOrdersOrderLineItemReservationsRequest(server string, id string, lineItemId string, body PostOrdersOrderLineItemReservationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderLineItemReservationsRequestWithBody(server, id, lineItemId, "application/json", bodyReader)
}

// NewPostOrdersOrderLineItemReservationsRequestWithBody generates requests for PostOrdersOrderLineItemReservations with any type of body
func NewPostOrdersOrderLineItemReservationsRequestWithBody(server string, id string, lineItemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "line_item_id", runtime.ParamLocationPath, lineItemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/line-items/%s/reserve", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderRefundsRequest calls the generic PostOrdersOrderRefunds builder with application/json body
func NewPostOrdersOrderRefundsRequest(server string, id string, params *PostOrdersOrderRefundsParams, body PostOrdersOrderRefundsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderRefundsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderRefundsRequestWithBody generates requests for PostOrdersOrderRefunds with any type of body
func NewPostOrdersOrderRefundsRequestWithBody(server string, id string, params *PostOrdersOrderRefundsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrdersOrderReservationsRequest generates requests for GetOrdersOrderReservations
func NewGetOrdersOrderReservationsRequest(server string, id string, params *GetOrdersOrderReservationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/reservations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderReturnsRequest calls the generic PostOrdersOrderReturns builder with application/json body
func NewPostOrdersOrderReturnsRequest(server string, id string, params *PostOrdersOrderReturnsParams, body PostOrdersOrderReturnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderReturnsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderReturnsRequestWithBody generates requests for PostOrdersOrderReturns with any type of body
func NewPostOrdersOrderReturnsRequestWithBody(server string, id string, params *PostOrdersOrderReturnsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/return", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderShipmentRequest calls the generic PostOrdersOrderShipment builder with application/json body
func NewPostOrdersOrderShipmentRequest(server string, id string, params *PostOrdersOrderShipmentParams, body PostOrdersOrderShipmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderShipmentRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderShipmentRequestWithBody generates requests for PostOrdersOrderShipment with any type of body
func NewPostOrdersOrderShipmentRequestWithBody(server string, id string, params *PostOrdersOrderShipmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/shipment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderShippingMethodsRequest calls the generic PostOrdersOrderShippingMethods builder with application/json body
func NewPostOrdersOrderShippingMethodsRequest(server string, id string, params *PostOrdersOrderShippingMethodsParams, body PostOrdersOrderShippingMethodsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderShippingMethodsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderShippingMethodsRequestWithBody generates requests for PostOrdersOrderShippingMethods with any type of body
func NewPostOrdersOrderShippingMethodsRequestWithBody(server string, id string, params *PostOrdersOrderShippingMethodsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/shipping-methods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersOrderSwapsRequest calls the generic PostOrdersOrderSwaps builder with application/json body
func NewPostOrdersOrderSwapsRequest(server string, id string, params *PostOrdersOrderSwapsParams, body PostOrdersOrderSwapsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderSwapsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostOrdersOrderSwapsRequestWithBody generates requests for PostOrdersOrderSwaps with any type of body
func NewPostOrdersOrderSwapsRequestWithBody(server string, id string, params *PostOrdersOrderSwapsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/swaps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersSwapCancelRequest generates requests for PostOrdersSwapCancel
func NewPostOrdersSwapCancelRequest(server string, id string, swapId string, params *PostOrdersSwapCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, swapId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/swaps/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderSwapsSwapFulfillmentsRequest calls the generic PostOrdersOrderSwapsSwapFulfillments builder with application/json body
func NewPostOrdersOrderSwapsSwapFulfillmentsRequest(server string, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, body PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderSwapsSwapFulfillmentsRequestWithBody(server, id, swapId, params, "application/json", bodyReader)
}

// NewPostOrdersOrderSwapsSwapFulfillmentsRequestWithBody generates requests for PostOrdersOrderSwapsSwapFulfillments with any type of body
func NewPostOrdersOrderSwapsSwapFulfillmentsRequestWithBody(server string, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, swapId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/swaps/%s/fulfillments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostOrdersSwapFulfillmentsCancelRequest generates requests for PostOrdersSwapFulfillmentsCancel
func NewPostOrdersSwapFulfillmentsCancelRequest(server string, id string, swapId string, fulfillmentId string, params *PostOrdersSwapFulfillmentsCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, swapId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "fulfillment_id", runtime.ParamLocationPath, fulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/swaps/%s/fulfillments/%s/cancel", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderSwapsSwapProcessPaymentRequest generates requests for PostOrdersOrderSwapsSwapProcessPayment
func NewPostOrdersOrderSwapsSwapProcessPaymentRequest(server string, id string, swapId string, params *PostOrdersOrderSwapsSwapProcessPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, swapId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/swaps/%s/process-payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOrdersOrderSwapsSwapShipmentsRequest calls the generic PostOrdersOrderSwapsSwapShipments builder with application/json body
func NewPostOrdersOrderSwapsSwapShipmentsRequest(server string, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, body PostOrdersOrderSwapsSwapShipmentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOrdersOrderSwapsSwapShipmentsRequestWithBody(server, id, swapId, params, "application/json", bodyReader)
}

// NewPostOrdersOrderSwapsSwapShipmentsRequestWithBody generates requests for PostOrdersOrderSwapsSwapShipments with any type of body
func NewPostOrdersOrderSwapsSwapShipmentsRequestWithBody(server string, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "swap_id", runtime.ParamLocationPath, swapId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/orders/%s/swaps/%s/shipments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePaymentCollectionsPaymentCollectionRequest generates requests for DeletePaymentCollectionsPaymentCollection
func NewDeletePaymentCollectionsPaymentCollectionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentCollectionsPaymentCollectionRequest generates requests for GetPaymentCollectionsPaymentCollection
func NewGetPaymentCollectionsPaymentCollectionRequest(server string, id string, params *GetPaymentCollectionsPaymentCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPaymentCollectionsPaymentCollectionRequest calls the generic PostPaymentCollectionsPaymentCollection builder with application/json body
func NewPostPaymentCollectionsPaymentCollectionRequest(server string, id string, body PostPaymentCollectionsPaymentCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPaymentCollectionsPaymentCollectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPaymentCollectionsPaymentCollectionRequestWithBody generates requests for PostPaymentCollectionsPaymentCollection with any type of body
func NewPostPaymentCollectionsPaymentCollectionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPaymentCollectionsPaymentCollectionAuthorizeRequest generates requests for PostPaymentCollectionsPaymentCollectionAuthorize
func NewPostPaymentCollectionsPaymentCollectionAuthorizeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payment-collections/%s/authorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentsPaymentRequest generates requests for GetPaymentsPayment
func NewGetPaymentsPaymentRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPaymentsPaymentCaptureRequest generates requests for PostPaymentsPaymentCapture
func NewPostPaymentsPaymentCaptureRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPaymentsPaymentRefundsRequest calls the generic PostPaymentsPaymentRefunds builder with application/json body
func NewPostPaymentsPaymentRefundsRequest(server string, id string, body PostPaymentsPaymentRefundsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPaymentsPaymentRefundsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPaymentsPaymentRefundsRequestWithBody generates requests for PostPaymentsPaymentRefunds with any type of body
func NewPostPaymentsPaymentRefundsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/payments/%s/refund", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPriceListsRequest generates requests for GetPriceLists
func NewGetPriceListsRequest(server string, params *GetPriceListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "customer_groups", runtime.ParamLocationQuery, *params.CustomerGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPriceListsPriceListRequest calls the generic PostPriceListsPriceList builder with application/json body
func NewPostPriceListsPriceListRequest(server string, body PostPriceListsPriceListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsPriceListRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPriceListsPriceListRequestWithBody generates requests for PostPriceListsPriceList with any type of body
func NewPostPriceListsPriceListRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePriceListsPriceListRequest generates requests for DeletePriceListsPriceList
func NewDeletePriceListsPriceListRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPriceListsPriceListRequest generates requests for GetPriceListsPriceList
func NewGetPriceListsPriceListRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPriceListsPriceListPriceListRequest calls the generic PostPriceListsPriceListPriceList builder with application/json body
func NewPostPriceListsPriceListPriceListRequest(server string, id string, body PostPriceListsPriceListPriceListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsPriceListPriceListRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPriceListsPriceListPriceListRequestWithBody generates requests for PostPriceListsPriceListPriceList with any type of body
func NewPostPriceListsPriceListPriceListRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePriceListsPriceListPricesBatchRequest calls the generic DeletePriceListsPriceListPricesBatch builder with application/json body
func NewDeletePriceListsPriceListPricesBatchRequest(server string, id string, body DeletePriceListsPriceListPricesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePriceListsPriceListPricesBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeletePriceListsPriceListPricesBatchRequestWithBody generates requests for DeletePriceListsPriceListPricesBatch with any type of body
func NewDeletePriceListsPriceListPricesBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/prices/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPriceListsPriceListPricesBatchRequest calls the generic PostPriceListsPriceListPricesBatch builder with application/json body
func NewPostPriceListsPriceListPricesBatchRequest(server string, id string, body PostPriceListsPriceListPricesBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPriceListsPriceListPricesBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPriceListsPriceListPricesBatchRequestWithBody generates requests for PostPriceListsPriceListPricesBatch with any type of body
func NewPostPriceListsPriceListPricesBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/prices/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPriceListsPriceListProductsRequest generates requests for GetPriceListsPriceListProducts
func NewGetPriceListsPriceListProductsRequest(server string, id string, params *GetPriceListsPriceListProductsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "collection_id", runtime.ParamLocationQuery, *params.CollectionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGiftcard != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_giftcard", runtime.ParamLocationQuery, *params.IsGiftcard); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePriceListsPriceListProductsPricesBatchRequest generates requests for DeletePriceListsPriceListProductsPricesBatch
func NewDeletePriceListsPriceListProductsPricesBatchRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/products/prices/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePriceListsPriceListProductsProductPricesRequest generates requests for DeletePriceListsPriceListProductsProductPrices
func NewDeletePriceListsPriceListProductsProductPricesRequest(server string, id string, productId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "product_id", runtime.ParamLocationPath, productId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/products/%s/prices", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePriceListsPriceListVariantsVariantPricesRequest generates requests for DeletePriceListsPriceListVariantsVariantPrices
func NewDeletePriceListsPriceListVariantsVariantPricesRequest(server string, id string, variantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/price-lists/%s/variants/%s/prices", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductCategoriesRequest generates requests for GetProductCategories
func NewGetProductCategoriesRequest(server string, params *GetProductCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsInternal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_internal", runtime.ParamLocationQuery, *params.IsInternal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsActive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_active", runtime.ParamLocationQuery, *params.IsActive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDescendantsTree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_descendants_tree", runtime.ParamLocationQuery, *params.IncludeDescendantsTree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentCategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_category_id", runtime.ParamLocationQuery, *params.ParentCategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductCategoriesRequest calls the generic PostProductCategories builder with application/json body
func NewPostProductCategoriesRequest(server string, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductCategoriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostProductCategoriesRequestWithBody generates requests for PostProductCategories with any type of body
func NewPostProductCategoriesRequestWithBody(server string, params *PostProductCategoriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductCategoriesCategoryRequest generates requests for DeleteProductCategoriesCategory
func NewDeleteProductCategoriesCategoryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductCategoriesCategoryRequest generates requests for GetProductCategoriesCategory
func NewGetProductCategoriesCategoryRequest(server string, id string, params *GetProductCategoriesCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductCategoriesCategoryRequest calls the generic PostProductCategoriesCategory builder with application/json body
func NewPostProductCategoriesCategoryRequest(server string, id string, params *PostProductCategoriesCategoryParams, body PostProductCategoriesCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductCategoriesCategoryRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductCategoriesCategoryRequestWithBody generates requests for PostProductCategoriesCategory with any type of body
func NewPostProductCategoriesCategoryRequestWithBody(server string, id string, params *PostProductCategoriesCategoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductCategoriesCategoryProductsBatchRequest calls the generic DeleteProductCategoriesCategoryProductsBatch builder with application/json body
func NewDeleteProductCategoriesCategoryProductsBatchRequest(server string, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, body DeleteProductCategoriesCategoryProductsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteProductCategoriesCategoryProductsBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewDeleteProductCategoriesCategoryProductsBatchRequestWithBody generates requests for DeleteProductCategoriesCategoryProductsBatch with any type of body
func NewDeleteProductCategoriesCategoryProductsBatchRequestWithBody(server string, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductCategoriesCategoryProductsBatchRequest calls the generic PostProductCategoriesCategoryProductsBatch builder with application/json body
func NewPostProductCategoriesCategoryProductsBatchRequest(server string, id string, params *PostProductCategoriesCategoryProductsBatchParams, body PostProductCategoriesCategoryProductsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductCategoriesCategoryProductsBatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostProductCategoriesCategoryProductsBatchRequestWithBody generates requests for PostProductCategoriesCategoryProductsBatch with any type of body
func NewPostProductCategoriesCategoryProductsBatchRequestWithBody(server string, id string, params *PostProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-categories/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductTagsRequest generates requests for GetProductTags
func NewGetProductTagsRequest(server string, params *GetProductTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscountConditionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discount_condition_id", runtime.ParamLocationQuery, *params.DiscountConditionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductTypesRequest generates requests for GetProductTypes
func NewGetProductTypesRequest(server string, params *GetProductTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/product-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscountConditionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discount_condition_id", runtime.ParamLocationQuery, *params.DiscountConditionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Value != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "value", runtime.ParamLocationQuery, *params.Value); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsRequest generates requests for GetProducts
func NewGetProductsRequest(server string, params *GetProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscountConditionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discount_condition_id", runtime.ParamLocationQuery, *params.DiscountConditionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CollectionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "collection_id", runtime.ParamLocationQuery, *params.CollectionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceListId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "price_list_id", runtime.ParamLocationQuery, *params.PriceListId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SalesChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sales_channel_id", runtime.ParamLocationQuery, *params.SalesChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type_id", runtime.ParamLocationQuery, *params.TypeId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CategoryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "category_id", runtime.ParamLocationQuery, *params.CategoryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeCategoryChildren != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include_category_children", runtime.ParamLocationQuery, *params.IncludeCategoryChildren); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handle", runtime.ParamLocationQuery, *params.Handle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGiftcard != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_giftcard", runtime.ParamLocationQuery, *params.IsGiftcard); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsRequest calls the generic PostProducts builder with application/json body
func NewPostProductsRequest(server string, body PostProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostProductsRequestWithBody generates requests for PostProducts with any type of body
func NewPostProductsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsTagUsageRequest generates requests for GetProductsTagUsage
func NewGetProductsTagUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/tag-usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsTypesRequest generates requests for GetProductsTypes
func NewGetProductsTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductsProductRequest generates requests for DeleteProductsProduct
func NewDeleteProductsProductRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductsProductRequest generates requests for GetProductsProduct
func NewGetProductsProductRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsProductRequest calls the generic PostProductsProduct builder with application/json body
func NewPostProductsProductRequest(server string, id string, body PostProductsProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProductsProductRequestWithBody generates requests for PostProductsProduct with any type of body
func NewPostProductsProductRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsProductMetadataRequest calls the generic PostProductsProductMetadata builder with application/json body
func NewPostProductsProductMetadataRequest(server string, id string, body PostProductsProductMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductMetadataRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProductsProductMetadataRequestWithBody generates requests for PostProductsProductMetadata with any type of body
func NewPostProductsProductMetadataRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostProductsProductOptionsRequest calls the generic PostProductsProductOptions builder with application/json body
func NewPostProductsProductOptionsRequest(server string, id string, body PostProductsProductOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductOptionsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProductsProductOptionsRequestWithBody generates requests for PostProductsProductOptions with any type of body
func NewPostProductsProductOptionsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsProductOptionsOptionRequest generates requests for DeleteProductsProductOptionsOption
func NewDeleteProductsProductOptionsOptionRequest(server string, id string, optionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "option_id", runtime.ParamLocationPath, optionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsProductOptionsOptionRequest calls the generic PostProductsProductOptionsOption builder with application/json body
func NewPostProductsProductOptionsOptionRequest(server string, id string, optionId string, body PostProductsProductOptionsOptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductOptionsOptionRequestWithBody(server, id, optionId, "application/json", bodyReader)
}

// NewPostProductsProductOptionsOptionRequestWithBody generates requests for PostProductsProductOptionsOption with any type of body
func NewPostProductsProductOptionsOptionRequestWithBody(server string, id string, optionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "option_id", runtime.ParamLocationPath, optionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/options/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProductsProductVariantsRequest generates requests for GetProductsProductVariants
func NewGetProductsProductVariantsRequest(server string, id string, params *GetProductsProductVariantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ManageInventory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "manage_inventory", runtime.ParamLocationQuery, *params.ManageInventory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowBackorder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_backorder", runtime.ParamLocationQuery, *params.AllowBackorder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InventoryQuantity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inventory_quantity", runtime.ParamLocationQuery, *params.InventoryQuantity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsProductVariantsRequest calls the generic PostProductsProductVariants builder with application/json body
func NewPostProductsProductVariantsRequest(server string, id string, body PostProductsProductVariantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductVariantsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProductsProductVariantsRequestWithBody generates requests for PostProductsProductVariants with any type of body
func NewPostProductsProductVariantsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductsProductVariantsVariantRequest generates requests for DeleteProductsProductVariantsVariant
func NewDeleteProductsProductVariantsVariantRequest(server string, id string, variantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProductsProductVariantsVariantRequest calls the generic PostProductsProductVariantsVariant builder with application/json body
func NewPostProductsProductVariantsVariantRequest(server string, id string, variantId string, body PostProductsProductVariantsVariantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProductsProductVariantsVariantRequestWithBody(server, id, variantId, "application/json", bodyReader)
}

// NewPostProductsProductVariantsVariantRequestWithBody generates requests for PostProductsProductVariantsVariant with any type of body
func NewPostProductsProductVariantsVariantRequestWithBody(server string, id string, variantId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "variant_id", runtime.ParamLocationPath, variantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/products/%s/variants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublishableApiKeysRequest generates requests for GetPublishableApiKeys
func NewGetPublishableApiKeysRequest(server string, params *GetPublishableApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RevokedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "revoked_at", runtime.ParamLocationQuery, *params.RevokedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPublishableApiKeysRequest calls the generic PostPublishableApiKeys builder with application/json body
func NewPostPublishableApiKeysRequest(server string, body PostPublishableApiKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPublishableApiKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPublishableApiKeysRequestWithBody generates requests for PostPublishableApiKeys with any type of body
func NewPostPublishableApiKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePublishableApiKeysPublishableApiKeyRequest generates requests for DeletePublishableApiKeysPublishableApiKey
func NewDeletePublishableApiKeysPublishableApiKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublishableApiKeysPublishableApiKeyRequest generates requests for GetPublishableApiKeysPublishableApiKey
func NewGetPublishableApiKeysPublishableApiKeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPublishableApiKysPublishableApiKeyRequest calls the generic PostPublishableApiKysPublishableApiKey builder with application/json body
func NewPostPublishableApiKysPublishableApiKeyRequest(server string, id string, body PostPublishableApiKysPublishableApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPublishableApiKysPublishableApiKeyRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPublishableApiKysPublishableApiKeyRequestWithBody generates requests for PostPublishableApiKysPublishableApiKey with any type of body
func NewPostPublishableApiKysPublishableApiKeyRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPublishableApiKeysPublishableApiKeyRevokeRequest generates requests for PostPublishableApiKeysPublishableApiKeyRevoke
func NewPostPublishableApiKeysPublishableApiKeyRevokeRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s/revoke", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublishableApiKeySalesChannelsRequest generates requests for GetPublishableApiKeySalesChannels
func NewGetPublishableApiKeySalesChannelsRequest(server string, id string, params *GetPublishableApiKeySalesChannelsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s/sales-channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePublishableApiKeySalesChannelsChannelsBatchRequest calls the generic DeletePublishableApiKeySalesChannelsChannelsBatch builder with application/json body
func NewDeletePublishableApiKeySalesChannelsChannelsBatchRequest(server string, id string, body DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePublishableApiKeySalesChannelsChannelsBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeletePublishableApiKeySalesChannelsChannelsBatchRequestWithBody generates requests for DeletePublishableApiKeySalesChannelsChannelsBatch with any type of body
func NewDeletePublishableApiKeySalesChannelsChannelsBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s/sales-channels/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostPublishableApiKeySalesChannelsChannelsBatchRequest calls the generic PostPublishableApiKeySalesChannelsChannelsBatch builder with application/json body
func NewPostPublishableApiKeySalesChannelsChannelsBatchRequest(server string, id string, body PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPublishableApiKeySalesChannelsChannelsBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostPublishableApiKeySalesChannelsChannelsBatchRequestWithBody generates requests for PostPublishableApiKeySalesChannelsChannelsBatch with any type of body
func NewPostPublishableApiKeySalesChannelsChannelsBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/publishable-api-keys/%s/sales-channels/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRegionsRequest generates requests for GetRegions
func NewGetRegionsRequest(server string, params *GetRegionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegionsRequest calls the generic PostRegions builder with application/json body
func NewPostRegionsRequest(server string, body PostRegionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRegionsRequestWithBody generates requests for PostRegions with any type of body
func NewPostRegionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRegionsRegionRequest generates requests for DeleteRegionsRegion
func NewDeleteRegionsRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegionsRegionRequest generates requests for GetRegionsRegion
func NewGetRegionsRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegionsRegionRequest calls the generic PostRegionsRegion builder with application/json body
func NewPostRegionsRegionRequest(server string, id string, body PostRegionsRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsRegionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostRegionsRegionRequestWithBody generates requests for PostRegionsRegion with any type of body
func NewPostRegionsRegionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRegionsRegionCountriesRequest calls the generic PostRegionsRegionCountries builder with application/json body
func NewPostRegionsRegionCountriesRequest(server string, id string, body PostRegionsRegionCountriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsRegionCountriesRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostRegionsRegionCountriesRequestWithBody generates requests for PostRegionsRegionCountries with any type of body
func NewPostRegionsRegionCountriesRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/countries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRegionsRegionCountriesCountryRequest generates requests for PostRegionsRegionCountriesCountry
func NewPostRegionsRegionCountriesCountryRequest(server string, id string, countryCode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "country_code", runtime.ParamLocationPath, countryCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/countries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegionsRegionFulfillmentOptionsRequest generates requests for GetRegionsRegionFulfillmentOptions
func NewGetRegionsRegionFulfillmentOptionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/fulfillment-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegionsRegionFulfillmentProvidersRequest calls the generic PostRegionsRegionFulfillmentProviders builder with application/json body
func NewPostRegionsRegionFulfillmentProvidersRequest(server string, id string, body PostRegionsRegionFulfillmentProvidersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsRegionFulfillmentProvidersRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostRegionsRegionFulfillmentProvidersRequestWithBody generates requests for PostRegionsRegionFulfillmentProviders with any type of body
func NewPostRegionsRegionFulfillmentProvidersRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/fulfillment-providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRegionsRegionFulfillmentProvidersProviderRequest generates requests for PostRegionsRegionFulfillmentProvidersProvider
func NewPostRegionsRegionFulfillmentProvidersProviderRequest(server string, id string, providerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/fulfillment-providers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegionsRegionPaymentProvidersRequest calls the generic PostRegionsRegionPaymentProviders builder with application/json body
func NewPostRegionsRegionPaymentProvidersRequest(server string, id string, body PostRegionsRegionPaymentProvidersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegionsRegionPaymentProvidersRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostRegionsRegionPaymentProvidersRequestWithBody generates requests for PostRegionsRegionPaymentProviders with any type of body
func NewPostRegionsRegionPaymentProvidersRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/payment-providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRegionsRegionPaymentProvidersProviderRequest generates requests for PostRegionsRegionPaymentProvidersProvider
func NewPostRegionsRegionPaymentProvidersProviderRequest(server string, id string, providerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/regions/%s/payment-providers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservationsRequest generates requests for GetReservations
func NewGetReservationsRequest(server string, params *GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LocationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "location_id", runtime.ParamLocationQuery, *params.LocationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InventoryItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "inventory_item_id", runtime.ParamLocationQuery, *params.InventoryItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LineItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "line_item_id", runtime.ParamLocationQuery, *params.LineItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Quantity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "quantity", runtime.ParamLocationQuery, *params.Quantity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservationsRequest calls the generic PostReservations builder with application/json body
func NewPostReservationsRequest(server string, body PostReservationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservationsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostReservationsRequestWithBody generates requests for PostReservations with any type of body
func NewPostReservationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReservationsReservationRequest generates requests for DeleteReservationsReservation
func NewDeleteReservationsReservationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservationsReservationRequest generates requests for GetReservationsReservation
func NewGetReservationsReservationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservationsReservationRequest calls the generic PostReservationsReservation builder with application/json body
func NewPostReservationsReservationRequest(server string, id string, body PostReservationsReservationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservationsReservationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostReservationsReservationRequestWithBody generates requests for PostReservationsReservation with any type of body
func NewPostReservationsReservationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/reservations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReturnReasonsRequest generates requests for GetReturnReasons
func NewGetReturnReasonsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnReasonsRequest calls the generic PostReturnReasons builder with application/json body
func NewPostReturnReasonsRequest(server string, body PostReturnReasonsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnReasonsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostReturnReasonsRequestWithBody generates requests for PostReturnReasons with any type of body
func NewPostReturnReasonsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReturnReasonRequest generates requests for DeleteReturnReason
func NewDeleteReturnReasonRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReturnReasonsReasonRequest generates requests for GetReturnReasonsReason
func NewGetReturnReasonsReasonRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnReasonsReasonRequest calls the generic PostReturnReasonsReason builder with application/json body
func NewPostReturnReasonsReasonRequest(server string, id string, body PostReturnReasonsReasonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnReasonsReasonRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostReturnReasonsReasonRequestWithBody generates requests for PostReturnReasonsReason with any type of body
func NewPostReturnReasonsReasonRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/return-reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReturnsRequest generates requests for GetReturns
func NewGetReturnsRequest(server string, params *GetReturnsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsReturnCancelRequest generates requests for PostReturnsReturnCancel
func NewPostReturnsReturnCancelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReturnsReturnReceiveRequest calls the generic PostReturnsReturnReceive builder with application/json body
func NewPostReturnsReturnReceiveRequest(server string, id string, body PostReturnsReturnReceiveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReturnsReturnReceiveRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostReturnsReturnReceiveRequestWithBody generates requests for PostReturnsReturnReceive with any type of body
func NewPostReturnsReturnReceiveRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/returns/%s/receive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSalesChannelsRequest generates requests for GetSalesChannels
func NewGetSalesChannelsRequest(server string, params *GetSalesChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSalesChannelsRequest calls the generic PostSalesChannels builder with application/json body
func NewPostSalesChannelsRequest(server string, body PostSalesChannelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSalesChannelsRequestWithBody generates requests for PostSalesChannels with any type of body
func NewPostSalesChannelsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSalesChannelsSalesChannelRequest generates requests for DeleteSalesChannelsSalesChannel
func NewDeleteSalesChannelsSalesChannelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSalesChannelsSalesChannelRequest generates requests for GetSalesChannelsSalesChannel
func NewGetSalesChannelsSalesChannelRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSalesChannelsSalesChannelRequest calls the generic PostSalesChannelsSalesChannel builder with application/json body
func NewPostSalesChannelsSalesChannelRequest(server string, id string, body PostSalesChannelsSalesChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsSalesChannelRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSalesChannelsSalesChannelRequestWithBody generates requests for PostSalesChannelsSalesChannel with any type of body
func NewPostSalesChannelsSalesChannelRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSalesChannelsChannelProductsBatchRequest calls the generic DeleteSalesChannelsChannelProductsBatch builder with application/json body
func NewDeleteSalesChannelsChannelProductsBatchRequest(server string, id string, body DeleteSalesChannelsChannelProductsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSalesChannelsChannelProductsBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteSalesChannelsChannelProductsBatchRequestWithBody generates requests for DeleteSalesChannelsChannelProductsBatch with any type of body
func NewDeleteSalesChannelsChannelProductsBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSalesChannelsChannelProductsBatchRequest calls the generic PostSalesChannelsChannelProductsBatch builder with application/json body
func NewPostSalesChannelsChannelProductsBatchRequest(server string, id string, body PostSalesChannelsChannelProductsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsChannelProductsBatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSalesChannelsChannelProductsBatchRequestWithBody generates requests for PostSalesChannelsChannelProductsBatch with any type of body
func NewPostSalesChannelsChannelProductsBatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSalesChannelsSalesChannelStockLocationRequest calls the generic DeleteSalesChannelsSalesChannelStockLocation builder with application/json body
func NewDeleteSalesChannelsSalesChannelStockLocationRequest(server string, id string, body DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSalesChannelsSalesChannelStockLocationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDeleteSalesChannelsSalesChannelStockLocationRequestWithBody generates requests for DeleteSalesChannelsSalesChannelStockLocation with any type of body
func NewDeleteSalesChannelsSalesChannelStockLocationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s/stock-locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostSalesChannelsSalesChannelStockLocationRequest calls the generic PostSalesChannelsSalesChannelStockLocation builder with application/json body
func NewPostSalesChannelsSalesChannelStockLocationRequest(server string, id string, body PostSalesChannelsSalesChannelStockLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSalesChannelsSalesChannelStockLocationRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostSalesChannelsSalesChannelStockLocationRequestWithBody generates requests for PostSalesChannelsSalesChannelStockLocation with any type of body
func NewPostSalesChannelsSalesChannelStockLocationRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/sales-channels/%s/stock-locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShippingOptionsRequest generates requests for GetShippingOptions
func NewGetShippingOptionsRequest(server string, params *GetShippingOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsReturn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_return", runtime.ParamLocationQuery, *params.IsReturn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "admin_only", runtime.ParamLocationQuery, *params.AdminOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingOptionsRequest calls the generic PostShippingOptions builder with application/json body
func NewPostShippingOptionsRequest(server string, body PostShippingOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingOptionsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostShippingOptionsRequestWithBody generates requests for PostShippingOptions with any type of body
func NewPostShippingOptionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShippingOptionsOptionRequest generates requests for DeleteShippingOptionsOption
func NewDeleteShippingOptionsOptionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShippingOptionsOptionRequest generates requests for GetShippingOptionsOption
func NewGetShippingOptionsOptionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingOptionsOptionRequest calls the generic PostShippingOptionsOption builder with application/json body
func NewPostShippingOptionsOptionRequest(server string, id string, body PostShippingOptionsOptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingOptionsOptionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostShippingOptionsOptionRequestWithBody generates requests for PostShippingOptionsOption with any type of body
func NewPostShippingOptionsOptionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-options/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetShippingProfilesRequest generates requests for GetShippingProfiles
func NewGetShippingProfilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingProfilesRequest calls the generic PostShippingProfiles builder with application/json body
func NewPostShippingProfilesRequest(server string, body PostShippingProfilesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingProfilesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostShippingProfilesRequestWithBody generates requests for PostShippingProfiles with any type of body
func NewPostShippingProfilesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteShippingProfilesProfileRequest generates requests for DeleteShippingProfilesProfile
func NewDeleteShippingProfilesProfileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShippingProfilesProfileRequest generates requests for GetShippingProfilesProfile
func NewGetShippingProfilesProfileRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostShippingProfilesProfileRequest calls the generic PostShippingProfilesProfile builder with application/json body
func NewPostShippingProfilesProfileRequest(server string, id string, body PostShippingProfilesProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostShippingProfilesProfileRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostShippingProfilesProfileRequestWithBody generates requests for PostShippingProfilesProfile with any type of body
func NewPostShippingProfilesProfileRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/shipping-profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStockLocationsRequest generates requests for GetStockLocations
func NewGetStockLocationsRequest(server string, params *GetStockLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStockLocationsRequest calls the generic PostStockLocations builder with application/json body
func NewPostStockLocationsRequest(server string, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostStockLocationsRequestWithBody generates requests for PostStockLocations with any type of body
func NewPostStockLocationsRequestWithBody(server string, params *PostStockLocationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStockLocationsStockLocationRequest generates requests for DeleteStockLocationsStockLocation
func NewDeleteStockLocationsStockLocationRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStockLocationsStockLocationRequest generates requests for GetStockLocationsStockLocation
func NewGetStockLocationsStockLocationRequest(server string, id string, params *GetStockLocationsStockLocationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStockLocationsStockLocationRequest calls the generic PostStockLocationsStockLocation builder with application/json body
func NewPostStockLocationsStockLocationRequest(server string, id string, params *PostStockLocationsStockLocationParams, body PostStockLocationsStockLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStockLocationsStockLocationRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostStockLocationsStockLocationRequestWithBody generates requests for PostStockLocationsStockLocation with any type of body
func NewPostStockLocationsStockLocationRequestWithBody(server string, id string, params *PostStockLocationsStockLocationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/stock-locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStoreRequest generates requests for GetStore
func NewGetStoreRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/store")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStoreRequest calls the generic PostStore builder with application/json body
func NewPostStoreRequest(server string, body PostStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStoreRequestWithBody generates requests for PostStore with any type of body
func NewPostStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/store")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStoreCurrenciesCodeRequest generates requests for DeleteStoreCurrenciesCode
func NewDeleteStoreCurrenciesCodeRequest(server string, code string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/store/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostStoreCurrenciesCodeRequest generates requests for PostStoreCurrenciesCode
func NewPostStoreCurrenciesCodeRequest(server string, code string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/store/currencies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorePaymentProvidersRequest generates requests for GetStorePaymentProviders
func NewGetStorePaymentProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/store/payment-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoreTaxProvidersRequest generates requests for GetStoreTaxProviders
func NewGetStoreTaxProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/store/tax-providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapsRequest generates requests for GetSwaps
func NewGetSwapsRequest(server string, params *GetSwapsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/swaps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapsSwapRequest generates requests for GetSwapsSwap
func NewGetSwapsSwapRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/swaps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxRatesRequest generates requests for GetTaxRates
func NewGetTaxRatesRequest(server string, params *GetTaxRatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rate", runtime.ParamLocationQuery, *params.Rate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTaxRatesRequest calls the generic PostTaxRates builder with application/json body
func NewPostTaxRatesRequest(server string, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostTaxRatesRequestWithBody generates requests for PostTaxRates with any type of body
func NewPostTaxRatesRequestWithBody(server string, params *PostTaxRatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRatesTaxRateRequest generates requests for DeleteTaxRatesTaxRate
func NewDeleteTaxRatesTaxRateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTaxRatesTaxRateRequest generates requests for GetTaxRatesTaxRate
func NewGetTaxRatesTaxRateRequest(server string, id string, params *GetTaxRatesTaxRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTaxRatesTaxRateRequest calls the generic PostTaxRatesTaxRate builder with application/json body
func NewPostTaxRatesTaxRateRequest(server string, id string, params *PostTaxRatesTaxRateParams, body PostTaxRatesTaxRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesTaxRateRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTaxRatesTaxRateRequestWithBody generates requests for PostTaxRatesTaxRate with any type of body
func NewPostTaxRatesTaxRateRequestWithBody(server string, id string, params *PostTaxRatesTaxRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRatesTaxRateProductTypesRequest calls the generic DeleteTaxRatesTaxRateProductTypes builder with application/json body
func NewDeleteTaxRatesTaxRateProductTypesRequest(server string, id string, params *DeleteTaxRatesTaxRateProductTypesParams, body DeleteTaxRatesTaxRateProductTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTaxRatesTaxRateProductTypesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewDeleteTaxRatesTaxRateProductTypesRequestWithBody generates requests for DeleteTaxRatesTaxRateProductTypes with any type of body
func NewDeleteTaxRatesTaxRateProductTypesRequestWithBody(server string, id string, params *DeleteTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/product-types/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTaxRatesTaxRateProductTypesRequest calls the generic PostTaxRatesTaxRateProductTypes builder with application/json body
func NewPostTaxRatesTaxRateProductTypesRequest(server string, id string, params *PostTaxRatesTaxRateProductTypesParams, body PostTaxRatesTaxRateProductTypesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesTaxRateProductTypesRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTaxRatesTaxRateProductTypesRequestWithBody generates requests for PostTaxRatesTaxRateProductTypes with any type of body
func NewPostTaxRatesTaxRateProductTypesRequestWithBody(server string, id string, params *PostTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/product-types/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRatesTaxRateProductsRequest calls the generic DeleteTaxRatesTaxRateProducts builder with application/json body
func NewDeleteTaxRatesTaxRateProductsRequest(server string, id string, params *DeleteTaxRatesTaxRateProductsParams, body DeleteTaxRatesTaxRateProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTaxRatesTaxRateProductsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewDeleteTaxRatesTaxRateProductsRequestWithBody generates requests for DeleteTaxRatesTaxRateProducts with any type of body
func NewDeleteTaxRatesTaxRateProductsRequestWithBody(server string, id string, params *DeleteTaxRatesTaxRateProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTaxRatesTaxRateProductsRequest calls the generic PostTaxRatesTaxRateProducts builder with application/json body
func NewPostTaxRatesTaxRateProductsRequest(server string, id string, params *PostTaxRatesTaxRateProductsParams, body PostTaxRatesTaxRateProductsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesTaxRateProductsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTaxRatesTaxRateProductsRequestWithBody generates requests for PostTaxRatesTaxRateProducts with any type of body
func NewPostTaxRatesTaxRateProductsRequestWithBody(server string, id string, params *PostTaxRatesTaxRateProductsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/products/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTaxRatesTaxRateShippingOptionsRequest calls the generic DeleteTaxRatesTaxRateShippingOptions builder with application/json body
func NewDeleteTaxRatesTaxRateShippingOptionsRequest(server string, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, body DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTaxRatesTaxRateShippingOptionsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewDeleteTaxRatesTaxRateShippingOptionsRequestWithBody generates requests for DeleteTaxRatesTaxRateShippingOptions with any type of body
func NewDeleteTaxRatesTaxRateShippingOptionsRequestWithBody(server string, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/shipping-options/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTaxRatesTaxRateShippingOptionsRequest calls the generic PostTaxRatesTaxRateShippingOptions builder with application/json body
func NewPostTaxRatesTaxRateShippingOptionsRequest(server string, id string, params *PostTaxRatesTaxRateShippingOptionsParams, body PostTaxRatesTaxRateShippingOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTaxRatesTaxRateShippingOptionsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostTaxRatesTaxRateShippingOptionsRequestWithBody generates requests for PostTaxRatesTaxRateShippingOptions with any type of body
func NewPostTaxRatesTaxRateShippingOptionsRequestWithBody(server string, id string, params *PostTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/tax-rates/%s/shipping-options/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUploadsRequest calls the generic DeleteUploads builder with application/json body
func NewDeleteUploadsRequest(server string, body DeleteUploadsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUploadsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteUploadsRequestWithBody generates requests for DeleteUploads with any type of body
func NewDeleteUploadsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUploadsRequestWithBody generates requests for PostUploads with any type of body
func NewPostUploadsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUploadsDownloadUrlRequest calls the generic PostUploadsDownloadUrl builder with application/json body
func NewPostUploadsDownloadUrlRequest(server string, body PostUploadsDownloadUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUploadsDownloadUrlRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUploadsDownloadUrlRequestWithBody generates requests for PostUploadsDownloadUrl with any type of body
func NewPostUploadsDownloadUrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads/download-url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUploadsProtectedRequestWithBody generates requests for PostUploadsProtected with any type of body
func NewPostUploadsProtectedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/uploads/protected")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Email != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, *params.Email); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_name", runtime.ParamLocationQuery, *params.FirstName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_name", runtime.ParamLocationQuery, *params.LastName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at", runtime.ParamLocationQuery, *params.UpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeletedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleted_at", runtime.ParamLocationQuery, *params.DeletedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersRequest calls the generic PostUsers builder with application/json body
func NewPostUsersRequest(server string, body PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUsersRequestWithBody generates requests for PostUsers with any type of body
func NewPostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUsersUserPasswordTokenRequest calls the generic PostUsersUserPasswordToken builder with application/json body
func NewPostUsersUserPasswordTokenRequest(server string, body PostUsersUserPasswordTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersUserPasswordTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUsersUserPasswordTokenRequestWithBody generates requests for PostUsersUserPasswordToken with any type of body
func NewPostUsersUserPasswordTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/password-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostUsersUserPasswordRequest calls the generic PostUsersUserPassword builder with application/json body
func NewPostUsersUserPasswordRequest(server string, body PostUsersUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersUserPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewPostUsersUserPasswordRequestWithBody generates requests for PostUsersUserPassword with any type of body
func NewPostUsersUserPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUsersUserRequest generates requests for DeleteUsersUser
func NewDeleteUsersUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserRequest generates requests for GetUsersUser
func NewGetUsersUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUsersUserRequest calls the generic PostUsersUser builder with application/json body
func NewPostUsersUserRequest(server string, id string, body PostUsersUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostUsersUserRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostUsersUserRequestWithBody generates requests for PostUsersUser with any type of body
func NewPostUsersUserRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVariantsRequest generates requests for GetVariants
func NewGetVariantsRequest(server string, params *GetVariantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/variants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ManageInventory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "manage_inventory", runtime.ParamLocationQuery, *params.ManageInventory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AllowBackorder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_backorder", runtime.ParamLocationQuery, *params.AllowBackorder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CartId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cart_id", runtime.ParamLocationQuery, *params.CartId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region_id", runtime.ParamLocationQuery, *params.RegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrencyCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "currency_code", runtime.ParamLocationQuery, *params.CurrencyCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "customer_id", runtime.ParamLocationQuery, *params.CustomerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InventoryQuantity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inventory_quantity", runtime.ParamLocationQuery, *params.InventoryQuantity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariantsVariantRequest generates requests for GetVariantsVariant
func NewGetVariantsVariantRequest(server string, id string, params *GetVariantsVariantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/variants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariantsVariantInventoryRequest generates requests for GetVariantsVariantInventory
func NewGetVariantsVariantInventoryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/admin/variants/%s/inventory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAppsWithResponse request
	GetAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAppsResponse, error)

	// PostAppsWithBodyWithResponse request with any body
	PostAppsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppsResponse, error)

	PostAppsWithResponse(ctx context.Context, body PostAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppsResponse, error)

	// DeleteAuthWithResponse request
	DeleteAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAuthResponse, error)

	// GetAuthWithResponse request
	GetAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthResponse, error)

	// PostAuthWithBodyWithResponse request with any body
	PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error)

	// PostTokenWithBodyWithResponse request with any body
	PostTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTokenResponse, error)

	PostTokenWithResponse(ctx context.Context, body PostTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTokenResponse, error)

	// GetBatchJobsWithResponse request
	GetBatchJobsWithResponse(ctx context.Context, params *GetBatchJobsParams, reqEditors ...RequestEditorFn) (*GetBatchJobsResponse, error)

	// PostBatchJobsWithBodyWithResponse request with any body
	PostBatchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBatchJobsResponse, error)

	PostBatchJobsWithResponse(ctx context.Context, body PostBatchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBatchJobsResponse, error)

	// GetBatchJobsBatchJobWithResponse request
	GetBatchJobsBatchJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBatchJobsBatchJobResponse, error)

	// PostBatchJobsBatchJobCancelWithResponse request
	PostBatchJobsBatchJobCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostBatchJobsBatchJobCancelResponse, error)

	// PostBatchJobsBatchJobConfirmProcessingWithResponse request
	PostBatchJobsBatchJobConfirmProcessingWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostBatchJobsBatchJobConfirmProcessingResponse, error)

	// GetCollectionsWithResponse request
	GetCollectionsWithResponse(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*GetCollectionsResponse, error)

	// PostCollectionsWithBodyWithResponse request with any body
	PostCollectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error)

	PostCollectionsWithResponse(ctx context.Context, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error)

	// DeleteCollectionsCollectionWithResponse request
	DeleteCollectionsCollectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCollectionsCollectionResponse, error)

	// GetCollectionsCollectionWithResponse request
	GetCollectionsCollectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCollectionsCollectionResponse, error)

	// PostCollectionsCollectionWithBodyWithResponse request with any body
	PostCollectionsCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsCollectionResponse, error)

	PostCollectionsCollectionWithResponse(ctx context.Context, id string, body PostCollectionsCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsCollectionResponse, error)

	// DeleteProductsFromCollectionWithBodyWithResponse request with any body
	DeleteProductsFromCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProductsFromCollectionResponse, error)

	DeleteProductsFromCollectionWithResponse(ctx context.Context, id string, body DeleteProductsFromCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProductsFromCollectionResponse, error)

	// PostProductsToCollectionWithBodyWithResponse request with any body
	PostProductsToCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsToCollectionResponse, error)

	PostProductsToCollectionWithResponse(ctx context.Context, id string, body PostProductsToCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsToCollectionResponse, error)

	// GetCurrenciesWithResponse request
	GetCurrenciesWithResponse(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*GetCurrenciesResponse, error)

	// PostCurrenciesCurrencyWithBodyWithResponse request with any body
	PostCurrenciesCurrencyWithBodyWithResponse(ctx context.Context, code string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCurrenciesCurrencyResponse, error)

	PostCurrenciesCurrencyWithResponse(ctx context.Context, code string, body PostCurrenciesCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCurrenciesCurrencyResponse, error)

	// GetCustomerGroupsWithResponse request
	GetCustomerGroupsWithResponse(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsResponse, error)

	// PostCustomerGroupsWithBodyWithResponse request with any body
	PostCustomerGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error)

	PostCustomerGroupsWithResponse(ctx context.Context, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error)

	// DeleteCustomerGroupsCustomerGroupWithResponse request
	DeleteCustomerGroupsCustomerGroupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsCustomerGroupResponse, error)

	// GetCustomerGroupsGroupWithResponse request
	GetCustomerGroupsGroupWithResponse(ctx context.Context, id string, params *GetCustomerGroupsGroupParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsGroupResponse, error)

	// PostCustomerGroupsGroupWithBodyWithResponse request with any body
	PostCustomerGroupsGroupWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupResponse, error)

	PostCustomerGroupsGroupWithResponse(ctx context.Context, id string, body PostCustomerGroupsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupResponse, error)

	// GetCustomerGroupsGroupCustomersWithResponse request
	GetCustomerGroupsGroupCustomersWithResponse(ctx context.Context, id string, params *GetCustomerGroupsGroupCustomersParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsGroupCustomersResponse, error)

	// DeleteCustomerGroupsGroupCustomerBatchWithBodyWithResponse request with any body
	DeleteCustomerGroupsGroupCustomerBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsGroupCustomerBatchResponse, error)

	DeleteCustomerGroupsGroupCustomerBatchWithResponse(ctx context.Context, id string, body DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsGroupCustomerBatchResponse, error)

	// PostCustomerGroupsGroupCustomersBatchWithBodyWithResponse request with any body
	PostCustomerGroupsGroupCustomersBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupCustomersBatchResponse, error)

	PostCustomerGroupsGroupCustomersBatchWithResponse(ctx context.Context, id string, body PostCustomerGroupsGroupCustomersBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupCustomersBatchResponse, error)

	// GetCustomersWithResponse request
	GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*GetCustomersResponse, error)

	// PostCustomersWithBodyWithResponse request with any body
	PostCustomersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error)

	PostCustomersWithResponse(ctx context.Context, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error)

	// GetCustomersCustomerWithResponse request
	GetCustomersCustomerWithResponse(ctx context.Context, id string, params *GetCustomersCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomersCustomerResponse, error)

	// PostCustomersCustomerWithBodyWithResponse request with any body
	PostCustomersCustomerWithBodyWithResponse(ctx context.Context, id string, params *PostCustomersCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersCustomerResponse, error)

	PostCustomersCustomerWithResponse(ctx context.Context, id string, params *PostCustomersCustomerParams, body PostCustomersCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersCustomerResponse, error)

	// GetDiscountsWithResponse request
	GetDiscountsWithResponse(ctx context.Context, params *GetDiscountsParams, reqEditors ...RequestEditorFn) (*GetDiscountsResponse, error)

	// PostDiscountsWithBodyWithResponse request with any body
	PostDiscountsWithBodyWithResponse(ctx context.Context, params *PostDiscountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsResponse, error)

	PostDiscountsWithResponse(ctx context.Context, params *PostDiscountsParams, body PostDiscountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsResponse, error)

	// GetDiscountsDiscountCodeWithResponse request
	GetDiscountsDiscountCodeWithResponse(ctx context.Context, code string, params *GetDiscountsDiscountCodeParams, reqEditors ...RequestEditorFn) (*GetDiscountsDiscountCodeResponse, error)

	// PostDiscountsDiscountConditionsWithBodyWithResponse request with any body
	PostDiscountsDiscountConditionsWithBodyWithResponse(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsResponse, error)

	PostDiscountsDiscountConditionsWithResponse(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, body PostDiscountsDiscountConditionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsResponse, error)

	// DeleteDiscountsDiscountConditionsConditionWithResponse request
	DeleteDiscountsDiscountConditionsConditionWithResponse(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountConditionsConditionResponse, error)

	// GetDiscountsDiscountConditionsConditionWithResponse request
	GetDiscountsDiscountConditionsConditionWithResponse(ctx context.Context, discountId string, conditionId string, params *GetDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*GetDiscountsDiscountConditionsConditionResponse, error)

	// PostDiscountsDiscountConditionsConditionWithBodyWithResponse request with any body
	PostDiscountsDiscountConditionsConditionWithBodyWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionResponse, error)

	PostDiscountsDiscountConditionsConditionWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, body PostDiscountsDiscountConditionsConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionResponse, error)

	// DeleteDiscountsDiscountConditionsConditionBatchWithBodyWithResponse request with any body
	DeleteDiscountsDiscountConditionsConditionBatchWithBodyWithResponse(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountConditionsConditionBatchResponse, error)

	DeleteDiscountsDiscountConditionsConditionBatchWithResponse(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, body DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountConditionsConditionBatchResponse, error)

	// PostDiscountsDiscountConditionsConditionBatchWithBodyWithResponse request with any body
	PostDiscountsDiscountConditionsConditionBatchWithBodyWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionBatchResponse, error)

	PostDiscountsDiscountConditionsConditionBatchWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, body PostDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionBatchResponse, error)

	// DeleteDiscountsDiscountWithResponse request
	DeleteDiscountsDiscountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountResponse, error)

	// GetDiscountsDiscountWithResponse request
	GetDiscountsDiscountWithResponse(ctx context.Context, id string, params *GetDiscountsDiscountParams, reqEditors ...RequestEditorFn) (*GetDiscountsDiscountResponse, error)

	// PostDiscountsDiscountWithBodyWithResponse request with any body
	PostDiscountsDiscountWithBodyWithResponse(ctx context.Context, id string, params *PostDiscountsDiscountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountResponse, error)

	PostDiscountsDiscountWithResponse(ctx context.Context, id string, params *PostDiscountsDiscountParams, body PostDiscountsDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountResponse, error)

	// PostDiscountsDiscountDynamicCodesWithBodyWithResponse request with any body
	PostDiscountsDiscountDynamicCodesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountDynamicCodesResponse, error)

	PostDiscountsDiscountDynamicCodesWithResponse(ctx context.Context, id string, body PostDiscountsDiscountDynamicCodesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountDynamicCodesResponse, error)

	// DeleteDiscountsDiscountDynamicCodesCodeWithResponse request
	DeleteDiscountsDiscountDynamicCodesCodeWithResponse(ctx context.Context, id string, code string, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountDynamicCodesCodeResponse, error)

	// DeleteDiscountsDiscountRegionsRegionWithResponse request
	DeleteDiscountsDiscountRegionsRegionWithResponse(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountRegionsRegionResponse, error)

	// PostDiscountsDiscountRegionsRegionWithResponse request
	PostDiscountsDiscountRegionsRegionWithResponse(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountRegionsRegionResponse, error)

	// GetDraftOrdersWithResponse request
	GetDraftOrdersWithResponse(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*GetDraftOrdersResponse, error)

	// PostDraftOrdersWithBodyWithResponse request with any body
	PostDraftOrdersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error)

	PostDraftOrdersWithResponse(ctx context.Context, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error)

	// DeleteDraftOrdersDraftOrderWithResponse request
	DeleteDraftOrdersDraftOrderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDraftOrdersDraftOrderResponse, error)

	// GetDraftOrdersDraftOrderWithResponse request
	GetDraftOrdersDraftOrderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDraftOrdersDraftOrderResponse, error)

	// PostDraftOrdersDraftOrderWithBodyWithResponse request with any body
	PostDraftOrdersDraftOrderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderResponse, error)

	PostDraftOrdersDraftOrderWithResponse(ctx context.Context, id string, body PostDraftOrdersDraftOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderResponse, error)

	// PostDraftOrdersDraftOrderLineItemsWithBodyWithResponse request with any body
	PostDraftOrdersDraftOrderLineItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsResponse, error)

	PostDraftOrdersDraftOrderLineItemsWithResponse(ctx context.Context, id string, body PostDraftOrdersDraftOrderLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsResponse, error)

	// DeleteDraftOrdersDraftOrderLineItemsItemWithResponse request
	DeleteDraftOrdersDraftOrderLineItemsItemWithResponse(ctx context.Context, id string, lineId string, reqEditors ...RequestEditorFn) (*DeleteDraftOrdersDraftOrderLineItemsItemResponse, error)

	// PostDraftOrdersDraftOrderLineItemsItemWithBodyWithResponse request with any body
	PostDraftOrdersDraftOrderLineItemsItemWithBodyWithResponse(ctx context.Context, id string, lineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsItemResponse, error)

	PostDraftOrdersDraftOrderLineItemsItemWithResponse(ctx context.Context, id string, lineId string, body PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsItemResponse, error)

	// PostDraftOrdersDraftOrderRegisterPaymentWithResponse request
	PostDraftOrdersDraftOrderRegisterPaymentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderRegisterPaymentResponse, error)

	// GetGiftCardsWithResponse request
	GetGiftCardsWithResponse(ctx context.Context, params *GetGiftCardsParams, reqEditors ...RequestEditorFn) (*GetGiftCardsResponse, error)

	// PostGiftCardsWithBodyWithResponse request with any body
	PostGiftCardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGiftCardsResponse, error)

	PostGiftCardsWithResponse(ctx context.Context, body PostGiftCardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGiftCardsResponse, error)

	// DeleteGiftCardsGiftCardWithResponse request
	DeleteGiftCardsGiftCardWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGiftCardsGiftCardResponse, error)

	// GetGiftCardsGiftCardWithResponse request
	GetGiftCardsGiftCardWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGiftCardsGiftCardResponse, error)

	// PostGiftCardsGiftCardWithBodyWithResponse request with any body
	PostGiftCardsGiftCardWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGiftCardsGiftCardResponse, error)

	PostGiftCardsGiftCardWithResponse(ctx context.Context, id string, body PostGiftCardsGiftCardJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGiftCardsGiftCardResponse, error)

	// GetInventoryItemsWithResponse request
	GetInventoryItemsWithResponse(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsResponse, error)

	// PostInventoryItemsWithBodyWithResponse request with any body
	PostInventoryItemsWithBodyWithResponse(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error)

	PostInventoryItemsWithResponse(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error)

	// DeleteInventoryItemsInventoryItemWithResponse request
	DeleteInventoryItemsInventoryItemWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsInventoryItemResponse, error)

	// GetInventoryItemsInventoryItemWithResponse request
	GetInventoryItemsInventoryItemWithResponse(ctx context.Context, id string, params *GetInventoryItemsInventoryItemParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsInventoryItemResponse, error)

	// PostInventoryItemsInventoryItemWithBodyWithResponse request with any body
	PostInventoryItemsInventoryItemWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemResponse, error)

	PostInventoryItemsInventoryItemWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, body PostInventoryItemsInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemResponse, error)

	// GetInventoryItemsInventoryItemLocationLevelsWithResponse request
	GetInventoryItemsInventoryItemLocationLevelsWithResponse(ctx context.Context, id string, params *GetInventoryItemsInventoryItemLocationLevelsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsInventoryItemLocationLevelsResponse, error)

	// PostInventoryItemsInventoryItemLocationLevelsWithBodyWithResponse request with any body
	PostInventoryItemsInventoryItemLocationLevelsWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsResponse, error)

	PostInventoryItemsInventoryItemLocationLevelsWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, body PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsResponse, error)

	// DeleteInventoryItemsInventoryIteLocationLevelsLocationWithResponse request
	DeleteInventoryItemsInventoryIteLocationLevelsLocationWithResponse(ctx context.Context, id string, locationId string, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse, error)

	// PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBodyWithResponse request with any body
	PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBodyWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse, error)

	PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, body PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse, error)

	// GetInvitesWithResponse request
	GetInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInvitesResponse, error)

	// PostInvitesWithBodyWithResponse request with any body
	PostInvitesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error)

	PostInvitesWithResponse(ctx context.Context, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error)

	// PostInvitesInviteAcceptWithBodyWithResponse request with any body
	PostInvitesInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesInviteAcceptResponse, error)

	PostInvitesInviteAcceptWithResponse(ctx context.Context, body PostInvitesInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesInviteAcceptResponse, error)

	// DeleteInvitesInviteWithResponse request
	DeleteInvitesInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*DeleteInvitesInviteResponse, error)

	// PostInvitesInviteResendWithResponse request
	PostInvitesInviteResendWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*PostInvitesInviteResendResponse, error)

	// GetNotesWithResponse request
	GetNotesWithResponse(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*GetNotesResponse, error)

	// PostNotesWithBodyWithResponse request with any body
	PostNotesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotesResponse, error)

	PostNotesWithResponse(ctx context.Context, body PostNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotesResponse, error)

	// DeleteNotesNoteWithResponse request
	DeleteNotesNoteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNotesNoteResponse, error)

	// GetNotesNoteWithResponse request
	GetNotesNoteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNotesNoteResponse, error)

	// PostNotesNoteWithBodyWithResponse request with any body
	PostNotesNoteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotesNoteResponse, error)

	PostNotesNoteWithResponse(ctx context.Context, id string, body PostNotesNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotesNoteResponse, error)

	// GetNotificationsWithResponse request
	GetNotificationsWithResponse(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error)

	// PostNotificationsNotificationResendWithBodyWithResponse request with any body
	PostNotificationsNotificationResendWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotificationsNotificationResendResponse, error)

	PostNotificationsNotificationResendWithResponse(ctx context.Context, id string, body PostNotificationsNotificationResendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotificationsNotificationResendResponse, error)

	// GetOrderEditsWithResponse request
	GetOrderEditsWithResponse(ctx context.Context, params *GetOrderEditsParams, reqEditors ...RequestEditorFn) (*GetOrderEditsResponse, error)

	// PostOrderEditsWithBodyWithResponse request with any body
	PostOrderEditsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error)

	PostOrderEditsWithResponse(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error)

	// DeleteOrderEditsOrderEditWithResponse request
	DeleteOrderEditsOrderEditWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsOrderEditResponse, error)

	// GetOrderEditsOrderEditWithResponse request
	GetOrderEditsOrderEditWithResponse(ctx context.Context, id string, params *GetOrderEditsOrderEditParams, reqEditors ...RequestEditorFn) (*GetOrderEditsOrderEditResponse, error)

	// PostOrderEditsOrderEditWithBodyWithResponse request with any body
	PostOrderEditsOrderEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditResponse, error)

	PostOrderEditsOrderEditWithResponse(ctx context.Context, id string, body PostOrderEditsOrderEditJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditResponse, error)

	// PostOrderEditsOrderEditCancelWithResponse request
	PostOrderEditsOrderEditCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditCancelResponse, error)

	// DeleteOrderEditsOrderEditItemChangeWithResponse request
	DeleteOrderEditsOrderEditItemChangeWithResponse(ctx context.Context, id string, changeId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsOrderEditItemChangeResponse, error)

	// PostOrderEditsOrderEditConfirmWithResponse request
	PostOrderEditsOrderEditConfirmWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditConfirmResponse, error)

	// PostOrderEditsEditLineItemsWithBodyWithResponse request with any body
	PostOrderEditsEditLineItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsResponse, error)

	PostOrderEditsEditLineItemsWithResponse(ctx context.Context, id string, body PostOrderEditsEditLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsResponse, error)

	// DeleteOrderEditsOrderEditLineItemsLineItemWithResponse request
	DeleteOrderEditsOrderEditLineItemsLineItemWithResponse(ctx context.Context, id string, itemId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsOrderEditLineItemsLineItemResponse, error)

	// PostOrderEditsEditLineItemsLineItemWithBodyWithResponse request with any body
	PostOrderEditsEditLineItemsLineItemWithBodyWithResponse(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsLineItemResponse, error)

	PostOrderEditsEditLineItemsLineItemWithResponse(ctx context.Context, id string, itemId string, body PostOrderEditsEditLineItemsLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsLineItemResponse, error)

	// PostOrderEditsOrderEditRequestWithResponse request
	PostOrderEditsOrderEditRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditRequestResponse, error)

	// GetOrdersWithResponse request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error)

	// GetOrdersOrderWithResponse request
	GetOrdersOrderWithResponse(ctx context.Context, id string, params *GetOrdersOrderParams, reqEditors ...RequestEditorFn) (*GetOrdersOrderResponse, error)

	// PostOrdersOrderWithBodyWithResponse request with any body
	PostOrdersOrderWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderResponse, error)

	PostOrdersOrderWithResponse(ctx context.Context, id string, params *PostOrdersOrderParams, body PostOrdersOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderResponse, error)

	// PostOrdersOrderArchiveWithResponse request
	PostOrdersOrderArchiveWithResponse(ctx context.Context, id string, params *PostOrdersOrderArchiveParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderArchiveResponse, error)

	// PostOrdersOrderCancelWithResponse request
	PostOrdersOrderCancelWithResponse(ctx context.Context, id string, params *PostOrdersOrderCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderCancelResponse, error)

	// PostOrdersOrderCaptureWithResponse request
	PostOrdersOrderCaptureWithResponse(ctx context.Context, id string, params *PostOrdersOrderCaptureParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderCaptureResponse, error)

	// PostOrdersOrderClaimsWithBodyWithResponse request with any body
	PostOrdersOrderClaimsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsResponse, error)

	PostOrdersOrderClaimsWithResponse(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, body PostOrdersOrderClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsResponse, error)

	// PostOrdersOrderClaimsClaimWithBodyWithResponse request with any body
	PostOrdersOrderClaimsClaimWithBodyWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimResponse, error)

	PostOrdersOrderClaimsClaimWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, body PostOrdersOrderClaimsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimResponse, error)

	// PostOrdersClaimCancelWithResponse request
	PostOrdersClaimCancelWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersClaimCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersClaimCancelResponse, error)

	// PostOrdersOrderClaimsClaimFulfillmentsWithBodyWithResponse request with any body
	PostOrdersOrderClaimsClaimFulfillmentsWithBodyWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimFulfillmentsResponse, error)

	PostOrdersOrderClaimsClaimFulfillmentsWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, body PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimFulfillmentsResponse, error)

	// PostOrdersClaimFulfillmentsCancelWithResponse request
	PostOrdersClaimFulfillmentsCancelWithResponse(ctx context.Context, id string, claimId string, fulfillmentId string, params *PostOrdersClaimFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersClaimFulfillmentsCancelResponse, error)

	// PostOrdersOrderClaimsClaimShipmentsWithBodyWithResponse request with any body
	PostOrdersOrderClaimsClaimShipmentsWithBodyWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimShipmentsResponse, error)

	PostOrdersOrderClaimsClaimShipmentsWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, body PostOrdersOrderClaimsClaimShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimShipmentsResponse, error)

	// PostOrdersOrderCompleteWithResponse request
	PostOrdersOrderCompleteWithResponse(ctx context.Context, id string, params *PostOrdersOrderCompleteParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderCompleteResponse, error)

	// PostOrdersOrderFulfillmentsWithBodyWithResponse request with any body
	PostOrdersOrderFulfillmentsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderFulfillmentsResponse, error)

	PostOrdersOrderFulfillmentsWithResponse(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, body PostOrdersOrderFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderFulfillmentsResponse, error)

	// PostOrdersOrderFulfillmentsCancelWithResponse request
	PostOrdersOrderFulfillmentsCancelWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersOrderFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderFulfillmentsCancelResponse, error)

	// PostOrdersOrderLineItemReservationsWithBodyWithResponse request with any body
	PostOrdersOrderLineItemReservationsWithBodyWithResponse(ctx context.Context, id string, lineItemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderLineItemReservationsResponse, error)

	PostOrdersOrderLineItemReservationsWithResponse(ctx context.Context, id string, lineItemId string, body PostOrdersOrderLineItemReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderLineItemReservationsResponse, error)

	// PostOrdersOrderRefundsWithBodyWithResponse request with any body
	PostOrdersOrderRefundsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderRefundsResponse, error)

	PostOrdersOrderRefundsWithResponse(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, body PostOrdersOrderRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderRefundsResponse, error)

	// GetOrdersOrderReservationsWithResponse request
	GetOrdersOrderReservationsWithResponse(ctx context.Context, id string, params *GetOrdersOrderReservationsParams, reqEditors ...RequestEditorFn) (*GetOrdersOrderReservationsResponse, error)

	// PostOrdersOrderReturnsWithBodyWithResponse request with any body
	PostOrdersOrderReturnsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderReturnsResponse, error)

	PostOrdersOrderReturnsWithResponse(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, body PostOrdersOrderReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderReturnsResponse, error)

	// PostOrdersOrderShipmentWithBodyWithResponse request with any body
	PostOrdersOrderShipmentWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderShipmentResponse, error)

	PostOrdersOrderShipmentWithResponse(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, body PostOrdersOrderShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderShipmentResponse, error)

	// PostOrdersOrderShippingMethodsWithBodyWithResponse request with any body
	PostOrdersOrderShippingMethodsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderShippingMethodsResponse, error)

	PostOrdersOrderShippingMethodsWithResponse(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, body PostOrdersOrderShippingMethodsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderShippingMethodsResponse, error)

	// PostOrdersOrderSwapsWithBodyWithResponse request with any body
	PostOrdersOrderSwapsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsResponse, error)

	PostOrdersOrderSwapsWithResponse(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, body PostOrdersOrderSwapsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsResponse, error)

	// PostOrdersSwapCancelWithResponse request
	PostOrdersSwapCancelWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersSwapCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersSwapCancelResponse, error)

	// PostOrdersOrderSwapsSwapFulfillmentsWithBodyWithResponse request with any body
	PostOrdersOrderSwapsSwapFulfillmentsWithBodyWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapFulfillmentsResponse, error)

	PostOrdersOrderSwapsSwapFulfillmentsWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, body PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapFulfillmentsResponse, error)

	// PostOrdersSwapFulfillmentsCancelWithResponse request
	PostOrdersSwapFulfillmentsCancelWithResponse(ctx context.Context, id string, swapId string, fulfillmentId string, params *PostOrdersSwapFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersSwapFulfillmentsCancelResponse, error)

	// PostOrdersOrderSwapsSwapProcessPaymentWithResponse request
	PostOrdersOrderSwapsSwapProcessPaymentWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapProcessPaymentParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapProcessPaymentResponse, error)

	// PostOrdersOrderSwapsSwapShipmentsWithBodyWithResponse request with any body
	PostOrdersOrderSwapsSwapShipmentsWithBodyWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapShipmentsResponse, error)

	PostOrdersOrderSwapsSwapShipmentsWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, body PostOrdersOrderSwapsSwapShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapShipmentsResponse, error)

	// DeletePaymentCollectionsPaymentCollectionWithResponse request
	DeletePaymentCollectionsPaymentCollectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePaymentCollectionsPaymentCollectionResponse, error)

	// GetPaymentCollectionsPaymentCollectionWithResponse request
	GetPaymentCollectionsPaymentCollectionWithResponse(ctx context.Context, id string, params *GetPaymentCollectionsPaymentCollectionParams, reqEditors ...RequestEditorFn) (*GetPaymentCollectionsPaymentCollectionResponse, error)

	// PostPaymentCollectionsPaymentCollectionWithBodyWithResponse request with any body
	PostPaymentCollectionsPaymentCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsPaymentCollectionResponse, error)

	PostPaymentCollectionsPaymentCollectionWithResponse(ctx context.Context, id string, body PostPaymentCollectionsPaymentCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsPaymentCollectionResponse, error)

	// PostPaymentCollectionsPaymentCollectionAuthorizeWithResponse request
	PostPaymentCollectionsPaymentCollectionAuthorizeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsPaymentCollectionAuthorizeResponse, error)

	// GetPaymentsPaymentWithResponse request
	GetPaymentsPaymentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPaymentsPaymentResponse, error)

	// PostPaymentsPaymentCaptureWithResponse request
	PostPaymentsPaymentCaptureWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostPaymentsPaymentCaptureResponse, error)

	// PostPaymentsPaymentRefundsWithBodyWithResponse request with any body
	PostPaymentsPaymentRefundsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentsPaymentRefundsResponse, error)

	PostPaymentsPaymentRefundsWithResponse(ctx context.Context, id string, body PostPaymentsPaymentRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentsPaymentRefundsResponse, error)

	// GetPriceListsWithResponse request
	GetPriceListsWithResponse(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*GetPriceListsResponse, error)

	// PostPriceListsPriceListWithBodyWithResponse request with any body
	PostPriceListsPriceListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListResponse, error)

	PostPriceListsPriceListWithResponse(ctx context.Context, body PostPriceListsPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListResponse, error)

	// DeletePriceListsPriceListWithResponse request
	DeletePriceListsPriceListWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListResponse, error)

	// GetPriceListsPriceListWithResponse request
	GetPriceListsPriceListWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPriceListsPriceListResponse, error)

	// PostPriceListsPriceListPriceListWithBodyWithResponse request with any body
	PostPriceListsPriceListPriceListWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPriceListResponse, error)

	PostPriceListsPriceListPriceListWithResponse(ctx context.Context, id string, body PostPriceListsPriceListPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPriceListResponse, error)

	// DeletePriceListsPriceListPricesBatchWithBodyWithResponse request with any body
	DeletePriceListsPriceListPricesBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListPricesBatchResponse, error)

	DeletePriceListsPriceListPricesBatchWithResponse(ctx context.Context, id string, body DeletePriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListPricesBatchResponse, error)

	// PostPriceListsPriceListPricesBatchWithBodyWithResponse request with any body
	PostPriceListsPriceListPricesBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPricesBatchResponse, error)

	PostPriceListsPriceListPricesBatchWithResponse(ctx context.Context, id string, body PostPriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPricesBatchResponse, error)

	// GetPriceListsPriceListProductsWithResponse request
	GetPriceListsPriceListProductsWithResponse(ctx context.Context, id string, params *GetPriceListsPriceListProductsParams, reqEditors ...RequestEditorFn) (*GetPriceListsPriceListProductsResponse, error)

	// DeletePriceListsPriceListProductsPricesBatchWithResponse request
	DeletePriceListsPriceListProductsPricesBatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListProductsPricesBatchResponse, error)

	// DeletePriceListsPriceListProductsProductPricesWithResponse request
	DeletePriceListsPriceListProductsProductPricesWithResponse(ctx context.Context, id string, productId string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListProductsProductPricesResponse, error)

	// DeletePriceListsPriceListVariantsVariantPricesWithResponse request
	DeletePriceListsPriceListVariantsVariantPricesWithResponse(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListVariantsVariantPricesResponse, error)

	// GetProductCategoriesWithResponse request
	GetProductCategoriesWithResponse(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesResponse, error)

	// PostProductCategoriesWithBodyWithResponse request with any body
	PostProductCategoriesWithBodyWithResponse(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error)

	PostProductCategoriesWithResponse(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error)

	// DeleteProductCategoriesCategoryWithResponse request
	DeleteProductCategoriesCategoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesCategoryResponse, error)

	// GetProductCategoriesCategoryWithResponse request
	GetProductCategoriesCategoryWithResponse(ctx context.Context, id string, params *GetProductCategoriesCategoryParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesCategoryResponse, error)

	// PostProductCategoriesCategoryWithBodyWithResponse request with any body
	PostProductCategoriesCategoryWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryResponse, error)

	PostProductCategoriesCategoryWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, body PostProductCategoriesCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryResponse, error)

	// DeleteProductCategoriesCategoryProductsBatchWithBodyWithResponse request with any body
	DeleteProductCategoriesCategoryProductsBatchWithBodyWithResponse(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesCategoryProductsBatchResponse, error)

	DeleteProductCategoriesCategoryProductsBatchWithResponse(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, body DeleteProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesCategoryProductsBatchResponse, error)

	// PostProductCategoriesCategoryProductsBatchWithBodyWithResponse request with any body
	PostProductCategoriesCategoryProductsBatchWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryProductsBatchResponse, error)

	PostProductCategoriesCategoryProductsBatchWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, body PostProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryProductsBatchResponse, error)

	// GetProductTagsWithResponse request
	GetProductTagsWithResponse(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*GetProductTagsResponse, error)

	// GetProductTypesWithResponse request
	GetProductTypesWithResponse(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*GetProductTypesResponse, error)

	// GetProductsWithResponse request
	GetProductsWithResponse(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*GetProductsResponse, error)

	// PostProductsWithBodyWithResponse request with any body
	PostProductsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsResponse, error)

	PostProductsWithResponse(ctx context.Context, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsResponse, error)

	// GetProductsTagUsageWithResponse request
	GetProductsTagUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProductsTagUsageResponse, error)

	// GetProductsTypesWithResponse request
	GetProductsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProductsTypesResponse, error)

	// DeleteProductsProductWithResponse request
	DeleteProductsProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductsProductResponse, error)

	// GetProductsProductWithResponse request
	GetProductsProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProductsProductResponse, error)

	// PostProductsProductWithBodyWithResponse request with any body
	PostProductsProductWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductResponse, error)

	PostProductsProductWithResponse(ctx context.Context, id string, body PostProductsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductResponse, error)

	// PostProductsProductMetadataWithBodyWithResponse request with any body
	PostProductsProductMetadataWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductMetadataResponse, error)

	PostProductsProductMetadataWithResponse(ctx context.Context, id string, body PostProductsProductMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductMetadataResponse, error)

	// PostProductsProductOptionsWithBodyWithResponse request with any body
	PostProductsProductOptionsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsResponse, error)

	PostProductsProductOptionsWithResponse(ctx context.Context, id string, body PostProductsProductOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsResponse, error)

	// DeleteProductsProductOptionsOptionWithResponse request
	DeleteProductsProductOptionsOptionWithResponse(ctx context.Context, id string, optionId string, reqEditors ...RequestEditorFn) (*DeleteProductsProductOptionsOptionResponse, error)

	// PostProductsProductOptionsOptionWithBodyWithResponse request with any body
	PostProductsProductOptionsOptionWithBodyWithResponse(ctx context.Context, id string, optionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsOptionResponse, error)

	PostProductsProductOptionsOptionWithResponse(ctx context.Context, id string, optionId string, body PostProductsProductOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsOptionResponse, error)

	// GetProductsProductVariantsWithResponse request
	GetProductsProductVariantsWithResponse(ctx context.Context, id string, params *GetProductsProductVariantsParams, reqEditors ...RequestEditorFn) (*GetProductsProductVariantsResponse, error)

	// PostProductsProductVariantsWithBodyWithResponse request with any body
	PostProductsProductVariantsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsResponse, error)

	PostProductsProductVariantsWithResponse(ctx context.Context, id string, body PostProductsProductVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsResponse, error)

	// DeleteProductsProductVariantsVariantWithResponse request
	DeleteProductsProductVariantsVariantWithResponse(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*DeleteProductsProductVariantsVariantResponse, error)

	// PostProductsProductVariantsVariantWithBodyWithResponse request with any body
	PostProductsProductVariantsVariantWithBodyWithResponse(ctx context.Context, id string, variantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsVariantResponse, error)

	PostProductsProductVariantsVariantWithResponse(ctx context.Context, id string, variantId string, body PostProductsProductVariantsVariantJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsVariantResponse, error)

	// GetPublishableApiKeysWithResponse request
	GetPublishableApiKeysWithResponse(ctx context.Context, params *GetPublishableApiKeysParams, reqEditors ...RequestEditorFn) (*GetPublishableApiKeysResponse, error)

	// PostPublishableApiKeysWithBodyWithResponse request with any body
	PostPublishableApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishableApiKeysResponse, error)

	PostPublishableApiKeysWithResponse(ctx context.Context, body PostPublishableApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishableApiKeysResponse, error)

	// DeletePublishableApiKeysPublishableApiKeyWithResponse request
	DeletePublishableApiKeysPublishableApiKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePublishableApiKeysPublishableApiKeyResponse, error)

	// GetPublishableApiKeysPublishableApiKeyWithResponse request
	GetPublishableApiKeysPublishableApiKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPublishableApiKeysPublishableApiKeyResponse, error)

	// PostPublishableApiKysPublishableApiKeyWithBodyWithResponse request with any body
	PostPublishableApiKysPublishableApiKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishableApiKysPublishableApiKeyResponse, error)

	PostPublishableApiKysPublishableApiKeyWithResponse(ctx context.Context, id string, body PostPublishableApiKysPublishableApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishableApiKysPublishableApiKeyResponse, error)

	// PostPublishableApiKeysPublishableApiKeyRevokeWithResponse request
	PostPublishableApiKeysPublishableApiKeyRevokeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostPublishableApiKeysPublishableApiKeyRevokeResponse, error)

	// GetPublishableApiKeySalesChannelsWithResponse request
	GetPublishableApiKeySalesChannelsWithResponse(ctx context.Context, id string, params *GetPublishableApiKeySalesChannelsParams, reqEditors ...RequestEditorFn) (*GetPublishableApiKeySalesChannelsResponse, error)

	// DeletePublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse request with any body
	DeletePublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePublishableApiKeySalesChannelsChannelsBatchResponse, error)

	DeletePublishableApiKeySalesChannelsChannelsBatchWithResponse(ctx context.Context, id string, body DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePublishableApiKeySalesChannelsChannelsBatchResponse, error)

	// PostPublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse request with any body
	PostPublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishableApiKeySalesChannelsChannelsBatchResponse, error)

	PostPublishableApiKeySalesChannelsChannelsBatchWithResponse(ctx context.Context, id string, body PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishableApiKeySalesChannelsChannelsBatchResponse, error)

	// GetRegionsWithResponse request
	GetRegionsWithResponse(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*GetRegionsResponse, error)

	// PostRegionsWithBodyWithResponse request with any body
	PostRegionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error)

	PostRegionsWithResponse(ctx context.Context, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error)

	// DeleteRegionsRegionWithResponse request
	DeleteRegionsRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRegionsRegionResponse, error)

	// GetRegionsRegionWithResponse request
	GetRegionsRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRegionsRegionResponse, error)

	// PostRegionsRegionWithBodyWithResponse request with any body
	PostRegionsRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionResponse, error)

	PostRegionsRegionWithResponse(ctx context.Context, id string, body PostRegionsRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionResponse, error)

	// PostRegionsRegionCountriesWithBodyWithResponse request with any body
	PostRegionsRegionCountriesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionCountriesResponse, error)

	PostRegionsRegionCountriesWithResponse(ctx context.Context, id string, body PostRegionsRegionCountriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionCountriesResponse, error)

	// PostRegionsRegionCountriesCountryWithResponse request
	PostRegionsRegionCountriesCountryWithResponse(ctx context.Context, id string, countryCode string, reqEditors ...RequestEditorFn) (*PostRegionsRegionCountriesCountryResponse, error)

	// GetRegionsRegionFulfillmentOptionsWithResponse request
	GetRegionsRegionFulfillmentOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRegionsRegionFulfillmentOptionsResponse, error)

	// PostRegionsRegionFulfillmentProvidersWithBodyWithResponse request with any body
	PostRegionsRegionFulfillmentProvidersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionFulfillmentProvidersResponse, error)

	PostRegionsRegionFulfillmentProvidersWithResponse(ctx context.Context, id string, body PostRegionsRegionFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionFulfillmentProvidersResponse, error)

	// PostRegionsRegionFulfillmentProvidersProviderWithResponse request
	PostRegionsRegionFulfillmentProvidersProviderWithResponse(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*PostRegionsRegionFulfillmentProvidersProviderResponse, error)

	// PostRegionsRegionPaymentProvidersWithBodyWithResponse request with any body
	PostRegionsRegionPaymentProvidersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionPaymentProvidersResponse, error)

	PostRegionsRegionPaymentProvidersWithResponse(ctx context.Context, id string, body PostRegionsRegionPaymentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionPaymentProvidersResponse, error)

	// PostRegionsRegionPaymentProvidersProviderWithResponse request
	PostRegionsRegionPaymentProvidersProviderWithResponse(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*PostRegionsRegionPaymentProvidersProviderResponse, error)

	// GetReservationsWithResponse request
	GetReservationsWithResponse(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*GetReservationsResponse, error)

	// PostReservationsWithBodyWithResponse request with any body
	PostReservationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error)

	PostReservationsWithResponse(ctx context.Context, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error)

	// DeleteReservationsReservationWithResponse request
	DeleteReservationsReservationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReservationsReservationResponse, error)

	// GetReservationsReservationWithResponse request
	GetReservationsReservationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReservationsReservationResponse, error)

	// PostReservationsReservationWithBodyWithResponse request with any body
	PostReservationsReservationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsReservationResponse, error)

	PostReservationsReservationWithResponse(ctx context.Context, id string, body PostReservationsReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsReservationResponse, error)

	// GetReturnReasonsWithResponse request
	GetReturnReasonsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReturnReasonsResponse, error)

	// PostReturnReasonsWithBodyWithResponse request with any body
	PostReturnReasonsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error)

	PostReturnReasonsWithResponse(ctx context.Context, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error)

	// DeleteReturnReasonWithResponse request
	DeleteReturnReasonWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnReasonResponse, error)

	// GetReturnReasonsReasonWithResponse request
	GetReturnReasonsReasonWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReturnReasonsReasonResponse, error)

	// PostReturnReasonsReasonWithBodyWithResponse request with any body
	PostReturnReasonsReasonWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsReasonResponse, error)

	PostReturnReasonsReasonWithResponse(ctx context.Context, id string, body PostReturnReasonsReasonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsReasonResponse, error)

	// GetReturnsWithResponse request
	GetReturnsWithResponse(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*GetReturnsResponse, error)

	// PostReturnsReturnCancelWithResponse request
	PostReturnsReturnCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostReturnsReturnCancelResponse, error)

	// PostReturnsReturnReceiveWithBodyWithResponse request with any body
	PostReturnsReturnReceiveWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsReturnReceiveResponse, error)

	PostReturnsReturnReceiveWithResponse(ctx context.Context, id string, body PostReturnsReturnReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsReturnReceiveResponse, error)

	// GetSalesChannelsWithResponse request
	GetSalesChannelsWithResponse(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*GetSalesChannelsResponse, error)

	// PostSalesChannelsWithBodyWithResponse request with any body
	PostSalesChannelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error)

	PostSalesChannelsWithResponse(ctx context.Context, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error)

	// DeleteSalesChannelsSalesChannelWithResponse request
	DeleteSalesChannelsSalesChannelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsSalesChannelResponse, error)

	// GetSalesChannelsSalesChannelWithResponse request
	GetSalesChannelsSalesChannelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSalesChannelsSalesChannelResponse, error)

	// PostSalesChannelsSalesChannelWithBodyWithResponse request with any body
	PostSalesChannelsSalesChannelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelResponse, error)

	PostSalesChannelsSalesChannelWithResponse(ctx context.Context, id string, body PostSalesChannelsSalesChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelResponse, error)

	// DeleteSalesChannelsChannelProductsBatchWithBodyWithResponse request with any body
	DeleteSalesChannelsChannelProductsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsChannelProductsBatchResponse, error)

	DeleteSalesChannelsChannelProductsBatchWithResponse(ctx context.Context, id string, body DeleteSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsChannelProductsBatchResponse, error)

	// PostSalesChannelsChannelProductsBatchWithBodyWithResponse request with any body
	PostSalesChannelsChannelProductsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsChannelProductsBatchResponse, error)

	PostSalesChannelsChannelProductsBatchWithResponse(ctx context.Context, id string, body PostSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsChannelProductsBatchResponse, error)

	// DeleteSalesChannelsSalesChannelStockLocationWithBodyWithResponse request with any body
	DeleteSalesChannelsSalesChannelStockLocationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsSalesChannelStockLocationResponse, error)

	DeleteSalesChannelsSalesChannelStockLocationWithResponse(ctx context.Context, id string, body DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsSalesChannelStockLocationResponse, error)

	// PostSalesChannelsSalesChannelStockLocationWithBodyWithResponse request with any body
	PostSalesChannelsSalesChannelStockLocationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelStockLocationResponse, error)

	PostSalesChannelsSalesChannelStockLocationWithResponse(ctx context.Context, id string, body PostSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelStockLocationResponse, error)

	// GetShippingOptionsWithResponse request
	GetShippingOptionsWithResponse(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*GetShippingOptionsResponse, error)

	// PostShippingOptionsWithBodyWithResponse request with any body
	PostShippingOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error)

	PostShippingOptionsWithResponse(ctx context.Context, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error)

	// DeleteShippingOptionsOptionWithResponse request
	DeleteShippingOptionsOptionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingOptionsOptionResponse, error)

	// GetShippingOptionsOptionWithResponse request
	GetShippingOptionsOptionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetShippingOptionsOptionResponse, error)

	// PostShippingOptionsOptionWithBodyWithResponse request with any body
	PostShippingOptionsOptionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsOptionResponse, error)

	PostShippingOptionsOptionWithResponse(ctx context.Context, id string, body PostShippingOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsOptionResponse, error)

	// GetShippingProfilesWithResponse request
	GetShippingProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetShippingProfilesResponse, error)

	// PostShippingProfilesWithBodyWithResponse request with any body
	PostShippingProfilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error)

	PostShippingProfilesWithResponse(ctx context.Context, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error)

	// DeleteShippingProfilesProfileWithResponse request
	DeleteShippingProfilesProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingProfilesProfileResponse, error)

	// GetShippingProfilesProfileWithResponse request
	GetShippingProfilesProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetShippingProfilesProfileResponse, error)

	// PostShippingProfilesProfileWithBodyWithResponse request with any body
	PostShippingProfilesProfileWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesProfileResponse, error)

	PostShippingProfilesProfileWithResponse(ctx context.Context, id string, body PostShippingProfilesProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesProfileResponse, error)

	// GetStockLocationsWithResponse request
	GetStockLocationsWithResponse(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*GetStockLocationsResponse, error)

	// PostStockLocationsWithBodyWithResponse request with any body
	PostStockLocationsWithBodyWithResponse(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error)

	PostStockLocationsWithResponse(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error)

	// DeleteStockLocationsStockLocationWithResponse request
	DeleteStockLocationsStockLocationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteStockLocationsStockLocationResponse, error)

	// GetStockLocationsStockLocationWithResponse request
	GetStockLocationsStockLocationWithResponse(ctx context.Context, id string, params *GetStockLocationsStockLocationParams, reqEditors ...RequestEditorFn) (*GetStockLocationsStockLocationResponse, error)

	// PostStockLocationsStockLocationWithBodyWithResponse request with any body
	PostStockLocationsStockLocationWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsStockLocationResponse, error)

	PostStockLocationsStockLocationWithResponse(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, body PostStockLocationsStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsStockLocationResponse, error)

	// GetStoreWithResponse request
	GetStoreWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoreResponse, error)

	// PostStoreWithBodyWithResponse request with any body
	PostStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStoreResponse, error)

	PostStoreWithResponse(ctx context.Context, body PostStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStoreResponse, error)

	// DeleteStoreCurrenciesCodeWithResponse request
	DeleteStoreCurrenciesCodeWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*DeleteStoreCurrenciesCodeResponse, error)

	// PostStoreCurrenciesCodeWithResponse request
	PostStoreCurrenciesCodeWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*PostStoreCurrenciesCodeResponse, error)

	// GetStorePaymentProvidersWithResponse request
	GetStorePaymentProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorePaymentProvidersResponse, error)

	// GetStoreTaxProvidersWithResponse request
	GetStoreTaxProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoreTaxProvidersResponse, error)

	// GetSwapsWithResponse request
	GetSwapsWithResponse(ctx context.Context, params *GetSwapsParams, reqEditors ...RequestEditorFn) (*GetSwapsResponse, error)

	// GetSwapsSwapWithResponse request
	GetSwapsSwapWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSwapsSwapResponse, error)

	// GetTaxRatesWithResponse request
	GetTaxRatesWithResponse(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*GetTaxRatesResponse, error)

	// PostTaxRatesWithBodyWithResponse request with any body
	PostTaxRatesWithBodyWithResponse(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error)

	PostTaxRatesWithResponse(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error)

	// DeleteTaxRatesTaxRateWithResponse request
	DeleteTaxRatesTaxRateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateResponse, error)

	// GetTaxRatesTaxRateWithResponse request
	GetTaxRatesTaxRateWithResponse(ctx context.Context, id string, params *GetTaxRatesTaxRateParams, reqEditors ...RequestEditorFn) (*GetTaxRatesTaxRateResponse, error)

	// PostTaxRatesTaxRateWithBodyWithResponse request with any body
	PostTaxRatesTaxRateWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateResponse, error)

	PostTaxRatesTaxRateWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, body PostTaxRatesTaxRateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateResponse, error)

	// DeleteTaxRatesTaxRateProductTypesWithBodyWithResponse request with any body
	DeleteTaxRatesTaxRateProductTypesWithBodyWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductTypesResponse, error)

	DeleteTaxRatesTaxRateProductTypesWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, body DeleteTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductTypesResponse, error)

	// PostTaxRatesTaxRateProductTypesWithBodyWithResponse request with any body
	PostTaxRatesTaxRateProductTypesWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductTypesResponse, error)

	PostTaxRatesTaxRateProductTypesWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, body PostTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductTypesResponse, error)

	// DeleteTaxRatesTaxRateProductsWithBodyWithResponse request with any body
	DeleteTaxRatesTaxRateProductsWithBodyWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductsResponse, error)

	DeleteTaxRatesTaxRateProductsWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, body DeleteTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductsResponse, error)

	// PostTaxRatesTaxRateProductsWithBodyWithResponse request with any body
	PostTaxRatesTaxRateProductsWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductsResponse, error)

	PostTaxRatesTaxRateProductsWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, body PostTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductsResponse, error)

	// DeleteTaxRatesTaxRateShippingOptionsWithBodyWithResponse request with any body
	DeleteTaxRatesTaxRateShippingOptionsWithBodyWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateShippingOptionsResponse, error)

	DeleteTaxRatesTaxRateShippingOptionsWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, body DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateShippingOptionsResponse, error)

	// PostTaxRatesTaxRateShippingOptionsWithBodyWithResponse request with any body
	PostTaxRatesTaxRateShippingOptionsWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateShippingOptionsResponse, error)

	PostTaxRatesTaxRateShippingOptionsWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, body PostTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateShippingOptionsResponse, error)

	// DeleteUploadsWithBodyWithResponse request with any body
	DeleteUploadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUploadsResponse, error)

	DeleteUploadsWithResponse(ctx context.Context, body DeleteUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUploadsResponse, error)

	// PostUploadsWithBodyWithResponse request with any body
	PostUploadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsResponse, error)

	// PostUploadsDownloadUrlWithBodyWithResponse request with any body
	PostUploadsDownloadUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsDownloadUrlResponse, error)

	PostUploadsDownloadUrlWithResponse(ctx context.Context, body PostUploadsDownloadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUploadsDownloadUrlResponse, error)

	// PostUploadsProtectedWithBodyWithResponse request with any body
	PostUploadsProtectedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsProtectedResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// PostUsersWithBodyWithResponse request with any body
	PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersResponse, error)

	PostUsersWithResponse(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersResponse, error)

	// PostUsersUserPasswordTokenWithBodyWithResponse request with any body
	PostUsersUserPasswordTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordTokenResponse, error)

	PostUsersUserPasswordTokenWithResponse(ctx context.Context, body PostUsersUserPasswordTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordTokenResponse, error)

	// PostUsersUserPasswordWithBodyWithResponse request with any body
	PostUsersUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordResponse, error)

	PostUsersUserPasswordWithResponse(ctx context.Context, body PostUsersUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordResponse, error)

	// DeleteUsersUserWithResponse request
	DeleteUsersUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUsersUserResponse, error)

	// GetUsersUserWithResponse request
	GetUsersUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUsersUserResponse, error)

	// PostUsersUserWithBodyWithResponse request with any body
	PostUsersUserWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersUserResponse, error)

	PostUsersUserWithResponse(ctx context.Context, id string, body PostUsersUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersUserResponse, error)

	// GetVariantsWithResponse request
	GetVariantsWithResponse(ctx context.Context, params *GetVariantsParams, reqEditors ...RequestEditorFn) (*GetVariantsResponse, error)

	// GetVariantsVariantWithResponse request
	GetVariantsVariantWithResponse(ctx context.Context, id string, params *GetVariantsVariantParams, reqEditors ...RequestEditorFn) (*GetVariantsVariantResponse, error)

	// GetVariantsVariantInventoryWithResponse request
	GetVariantsVariantInventoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVariantsVariantInventoryResponse, error)
}

type GetAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminAppsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminAppsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminAuthRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminAuthRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBearerAuthRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBatchJobListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetBatchJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBatchJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AdminBatchJobRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostBatchJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBatchJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchJobsBatchJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBatchJobRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetBatchJobsBatchJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchJobsBatchJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBatchJobsBatchJobCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBatchJobRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostBatchJobsBatchJobCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBatchJobsBatchJobCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBatchJobsBatchJobConfirmProcessingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminBatchJobRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostBatchJobsBatchJobConfirmProcessingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBatchJobsBatchJobConfirmProcessingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionsCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionsCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionsCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionsCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCollectionsCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionsCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCollectionsCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCollectionsCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCollectionsCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsFromCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDeleteProductsFromCollectionRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsFromCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsFromCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsToCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsToCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsToCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCurrenciesListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCurrenciesCurrencyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCurrenciesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCurrenciesCurrencyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCurrenciesCurrencyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomerGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerGroupsCustomerGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerGroupsCustomerGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerGroupsCustomerGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerGroupsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomerGroupsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerGroupsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerGroupsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomerGroupsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerGroupsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerGroupsGroupCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomersListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomerGroupsGroupCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerGroupsGroupCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomerGroupsGroupCustomerBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerGroupsGroupCustomerBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerGroupsGroupCustomerBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomerGroupsGroupCustomersBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomerGroupsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomerGroupsGroupCustomersBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomerGroupsGroupCustomersBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomersListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AdminCustomersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetCustomersCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCustomersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostCustomersCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDiscountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscountsDiscountCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDiscountsDiscountCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscountsDiscountCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsDiscountConditionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsDiscountConditionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsDiscountConditionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDiscountsDiscountConditionsConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountConditionsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDiscountsDiscountConditionsConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDiscountsDiscountConditionsConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscountsDiscountConditionsConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountConditionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDiscountsDiscountConditionsConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscountsDiscountConditionsConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsDiscountConditionsConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsDiscountConditionsConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsDiscountConditionsConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDiscountsDiscountConditionsConditionBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDiscountsDiscountConditionsConditionBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDiscountsDiscountConditionsConditionBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsDiscountConditionsConditionBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsDiscountConditionsConditionBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsDiscountConditionsConditionBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDiscountsDiscountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDiscountsDiscountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDiscountsDiscountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiscountsDiscountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDiscountsDiscountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiscountsDiscountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsDiscountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsDiscountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsDiscountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsDiscountDynamicCodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsDiscountDynamicCodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsDiscountDynamicCodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDiscountsDiscountDynamicCodesCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDiscountsDiscountDynamicCodesCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDiscountsDiscountDynamicCodesCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDiscountsDiscountRegionsRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDiscountsDiscountRegionsRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDiscountsDiscountRegionsRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDiscountsDiscountRegionsRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDiscountsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDiscountsDiscountRegionsRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDiscountsDiscountRegionsRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDraftOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDraftOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDraftOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDraftOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDraftOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDraftOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDraftOrdersDraftOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDraftOrdersDraftOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDraftOrdersDraftOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDraftOrdersDraftOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetDraftOrdersDraftOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDraftOrdersDraftOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDraftOrdersDraftOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDraftOrdersDraftOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDraftOrdersDraftOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDraftOrdersDraftOrderLineItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDraftOrdersDraftOrderLineItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDraftOrdersDraftOrderLineItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDraftOrdersDraftOrderLineItemsItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteDraftOrdersDraftOrderLineItemsItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDraftOrdersDraftOrderLineItemsItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDraftOrdersDraftOrderLineItemsItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDraftOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDraftOrdersDraftOrderLineItemsItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDraftOrdersDraftOrderLineItemsItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDraftOrdersDraftOrderRegisterPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPostDraftOrdersDraftOrderRegisterPaymentRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostDraftOrdersDraftOrderRegisterPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDraftOrdersDraftOrderRegisterPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGiftCardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGiftCardsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetGiftCardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGiftCardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGiftCardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGiftCardsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostGiftCardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGiftCardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGiftCardsGiftCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGiftCardsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteGiftCardsGiftCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGiftCardsGiftCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGiftCardsGiftCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGiftCardsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetGiftCardsGiftCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGiftCardsGiftCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGiftCardsGiftCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGiftCardsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostGiftCardsGiftCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGiftCardsGiftCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsListWithVariantsAndLocationLevelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryItemsInventoryItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsDeleteRes
	JSON400      *N400Error
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryItemsInventoryItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryItemsInventoryItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemsInventoryItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemsInventoryItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemsInventoryItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsInventoryItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsInventoryItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsInventoryItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInventoryItemsInventoryItemLocationLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsLocationLevelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInventoryItemsInventoryItemLocationLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInventoryItemsInventoryItemLocationLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsInventoryItemLocationLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsInventoryItemLocationLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsInventoryItemLocationLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInventoryItemsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminListInvitesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvitesInviteAcceptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInvitesInviteAcceptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvitesInviteAcceptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInvitesInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminInviteDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteInvitesInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvitesInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvitesInviteResendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostInvitesInviteResendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvitesInviteResendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotesListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotesNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotesDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteNotesNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotesNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotesNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetNotesNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotesNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNotesNoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostNotesNoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNotesNoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotificationsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetNotificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNotificationsNotificationResendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminNotificationsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostNotificationsNotificationResendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNotificationsNotificationResendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderEditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrderEditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderEditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderEditsOrderEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditDeleteRes
	JSON400      *N400Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrderEditsOrderEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderEditsOrderEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderEditsOrderEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrderEditsOrderEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderEditsOrderEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsOrderEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsOrderEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsOrderEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsOrderEditCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsOrderEditCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsOrderEditCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderEditsOrderEditItemChangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditItemChangeDeleteRes
	JSON400      *N400Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrderEditsOrderEditItemChangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderEditsOrderEditItemChangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsOrderEditConfirmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsOrderEditConfirmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsOrderEditConfirmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsEditLineItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsEditLineItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsEditLineItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrderEditsOrderEditLineItemsLineItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteOrderEditsOrderEditLineItemsLineItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrderEditsOrderEditLineItemsLineItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsEditLineItemsLineItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsEditLineItemsLineItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsEditLineItemsLineItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrderEditsOrderEditRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrderEditsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrderEditsOrderEditRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrderEditsOrderEditRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderArchiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderArchiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderArchiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderClaimsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderClaimsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderClaimsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderClaimsClaimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderClaimsClaimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderClaimsClaimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersClaimCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersClaimCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersClaimCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderClaimsClaimFulfillmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderClaimsClaimFulfillmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderClaimsClaimFulfillmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersClaimFulfillmentsCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersClaimFulfillmentsCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersClaimFulfillmentsCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderClaimsClaimShipmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderClaimsClaimShipmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderClaimsClaimShipmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderCompleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderCompleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderCompleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderFulfillmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderFulfillmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderFulfillmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderFulfillmentsCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderFulfillmentsCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderFulfillmentsCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderLineItemReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPostReservationsReq
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderLineItemReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderLineItemReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderRefundsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderRefundsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderRefundsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersOrderReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetOrdersOrderReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersOrderReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderReturnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderReturnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderReturnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderShipmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderShipmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderShipmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderShippingMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderShippingMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderShippingMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderSwapsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderSwapsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderSwapsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersSwapCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersSwapCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersSwapCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderSwapsSwapFulfillmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderSwapsSwapFulfillmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderSwapsSwapFulfillmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersSwapFulfillmentsCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersSwapFulfillmentsCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersSwapFulfillmentsCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderSwapsSwapProcessPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderSwapsSwapProcessPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderSwapsSwapProcessPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOrdersOrderSwapsSwapShipmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminOrdersRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostOrdersOrderSwapsSwapShipmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOrdersOrderSwapsSwapShipmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePaymentCollectionsPaymentCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentCollectionDeleteRes
	JSON400      *N400Error
}

// Status returns HTTPResponse.Status
func (r DeletePaymentCollectionsPaymentCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePaymentCollectionsPaymentCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentCollectionsPaymentCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPaymentCollectionsPaymentCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentCollectionsPaymentCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentCollectionsPaymentCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentCollectionsPaymentCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentCollectionsPaymentCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentCollectionsPaymentCollectionAuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentCollectionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentCollectionsPaymentCollectionAuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentCollectionsPaymentCollectionAuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentsPaymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPaymentsPaymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentsPaymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentsPaymentCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentsPaymentCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentsPaymentCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPaymentsPaymentRefundsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRefundRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPaymentsPaymentRefundsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPaymentsPaymentRefundsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPriceListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPriceListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPriceListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsPriceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsPriceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsPriceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePriceListsPriceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePriceListsPriceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePriceListsPriceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPriceListsPriceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPriceListsPriceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPriceListsPriceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsPriceListPriceListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsPriceListPriceListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsPriceListPriceListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePriceListsPriceListPricesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListDeleteBatchRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePriceListsPriceListPricesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePriceListsPriceListPricesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPriceListsPriceListPricesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPriceListsPriceListPricesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPriceListsPriceListPricesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPriceListsPriceListProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListsProductsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPriceListsPriceListProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPriceListsPriceListProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePriceListsPriceListProductsPricesBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListDeleteProductPricesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePriceListsPriceListProductsPricesBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePriceListsPriceListProductsPricesBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePriceListsPriceListProductsProductPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListDeleteProductPricesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePriceListsPriceListProductsProductPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePriceListsPriceListProductsProductPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePriceListsPriceListVariantsVariantPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPriceListDeleteVariantPricesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePriceListsPriceListVariantsVariantPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePriceListsPriceListVariantsVariantPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesCategoryRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductCategoriesCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesCategoryDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductCategoriesCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductCategoriesCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductCategoriesCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesCategoryRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductCategoriesCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductCategoriesCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductCategoriesCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesCategoryRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductCategoriesCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductCategoriesCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductCategoriesCategoryProductsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesCategoryRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductCategoriesCategoryProductsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductCategoriesCategoryProductsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductCategoriesCategoryProductsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductCategoriesCategoryRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductCategoriesCategoryProductsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductCategoriesCategoryProductsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTagsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductTypesListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsTagUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsListTagsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsTagUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsTagUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsListTypesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsProductOptionsOptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsDeleteOptionRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsProductOptionsOptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsProductOptionsOptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductOptionsOptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductOptionsOptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductOptionsOptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductsProductVariantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsListVariantsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetProductsProductVariantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductsProductVariantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductVariantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductVariantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductVariantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductsProductVariantsVariantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsDeleteVariantRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductsProductVariantsVariantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductsProductVariantsVariantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProductsProductVariantsVariantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminProductsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostProductsProductVariantsVariantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProductsProductVariantsVariantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublishableApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPublishableApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublishableApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPublishableApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPublishableApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPublishableApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublishableApiKeysPublishableApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeyDeleteRes
	JSON400      *N400Error
}

// Status returns HTTPResponse.Status
func (r DeletePublishableApiKeysPublishableApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublishableApiKeysPublishableApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublishableApiKeysPublishableApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPublishableApiKeysPublishableApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublishableApiKeysPublishableApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPublishableApiKysPublishableApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPublishableApiKysPublishableApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPublishableApiKysPublishableApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPublishableApiKeysPublishableApiKeyRevokeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPublishableApiKeysPublishableApiKeyRevokeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPublishableApiKeysPublishableApiKeyRevokeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublishableApiKeySalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysListSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetPublishableApiKeySalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublishableApiKeySalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePublishableApiKeySalesChannelsChannelsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeletePublishableApiKeySalesChannelsChannelsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePublishableApiKeySalesChannelsChannelsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPublishableApiKeySalesChannelsChannelsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPublishableApiKeysRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostPublishableApiKeySalesChannelsChannelsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPublishableApiKeySalesChannelsChannelsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRegionsRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteRegionsRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRegionsRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionsRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRegionsRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionsRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionCountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionCountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionCountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionCountriesCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionCountriesCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionCountriesCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionsRegionFulfillmentOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGetRegionsRegionFulfillmentOptionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetRegionsRegionFulfillmentOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionsRegionFulfillmentOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionFulfillmentProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionFulfillmentProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionFulfillmentProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionFulfillmentProvidersProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionFulfillmentProvidersProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionFulfillmentProvidersProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionPaymentProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionPaymentProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionPaymentProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegionsRegionPaymentProvidersProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminRegionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostRegionsRegionPaymentProvidersProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegionsRegionPaymentProvidersProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservationsReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservationsReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservationsReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservationsReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReservationsReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservationsReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservationsReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReservationsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReservationsReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservationsReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnReasonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnReasonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnReasonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReturnReasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteReturnReasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReturnReasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnReasonsReasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnReasonsReasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnReasonsReasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnReasonsReasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnReasonsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnReasonsReasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnReasonsReasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReturnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetReturnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReturnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsReturnCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnsCancelRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsReturnCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsReturnCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReturnsReturnReceiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminReturnsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostReturnsReturnReceiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReturnsReturnReceiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetSalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSalesChannelsSalesChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteSalesChannelsSalesChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSalesChannelsSalesChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSalesChannelsSalesChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetSalesChannelsSalesChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSalesChannelsSalesChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsSalesChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsSalesChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsSalesChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSalesChannelsChannelProductsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteSalesChannelsChannelProductsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSalesChannelsChannelProductsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsChannelProductsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsChannelProductsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsChannelProductsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSalesChannelsSalesChannelStockLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsDeleteLocationRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteSalesChannelsSalesChannelStockLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSalesChannelsSalesChannelStockLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSalesChannelsSalesChannelStockLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSalesChannelsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostSalesChannelsSalesChannelStockLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSalesChannelsSalesChannelStockLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShippingOptionsOptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionsDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteShippingOptionsOptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShippingOptionsOptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingOptionsOptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingOptionsOptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingOptionsOptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingOptionsOptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingOptionsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingOptionsOptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingOptionsOptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfilesListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfilesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteShippingProfilesProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDeleteShippingProfileRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteShippingProfilesProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShippingProfilesProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShippingProfilesProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfilesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetShippingProfilesProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShippingProfilesProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostShippingProfilesProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminShippingProfilesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostShippingProfilesProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostShippingProfilesProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStockLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStockLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStockLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStockLocationsStockLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationsDeleteRes
	JSON400      *N400Error
}

// Status returns HTTPResponse.Status
func (r DeleteStockLocationsStockLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStockLocationsStockLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStockLocationsStockLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationsRes
}

// Status returns HTTPResponse.Status
func (r GetStockLocationsStockLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStockLocationsStockLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStockLocationsStockLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStockLocationsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStockLocationsStockLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStockLocationsStockLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminExtendedStoresRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStoresRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoreCurrenciesCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStoresRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteStoreCurrenciesCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoreCurrenciesCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStoreCurrenciesCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminStoresRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostStoreCurrenciesCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStoreCurrenciesCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorePaymentProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminPaymentProvidersList
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStorePaymentProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorePaymentProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoreTaxProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxProvidersList
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetStoreTaxProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoreTaxProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSwapsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetSwapsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapsSwapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSwapsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetSwapsSwapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapsSwapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetTaxRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRatesTaxRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesDeleteRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRatesTaxRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRatesTaxRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaxRatesTaxRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetTaxRatesTaxRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaxRatesTaxRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesTaxRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesTaxRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesTaxRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRatesTaxRateProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRatesTaxRateProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRatesTaxRateProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesTaxRateProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesTaxRateProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesTaxRateProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRatesTaxRateProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRatesTaxRateProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRatesTaxRateProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesTaxRateProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesTaxRateProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesTaxRateProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTaxRatesTaxRateShippingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteTaxRatesTaxRateShippingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaxRatesTaxRateShippingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTaxRatesTaxRateShippingOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminTaxRatesRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostTaxRatesTaxRateShippingOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTaxRatesTaxRateShippingOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUploadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDeleteUploadsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteUploadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUploadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUploadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUploadsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUploadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUploadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUploadsDownloadUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUploadsDownloadUrlRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUploadsDownloadUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUploadsDownloadUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUploadsProtectedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUploadsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUploadsProtectedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUploadsProtectedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUsersListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersUserPasswordTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUsersUserPasswordTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersUserPasswordTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUsersUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUsersUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminDeleteUserRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r DeleteUsersUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsersUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetUsersUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUsersUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminUserRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r PostUsersUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUsersUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminVariantsListRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetVariantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariantsVariantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminVariantsRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetVariantsVariantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariantsVariantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariantsVariantInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGetVariantsVariantInventoryRes
	JSON400      *N400Error
	JSON404      *NotFoundError
	JSON409      *InvalidStateError
	JSON422      *InvalidRequestError
	JSON500      *N500Error
}

// Status returns HTTPResponse.Status
func (r GetVariantsVariantInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariantsVariantInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAppsWithResponse request returning *GetAppsResponse
func (c *ClientWithResponses) GetAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAppsResponse, error) {
	rsp, err := c.GetApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppsResponse(rsp)
}

// PostAppsWithBodyWithResponse request with arbitrary body returning *PostAppsResponse
func (c *ClientWithResponses) PostAppsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAppsResponse, error) {
	rsp, err := c.PostAppsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppsResponse(rsp)
}

func (c *ClientWithResponses) PostAppsWithResponse(ctx context.Context, body PostAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAppsResponse, error) {
	rsp, err := c.PostApps(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAppsResponse(rsp)
}

// DeleteAuthWithResponse request returning *DeleteAuthResponse
func (c *ClientWithResponses) DeleteAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAuthResponse, error) {
	rsp, err := c.DeleteAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthResponse(rsp)
}

// GetAuthWithResponse request returning *GetAuthResponse
func (c *ClientWithResponses) GetAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthResponse, error) {
	rsp, err := c.GetAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthResponse(rsp)
}

// PostAuthWithBodyWithResponse request with arbitrary body returning *PostAuthResponse
func (c *ClientWithResponses) PostAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

func (c *ClientWithResponses) PostAuthWithResponse(ctx context.Context, body PostAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthResponse, error) {
	rsp, err := c.PostAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthResponse(rsp)
}

// PostTokenWithBodyWithResponse request with arbitrary body returning *PostTokenResponse
func (c *ClientWithResponses) PostTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTokenResponse, error) {
	rsp, err := c.PostTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTokenResponse(rsp)
}

func (c *ClientWithResponses) PostTokenWithResponse(ctx context.Context, body PostTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTokenResponse, error) {
	rsp, err := c.PostToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTokenResponse(rsp)
}

// GetBatchJobsWithResponse request returning *GetBatchJobsResponse
func (c *ClientWithResponses) GetBatchJobsWithResponse(ctx context.Context, params *GetBatchJobsParams, reqEditors ...RequestEditorFn) (*GetBatchJobsResponse, error) {
	rsp, err := c.GetBatchJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchJobsResponse(rsp)
}

// PostBatchJobsWithBodyWithResponse request with arbitrary body returning *PostBatchJobsResponse
func (c *ClientWithResponses) PostBatchJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBatchJobsResponse, error) {
	rsp, err := c.PostBatchJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBatchJobsResponse(rsp)
}

func (c *ClientWithResponses) PostBatchJobsWithResponse(ctx context.Context, body PostBatchJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBatchJobsResponse, error) {
	rsp, err := c.PostBatchJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBatchJobsResponse(rsp)
}

// GetBatchJobsBatchJobWithResponse request returning *GetBatchJobsBatchJobResponse
func (c *ClientWithResponses) GetBatchJobsBatchJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetBatchJobsBatchJobResponse, error) {
	rsp, err := c.GetBatchJobsBatchJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchJobsBatchJobResponse(rsp)
}

// PostBatchJobsBatchJobCancelWithResponse request returning *PostBatchJobsBatchJobCancelResponse
func (c *ClientWithResponses) PostBatchJobsBatchJobCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostBatchJobsBatchJobCancelResponse, error) {
	rsp, err := c.PostBatchJobsBatchJobCancel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBatchJobsBatchJobCancelResponse(rsp)
}

// PostBatchJobsBatchJobConfirmProcessingWithResponse request returning *PostBatchJobsBatchJobConfirmProcessingResponse
func (c *ClientWithResponses) PostBatchJobsBatchJobConfirmProcessingWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostBatchJobsBatchJobConfirmProcessingResponse, error) {
	rsp, err := c.PostBatchJobsBatchJobConfirmProcessing(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBatchJobsBatchJobConfirmProcessingResponse(rsp)
}

// GetCollectionsWithResponse request returning *GetCollectionsResponse
func (c *ClientWithResponses) GetCollectionsWithResponse(ctx context.Context, params *GetCollectionsParams, reqEditors ...RequestEditorFn) (*GetCollectionsResponse, error) {
	rsp, err := c.GetCollections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsResponse(rsp)
}

// PostCollectionsWithBodyWithResponse request with arbitrary body returning *PostCollectionsResponse
func (c *ClientWithResponses) PostCollectionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error) {
	rsp, err := c.PostCollectionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsResponse(rsp)
}

func (c *ClientWithResponses) PostCollectionsWithResponse(ctx context.Context, body PostCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsResponse, error) {
	rsp, err := c.PostCollections(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsResponse(rsp)
}

// DeleteCollectionsCollectionWithResponse request returning *DeleteCollectionsCollectionResponse
func (c *ClientWithResponses) DeleteCollectionsCollectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCollectionsCollectionResponse, error) {
	rsp, err := c.DeleteCollectionsCollection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionsCollectionResponse(rsp)
}

// GetCollectionsCollectionWithResponse request returning *GetCollectionsCollectionResponse
func (c *ClientWithResponses) GetCollectionsCollectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCollectionsCollectionResponse, error) {
	rsp, err := c.GetCollectionsCollection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionsCollectionResponse(rsp)
}

// PostCollectionsCollectionWithBodyWithResponse request with arbitrary body returning *PostCollectionsCollectionResponse
func (c *ClientWithResponses) PostCollectionsCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCollectionsCollectionResponse, error) {
	rsp, err := c.PostCollectionsCollectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsCollectionResponse(rsp)
}

func (c *ClientWithResponses) PostCollectionsCollectionWithResponse(ctx context.Context, id string, body PostCollectionsCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCollectionsCollectionResponse, error) {
	rsp, err := c.PostCollectionsCollection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCollectionsCollectionResponse(rsp)
}

// DeleteProductsFromCollectionWithBodyWithResponse request with arbitrary body returning *DeleteProductsFromCollectionResponse
func (c *ClientWithResponses) DeleteProductsFromCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProductsFromCollectionResponse, error) {
	rsp, err := c.DeleteProductsFromCollectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsFromCollectionResponse(rsp)
}

func (c *ClientWithResponses) DeleteProductsFromCollectionWithResponse(ctx context.Context, id string, body DeleteProductsFromCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProductsFromCollectionResponse, error) {
	rsp, err := c.DeleteProductsFromCollection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsFromCollectionResponse(rsp)
}

// PostProductsToCollectionWithBodyWithResponse request with arbitrary body returning *PostProductsToCollectionResponse
func (c *ClientWithResponses) PostProductsToCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsToCollectionResponse, error) {
	rsp, err := c.PostProductsToCollectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsToCollectionResponse(rsp)
}

func (c *ClientWithResponses) PostProductsToCollectionWithResponse(ctx context.Context, id string, body PostProductsToCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsToCollectionResponse, error) {
	rsp, err := c.PostProductsToCollection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsToCollectionResponse(rsp)
}

// GetCurrenciesWithResponse request returning *GetCurrenciesResponse
func (c *ClientWithResponses) GetCurrenciesWithResponse(ctx context.Context, params *GetCurrenciesParams, reqEditors ...RequestEditorFn) (*GetCurrenciesResponse, error) {
	rsp, err := c.GetCurrencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrenciesResponse(rsp)
}

// PostCurrenciesCurrencyWithBodyWithResponse request with arbitrary body returning *PostCurrenciesCurrencyResponse
func (c *ClientWithResponses) PostCurrenciesCurrencyWithBodyWithResponse(ctx context.Context, code string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCurrenciesCurrencyResponse, error) {
	rsp, err := c.PostCurrenciesCurrencyWithBody(ctx, code, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCurrenciesCurrencyResponse(rsp)
}

func (c *ClientWithResponses) PostCurrenciesCurrencyWithResponse(ctx context.Context, code string, body PostCurrenciesCurrencyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCurrenciesCurrencyResponse, error) {
	rsp, err := c.PostCurrenciesCurrency(ctx, code, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCurrenciesCurrencyResponse(rsp)
}

// GetCustomerGroupsWithResponse request returning *GetCustomerGroupsResponse
func (c *ClientWithResponses) GetCustomerGroupsWithResponse(ctx context.Context, params *GetCustomerGroupsParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsResponse, error) {
	rsp, err := c.GetCustomerGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerGroupsResponse(rsp)
}

// PostCustomerGroupsWithBodyWithResponse request with arbitrary body returning *PostCustomerGroupsResponse
func (c *ClientWithResponses) PostCustomerGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error) {
	rsp, err := c.PostCustomerGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerGroupsWithResponse(ctx context.Context, body PostCustomerGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsResponse, error) {
	rsp, err := c.PostCustomerGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsResponse(rsp)
}

// DeleteCustomerGroupsCustomerGroupWithResponse request returning *DeleteCustomerGroupsCustomerGroupResponse
func (c *ClientWithResponses) DeleteCustomerGroupsCustomerGroupWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsCustomerGroupResponse, error) {
	rsp, err := c.DeleteCustomerGroupsCustomerGroup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerGroupsCustomerGroupResponse(rsp)
}

// GetCustomerGroupsGroupWithResponse request returning *GetCustomerGroupsGroupResponse
func (c *ClientWithResponses) GetCustomerGroupsGroupWithResponse(ctx context.Context, id string, params *GetCustomerGroupsGroupParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsGroupResponse, error) {
	rsp, err := c.GetCustomerGroupsGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerGroupsGroupResponse(rsp)
}

// PostCustomerGroupsGroupWithBodyWithResponse request with arbitrary body returning *PostCustomerGroupsGroupResponse
func (c *ClientWithResponses) PostCustomerGroupsGroupWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupResponse, error) {
	rsp, err := c.PostCustomerGroupsGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsGroupResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerGroupsGroupWithResponse(ctx context.Context, id string, body PostCustomerGroupsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupResponse, error) {
	rsp, err := c.PostCustomerGroupsGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsGroupResponse(rsp)
}

// GetCustomerGroupsGroupCustomersWithResponse request returning *GetCustomerGroupsGroupCustomersResponse
func (c *ClientWithResponses) GetCustomerGroupsGroupCustomersWithResponse(ctx context.Context, id string, params *GetCustomerGroupsGroupCustomersParams, reqEditors ...RequestEditorFn) (*GetCustomerGroupsGroupCustomersResponse, error) {
	rsp, err := c.GetCustomerGroupsGroupCustomers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerGroupsGroupCustomersResponse(rsp)
}

// DeleteCustomerGroupsGroupCustomerBatchWithBodyWithResponse request with arbitrary body returning *DeleteCustomerGroupsGroupCustomerBatchResponse
func (c *ClientWithResponses) DeleteCustomerGroupsGroupCustomerBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsGroupCustomerBatchResponse, error) {
	rsp, err := c.DeleteCustomerGroupsGroupCustomerBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerGroupsGroupCustomerBatchResponse(rsp)
}

func (c *ClientWithResponses) DeleteCustomerGroupsGroupCustomerBatchWithResponse(ctx context.Context, id string, body DeleteCustomerGroupsGroupCustomerBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCustomerGroupsGroupCustomerBatchResponse, error) {
	rsp, err := c.DeleteCustomerGroupsGroupCustomerBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomerGroupsGroupCustomerBatchResponse(rsp)
}

// PostCustomerGroupsGroupCustomersBatchWithBodyWithResponse request with arbitrary body returning *PostCustomerGroupsGroupCustomersBatchResponse
func (c *ClientWithResponses) PostCustomerGroupsGroupCustomersBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupCustomersBatchResponse, error) {
	rsp, err := c.PostCustomerGroupsGroupCustomersBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsGroupCustomersBatchResponse(rsp)
}

func (c *ClientWithResponses) PostCustomerGroupsGroupCustomersBatchWithResponse(ctx context.Context, id string, body PostCustomerGroupsGroupCustomersBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomerGroupsGroupCustomersBatchResponse, error) {
	rsp, err := c.PostCustomerGroupsGroupCustomersBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomerGroupsGroupCustomersBatchResponse(rsp)
}

// GetCustomersWithResponse request returning *GetCustomersResponse
func (c *ClientWithResponses) GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams, reqEditors ...RequestEditorFn) (*GetCustomersResponse, error) {
	rsp, err := c.GetCustomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersResponse(rsp)
}

// PostCustomersWithBodyWithResponse request with arbitrary body returning *PostCustomersResponse
func (c *ClientWithResponses) PostCustomersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error) {
	rsp, err := c.PostCustomersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersWithResponse(ctx context.Context, body PostCustomersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersResponse, error) {
	rsp, err := c.PostCustomers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersResponse(rsp)
}

// GetCustomersCustomerWithResponse request returning *GetCustomersCustomerResponse
func (c *ClientWithResponses) GetCustomersCustomerWithResponse(ctx context.Context, id string, params *GetCustomersCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomersCustomerResponse, error) {
	rsp, err := c.GetCustomersCustomer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersCustomerResponse(rsp)
}

// PostCustomersCustomerWithBodyWithResponse request with arbitrary body returning *PostCustomersCustomerResponse
func (c *ClientWithResponses) PostCustomersCustomerWithBodyWithResponse(ctx context.Context, id string, params *PostCustomersCustomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCustomersCustomerResponse, error) {
	rsp, err := c.PostCustomersCustomerWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersCustomerResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersCustomerWithResponse(ctx context.Context, id string, params *PostCustomersCustomerParams, body PostCustomersCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCustomersCustomerResponse, error) {
	rsp, err := c.PostCustomersCustomer(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersCustomerResponse(rsp)
}

// GetDiscountsWithResponse request returning *GetDiscountsResponse
func (c *ClientWithResponses) GetDiscountsWithResponse(ctx context.Context, params *GetDiscountsParams, reqEditors ...RequestEditorFn) (*GetDiscountsResponse, error) {
	rsp, err := c.GetDiscounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscountsResponse(rsp)
}

// PostDiscountsWithBodyWithResponse request with arbitrary body returning *PostDiscountsResponse
func (c *ClientWithResponses) PostDiscountsWithBodyWithResponse(ctx context.Context, params *PostDiscountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsResponse, error) {
	rsp, err := c.PostDiscountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsResponse(rsp)
}

func (c *ClientWithResponses) PostDiscountsWithResponse(ctx context.Context, params *PostDiscountsParams, body PostDiscountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsResponse, error) {
	rsp, err := c.PostDiscounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsResponse(rsp)
}

// GetDiscountsDiscountCodeWithResponse request returning *GetDiscountsDiscountCodeResponse
func (c *ClientWithResponses) GetDiscountsDiscountCodeWithResponse(ctx context.Context, code string, params *GetDiscountsDiscountCodeParams, reqEditors ...RequestEditorFn) (*GetDiscountsDiscountCodeResponse, error) {
	rsp, err := c.GetDiscountsDiscountCode(ctx, code, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscountsDiscountCodeResponse(rsp)
}

// PostDiscountsDiscountConditionsWithBodyWithResponse request with arbitrary body returning *PostDiscountsDiscountConditionsResponse
func (c *ClientWithResponses) PostDiscountsDiscountConditionsWithBodyWithResponse(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsResponse, error) {
	rsp, err := c.PostDiscountsDiscountConditionsWithBody(ctx, discountId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountConditionsResponse(rsp)
}

func (c *ClientWithResponses) PostDiscountsDiscountConditionsWithResponse(ctx context.Context, discountId string, params *PostDiscountsDiscountConditionsParams, body PostDiscountsDiscountConditionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsResponse, error) {
	rsp, err := c.PostDiscountsDiscountConditions(ctx, discountId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountConditionsResponse(rsp)
}

// DeleteDiscountsDiscountConditionsConditionWithResponse request returning *DeleteDiscountsDiscountConditionsConditionResponse
func (c *ClientWithResponses) DeleteDiscountsDiscountConditionsConditionWithResponse(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountConditionsConditionResponse, error) {
	rsp, err := c.DeleteDiscountsDiscountConditionsCondition(ctx, discountId, conditionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiscountsDiscountConditionsConditionResponse(rsp)
}

// GetDiscountsDiscountConditionsConditionWithResponse request returning *GetDiscountsDiscountConditionsConditionResponse
func (c *ClientWithResponses) GetDiscountsDiscountConditionsConditionWithResponse(ctx context.Context, discountId string, conditionId string, params *GetDiscountsDiscountConditionsConditionParams, reqEditors ...RequestEditorFn) (*GetDiscountsDiscountConditionsConditionResponse, error) {
	rsp, err := c.GetDiscountsDiscountConditionsCondition(ctx, discountId, conditionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscountsDiscountConditionsConditionResponse(rsp)
}

// PostDiscountsDiscountConditionsConditionWithBodyWithResponse request with arbitrary body returning *PostDiscountsDiscountConditionsConditionResponse
func (c *ClientWithResponses) PostDiscountsDiscountConditionsConditionWithBodyWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionResponse, error) {
	rsp, err := c.PostDiscountsDiscountConditionsConditionWithBody(ctx, discountId, conditionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountConditionsConditionResponse(rsp)
}

func (c *ClientWithResponses) PostDiscountsDiscountConditionsConditionWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionParams, body PostDiscountsDiscountConditionsConditionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionResponse, error) {
	rsp, err := c.PostDiscountsDiscountConditionsCondition(ctx, discountId, conditionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountConditionsConditionResponse(rsp)
}

// DeleteDiscountsDiscountConditionsConditionBatchWithBodyWithResponse request with arbitrary body returning *DeleteDiscountsDiscountConditionsConditionBatchResponse
func (c *ClientWithResponses) DeleteDiscountsDiscountConditionsConditionBatchWithBodyWithResponse(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountConditionsConditionBatchResponse, error) {
	rsp, err := c.DeleteDiscountsDiscountConditionsConditionBatchWithBody(ctx, discountId, conditionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiscountsDiscountConditionsConditionBatchResponse(rsp)
}

func (c *ClientWithResponses) DeleteDiscountsDiscountConditionsConditionBatchWithResponse(ctx context.Context, discountId string, conditionId string, params *DeleteDiscountsDiscountConditionsConditionBatchParams, body DeleteDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountConditionsConditionBatchResponse, error) {
	rsp, err := c.DeleteDiscountsDiscountConditionsConditionBatch(ctx, discountId, conditionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiscountsDiscountConditionsConditionBatchResponse(rsp)
}

// PostDiscountsDiscountConditionsConditionBatchWithBodyWithResponse request with arbitrary body returning *PostDiscountsDiscountConditionsConditionBatchResponse
func (c *ClientWithResponses) PostDiscountsDiscountConditionsConditionBatchWithBodyWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionBatchResponse, error) {
	rsp, err := c.PostDiscountsDiscountConditionsConditionBatchWithBody(ctx, discountId, conditionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountConditionsConditionBatchResponse(rsp)
}

func (c *ClientWithResponses) PostDiscountsDiscountConditionsConditionBatchWithResponse(ctx context.Context, discountId string, conditionId string, params *PostDiscountsDiscountConditionsConditionBatchParams, body PostDiscountsDiscountConditionsConditionBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountConditionsConditionBatchResponse, error) {
	rsp, err := c.PostDiscountsDiscountConditionsConditionBatch(ctx, discountId, conditionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountConditionsConditionBatchResponse(rsp)
}

// DeleteDiscountsDiscountWithResponse request returning *DeleteDiscountsDiscountResponse
func (c *ClientWithResponses) DeleteDiscountsDiscountWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountResponse, error) {
	rsp, err := c.DeleteDiscountsDiscount(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiscountsDiscountResponse(rsp)
}

// GetDiscountsDiscountWithResponse request returning *GetDiscountsDiscountResponse
func (c *ClientWithResponses) GetDiscountsDiscountWithResponse(ctx context.Context, id string, params *GetDiscountsDiscountParams, reqEditors ...RequestEditorFn) (*GetDiscountsDiscountResponse, error) {
	rsp, err := c.GetDiscountsDiscount(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiscountsDiscountResponse(rsp)
}

// PostDiscountsDiscountWithBodyWithResponse request with arbitrary body returning *PostDiscountsDiscountResponse
func (c *ClientWithResponses) PostDiscountsDiscountWithBodyWithResponse(ctx context.Context, id string, params *PostDiscountsDiscountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountResponse, error) {
	rsp, err := c.PostDiscountsDiscountWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountResponse(rsp)
}

func (c *ClientWithResponses) PostDiscountsDiscountWithResponse(ctx context.Context, id string, params *PostDiscountsDiscountParams, body PostDiscountsDiscountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountResponse, error) {
	rsp, err := c.PostDiscountsDiscount(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountResponse(rsp)
}

// PostDiscountsDiscountDynamicCodesWithBodyWithResponse request with arbitrary body returning *PostDiscountsDiscountDynamicCodesResponse
func (c *ClientWithResponses) PostDiscountsDiscountDynamicCodesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountDynamicCodesResponse, error) {
	rsp, err := c.PostDiscountsDiscountDynamicCodesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountDynamicCodesResponse(rsp)
}

func (c *ClientWithResponses) PostDiscountsDiscountDynamicCodesWithResponse(ctx context.Context, id string, body PostDiscountsDiscountDynamicCodesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountDynamicCodesResponse, error) {
	rsp, err := c.PostDiscountsDiscountDynamicCodes(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountDynamicCodesResponse(rsp)
}

// DeleteDiscountsDiscountDynamicCodesCodeWithResponse request returning *DeleteDiscountsDiscountDynamicCodesCodeResponse
func (c *ClientWithResponses) DeleteDiscountsDiscountDynamicCodesCodeWithResponse(ctx context.Context, id string, code string, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountDynamicCodesCodeResponse, error) {
	rsp, err := c.DeleteDiscountsDiscountDynamicCodesCode(ctx, id, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiscountsDiscountDynamicCodesCodeResponse(rsp)
}

// DeleteDiscountsDiscountRegionsRegionWithResponse request returning *DeleteDiscountsDiscountRegionsRegionResponse
func (c *ClientWithResponses) DeleteDiscountsDiscountRegionsRegionWithResponse(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*DeleteDiscountsDiscountRegionsRegionResponse, error) {
	rsp, err := c.DeleteDiscountsDiscountRegionsRegion(ctx, id, regionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiscountsDiscountRegionsRegionResponse(rsp)
}

// PostDiscountsDiscountRegionsRegionWithResponse request returning *PostDiscountsDiscountRegionsRegionResponse
func (c *ClientWithResponses) PostDiscountsDiscountRegionsRegionWithResponse(ctx context.Context, id string, regionId string, reqEditors ...RequestEditorFn) (*PostDiscountsDiscountRegionsRegionResponse, error) {
	rsp, err := c.PostDiscountsDiscountRegionsRegion(ctx, id, regionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDiscountsDiscountRegionsRegionResponse(rsp)
}

// GetDraftOrdersWithResponse request returning *GetDraftOrdersResponse
func (c *ClientWithResponses) GetDraftOrdersWithResponse(ctx context.Context, params *GetDraftOrdersParams, reqEditors ...RequestEditorFn) (*GetDraftOrdersResponse, error) {
	rsp, err := c.GetDraftOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDraftOrdersResponse(rsp)
}

// PostDraftOrdersWithBodyWithResponse request with arbitrary body returning *PostDraftOrdersResponse
func (c *ClientWithResponses) PostDraftOrdersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error) {
	rsp, err := c.PostDraftOrdersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersResponse(rsp)
}

func (c *ClientWithResponses) PostDraftOrdersWithResponse(ctx context.Context, body PostDraftOrdersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersResponse, error) {
	rsp, err := c.PostDraftOrders(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersResponse(rsp)
}

// DeleteDraftOrdersDraftOrderWithResponse request returning *DeleteDraftOrdersDraftOrderResponse
func (c *ClientWithResponses) DeleteDraftOrdersDraftOrderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDraftOrdersDraftOrderResponse, error) {
	rsp, err := c.DeleteDraftOrdersDraftOrder(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDraftOrdersDraftOrderResponse(rsp)
}

// GetDraftOrdersDraftOrderWithResponse request returning *GetDraftOrdersDraftOrderResponse
func (c *ClientWithResponses) GetDraftOrdersDraftOrderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDraftOrdersDraftOrderResponse, error) {
	rsp, err := c.GetDraftOrdersDraftOrder(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDraftOrdersDraftOrderResponse(rsp)
}

// PostDraftOrdersDraftOrderWithBodyWithResponse request with arbitrary body returning *PostDraftOrdersDraftOrderResponse
func (c *ClientWithResponses) PostDraftOrdersDraftOrderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderResponse(rsp)
}

func (c *ClientWithResponses) PostDraftOrdersDraftOrderWithResponse(ctx context.Context, id string, body PostDraftOrdersDraftOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrder(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderResponse(rsp)
}

// PostDraftOrdersDraftOrderLineItemsWithBodyWithResponse request with arbitrary body returning *PostDraftOrdersDraftOrderLineItemsResponse
func (c *ClientWithResponses) PostDraftOrdersDraftOrderLineItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrderLineItemsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderLineItemsResponse(rsp)
}

func (c *ClientWithResponses) PostDraftOrdersDraftOrderLineItemsWithResponse(ctx context.Context, id string, body PostDraftOrdersDraftOrderLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrderLineItems(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderLineItemsResponse(rsp)
}

// DeleteDraftOrdersDraftOrderLineItemsItemWithResponse request returning *DeleteDraftOrdersDraftOrderLineItemsItemResponse
func (c *ClientWithResponses) DeleteDraftOrdersDraftOrderLineItemsItemWithResponse(ctx context.Context, id string, lineId string, reqEditors ...RequestEditorFn) (*DeleteDraftOrdersDraftOrderLineItemsItemResponse, error) {
	rsp, err := c.DeleteDraftOrdersDraftOrderLineItemsItem(ctx, id, lineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDraftOrdersDraftOrderLineItemsItemResponse(rsp)
}

// PostDraftOrdersDraftOrderLineItemsItemWithBodyWithResponse request with arbitrary body returning *PostDraftOrdersDraftOrderLineItemsItemResponse
func (c *ClientWithResponses) PostDraftOrdersDraftOrderLineItemsItemWithBodyWithResponse(ctx context.Context, id string, lineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsItemResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrderLineItemsItemWithBody(ctx, id, lineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderLineItemsItemResponse(rsp)
}

func (c *ClientWithResponses) PostDraftOrdersDraftOrderLineItemsItemWithResponse(ctx context.Context, id string, lineId string, body PostDraftOrdersDraftOrderLineItemsItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderLineItemsItemResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrderLineItemsItem(ctx, id, lineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderLineItemsItemResponse(rsp)
}

// PostDraftOrdersDraftOrderRegisterPaymentWithResponse request returning *PostDraftOrdersDraftOrderRegisterPaymentResponse
func (c *ClientWithResponses) PostDraftOrdersDraftOrderRegisterPaymentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostDraftOrdersDraftOrderRegisterPaymentResponse, error) {
	rsp, err := c.PostDraftOrdersDraftOrderRegisterPayment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDraftOrdersDraftOrderRegisterPaymentResponse(rsp)
}

// GetGiftCardsWithResponse request returning *GetGiftCardsResponse
func (c *ClientWithResponses) GetGiftCardsWithResponse(ctx context.Context, params *GetGiftCardsParams, reqEditors ...RequestEditorFn) (*GetGiftCardsResponse, error) {
	rsp, err := c.GetGiftCards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGiftCardsResponse(rsp)
}

// PostGiftCardsWithBodyWithResponse request with arbitrary body returning *PostGiftCardsResponse
func (c *ClientWithResponses) PostGiftCardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGiftCardsResponse, error) {
	rsp, err := c.PostGiftCardsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGiftCardsResponse(rsp)
}

func (c *ClientWithResponses) PostGiftCardsWithResponse(ctx context.Context, body PostGiftCardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGiftCardsResponse, error) {
	rsp, err := c.PostGiftCards(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGiftCardsResponse(rsp)
}

// DeleteGiftCardsGiftCardWithResponse request returning *DeleteGiftCardsGiftCardResponse
func (c *ClientWithResponses) DeleteGiftCardsGiftCardWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteGiftCardsGiftCardResponse, error) {
	rsp, err := c.DeleteGiftCardsGiftCard(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGiftCardsGiftCardResponse(rsp)
}

// GetGiftCardsGiftCardWithResponse request returning *GetGiftCardsGiftCardResponse
func (c *ClientWithResponses) GetGiftCardsGiftCardWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGiftCardsGiftCardResponse, error) {
	rsp, err := c.GetGiftCardsGiftCard(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGiftCardsGiftCardResponse(rsp)
}

// PostGiftCardsGiftCardWithBodyWithResponse request with arbitrary body returning *PostGiftCardsGiftCardResponse
func (c *ClientWithResponses) PostGiftCardsGiftCardWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGiftCardsGiftCardResponse, error) {
	rsp, err := c.PostGiftCardsGiftCardWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGiftCardsGiftCardResponse(rsp)
}

func (c *ClientWithResponses) PostGiftCardsGiftCardWithResponse(ctx context.Context, id string, body PostGiftCardsGiftCardJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGiftCardsGiftCardResponse, error) {
	rsp, err := c.PostGiftCardsGiftCard(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGiftCardsGiftCardResponse(rsp)
}

// GetInventoryItemsWithResponse request returning *GetInventoryItemsResponse
func (c *ClientWithResponses) GetInventoryItemsWithResponse(ctx context.Context, params *GetInventoryItemsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsResponse, error) {
	rsp, err := c.GetInventoryItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemsResponse(rsp)
}

// PostInventoryItemsWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsResponse
func (c *ClientWithResponses) PostInventoryItemsWithBodyWithResponse(ctx context.Context, params *PostInventoryItemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error) {
	rsp, err := c.PostInventoryItemsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsWithResponse(ctx context.Context, params *PostInventoryItemsParams, body PostInventoryItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsResponse, error) {
	rsp, err := c.PostInventoryItems(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsResponse(rsp)
}

// DeleteInventoryItemsInventoryItemWithResponse request returning *DeleteInventoryItemsInventoryItemResponse
func (c *ClientWithResponses) DeleteInventoryItemsInventoryItemWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsInventoryItemResponse, error) {
	rsp, err := c.DeleteInventoryItemsInventoryItem(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryItemsInventoryItemResponse(rsp)
}

// GetInventoryItemsInventoryItemWithResponse request returning *GetInventoryItemsInventoryItemResponse
func (c *ClientWithResponses) GetInventoryItemsInventoryItemWithResponse(ctx context.Context, id string, params *GetInventoryItemsInventoryItemParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsInventoryItemResponse, error) {
	rsp, err := c.GetInventoryItemsInventoryItem(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemsInventoryItemResponse(rsp)
}

// PostInventoryItemsInventoryItemWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsInventoryItemResponse
func (c *ClientWithResponses) PostInventoryItemsInventoryItemWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemResponse, error) {
	rsp, err := c.PostInventoryItemsInventoryItemWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsInventoryItemResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsInventoryItemWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemParams, body PostInventoryItemsInventoryItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemResponse, error) {
	rsp, err := c.PostInventoryItemsInventoryItem(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsInventoryItemResponse(rsp)
}

// GetInventoryItemsInventoryItemLocationLevelsWithResponse request returning *GetInventoryItemsInventoryItemLocationLevelsResponse
func (c *ClientWithResponses) GetInventoryItemsInventoryItemLocationLevelsWithResponse(ctx context.Context, id string, params *GetInventoryItemsInventoryItemLocationLevelsParams, reqEditors ...RequestEditorFn) (*GetInventoryItemsInventoryItemLocationLevelsResponse, error) {
	rsp, err := c.GetInventoryItemsInventoryItemLocationLevels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInventoryItemsInventoryItemLocationLevelsResponse(rsp)
}

// PostInventoryItemsInventoryItemLocationLevelsWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsInventoryItemLocationLevelsResponse
func (c *ClientWithResponses) PostInventoryItemsInventoryItemLocationLevelsWithBodyWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsResponse, error) {
	rsp, err := c.PostInventoryItemsInventoryItemLocationLevelsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsInventoryItemLocationLevelsResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsInventoryItemLocationLevelsWithResponse(ctx context.Context, id string, params *PostInventoryItemsInventoryItemLocationLevelsParams, body PostInventoryItemsInventoryItemLocationLevelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsResponse, error) {
	rsp, err := c.PostInventoryItemsInventoryItemLocationLevels(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsInventoryItemLocationLevelsResponse(rsp)
}

// DeleteInventoryItemsInventoryIteLocationLevelsLocationWithResponse request returning *DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse
func (c *ClientWithResponses) DeleteInventoryItemsInventoryIteLocationLevelsLocationWithResponse(ctx context.Context, id string, locationId string, reqEditors ...RequestEditorFn) (*DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse, error) {
	rsp, err := c.DeleteInventoryItemsInventoryIteLocationLevelsLocation(ctx, id, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInventoryItemsInventoryIteLocationLevelsLocationResponse(rsp)
}

// PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBodyWithResponse request with arbitrary body returning *PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse
func (c *ClientWithResponses) PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBodyWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse, error) {
	rsp, err := c.PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithBody(ctx, id, locationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse(rsp)
}

func (c *ClientWithResponses) PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithResponse(ctx context.Context, id string, locationId string, params *PostInventoryItemsInventoryItemLocationLevelsLocationLevelParams, body PostInventoryItemsInventoryItemLocationLevelsLocationLevelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse, error) {
	rsp, err := c.PostInventoryItemsInventoryItemLocationLevelsLocationLevel(ctx, id, locationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse(rsp)
}

// GetInvitesWithResponse request returning *GetInvitesResponse
func (c *ClientWithResponses) GetInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInvitesResponse, error) {
	rsp, err := c.GetInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvitesResponse(rsp)
}

// PostInvitesWithBodyWithResponse request with arbitrary body returning *PostInvitesResponse
func (c *ClientWithResponses) PostInvitesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error) {
	rsp, err := c.PostInvitesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesResponse(rsp)
}

func (c *ClientWithResponses) PostInvitesWithResponse(ctx context.Context, body PostInvitesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesResponse, error) {
	rsp, err := c.PostInvites(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesResponse(rsp)
}

// PostInvitesInviteAcceptWithBodyWithResponse request with arbitrary body returning *PostInvitesInviteAcceptResponse
func (c *ClientWithResponses) PostInvitesInviteAcceptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInvitesInviteAcceptResponse, error) {
	rsp, err := c.PostInvitesInviteAcceptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesInviteAcceptResponse(rsp)
}

func (c *ClientWithResponses) PostInvitesInviteAcceptWithResponse(ctx context.Context, body PostInvitesInviteAcceptJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInvitesInviteAcceptResponse, error) {
	rsp, err := c.PostInvitesInviteAccept(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesInviteAcceptResponse(rsp)
}

// DeleteInvitesInviteWithResponse request returning *DeleteInvitesInviteResponse
func (c *ClientWithResponses) DeleteInvitesInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*DeleteInvitesInviteResponse, error) {
	rsp, err := c.DeleteInvitesInvite(ctx, inviteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInvitesInviteResponse(rsp)
}

// PostInvitesInviteResendWithResponse request returning *PostInvitesInviteResendResponse
func (c *ClientWithResponses) PostInvitesInviteResendWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*PostInvitesInviteResendResponse, error) {
	rsp, err := c.PostInvitesInviteResend(ctx, inviteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInvitesInviteResendResponse(rsp)
}

// GetNotesWithResponse request returning *GetNotesResponse
func (c *ClientWithResponses) GetNotesWithResponse(ctx context.Context, params *GetNotesParams, reqEditors ...RequestEditorFn) (*GetNotesResponse, error) {
	rsp, err := c.GetNotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotesResponse(rsp)
}

// PostNotesWithBodyWithResponse request with arbitrary body returning *PostNotesResponse
func (c *ClientWithResponses) PostNotesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotesResponse, error) {
	rsp, err := c.PostNotesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotesResponse(rsp)
}

func (c *ClientWithResponses) PostNotesWithResponse(ctx context.Context, body PostNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotesResponse, error) {
	rsp, err := c.PostNotes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotesResponse(rsp)
}

// DeleteNotesNoteWithResponse request returning *DeleteNotesNoteResponse
func (c *ClientWithResponses) DeleteNotesNoteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteNotesNoteResponse, error) {
	rsp, err := c.DeleteNotesNote(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotesNoteResponse(rsp)
}

// GetNotesNoteWithResponse request returning *GetNotesNoteResponse
func (c *ClientWithResponses) GetNotesNoteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetNotesNoteResponse, error) {
	rsp, err := c.GetNotesNote(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotesNoteResponse(rsp)
}

// PostNotesNoteWithBodyWithResponse request with arbitrary body returning *PostNotesNoteResponse
func (c *ClientWithResponses) PostNotesNoteWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotesNoteResponse, error) {
	rsp, err := c.PostNotesNoteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotesNoteResponse(rsp)
}

func (c *ClientWithResponses) PostNotesNoteWithResponse(ctx context.Context, id string, body PostNotesNoteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotesNoteResponse, error) {
	rsp, err := c.PostNotesNote(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotesNoteResponse(rsp)
}

// GetNotificationsWithResponse request returning *GetNotificationsResponse
func (c *ClientWithResponses) GetNotificationsWithResponse(ctx context.Context, params *GetNotificationsParams, reqEditors ...RequestEditorFn) (*GetNotificationsResponse, error) {
	rsp, err := c.GetNotifications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationsResponse(rsp)
}

// PostNotificationsNotificationResendWithBodyWithResponse request with arbitrary body returning *PostNotificationsNotificationResendResponse
func (c *ClientWithResponses) PostNotificationsNotificationResendWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNotificationsNotificationResendResponse, error) {
	rsp, err := c.PostNotificationsNotificationResendWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotificationsNotificationResendResponse(rsp)
}

func (c *ClientWithResponses) PostNotificationsNotificationResendWithResponse(ctx context.Context, id string, body PostNotificationsNotificationResendJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNotificationsNotificationResendResponse, error) {
	rsp, err := c.PostNotificationsNotificationResend(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNotificationsNotificationResendResponse(rsp)
}

// GetOrderEditsWithResponse request returning *GetOrderEditsResponse
func (c *ClientWithResponses) GetOrderEditsWithResponse(ctx context.Context, params *GetOrderEditsParams, reqEditors ...RequestEditorFn) (*GetOrderEditsResponse, error) {
	rsp, err := c.GetOrderEdits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderEditsResponse(rsp)
}

// PostOrderEditsWithBodyWithResponse request with arbitrary body returning *PostOrderEditsResponse
func (c *ClientWithResponses) PostOrderEditsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error) {
	rsp, err := c.PostOrderEditsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsWithResponse(ctx context.Context, body PostOrderEditsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsResponse, error) {
	rsp, err := c.PostOrderEdits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsResponse(rsp)
}

// DeleteOrderEditsOrderEditWithResponse request returning *DeleteOrderEditsOrderEditResponse
func (c *ClientWithResponses) DeleteOrderEditsOrderEditWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsOrderEditResponse, error) {
	rsp, err := c.DeleteOrderEditsOrderEdit(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderEditsOrderEditResponse(rsp)
}

// GetOrderEditsOrderEditWithResponse request returning *GetOrderEditsOrderEditResponse
func (c *ClientWithResponses) GetOrderEditsOrderEditWithResponse(ctx context.Context, id string, params *GetOrderEditsOrderEditParams, reqEditors ...RequestEditorFn) (*GetOrderEditsOrderEditResponse, error) {
	rsp, err := c.GetOrderEditsOrderEdit(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderEditsOrderEditResponse(rsp)
}

// PostOrderEditsOrderEditWithBodyWithResponse request with arbitrary body returning *PostOrderEditsOrderEditResponse
func (c *ClientWithResponses) PostOrderEditsOrderEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditResponse, error) {
	rsp, err := c.PostOrderEditsOrderEditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsOrderEditResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsOrderEditWithResponse(ctx context.Context, id string, body PostOrderEditsOrderEditJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditResponse, error) {
	rsp, err := c.PostOrderEditsOrderEdit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsOrderEditResponse(rsp)
}

// PostOrderEditsOrderEditCancelWithResponse request returning *PostOrderEditsOrderEditCancelResponse
func (c *ClientWithResponses) PostOrderEditsOrderEditCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditCancelResponse, error) {
	rsp, err := c.PostOrderEditsOrderEditCancel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsOrderEditCancelResponse(rsp)
}

// DeleteOrderEditsOrderEditItemChangeWithResponse request returning *DeleteOrderEditsOrderEditItemChangeResponse
func (c *ClientWithResponses) DeleteOrderEditsOrderEditItemChangeWithResponse(ctx context.Context, id string, changeId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsOrderEditItemChangeResponse, error) {
	rsp, err := c.DeleteOrderEditsOrderEditItemChange(ctx, id, changeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderEditsOrderEditItemChangeResponse(rsp)
}

// PostOrderEditsOrderEditConfirmWithResponse request returning *PostOrderEditsOrderEditConfirmResponse
func (c *ClientWithResponses) PostOrderEditsOrderEditConfirmWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditConfirmResponse, error) {
	rsp, err := c.PostOrderEditsOrderEditConfirm(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsOrderEditConfirmResponse(rsp)
}

// PostOrderEditsEditLineItemsWithBodyWithResponse request with arbitrary body returning *PostOrderEditsEditLineItemsResponse
func (c *ClientWithResponses) PostOrderEditsEditLineItemsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsResponse, error) {
	rsp, err := c.PostOrderEditsEditLineItemsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsEditLineItemsResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsEditLineItemsWithResponse(ctx context.Context, id string, body PostOrderEditsEditLineItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsResponse, error) {
	rsp, err := c.PostOrderEditsEditLineItems(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsEditLineItemsResponse(rsp)
}

// DeleteOrderEditsOrderEditLineItemsLineItemWithResponse request returning *DeleteOrderEditsOrderEditLineItemsLineItemResponse
func (c *ClientWithResponses) DeleteOrderEditsOrderEditLineItemsLineItemWithResponse(ctx context.Context, id string, itemId string, reqEditors ...RequestEditorFn) (*DeleteOrderEditsOrderEditLineItemsLineItemResponse, error) {
	rsp, err := c.DeleteOrderEditsOrderEditLineItemsLineItem(ctx, id, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrderEditsOrderEditLineItemsLineItemResponse(rsp)
}

// PostOrderEditsEditLineItemsLineItemWithBodyWithResponse request with arbitrary body returning *PostOrderEditsEditLineItemsLineItemResponse
func (c *ClientWithResponses) PostOrderEditsEditLineItemsLineItemWithBodyWithResponse(ctx context.Context, id string, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsLineItemResponse, error) {
	rsp, err := c.PostOrderEditsEditLineItemsLineItemWithBody(ctx, id, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsEditLineItemsLineItemResponse(rsp)
}

func (c *ClientWithResponses) PostOrderEditsEditLineItemsLineItemWithResponse(ctx context.Context, id string, itemId string, body PostOrderEditsEditLineItemsLineItemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrderEditsEditLineItemsLineItemResponse, error) {
	rsp, err := c.PostOrderEditsEditLineItemsLineItem(ctx, id, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsEditLineItemsLineItemResponse(rsp)
}

// PostOrderEditsOrderEditRequestWithResponse request returning *PostOrderEditsOrderEditRequestResponse
func (c *ClientWithResponses) PostOrderEditsOrderEditRequestWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostOrderEditsOrderEditRequestResponse, error) {
	rsp, err := c.PostOrderEditsOrderEditRequest(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrderEditsOrderEditRequestResponse(rsp)
}

// GetOrdersWithResponse request returning *GetOrdersResponse
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error) {
	rsp, err := c.GetOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResponse(rsp)
}

// GetOrdersOrderWithResponse request returning *GetOrdersOrderResponse
func (c *ClientWithResponses) GetOrdersOrderWithResponse(ctx context.Context, id string, params *GetOrdersOrderParams, reqEditors ...RequestEditorFn) (*GetOrdersOrderResponse, error) {
	rsp, err := c.GetOrdersOrder(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersOrderResponse(rsp)
}

// PostOrdersOrderWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderResponse
func (c *ClientWithResponses) PostOrdersOrderWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderResponse, error) {
	rsp, err := c.PostOrdersOrderWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderWithResponse(ctx context.Context, id string, params *PostOrdersOrderParams, body PostOrdersOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderResponse, error) {
	rsp, err := c.PostOrdersOrder(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderResponse(rsp)
}

// PostOrdersOrderArchiveWithResponse request returning *PostOrdersOrderArchiveResponse
func (c *ClientWithResponses) PostOrdersOrderArchiveWithResponse(ctx context.Context, id string, params *PostOrdersOrderArchiveParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderArchiveResponse, error) {
	rsp, err := c.PostOrdersOrderArchive(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderArchiveResponse(rsp)
}

// PostOrdersOrderCancelWithResponse request returning *PostOrdersOrderCancelResponse
func (c *ClientWithResponses) PostOrdersOrderCancelWithResponse(ctx context.Context, id string, params *PostOrdersOrderCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderCancelResponse, error) {
	rsp, err := c.PostOrdersOrderCancel(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderCancelResponse(rsp)
}

// PostOrdersOrderCaptureWithResponse request returning *PostOrdersOrderCaptureResponse
func (c *ClientWithResponses) PostOrdersOrderCaptureWithResponse(ctx context.Context, id string, params *PostOrdersOrderCaptureParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderCaptureResponse, error) {
	rsp, err := c.PostOrdersOrderCapture(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderCaptureResponse(rsp)
}

// PostOrdersOrderClaimsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderClaimsResponse
func (c *ClientWithResponses) PostOrdersOrderClaimsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderClaimsWithResponse(ctx context.Context, id string, params *PostOrdersOrderClaimsParams, body PostOrdersOrderClaimsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsResponse, error) {
	rsp, err := c.PostOrdersOrderClaims(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsResponse(rsp)
}

// PostOrdersOrderClaimsClaimWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderClaimsClaimResponse
func (c *ClientWithResponses) PostOrdersOrderClaimsClaimWithBodyWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsClaimWithBody(ctx, id, claimId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsClaimResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderClaimsClaimWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimParams, body PostOrdersOrderClaimsClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsClaim(ctx, id, claimId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsClaimResponse(rsp)
}

// PostOrdersClaimCancelWithResponse request returning *PostOrdersClaimCancelResponse
func (c *ClientWithResponses) PostOrdersClaimCancelWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersClaimCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersClaimCancelResponse, error) {
	rsp, err := c.PostOrdersClaimCancel(ctx, id, claimId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersClaimCancelResponse(rsp)
}

// PostOrdersOrderClaimsClaimFulfillmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderClaimsClaimFulfillmentsResponse
func (c *ClientWithResponses) PostOrdersOrderClaimsClaimFulfillmentsWithBodyWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsClaimFulfillmentsWithBody(ctx, id, claimId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsClaimFulfillmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderClaimsClaimFulfillmentsWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimFulfillmentsParams, body PostOrdersOrderClaimsClaimFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsClaimFulfillments(ctx, id, claimId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsClaimFulfillmentsResponse(rsp)
}

// PostOrdersClaimFulfillmentsCancelWithResponse request returning *PostOrdersClaimFulfillmentsCancelResponse
func (c *ClientWithResponses) PostOrdersClaimFulfillmentsCancelWithResponse(ctx context.Context, id string, claimId string, fulfillmentId string, params *PostOrdersClaimFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersClaimFulfillmentsCancelResponse, error) {
	rsp, err := c.PostOrdersClaimFulfillmentsCancel(ctx, id, claimId, fulfillmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersClaimFulfillmentsCancelResponse(rsp)
}

// PostOrdersOrderClaimsClaimShipmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderClaimsClaimShipmentsResponse
func (c *ClientWithResponses) PostOrdersOrderClaimsClaimShipmentsWithBodyWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimShipmentsResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsClaimShipmentsWithBody(ctx, id, claimId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsClaimShipmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderClaimsClaimShipmentsWithResponse(ctx context.Context, id string, claimId string, params *PostOrdersOrderClaimsClaimShipmentsParams, body PostOrdersOrderClaimsClaimShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderClaimsClaimShipmentsResponse, error) {
	rsp, err := c.PostOrdersOrderClaimsClaimShipments(ctx, id, claimId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderClaimsClaimShipmentsResponse(rsp)
}

// PostOrdersOrderCompleteWithResponse request returning *PostOrdersOrderCompleteResponse
func (c *ClientWithResponses) PostOrdersOrderCompleteWithResponse(ctx context.Context, id string, params *PostOrdersOrderCompleteParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderCompleteResponse, error) {
	rsp, err := c.PostOrdersOrderComplete(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderCompleteResponse(rsp)
}

// PostOrdersOrderFulfillmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderFulfillmentsResponse
func (c *ClientWithResponses) PostOrdersOrderFulfillmentsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersOrderFulfillmentsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderFulfillmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderFulfillmentsWithResponse(ctx context.Context, id string, params *PostOrdersOrderFulfillmentsParams, body PostOrdersOrderFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersOrderFulfillments(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderFulfillmentsResponse(rsp)
}

// PostOrdersOrderFulfillmentsCancelWithResponse request returning *PostOrdersOrderFulfillmentsCancelResponse
func (c *ClientWithResponses) PostOrdersOrderFulfillmentsCancelWithResponse(ctx context.Context, id string, fulfillmentId string, params *PostOrdersOrderFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderFulfillmentsCancelResponse, error) {
	rsp, err := c.PostOrdersOrderFulfillmentsCancel(ctx, id, fulfillmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderFulfillmentsCancelResponse(rsp)
}

// PostOrdersOrderLineItemReservationsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderLineItemReservationsResponse
func (c *ClientWithResponses) PostOrdersOrderLineItemReservationsWithBodyWithResponse(ctx context.Context, id string, lineItemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderLineItemReservationsResponse, error) {
	rsp, err := c.PostOrdersOrderLineItemReservationsWithBody(ctx, id, lineItemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderLineItemReservationsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderLineItemReservationsWithResponse(ctx context.Context, id string, lineItemId string, body PostOrdersOrderLineItemReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderLineItemReservationsResponse, error) {
	rsp, err := c.PostOrdersOrderLineItemReservations(ctx, id, lineItemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderLineItemReservationsResponse(rsp)
}

// PostOrdersOrderRefundsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderRefundsResponse
func (c *ClientWithResponses) PostOrdersOrderRefundsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderRefundsResponse, error) {
	rsp, err := c.PostOrdersOrderRefundsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderRefundsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderRefundsWithResponse(ctx context.Context, id string, params *PostOrdersOrderRefundsParams, body PostOrdersOrderRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderRefundsResponse, error) {
	rsp, err := c.PostOrdersOrderRefunds(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderRefundsResponse(rsp)
}

// GetOrdersOrderReservationsWithResponse request returning *GetOrdersOrderReservationsResponse
func (c *ClientWithResponses) GetOrdersOrderReservationsWithResponse(ctx context.Context, id string, params *GetOrdersOrderReservationsParams, reqEditors ...RequestEditorFn) (*GetOrdersOrderReservationsResponse, error) {
	rsp, err := c.GetOrdersOrderReservations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersOrderReservationsResponse(rsp)
}

// PostOrdersOrderReturnsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderReturnsResponse
func (c *ClientWithResponses) PostOrdersOrderReturnsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderReturnsResponse, error) {
	rsp, err := c.PostOrdersOrderReturnsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderReturnsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderReturnsWithResponse(ctx context.Context, id string, params *PostOrdersOrderReturnsParams, body PostOrdersOrderReturnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderReturnsResponse, error) {
	rsp, err := c.PostOrdersOrderReturns(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderReturnsResponse(rsp)
}

// PostOrdersOrderShipmentWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderShipmentResponse
func (c *ClientWithResponses) PostOrdersOrderShipmentWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderShipmentResponse, error) {
	rsp, err := c.PostOrdersOrderShipmentWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderShipmentResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderShipmentWithResponse(ctx context.Context, id string, params *PostOrdersOrderShipmentParams, body PostOrdersOrderShipmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderShipmentResponse, error) {
	rsp, err := c.PostOrdersOrderShipment(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderShipmentResponse(rsp)
}

// PostOrdersOrderShippingMethodsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderShippingMethodsResponse
func (c *ClientWithResponses) PostOrdersOrderShippingMethodsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderShippingMethodsResponse, error) {
	rsp, err := c.PostOrdersOrderShippingMethodsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderShippingMethodsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderShippingMethodsWithResponse(ctx context.Context, id string, params *PostOrdersOrderShippingMethodsParams, body PostOrdersOrderShippingMethodsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderShippingMethodsResponse, error) {
	rsp, err := c.PostOrdersOrderShippingMethods(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderShippingMethodsResponse(rsp)
}

// PostOrdersOrderSwapsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderSwapsResponse
func (c *ClientWithResponses) PostOrdersOrderSwapsWithBodyWithResponse(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsResponse, error) {
	rsp, err := c.PostOrdersOrderSwapsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderSwapsWithResponse(ctx context.Context, id string, params *PostOrdersOrderSwapsParams, body PostOrdersOrderSwapsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsResponse, error) {
	rsp, err := c.PostOrdersOrderSwaps(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsResponse(rsp)
}

// PostOrdersSwapCancelWithResponse request returning *PostOrdersSwapCancelResponse
func (c *ClientWithResponses) PostOrdersSwapCancelWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersSwapCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersSwapCancelResponse, error) {
	rsp, err := c.PostOrdersSwapCancel(ctx, id, swapId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersSwapCancelResponse(rsp)
}

// PostOrdersOrderSwapsSwapFulfillmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderSwapsSwapFulfillmentsResponse
func (c *ClientWithResponses) PostOrdersOrderSwapsSwapFulfillmentsWithBodyWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersOrderSwapsSwapFulfillmentsWithBody(ctx, id, swapId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsSwapFulfillmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderSwapsSwapFulfillmentsWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapFulfillmentsParams, body PostOrdersOrderSwapsSwapFulfillmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapFulfillmentsResponse, error) {
	rsp, err := c.PostOrdersOrderSwapsSwapFulfillments(ctx, id, swapId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsSwapFulfillmentsResponse(rsp)
}

// PostOrdersSwapFulfillmentsCancelWithResponse request returning *PostOrdersSwapFulfillmentsCancelResponse
func (c *ClientWithResponses) PostOrdersSwapFulfillmentsCancelWithResponse(ctx context.Context, id string, swapId string, fulfillmentId string, params *PostOrdersSwapFulfillmentsCancelParams, reqEditors ...RequestEditorFn) (*PostOrdersSwapFulfillmentsCancelResponse, error) {
	rsp, err := c.PostOrdersSwapFulfillmentsCancel(ctx, id, swapId, fulfillmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersSwapFulfillmentsCancelResponse(rsp)
}

// PostOrdersOrderSwapsSwapProcessPaymentWithResponse request returning *PostOrdersOrderSwapsSwapProcessPaymentResponse
func (c *ClientWithResponses) PostOrdersOrderSwapsSwapProcessPaymentWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapProcessPaymentParams, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapProcessPaymentResponse, error) {
	rsp, err := c.PostOrdersOrderSwapsSwapProcessPayment(ctx, id, swapId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsSwapProcessPaymentResponse(rsp)
}

// PostOrdersOrderSwapsSwapShipmentsWithBodyWithResponse request with arbitrary body returning *PostOrdersOrderSwapsSwapShipmentsResponse
func (c *ClientWithResponses) PostOrdersOrderSwapsSwapShipmentsWithBodyWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapShipmentsResponse, error) {
	rsp, err := c.PostOrdersOrderSwapsSwapShipmentsWithBody(ctx, id, swapId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsSwapShipmentsResponse(rsp)
}

func (c *ClientWithResponses) PostOrdersOrderSwapsSwapShipmentsWithResponse(ctx context.Context, id string, swapId string, params *PostOrdersOrderSwapsSwapShipmentsParams, body PostOrdersOrderSwapsSwapShipmentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOrdersOrderSwapsSwapShipmentsResponse, error) {
	rsp, err := c.PostOrdersOrderSwapsSwapShipments(ctx, id, swapId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOrdersOrderSwapsSwapShipmentsResponse(rsp)
}

// DeletePaymentCollectionsPaymentCollectionWithResponse request returning *DeletePaymentCollectionsPaymentCollectionResponse
func (c *ClientWithResponses) DeletePaymentCollectionsPaymentCollectionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePaymentCollectionsPaymentCollectionResponse, error) {
	rsp, err := c.DeletePaymentCollectionsPaymentCollection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePaymentCollectionsPaymentCollectionResponse(rsp)
}

// GetPaymentCollectionsPaymentCollectionWithResponse request returning *GetPaymentCollectionsPaymentCollectionResponse
func (c *ClientWithResponses) GetPaymentCollectionsPaymentCollectionWithResponse(ctx context.Context, id string, params *GetPaymentCollectionsPaymentCollectionParams, reqEditors ...RequestEditorFn) (*GetPaymentCollectionsPaymentCollectionResponse, error) {
	rsp, err := c.GetPaymentCollectionsPaymentCollection(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentCollectionsPaymentCollectionResponse(rsp)
}

// PostPaymentCollectionsPaymentCollectionWithBodyWithResponse request with arbitrary body returning *PostPaymentCollectionsPaymentCollectionResponse
func (c *ClientWithResponses) PostPaymentCollectionsPaymentCollectionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsPaymentCollectionResponse, error) {
	rsp, err := c.PostPaymentCollectionsPaymentCollectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsPaymentCollectionResponse(rsp)
}

func (c *ClientWithResponses) PostPaymentCollectionsPaymentCollectionWithResponse(ctx context.Context, id string, body PostPaymentCollectionsPaymentCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsPaymentCollectionResponse, error) {
	rsp, err := c.PostPaymentCollectionsPaymentCollection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsPaymentCollectionResponse(rsp)
}

// PostPaymentCollectionsPaymentCollectionAuthorizeWithResponse request returning *PostPaymentCollectionsPaymentCollectionAuthorizeResponse
func (c *ClientWithResponses) PostPaymentCollectionsPaymentCollectionAuthorizeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostPaymentCollectionsPaymentCollectionAuthorizeResponse, error) {
	rsp, err := c.PostPaymentCollectionsPaymentCollectionAuthorize(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentCollectionsPaymentCollectionAuthorizeResponse(rsp)
}

// GetPaymentsPaymentWithResponse request returning *GetPaymentsPaymentResponse
func (c *ClientWithResponses) GetPaymentsPaymentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPaymentsPaymentResponse, error) {
	rsp, err := c.GetPaymentsPayment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentsPaymentResponse(rsp)
}

// PostPaymentsPaymentCaptureWithResponse request returning *PostPaymentsPaymentCaptureResponse
func (c *ClientWithResponses) PostPaymentsPaymentCaptureWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostPaymentsPaymentCaptureResponse, error) {
	rsp, err := c.PostPaymentsPaymentCapture(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsPaymentCaptureResponse(rsp)
}

// PostPaymentsPaymentRefundsWithBodyWithResponse request with arbitrary body returning *PostPaymentsPaymentRefundsResponse
func (c *ClientWithResponses) PostPaymentsPaymentRefundsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPaymentsPaymentRefundsResponse, error) {
	rsp, err := c.PostPaymentsPaymentRefundsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsPaymentRefundsResponse(rsp)
}

func (c *ClientWithResponses) PostPaymentsPaymentRefundsWithResponse(ctx context.Context, id string, body PostPaymentsPaymentRefundsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPaymentsPaymentRefundsResponse, error) {
	rsp, err := c.PostPaymentsPaymentRefunds(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPaymentsPaymentRefundsResponse(rsp)
}

// GetPriceListsWithResponse request returning *GetPriceListsResponse
func (c *ClientWithResponses) GetPriceListsWithResponse(ctx context.Context, params *GetPriceListsParams, reqEditors ...RequestEditorFn) (*GetPriceListsResponse, error) {
	rsp, err := c.GetPriceLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPriceListsResponse(rsp)
}

// PostPriceListsPriceListWithBodyWithResponse request with arbitrary body returning *PostPriceListsPriceListResponse
func (c *ClientWithResponses) PostPriceListsPriceListWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListResponse, error) {
	rsp, err := c.PostPriceListsPriceListWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsPriceListResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsPriceListWithResponse(ctx context.Context, body PostPriceListsPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListResponse, error) {
	rsp, err := c.PostPriceListsPriceList(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsPriceListResponse(rsp)
}

// DeletePriceListsPriceListWithResponse request returning *DeletePriceListsPriceListResponse
func (c *ClientWithResponses) DeletePriceListsPriceListWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListResponse, error) {
	rsp, err := c.DeletePriceListsPriceList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsPriceListResponse(rsp)
}

// GetPriceListsPriceListWithResponse request returning *GetPriceListsPriceListResponse
func (c *ClientWithResponses) GetPriceListsPriceListWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPriceListsPriceListResponse, error) {
	rsp, err := c.GetPriceListsPriceList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPriceListsPriceListResponse(rsp)
}

// PostPriceListsPriceListPriceListWithBodyWithResponse request with arbitrary body returning *PostPriceListsPriceListPriceListResponse
func (c *ClientWithResponses) PostPriceListsPriceListPriceListWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPriceListResponse, error) {
	rsp, err := c.PostPriceListsPriceListPriceListWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsPriceListPriceListResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsPriceListPriceListWithResponse(ctx context.Context, id string, body PostPriceListsPriceListPriceListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPriceListResponse, error) {
	rsp, err := c.PostPriceListsPriceListPriceList(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsPriceListPriceListResponse(rsp)
}

// DeletePriceListsPriceListPricesBatchWithBodyWithResponse request with arbitrary body returning *DeletePriceListsPriceListPricesBatchResponse
func (c *ClientWithResponses) DeletePriceListsPriceListPricesBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListPricesBatchResponse, error) {
	rsp, err := c.DeletePriceListsPriceListPricesBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsPriceListPricesBatchResponse(rsp)
}

func (c *ClientWithResponses) DeletePriceListsPriceListPricesBatchWithResponse(ctx context.Context, id string, body DeletePriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListPricesBatchResponse, error) {
	rsp, err := c.DeletePriceListsPriceListPricesBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsPriceListPricesBatchResponse(rsp)
}

// PostPriceListsPriceListPricesBatchWithBodyWithResponse request with arbitrary body returning *PostPriceListsPriceListPricesBatchResponse
func (c *ClientWithResponses) PostPriceListsPriceListPricesBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPricesBatchResponse, error) {
	rsp, err := c.PostPriceListsPriceListPricesBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsPriceListPricesBatchResponse(rsp)
}

func (c *ClientWithResponses) PostPriceListsPriceListPricesBatchWithResponse(ctx context.Context, id string, body PostPriceListsPriceListPricesBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPriceListsPriceListPricesBatchResponse, error) {
	rsp, err := c.PostPriceListsPriceListPricesBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPriceListsPriceListPricesBatchResponse(rsp)
}

// GetPriceListsPriceListProductsWithResponse request returning *GetPriceListsPriceListProductsResponse
func (c *ClientWithResponses) GetPriceListsPriceListProductsWithResponse(ctx context.Context, id string, params *GetPriceListsPriceListProductsParams, reqEditors ...RequestEditorFn) (*GetPriceListsPriceListProductsResponse, error) {
	rsp, err := c.GetPriceListsPriceListProducts(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPriceListsPriceListProductsResponse(rsp)
}

// DeletePriceListsPriceListProductsPricesBatchWithResponse request returning *DeletePriceListsPriceListProductsPricesBatchResponse
func (c *ClientWithResponses) DeletePriceListsPriceListProductsPricesBatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListProductsPricesBatchResponse, error) {
	rsp, err := c.DeletePriceListsPriceListProductsPricesBatch(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsPriceListProductsPricesBatchResponse(rsp)
}

// DeletePriceListsPriceListProductsProductPricesWithResponse request returning *DeletePriceListsPriceListProductsProductPricesResponse
func (c *ClientWithResponses) DeletePriceListsPriceListProductsProductPricesWithResponse(ctx context.Context, id string, productId string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListProductsProductPricesResponse, error) {
	rsp, err := c.DeletePriceListsPriceListProductsProductPrices(ctx, id, productId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsPriceListProductsProductPricesResponse(rsp)
}

// DeletePriceListsPriceListVariantsVariantPricesWithResponse request returning *DeletePriceListsPriceListVariantsVariantPricesResponse
func (c *ClientWithResponses) DeletePriceListsPriceListVariantsVariantPricesWithResponse(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*DeletePriceListsPriceListVariantsVariantPricesResponse, error) {
	rsp, err := c.DeletePriceListsPriceListVariantsVariantPrices(ctx, id, variantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePriceListsPriceListVariantsVariantPricesResponse(rsp)
}

// GetProductCategoriesWithResponse request returning *GetProductCategoriesResponse
func (c *ClientWithResponses) GetProductCategoriesWithResponse(ctx context.Context, params *GetProductCategoriesParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesResponse, error) {
	rsp, err := c.GetProductCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductCategoriesResponse(rsp)
}

// PostProductCategoriesWithBodyWithResponse request with arbitrary body returning *PostProductCategoriesResponse
func (c *ClientWithResponses) PostProductCategoriesWithBodyWithResponse(ctx context.Context, params *PostProductCategoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error) {
	rsp, err := c.PostProductCategoriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesResponse(rsp)
}

func (c *ClientWithResponses) PostProductCategoriesWithResponse(ctx context.Context, params *PostProductCategoriesParams, body PostProductCategoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesResponse, error) {
	rsp, err := c.PostProductCategories(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesResponse(rsp)
}

// DeleteProductCategoriesCategoryWithResponse request returning *DeleteProductCategoriesCategoryResponse
func (c *ClientWithResponses) DeleteProductCategoriesCategoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesCategoryResponse, error) {
	rsp, err := c.DeleteProductCategoriesCategory(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductCategoriesCategoryResponse(rsp)
}

// GetProductCategoriesCategoryWithResponse request returning *GetProductCategoriesCategoryResponse
func (c *ClientWithResponses) GetProductCategoriesCategoryWithResponse(ctx context.Context, id string, params *GetProductCategoriesCategoryParams, reqEditors ...RequestEditorFn) (*GetProductCategoriesCategoryResponse, error) {
	rsp, err := c.GetProductCategoriesCategory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductCategoriesCategoryResponse(rsp)
}

// PostProductCategoriesCategoryWithBodyWithResponse request with arbitrary body returning *PostProductCategoriesCategoryResponse
func (c *ClientWithResponses) PostProductCategoriesCategoryWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryResponse, error) {
	rsp, err := c.PostProductCategoriesCategoryWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesCategoryResponse(rsp)
}

func (c *ClientWithResponses) PostProductCategoriesCategoryWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryParams, body PostProductCategoriesCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryResponse, error) {
	rsp, err := c.PostProductCategoriesCategory(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesCategoryResponse(rsp)
}

// DeleteProductCategoriesCategoryProductsBatchWithBodyWithResponse request with arbitrary body returning *DeleteProductCategoriesCategoryProductsBatchResponse
func (c *ClientWithResponses) DeleteProductCategoriesCategoryProductsBatchWithBodyWithResponse(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesCategoryProductsBatchResponse, error) {
	rsp, err := c.DeleteProductCategoriesCategoryProductsBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductCategoriesCategoryProductsBatchResponse(rsp)
}

func (c *ClientWithResponses) DeleteProductCategoriesCategoryProductsBatchWithResponse(ctx context.Context, id string, params *DeleteProductCategoriesCategoryProductsBatchParams, body DeleteProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProductCategoriesCategoryProductsBatchResponse, error) {
	rsp, err := c.DeleteProductCategoriesCategoryProductsBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductCategoriesCategoryProductsBatchResponse(rsp)
}

// PostProductCategoriesCategoryProductsBatchWithBodyWithResponse request with arbitrary body returning *PostProductCategoriesCategoryProductsBatchResponse
func (c *ClientWithResponses) PostProductCategoriesCategoryProductsBatchWithBodyWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryProductsBatchResponse, error) {
	rsp, err := c.PostProductCategoriesCategoryProductsBatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesCategoryProductsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostProductCategoriesCategoryProductsBatchWithResponse(ctx context.Context, id string, params *PostProductCategoriesCategoryProductsBatchParams, body PostProductCategoriesCategoryProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductCategoriesCategoryProductsBatchResponse, error) {
	rsp, err := c.PostProductCategoriesCategoryProductsBatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductCategoriesCategoryProductsBatchResponse(rsp)
}

// GetProductTagsWithResponse request returning *GetProductTagsResponse
func (c *ClientWithResponses) GetProductTagsWithResponse(ctx context.Context, params *GetProductTagsParams, reqEditors ...RequestEditorFn) (*GetProductTagsResponse, error) {
	rsp, err := c.GetProductTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductTagsResponse(rsp)
}

// GetProductTypesWithResponse request returning *GetProductTypesResponse
func (c *ClientWithResponses) GetProductTypesWithResponse(ctx context.Context, params *GetProductTypesParams, reqEditors ...RequestEditorFn) (*GetProductTypesResponse, error) {
	rsp, err := c.GetProductTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductTypesResponse(rsp)
}

// GetProductsWithResponse request returning *GetProductsResponse
func (c *ClientWithResponses) GetProductsWithResponse(ctx context.Context, params *GetProductsParams, reqEditors ...RequestEditorFn) (*GetProductsResponse, error) {
	rsp, err := c.GetProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsResponse(rsp)
}

// PostProductsWithBodyWithResponse request with arbitrary body returning *PostProductsResponse
func (c *ClientWithResponses) PostProductsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsResponse, error) {
	rsp, err := c.PostProductsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsWithResponse(ctx context.Context, body PostProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsResponse, error) {
	rsp, err := c.PostProducts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsResponse(rsp)
}

// GetProductsTagUsageWithResponse request returning *GetProductsTagUsageResponse
func (c *ClientWithResponses) GetProductsTagUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProductsTagUsageResponse, error) {
	rsp, err := c.GetProductsTagUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsTagUsageResponse(rsp)
}

// GetProductsTypesWithResponse request returning *GetProductsTypesResponse
func (c *ClientWithResponses) GetProductsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProductsTypesResponse, error) {
	rsp, err := c.GetProductsTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsTypesResponse(rsp)
}

// DeleteProductsProductWithResponse request returning *DeleteProductsProductResponse
func (c *ClientWithResponses) DeleteProductsProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductsProductResponse, error) {
	rsp, err := c.DeleteProductsProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsProductResponse(rsp)
}

// GetProductsProductWithResponse request returning *GetProductsProductResponse
func (c *ClientWithResponses) GetProductsProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProductsProductResponse, error) {
	rsp, err := c.GetProductsProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsProductResponse(rsp)
}

// PostProductsProductWithBodyWithResponse request with arbitrary body returning *PostProductsProductResponse
func (c *ClientWithResponses) PostProductsProductWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductResponse, error) {
	rsp, err := c.PostProductsProductWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductWithResponse(ctx context.Context, id string, body PostProductsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductResponse, error) {
	rsp, err := c.PostProductsProduct(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductResponse(rsp)
}

// PostProductsProductMetadataWithBodyWithResponse request with arbitrary body returning *PostProductsProductMetadataResponse
func (c *ClientWithResponses) PostProductsProductMetadataWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductMetadataResponse, error) {
	rsp, err := c.PostProductsProductMetadataWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductMetadataResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductMetadataWithResponse(ctx context.Context, id string, body PostProductsProductMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductMetadataResponse, error) {
	rsp, err := c.PostProductsProductMetadata(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductMetadataResponse(rsp)
}

// PostProductsProductOptionsWithBodyWithResponse request with arbitrary body returning *PostProductsProductOptionsResponse
func (c *ClientWithResponses) PostProductsProductOptionsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsResponse, error) {
	rsp, err := c.PostProductsProductOptionsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductOptionsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductOptionsWithResponse(ctx context.Context, id string, body PostProductsProductOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsResponse, error) {
	rsp, err := c.PostProductsProductOptions(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductOptionsResponse(rsp)
}

// DeleteProductsProductOptionsOptionWithResponse request returning *DeleteProductsProductOptionsOptionResponse
func (c *ClientWithResponses) DeleteProductsProductOptionsOptionWithResponse(ctx context.Context, id string, optionId string, reqEditors ...RequestEditorFn) (*DeleteProductsProductOptionsOptionResponse, error) {
	rsp, err := c.DeleteProductsProductOptionsOption(ctx, id, optionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsProductOptionsOptionResponse(rsp)
}

// PostProductsProductOptionsOptionWithBodyWithResponse request with arbitrary body returning *PostProductsProductOptionsOptionResponse
func (c *ClientWithResponses) PostProductsProductOptionsOptionWithBodyWithResponse(ctx context.Context, id string, optionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsOptionResponse, error) {
	rsp, err := c.PostProductsProductOptionsOptionWithBody(ctx, id, optionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductOptionsOptionResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductOptionsOptionWithResponse(ctx context.Context, id string, optionId string, body PostProductsProductOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductOptionsOptionResponse, error) {
	rsp, err := c.PostProductsProductOptionsOption(ctx, id, optionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductOptionsOptionResponse(rsp)
}

// GetProductsProductVariantsWithResponse request returning *GetProductsProductVariantsResponse
func (c *ClientWithResponses) GetProductsProductVariantsWithResponse(ctx context.Context, id string, params *GetProductsProductVariantsParams, reqEditors ...RequestEditorFn) (*GetProductsProductVariantsResponse, error) {
	rsp, err := c.GetProductsProductVariants(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductsProductVariantsResponse(rsp)
}

// PostProductsProductVariantsWithBodyWithResponse request with arbitrary body returning *PostProductsProductVariantsResponse
func (c *ClientWithResponses) PostProductsProductVariantsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsResponse, error) {
	rsp, err := c.PostProductsProductVariantsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductVariantsResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductVariantsWithResponse(ctx context.Context, id string, body PostProductsProductVariantsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsResponse, error) {
	rsp, err := c.PostProductsProductVariants(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductVariantsResponse(rsp)
}

// DeleteProductsProductVariantsVariantWithResponse request returning *DeleteProductsProductVariantsVariantResponse
func (c *ClientWithResponses) DeleteProductsProductVariantsVariantWithResponse(ctx context.Context, id string, variantId string, reqEditors ...RequestEditorFn) (*DeleteProductsProductVariantsVariantResponse, error) {
	rsp, err := c.DeleteProductsProductVariantsVariant(ctx, id, variantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductsProductVariantsVariantResponse(rsp)
}

// PostProductsProductVariantsVariantWithBodyWithResponse request with arbitrary body returning *PostProductsProductVariantsVariantResponse
func (c *ClientWithResponses) PostProductsProductVariantsVariantWithBodyWithResponse(ctx context.Context, id string, variantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsVariantResponse, error) {
	rsp, err := c.PostProductsProductVariantsVariantWithBody(ctx, id, variantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductVariantsVariantResponse(rsp)
}

func (c *ClientWithResponses) PostProductsProductVariantsVariantWithResponse(ctx context.Context, id string, variantId string, body PostProductsProductVariantsVariantJSONRequestBody, reqEditors ...RequestEditorFn) (*PostProductsProductVariantsVariantResponse, error) {
	rsp, err := c.PostProductsProductVariantsVariant(ctx, id, variantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostProductsProductVariantsVariantResponse(rsp)
}

// GetPublishableApiKeysWithResponse request returning *GetPublishableApiKeysResponse
func (c *ClientWithResponses) GetPublishableApiKeysWithResponse(ctx context.Context, params *GetPublishableApiKeysParams, reqEditors ...RequestEditorFn) (*GetPublishableApiKeysResponse, error) {
	rsp, err := c.GetPublishableApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublishableApiKeysResponse(rsp)
}

// PostPublishableApiKeysWithBodyWithResponse request with arbitrary body returning *PostPublishableApiKeysResponse
func (c *ClientWithResponses) PostPublishableApiKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishableApiKeysResponse, error) {
	rsp, err := c.PostPublishableApiKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKeysResponse(rsp)
}

func (c *ClientWithResponses) PostPublishableApiKeysWithResponse(ctx context.Context, body PostPublishableApiKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishableApiKeysResponse, error) {
	rsp, err := c.PostPublishableApiKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKeysResponse(rsp)
}

// DeletePublishableApiKeysPublishableApiKeyWithResponse request returning *DeletePublishableApiKeysPublishableApiKeyResponse
func (c *ClientWithResponses) DeletePublishableApiKeysPublishableApiKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePublishableApiKeysPublishableApiKeyResponse, error) {
	rsp, err := c.DeletePublishableApiKeysPublishableApiKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublishableApiKeysPublishableApiKeyResponse(rsp)
}

// GetPublishableApiKeysPublishableApiKeyWithResponse request returning *GetPublishableApiKeysPublishableApiKeyResponse
func (c *ClientWithResponses) GetPublishableApiKeysPublishableApiKeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPublishableApiKeysPublishableApiKeyResponse, error) {
	rsp, err := c.GetPublishableApiKeysPublishableApiKey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublishableApiKeysPublishableApiKeyResponse(rsp)
}

// PostPublishableApiKysPublishableApiKeyWithBodyWithResponse request with arbitrary body returning *PostPublishableApiKysPublishableApiKeyResponse
func (c *ClientWithResponses) PostPublishableApiKysPublishableApiKeyWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishableApiKysPublishableApiKeyResponse, error) {
	rsp, err := c.PostPublishableApiKysPublishableApiKeyWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKysPublishableApiKeyResponse(rsp)
}

func (c *ClientWithResponses) PostPublishableApiKysPublishableApiKeyWithResponse(ctx context.Context, id string, body PostPublishableApiKysPublishableApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishableApiKysPublishableApiKeyResponse, error) {
	rsp, err := c.PostPublishableApiKysPublishableApiKey(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKysPublishableApiKeyResponse(rsp)
}

// PostPublishableApiKeysPublishableApiKeyRevokeWithResponse request returning *PostPublishableApiKeysPublishableApiKeyRevokeResponse
func (c *ClientWithResponses) PostPublishableApiKeysPublishableApiKeyRevokeWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostPublishableApiKeysPublishableApiKeyRevokeResponse, error) {
	rsp, err := c.PostPublishableApiKeysPublishableApiKeyRevoke(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKeysPublishableApiKeyRevokeResponse(rsp)
}

// GetPublishableApiKeySalesChannelsWithResponse request returning *GetPublishableApiKeySalesChannelsResponse
func (c *ClientWithResponses) GetPublishableApiKeySalesChannelsWithResponse(ctx context.Context, id string, params *GetPublishableApiKeySalesChannelsParams, reqEditors ...RequestEditorFn) (*GetPublishableApiKeySalesChannelsResponse, error) {
	rsp, err := c.GetPublishableApiKeySalesChannels(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublishableApiKeySalesChannelsResponse(rsp)
}

// DeletePublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse request with arbitrary body returning *DeletePublishableApiKeySalesChannelsChannelsBatchResponse
func (c *ClientWithResponses) DeletePublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePublishableApiKeySalesChannelsChannelsBatchResponse, error) {
	rsp, err := c.DeletePublishableApiKeySalesChannelsChannelsBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublishableApiKeySalesChannelsChannelsBatchResponse(rsp)
}

func (c *ClientWithResponses) DeletePublishableApiKeySalesChannelsChannelsBatchWithResponse(ctx context.Context, id string, body DeletePublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePublishableApiKeySalesChannelsChannelsBatchResponse, error) {
	rsp, err := c.DeletePublishableApiKeySalesChannelsChannelsBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePublishableApiKeySalesChannelsChannelsBatchResponse(rsp)
}

// PostPublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse request with arbitrary body returning *PostPublishableApiKeySalesChannelsChannelsBatchResponse
func (c *ClientWithResponses) PostPublishableApiKeySalesChannelsChannelsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPublishableApiKeySalesChannelsChannelsBatchResponse, error) {
	rsp, err := c.PostPublishableApiKeySalesChannelsChannelsBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKeySalesChannelsChannelsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostPublishableApiKeySalesChannelsChannelsBatchWithResponse(ctx context.Context, id string, body PostPublishableApiKeySalesChannelsChannelsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPublishableApiKeySalesChannelsChannelsBatchResponse, error) {
	rsp, err := c.PostPublishableApiKeySalesChannelsChannelsBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPublishableApiKeySalesChannelsChannelsBatchResponse(rsp)
}

// GetRegionsWithResponse request returning *GetRegionsResponse
func (c *ClientWithResponses) GetRegionsWithResponse(ctx context.Context, params *GetRegionsParams, reqEditors ...RequestEditorFn) (*GetRegionsResponse, error) {
	rsp, err := c.GetRegions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionsResponse(rsp)
}

// PostRegionsWithBodyWithResponse request with arbitrary body returning *PostRegionsResponse
func (c *ClientWithResponses) PostRegionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error) {
	rsp, err := c.PostRegionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsWithResponse(ctx context.Context, body PostRegionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsResponse, error) {
	rsp, err := c.PostRegions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsResponse(rsp)
}

// DeleteRegionsRegionWithResponse request returning *DeleteRegionsRegionResponse
func (c *ClientWithResponses) DeleteRegionsRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteRegionsRegionResponse, error) {
	rsp, err := c.DeleteRegionsRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRegionsRegionResponse(rsp)
}

// GetRegionsRegionWithResponse request returning *GetRegionsRegionResponse
func (c *ClientWithResponses) GetRegionsRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRegionsRegionResponse, error) {
	rsp, err := c.GetRegionsRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionsRegionResponse(rsp)
}

// PostRegionsRegionWithBodyWithResponse request with arbitrary body returning *PostRegionsRegionResponse
func (c *ClientWithResponses) PostRegionsRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionResponse, error) {
	rsp, err := c.PostRegionsRegionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsRegionWithResponse(ctx context.Context, id string, body PostRegionsRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionResponse, error) {
	rsp, err := c.PostRegionsRegion(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionResponse(rsp)
}

// PostRegionsRegionCountriesWithBodyWithResponse request with arbitrary body returning *PostRegionsRegionCountriesResponse
func (c *ClientWithResponses) PostRegionsRegionCountriesWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionCountriesResponse, error) {
	rsp, err := c.PostRegionsRegionCountriesWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionCountriesResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsRegionCountriesWithResponse(ctx context.Context, id string, body PostRegionsRegionCountriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionCountriesResponse, error) {
	rsp, err := c.PostRegionsRegionCountries(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionCountriesResponse(rsp)
}

// PostRegionsRegionCountriesCountryWithResponse request returning *PostRegionsRegionCountriesCountryResponse
func (c *ClientWithResponses) PostRegionsRegionCountriesCountryWithResponse(ctx context.Context, id string, countryCode string, reqEditors ...RequestEditorFn) (*PostRegionsRegionCountriesCountryResponse, error) {
	rsp, err := c.PostRegionsRegionCountriesCountry(ctx, id, countryCode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionCountriesCountryResponse(rsp)
}

// GetRegionsRegionFulfillmentOptionsWithResponse request returning *GetRegionsRegionFulfillmentOptionsResponse
func (c *ClientWithResponses) GetRegionsRegionFulfillmentOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRegionsRegionFulfillmentOptionsResponse, error) {
	rsp, err := c.GetRegionsRegionFulfillmentOptions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionsRegionFulfillmentOptionsResponse(rsp)
}

// PostRegionsRegionFulfillmentProvidersWithBodyWithResponse request with arbitrary body returning *PostRegionsRegionFulfillmentProvidersResponse
func (c *ClientWithResponses) PostRegionsRegionFulfillmentProvidersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionFulfillmentProvidersResponse, error) {
	rsp, err := c.PostRegionsRegionFulfillmentProvidersWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionFulfillmentProvidersResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsRegionFulfillmentProvidersWithResponse(ctx context.Context, id string, body PostRegionsRegionFulfillmentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionFulfillmentProvidersResponse, error) {
	rsp, err := c.PostRegionsRegionFulfillmentProviders(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionFulfillmentProvidersResponse(rsp)
}

// PostRegionsRegionFulfillmentProvidersProviderWithResponse request returning *PostRegionsRegionFulfillmentProvidersProviderResponse
func (c *ClientWithResponses) PostRegionsRegionFulfillmentProvidersProviderWithResponse(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*PostRegionsRegionFulfillmentProvidersProviderResponse, error) {
	rsp, err := c.PostRegionsRegionFulfillmentProvidersProvider(ctx, id, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionFulfillmentProvidersProviderResponse(rsp)
}

// PostRegionsRegionPaymentProvidersWithBodyWithResponse request with arbitrary body returning *PostRegionsRegionPaymentProvidersResponse
func (c *ClientWithResponses) PostRegionsRegionPaymentProvidersWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegionsRegionPaymentProvidersResponse, error) {
	rsp, err := c.PostRegionsRegionPaymentProvidersWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionPaymentProvidersResponse(rsp)
}

func (c *ClientWithResponses) PostRegionsRegionPaymentProvidersWithResponse(ctx context.Context, id string, body PostRegionsRegionPaymentProvidersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegionsRegionPaymentProvidersResponse, error) {
	rsp, err := c.PostRegionsRegionPaymentProviders(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionPaymentProvidersResponse(rsp)
}

// PostRegionsRegionPaymentProvidersProviderWithResponse request returning *PostRegionsRegionPaymentProvidersProviderResponse
func (c *ClientWithResponses) PostRegionsRegionPaymentProvidersProviderWithResponse(ctx context.Context, id string, providerId string, reqEditors ...RequestEditorFn) (*PostRegionsRegionPaymentProvidersProviderResponse, error) {
	rsp, err := c.PostRegionsRegionPaymentProvidersProvider(ctx, id, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegionsRegionPaymentProvidersProviderResponse(rsp)
}

// GetReservationsWithResponse request returning *GetReservationsResponse
func (c *ClientWithResponses) GetReservationsWithResponse(ctx context.Context, params *GetReservationsParams, reqEditors ...RequestEditorFn) (*GetReservationsResponse, error) {
	rsp, err := c.GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservationsResponse(rsp)
}

// PostReservationsWithBodyWithResponse request with arbitrary body returning *PostReservationsResponse
func (c *ClientWithResponses) PostReservationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error) {
	rsp, err := c.PostReservationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsResponse(rsp)
}

func (c *ClientWithResponses) PostReservationsWithResponse(ctx context.Context, body PostReservationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsResponse, error) {
	rsp, err := c.PostReservations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsResponse(rsp)
}

// DeleteReservationsReservationWithResponse request returning *DeleteReservationsReservationResponse
func (c *ClientWithResponses) DeleteReservationsReservationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReservationsReservationResponse, error) {
	rsp, err := c.DeleteReservationsReservation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservationsReservationResponse(rsp)
}

// GetReservationsReservationWithResponse request returning *GetReservationsReservationResponse
func (c *ClientWithResponses) GetReservationsReservationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReservationsReservationResponse, error) {
	rsp, err := c.GetReservationsReservation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservationsReservationResponse(rsp)
}

// PostReservationsReservationWithBodyWithResponse request with arbitrary body returning *PostReservationsReservationResponse
func (c *ClientWithResponses) PostReservationsReservationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservationsReservationResponse, error) {
	rsp, err := c.PostReservationsReservationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsReservationResponse(rsp)
}

func (c *ClientWithResponses) PostReservationsReservationWithResponse(ctx context.Context, id string, body PostReservationsReservationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservationsReservationResponse, error) {
	rsp, err := c.PostReservationsReservation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservationsReservationResponse(rsp)
}

// GetReturnReasonsWithResponse request returning *GetReturnReasonsResponse
func (c *ClientWithResponses) GetReturnReasonsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReturnReasonsResponse, error) {
	rsp, err := c.GetReturnReasons(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnReasonsResponse(rsp)
}

// PostReturnReasonsWithBodyWithResponse request with arbitrary body returning *PostReturnReasonsResponse
func (c *ClientWithResponses) PostReturnReasonsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error) {
	rsp, err := c.PostReturnReasonsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsResponse(rsp)
}

func (c *ClientWithResponses) PostReturnReasonsWithResponse(ctx context.Context, body PostReturnReasonsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsResponse, error) {
	rsp, err := c.PostReturnReasons(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsResponse(rsp)
}

// DeleteReturnReasonWithResponse request returning *DeleteReturnReasonResponse
func (c *ClientWithResponses) DeleteReturnReasonWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteReturnReasonResponse, error) {
	rsp, err := c.DeleteReturnReason(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReturnReasonResponse(rsp)
}

// GetReturnReasonsReasonWithResponse request returning *GetReturnReasonsReasonResponse
func (c *ClientWithResponses) GetReturnReasonsReasonWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReturnReasonsReasonResponse, error) {
	rsp, err := c.GetReturnReasonsReason(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnReasonsReasonResponse(rsp)
}

// PostReturnReasonsReasonWithBodyWithResponse request with arbitrary body returning *PostReturnReasonsReasonResponse
func (c *ClientWithResponses) PostReturnReasonsReasonWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnReasonsReasonResponse, error) {
	rsp, err := c.PostReturnReasonsReasonWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsReasonResponse(rsp)
}

func (c *ClientWithResponses) PostReturnReasonsReasonWithResponse(ctx context.Context, id string, body PostReturnReasonsReasonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnReasonsReasonResponse, error) {
	rsp, err := c.PostReturnReasonsReason(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnReasonsReasonResponse(rsp)
}

// GetReturnsWithResponse request returning *GetReturnsResponse
func (c *ClientWithResponses) GetReturnsWithResponse(ctx context.Context, params *GetReturnsParams, reqEditors ...RequestEditorFn) (*GetReturnsResponse, error) {
	rsp, err := c.GetReturns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReturnsResponse(rsp)
}

// PostReturnsReturnCancelWithResponse request returning *PostReturnsReturnCancelResponse
func (c *ClientWithResponses) PostReturnsReturnCancelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PostReturnsReturnCancelResponse, error) {
	rsp, err := c.PostReturnsReturnCancel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsReturnCancelResponse(rsp)
}

// PostReturnsReturnReceiveWithBodyWithResponse request with arbitrary body returning *PostReturnsReturnReceiveResponse
func (c *ClientWithResponses) PostReturnsReturnReceiveWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReturnsReturnReceiveResponse, error) {
	rsp, err := c.PostReturnsReturnReceiveWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsReturnReceiveResponse(rsp)
}

func (c *ClientWithResponses) PostReturnsReturnReceiveWithResponse(ctx context.Context, id string, body PostReturnsReturnReceiveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReturnsReturnReceiveResponse, error) {
	rsp, err := c.PostReturnsReturnReceive(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReturnsReturnReceiveResponse(rsp)
}

// GetSalesChannelsWithResponse request returning *GetSalesChannelsResponse
func (c *ClientWithResponses) GetSalesChannelsWithResponse(ctx context.Context, params *GetSalesChannelsParams, reqEditors ...RequestEditorFn) (*GetSalesChannelsResponse, error) {
	rsp, err := c.GetSalesChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSalesChannelsResponse(rsp)
}

// PostSalesChannelsWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsResponse
func (c *ClientWithResponses) PostSalesChannelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error) {
	rsp, err := c.PostSalesChannelsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsWithResponse(ctx context.Context, body PostSalesChannelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsResponse, error) {
	rsp, err := c.PostSalesChannels(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsResponse(rsp)
}

// DeleteSalesChannelsSalesChannelWithResponse request returning *DeleteSalesChannelsSalesChannelResponse
func (c *ClientWithResponses) DeleteSalesChannelsSalesChannelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsSalesChannelResponse, error) {
	rsp, err := c.DeleteSalesChannelsSalesChannel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSalesChannelsSalesChannelResponse(rsp)
}

// GetSalesChannelsSalesChannelWithResponse request returning *GetSalesChannelsSalesChannelResponse
func (c *ClientWithResponses) GetSalesChannelsSalesChannelWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSalesChannelsSalesChannelResponse, error) {
	rsp, err := c.GetSalesChannelsSalesChannel(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSalesChannelsSalesChannelResponse(rsp)
}

// PostSalesChannelsSalesChannelWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsSalesChannelResponse
func (c *ClientWithResponses) PostSalesChannelsSalesChannelWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelResponse, error) {
	rsp, err := c.PostSalesChannelsSalesChannelWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsSalesChannelResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsSalesChannelWithResponse(ctx context.Context, id string, body PostSalesChannelsSalesChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelResponse, error) {
	rsp, err := c.PostSalesChannelsSalesChannel(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsSalesChannelResponse(rsp)
}

// DeleteSalesChannelsChannelProductsBatchWithBodyWithResponse request with arbitrary body returning *DeleteSalesChannelsChannelProductsBatchResponse
func (c *ClientWithResponses) DeleteSalesChannelsChannelProductsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsChannelProductsBatchResponse, error) {
	rsp, err := c.DeleteSalesChannelsChannelProductsBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSalesChannelsChannelProductsBatchResponse(rsp)
}

func (c *ClientWithResponses) DeleteSalesChannelsChannelProductsBatchWithResponse(ctx context.Context, id string, body DeleteSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsChannelProductsBatchResponse, error) {
	rsp, err := c.DeleteSalesChannelsChannelProductsBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSalesChannelsChannelProductsBatchResponse(rsp)
}

// PostSalesChannelsChannelProductsBatchWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsChannelProductsBatchResponse
func (c *ClientWithResponses) PostSalesChannelsChannelProductsBatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsChannelProductsBatchResponse, error) {
	rsp, err := c.PostSalesChannelsChannelProductsBatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsChannelProductsBatchResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsChannelProductsBatchWithResponse(ctx context.Context, id string, body PostSalesChannelsChannelProductsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsChannelProductsBatchResponse, error) {
	rsp, err := c.PostSalesChannelsChannelProductsBatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsChannelProductsBatchResponse(rsp)
}

// DeleteSalesChannelsSalesChannelStockLocationWithBodyWithResponse request with arbitrary body returning *DeleteSalesChannelsSalesChannelStockLocationResponse
func (c *ClientWithResponses) DeleteSalesChannelsSalesChannelStockLocationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsSalesChannelStockLocationResponse, error) {
	rsp, err := c.DeleteSalesChannelsSalesChannelStockLocationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSalesChannelsSalesChannelStockLocationResponse(rsp)
}

func (c *ClientWithResponses) DeleteSalesChannelsSalesChannelStockLocationWithResponse(ctx context.Context, id string, body DeleteSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSalesChannelsSalesChannelStockLocationResponse, error) {
	rsp, err := c.DeleteSalesChannelsSalesChannelStockLocation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSalesChannelsSalesChannelStockLocationResponse(rsp)
}

// PostSalesChannelsSalesChannelStockLocationWithBodyWithResponse request with arbitrary body returning *PostSalesChannelsSalesChannelStockLocationResponse
func (c *ClientWithResponses) PostSalesChannelsSalesChannelStockLocationWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelStockLocationResponse, error) {
	rsp, err := c.PostSalesChannelsSalesChannelStockLocationWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsSalesChannelStockLocationResponse(rsp)
}

func (c *ClientWithResponses) PostSalesChannelsSalesChannelStockLocationWithResponse(ctx context.Context, id string, body PostSalesChannelsSalesChannelStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSalesChannelsSalesChannelStockLocationResponse, error) {
	rsp, err := c.PostSalesChannelsSalesChannelStockLocation(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSalesChannelsSalesChannelStockLocationResponse(rsp)
}

// GetShippingOptionsWithResponse request returning *GetShippingOptionsResponse
func (c *ClientWithResponses) GetShippingOptionsWithResponse(ctx context.Context, params *GetShippingOptionsParams, reqEditors ...RequestEditorFn) (*GetShippingOptionsResponse, error) {
	rsp, err := c.GetShippingOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingOptionsResponse(rsp)
}

// PostShippingOptionsWithBodyWithResponse request with arbitrary body returning *PostShippingOptionsResponse
func (c *ClientWithResponses) PostShippingOptionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error) {
	rsp, err := c.PostShippingOptionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsResponse(rsp)
}

func (c *ClientWithResponses) PostShippingOptionsWithResponse(ctx context.Context, body PostShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsResponse, error) {
	rsp, err := c.PostShippingOptions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsResponse(rsp)
}

// DeleteShippingOptionsOptionWithResponse request returning *DeleteShippingOptionsOptionResponse
func (c *ClientWithResponses) DeleteShippingOptionsOptionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingOptionsOptionResponse, error) {
	rsp, err := c.DeleteShippingOptionsOption(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShippingOptionsOptionResponse(rsp)
}

// GetShippingOptionsOptionWithResponse request returning *GetShippingOptionsOptionResponse
func (c *ClientWithResponses) GetShippingOptionsOptionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetShippingOptionsOptionResponse, error) {
	rsp, err := c.GetShippingOptionsOption(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingOptionsOptionResponse(rsp)
}

// PostShippingOptionsOptionWithBodyWithResponse request with arbitrary body returning *PostShippingOptionsOptionResponse
func (c *ClientWithResponses) PostShippingOptionsOptionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingOptionsOptionResponse, error) {
	rsp, err := c.PostShippingOptionsOptionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsOptionResponse(rsp)
}

func (c *ClientWithResponses) PostShippingOptionsOptionWithResponse(ctx context.Context, id string, body PostShippingOptionsOptionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingOptionsOptionResponse, error) {
	rsp, err := c.PostShippingOptionsOption(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingOptionsOptionResponse(rsp)
}

// GetShippingProfilesWithResponse request returning *GetShippingProfilesResponse
func (c *ClientWithResponses) GetShippingProfilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetShippingProfilesResponse, error) {
	rsp, err := c.GetShippingProfiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingProfilesResponse(rsp)
}

// PostShippingProfilesWithBodyWithResponse request with arbitrary body returning *PostShippingProfilesResponse
func (c *ClientWithResponses) PostShippingProfilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error) {
	rsp, err := c.PostShippingProfilesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesResponse(rsp)
}

func (c *ClientWithResponses) PostShippingProfilesWithResponse(ctx context.Context, body PostShippingProfilesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesResponse, error) {
	rsp, err := c.PostShippingProfiles(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesResponse(rsp)
}

// DeleteShippingProfilesProfileWithResponse request returning *DeleteShippingProfilesProfileResponse
func (c *ClientWithResponses) DeleteShippingProfilesProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteShippingProfilesProfileResponse, error) {
	rsp, err := c.DeleteShippingProfilesProfile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteShippingProfilesProfileResponse(rsp)
}

// GetShippingProfilesProfileWithResponse request returning *GetShippingProfilesProfileResponse
func (c *ClientWithResponses) GetShippingProfilesProfileWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetShippingProfilesProfileResponse, error) {
	rsp, err := c.GetShippingProfilesProfile(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShippingProfilesProfileResponse(rsp)
}

// PostShippingProfilesProfileWithBodyWithResponse request with arbitrary body returning *PostShippingProfilesProfileResponse
func (c *ClientWithResponses) PostShippingProfilesProfileWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostShippingProfilesProfileResponse, error) {
	rsp, err := c.PostShippingProfilesProfileWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesProfileResponse(rsp)
}

func (c *ClientWithResponses) PostShippingProfilesProfileWithResponse(ctx context.Context, id string, body PostShippingProfilesProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*PostShippingProfilesProfileResponse, error) {
	rsp, err := c.PostShippingProfilesProfile(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostShippingProfilesProfileResponse(rsp)
}

// GetStockLocationsWithResponse request returning *GetStockLocationsResponse
func (c *ClientWithResponses) GetStockLocationsWithResponse(ctx context.Context, params *GetStockLocationsParams, reqEditors ...RequestEditorFn) (*GetStockLocationsResponse, error) {
	rsp, err := c.GetStockLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStockLocationsResponse(rsp)
}

// PostStockLocationsWithBodyWithResponse request with arbitrary body returning *PostStockLocationsResponse
func (c *ClientWithResponses) PostStockLocationsWithBodyWithResponse(ctx context.Context, params *PostStockLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error) {
	rsp, err := c.PostStockLocationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsWithResponse(ctx context.Context, params *PostStockLocationsParams, body PostStockLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsResponse, error) {
	rsp, err := c.PostStockLocations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsResponse(rsp)
}

// DeleteStockLocationsStockLocationWithResponse request returning *DeleteStockLocationsStockLocationResponse
func (c *ClientWithResponses) DeleteStockLocationsStockLocationWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteStockLocationsStockLocationResponse, error) {
	rsp, err := c.DeleteStockLocationsStockLocation(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStockLocationsStockLocationResponse(rsp)
}

// GetStockLocationsStockLocationWithResponse request returning *GetStockLocationsStockLocationResponse
func (c *ClientWithResponses) GetStockLocationsStockLocationWithResponse(ctx context.Context, id string, params *GetStockLocationsStockLocationParams, reqEditors ...RequestEditorFn) (*GetStockLocationsStockLocationResponse, error) {
	rsp, err := c.GetStockLocationsStockLocation(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStockLocationsStockLocationResponse(rsp)
}

// PostStockLocationsStockLocationWithBodyWithResponse request with arbitrary body returning *PostStockLocationsStockLocationResponse
func (c *ClientWithResponses) PostStockLocationsStockLocationWithBodyWithResponse(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStockLocationsStockLocationResponse, error) {
	rsp, err := c.PostStockLocationsStockLocationWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsStockLocationResponse(rsp)
}

func (c *ClientWithResponses) PostStockLocationsStockLocationWithResponse(ctx context.Context, id string, params *PostStockLocationsStockLocationParams, body PostStockLocationsStockLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStockLocationsStockLocationResponse, error) {
	rsp, err := c.PostStockLocationsStockLocation(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStockLocationsStockLocationResponse(rsp)
}

// GetStoreWithResponse request returning *GetStoreResponse
func (c *ClientWithResponses) GetStoreWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoreResponse, error) {
	rsp, err := c.GetStore(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoreResponse(rsp)
}

// PostStoreWithBodyWithResponse request with arbitrary body returning *PostStoreResponse
func (c *ClientWithResponses) PostStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStoreResponse, error) {
	rsp, err := c.PostStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStoreResponse(rsp)
}

func (c *ClientWithResponses) PostStoreWithResponse(ctx context.Context, body PostStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStoreResponse, error) {
	rsp, err := c.PostStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStoreResponse(rsp)
}

// DeleteStoreCurrenciesCodeWithResponse request returning *DeleteStoreCurrenciesCodeResponse
func (c *ClientWithResponses) DeleteStoreCurrenciesCodeWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*DeleteStoreCurrenciesCodeResponse, error) {
	rsp, err := c.DeleteStoreCurrenciesCode(ctx, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoreCurrenciesCodeResponse(rsp)
}

// PostStoreCurrenciesCodeWithResponse request returning *PostStoreCurrenciesCodeResponse
func (c *ClientWithResponses) PostStoreCurrenciesCodeWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*PostStoreCurrenciesCodeResponse, error) {
	rsp, err := c.PostStoreCurrenciesCode(ctx, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStoreCurrenciesCodeResponse(rsp)
}

// GetStorePaymentProvidersWithResponse request returning *GetStorePaymentProvidersResponse
func (c *ClientWithResponses) GetStorePaymentProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorePaymentProvidersResponse, error) {
	rsp, err := c.GetStorePaymentProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorePaymentProvidersResponse(rsp)
}

// GetStoreTaxProvidersWithResponse request returning *GetStoreTaxProvidersResponse
func (c *ClientWithResponses) GetStoreTaxProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoreTaxProvidersResponse, error) {
	rsp, err := c.GetStoreTaxProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoreTaxProvidersResponse(rsp)
}

// GetSwapsWithResponse request returning *GetSwapsResponse
func (c *ClientWithResponses) GetSwapsWithResponse(ctx context.Context, params *GetSwapsParams, reqEditors ...RequestEditorFn) (*GetSwapsResponse, error) {
	rsp, err := c.GetSwaps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapsResponse(rsp)
}

// GetSwapsSwapWithResponse request returning *GetSwapsSwapResponse
func (c *ClientWithResponses) GetSwapsSwapWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSwapsSwapResponse, error) {
	rsp, err := c.GetSwapsSwap(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapsSwapResponse(rsp)
}

// GetTaxRatesWithResponse request returning *GetTaxRatesResponse
func (c *ClientWithResponses) GetTaxRatesWithResponse(ctx context.Context, params *GetTaxRatesParams, reqEditors ...RequestEditorFn) (*GetTaxRatesResponse, error) {
	rsp, err := c.GetTaxRates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxRatesResponse(rsp)
}

// PostTaxRatesWithBodyWithResponse request with arbitrary body returning *PostTaxRatesResponse
func (c *ClientWithResponses) PostTaxRatesWithBodyWithResponse(ctx context.Context, params *PostTaxRatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error) {
	rsp, err := c.PostTaxRatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesWithResponse(ctx context.Context, params *PostTaxRatesParams, body PostTaxRatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesResponse, error) {
	rsp, err := c.PostTaxRates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesResponse(rsp)
}

// DeleteTaxRatesTaxRateWithResponse request returning *DeleteTaxRatesTaxRateResponse
func (c *ClientWithResponses) DeleteTaxRatesTaxRateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateResponse(rsp)
}

// GetTaxRatesTaxRateWithResponse request returning *GetTaxRatesTaxRateResponse
func (c *ClientWithResponses) GetTaxRatesTaxRateWithResponse(ctx context.Context, id string, params *GetTaxRatesTaxRateParams, reqEditors ...RequestEditorFn) (*GetTaxRatesTaxRateResponse, error) {
	rsp, err := c.GetTaxRatesTaxRate(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaxRatesTaxRateResponse(rsp)
}

// PostTaxRatesTaxRateWithBodyWithResponse request with arbitrary body returning *PostTaxRatesTaxRateResponse
func (c *ClientWithResponses) PostTaxRatesTaxRateWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesTaxRateWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateParams, body PostTaxRatesTaxRateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateResponse, error) {
	rsp, err := c.PostTaxRatesTaxRate(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateResponse(rsp)
}

// DeleteTaxRatesTaxRateProductTypesWithBodyWithResponse request with arbitrary body returning *DeleteTaxRatesTaxRateProductTypesResponse
func (c *ClientWithResponses) DeleteTaxRatesTaxRateProductTypesWithBodyWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductTypesResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRateProductTypesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateProductTypesResponse(rsp)
}

func (c *ClientWithResponses) DeleteTaxRatesTaxRateProductTypesWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductTypesParams, body DeleteTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductTypesResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRateProductTypes(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateProductTypesResponse(rsp)
}

// PostTaxRatesTaxRateProductTypesWithBodyWithResponse request with arbitrary body returning *PostTaxRatesTaxRateProductTypesResponse
func (c *ClientWithResponses) PostTaxRatesTaxRateProductTypesWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductTypesResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateProductTypesWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateProductTypesResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesTaxRateProductTypesWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductTypesParams, body PostTaxRatesTaxRateProductTypesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductTypesResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateProductTypes(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateProductTypesResponse(rsp)
}

// DeleteTaxRatesTaxRateProductsWithBodyWithResponse request with arbitrary body returning *DeleteTaxRatesTaxRateProductsResponse
func (c *ClientWithResponses) DeleteTaxRatesTaxRateProductsWithBodyWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductsResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRateProductsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateProductsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTaxRatesTaxRateProductsWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateProductsParams, body DeleteTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateProductsResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRateProducts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateProductsResponse(rsp)
}

// PostTaxRatesTaxRateProductsWithBodyWithResponse request with arbitrary body returning *PostTaxRatesTaxRateProductsResponse
func (c *ClientWithResponses) PostTaxRatesTaxRateProductsWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductsResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateProductsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateProductsResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesTaxRateProductsWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateProductsParams, body PostTaxRatesTaxRateProductsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateProductsResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateProducts(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateProductsResponse(rsp)
}

// DeleteTaxRatesTaxRateShippingOptionsWithBodyWithResponse request with arbitrary body returning *DeleteTaxRatesTaxRateShippingOptionsResponse
func (c *ClientWithResponses) DeleteTaxRatesTaxRateShippingOptionsWithBodyWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateShippingOptionsResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRateShippingOptionsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateShippingOptionsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTaxRatesTaxRateShippingOptionsWithResponse(ctx context.Context, id string, params *DeleteTaxRatesTaxRateShippingOptionsParams, body DeleteTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTaxRatesTaxRateShippingOptionsResponse, error) {
	rsp, err := c.DeleteTaxRatesTaxRateShippingOptions(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTaxRatesTaxRateShippingOptionsResponse(rsp)
}

// PostTaxRatesTaxRateShippingOptionsWithBodyWithResponse request with arbitrary body returning *PostTaxRatesTaxRateShippingOptionsResponse
func (c *ClientWithResponses) PostTaxRatesTaxRateShippingOptionsWithBodyWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateShippingOptionsResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateShippingOptionsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateShippingOptionsResponse(rsp)
}

func (c *ClientWithResponses) PostTaxRatesTaxRateShippingOptionsWithResponse(ctx context.Context, id string, params *PostTaxRatesTaxRateShippingOptionsParams, body PostTaxRatesTaxRateShippingOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTaxRatesTaxRateShippingOptionsResponse, error) {
	rsp, err := c.PostTaxRatesTaxRateShippingOptions(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTaxRatesTaxRateShippingOptionsResponse(rsp)
}

// DeleteUploadsWithBodyWithResponse request with arbitrary body returning *DeleteUploadsResponse
func (c *ClientWithResponses) DeleteUploadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUploadsResponse, error) {
	rsp, err := c.DeleteUploadsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUploadsResponse(rsp)
}

func (c *ClientWithResponses) DeleteUploadsWithResponse(ctx context.Context, body DeleteUploadsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUploadsResponse, error) {
	rsp, err := c.DeleteUploads(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUploadsResponse(rsp)
}

// PostUploadsWithBodyWithResponse request with arbitrary body returning *PostUploadsResponse
func (c *ClientWithResponses) PostUploadsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsResponse, error) {
	rsp, err := c.PostUploadsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadsResponse(rsp)
}

// PostUploadsDownloadUrlWithBodyWithResponse request with arbitrary body returning *PostUploadsDownloadUrlResponse
func (c *ClientWithResponses) PostUploadsDownloadUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsDownloadUrlResponse, error) {
	rsp, err := c.PostUploadsDownloadUrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadsDownloadUrlResponse(rsp)
}

func (c *ClientWithResponses) PostUploadsDownloadUrlWithResponse(ctx context.Context, body PostUploadsDownloadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUploadsDownloadUrlResponse, error) {
	rsp, err := c.PostUploadsDownloadUrl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadsDownloadUrlResponse(rsp)
}

// PostUploadsProtectedWithBodyWithResponse request with arbitrary body returning *PostUploadsProtectedResponse
func (c *ClientWithResponses) PostUploadsProtectedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUploadsProtectedResponse, error) {
	rsp, err := c.PostUploadsProtectedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUploadsProtectedResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// PostUsersWithBodyWithResponse request with arbitrary body returning *PostUsersResponse
func (c *ClientWithResponses) PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersResponse, error) {
	rsp, err := c.PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersResponse(rsp)
}

func (c *ClientWithResponses) PostUsersWithResponse(ctx context.Context, body PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersResponse, error) {
	rsp, err := c.PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersResponse(rsp)
}

// PostUsersUserPasswordTokenWithBodyWithResponse request with arbitrary body returning *PostUsersUserPasswordTokenResponse
func (c *ClientWithResponses) PostUsersUserPasswordTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordTokenResponse, error) {
	rsp, err := c.PostUsersUserPasswordTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersUserPasswordTokenResponse(rsp)
}

func (c *ClientWithResponses) PostUsersUserPasswordTokenWithResponse(ctx context.Context, body PostUsersUserPasswordTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordTokenResponse, error) {
	rsp, err := c.PostUsersUserPasswordToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersUserPasswordTokenResponse(rsp)
}

// PostUsersUserPasswordWithBodyWithResponse request with arbitrary body returning *PostUsersUserPasswordResponse
func (c *ClientWithResponses) PostUsersUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordResponse, error) {
	rsp, err := c.PostUsersUserPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) PostUsersUserPasswordWithResponse(ctx context.Context, body PostUsersUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersUserPasswordResponse, error) {
	rsp, err := c.PostUsersUserPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersUserPasswordResponse(rsp)
}

// DeleteUsersUserWithResponse request returning *DeleteUsersUserResponse
func (c *ClientWithResponses) DeleteUsersUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUsersUserResponse, error) {
	rsp, err := c.DeleteUsersUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUsersUserResponse(rsp)
}

// GetUsersUserWithResponse request returning *GetUsersUserResponse
func (c *ClientWithResponses) GetUsersUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUsersUserResponse, error) {
	rsp, err := c.GetUsersUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserResponse(rsp)
}

// PostUsersUserWithBodyWithResponse request with arbitrary body returning *PostUsersUserResponse
func (c *ClientWithResponses) PostUsersUserWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostUsersUserResponse, error) {
	rsp, err := c.PostUsersUserWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersUserResponse(rsp)
}

func (c *ClientWithResponses) PostUsersUserWithResponse(ctx context.Context, id string, body PostUsersUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PostUsersUserResponse, error) {
	rsp, err := c.PostUsersUser(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUsersUserResponse(rsp)
}

// GetVariantsWithResponse request returning *GetVariantsResponse
func (c *ClientWithResponses) GetVariantsWithResponse(ctx context.Context, params *GetVariantsParams, reqEditors ...RequestEditorFn) (*GetVariantsResponse, error) {
	rsp, err := c.GetVariants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariantsResponse(rsp)
}

// GetVariantsVariantWithResponse request returning *GetVariantsVariantResponse
func (c *ClientWithResponses) GetVariantsVariantWithResponse(ctx context.Context, id string, params *GetVariantsVariantParams, reqEditors ...RequestEditorFn) (*GetVariantsVariantResponse, error) {
	rsp, err := c.GetVariantsVariant(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariantsVariantResponse(rsp)
}

// GetVariantsVariantInventoryWithResponse request returning *GetVariantsVariantInventoryResponse
func (c *ClientWithResponses) GetVariantsVariantInventoryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetVariantsVariantInventoryResponse, error) {
	rsp, err := c.GetVariantsVariantInventory(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariantsVariantInventoryResponse(rsp)
}

// ParseGetAppsResponse parses an HTTP response from a GetAppsWithResponse call
func ParseGetAppsResponse(rsp *http.Response) (*GetAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminAppsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAppsResponse parses an HTTP response from a PostAppsWithResponse call
func ParsePostAppsResponse(rsp *http.Response) (*PostAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminAppsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAuthResponse parses an HTTP response from a DeleteAuthWithResponse call
func ParseDeleteAuthResponse(rsp *http.Response) (*DeleteAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAuthResponse parses an HTTP response from a GetAuthWithResponse call
func ParseGetAuthResponse(rsp *http.Response) (*GetAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminAuthRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAuthResponse parses an HTTP response from a PostAuthWithResponse call
func ParsePostAuthResponse(rsp *http.Response) (*PostAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminAuthRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTokenResponse parses an HTTP response from a PostTokenWithResponse call
func ParsePostTokenResponse(rsp *http.Response) (*PostTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBearerAuthRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBatchJobsResponse parses an HTTP response from a GetBatchJobsWithResponse call
func ParseGetBatchJobsResponse(rsp *http.Response) (*GetBatchJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBatchJobListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBatchJobsResponse parses an HTTP response from a PostBatchJobsWithResponse call
func ParsePostBatchJobsResponse(rsp *http.Response) (*PostBatchJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBatchJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AdminBatchJobRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBatchJobsBatchJobResponse parses an HTTP response from a GetBatchJobsBatchJobWithResponse call
func ParseGetBatchJobsBatchJobResponse(rsp *http.Response) (*GetBatchJobsBatchJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchJobsBatchJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBatchJobRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBatchJobsBatchJobCancelResponse parses an HTTP response from a PostBatchJobsBatchJobCancelWithResponse call
func ParsePostBatchJobsBatchJobCancelResponse(rsp *http.Response) (*PostBatchJobsBatchJobCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBatchJobsBatchJobCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBatchJobRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBatchJobsBatchJobConfirmProcessingResponse parses an HTTP response from a PostBatchJobsBatchJobConfirmProcessingWithResponse call
func ParsePostBatchJobsBatchJobConfirmProcessingResponse(rsp *http.Response) (*PostBatchJobsBatchJobConfirmProcessingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBatchJobsBatchJobConfirmProcessingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminBatchJobRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionsResponse parses an HTTP response from a GetCollectionsWithResponse call
func ParseGetCollectionsResponse(rsp *http.Response) (*GetCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionsResponse parses an HTTP response from a PostCollectionsWithResponse call
func ParsePostCollectionsResponse(rsp *http.Response) (*PostCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionsCollectionResponse parses an HTTP response from a DeleteCollectionsCollectionWithResponse call
func ParseDeleteCollectionsCollectionResponse(rsp *http.Response) (*DeleteCollectionsCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionsCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectionsCollectionResponse parses an HTTP response from a GetCollectionsCollectionWithResponse call
func ParseGetCollectionsCollectionResponse(rsp *http.Response) (*GetCollectionsCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionsCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCollectionsCollectionResponse parses an HTTP response from a PostCollectionsCollectionWithResponse call
func ParsePostCollectionsCollectionResponse(rsp *http.Response) (*PostCollectionsCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCollectionsCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsFromCollectionResponse parses an HTTP response from a DeleteProductsFromCollectionWithResponse call
func ParseDeleteProductsFromCollectionResponse(rsp *http.Response) (*DeleteProductsFromCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsFromCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDeleteProductsFromCollectionRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsToCollectionResponse parses an HTTP response from a PostProductsToCollectionWithResponse call
func ParsePostProductsToCollectionResponse(rsp *http.Response) (*PostProductsToCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsToCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrenciesResponse parses an HTTP response from a GetCurrenciesWithResponse call
func ParseGetCurrenciesResponse(rsp *http.Response) (*GetCurrenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCurrenciesListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCurrenciesCurrencyResponse parses an HTTP response from a PostCurrenciesCurrencyWithResponse call
func ParsePostCurrenciesCurrencyResponse(rsp *http.Response) (*PostCurrenciesCurrencyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCurrenciesCurrencyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCurrenciesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomerGroupsResponse parses an HTTP response from a GetCustomerGroupsWithResponse call
func ParseGetCustomerGroupsResponse(rsp *http.Response) (*GetCustomerGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomerGroupsResponse parses an HTTP response from a PostCustomerGroupsWithResponse call
func ParsePostCustomerGroupsResponse(rsp *http.Response) (*PostCustomerGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomerGroupsCustomerGroupResponse parses an HTTP response from a DeleteCustomerGroupsCustomerGroupWithResponse call
func ParseDeleteCustomerGroupsCustomerGroupResponse(rsp *http.Response) (*DeleteCustomerGroupsCustomerGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerGroupsCustomerGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomerGroupsGroupResponse parses an HTTP response from a GetCustomerGroupsGroupWithResponse call
func ParseGetCustomerGroupsGroupResponse(rsp *http.Response) (*GetCustomerGroupsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerGroupsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomerGroupsGroupResponse parses an HTTP response from a PostCustomerGroupsGroupWithResponse call
func ParsePostCustomerGroupsGroupResponse(rsp *http.Response) (*PostCustomerGroupsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerGroupsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomerGroupsGroupCustomersResponse parses an HTTP response from a GetCustomerGroupsGroupCustomersWithResponse call
func ParseGetCustomerGroupsGroupCustomersResponse(rsp *http.Response) (*GetCustomerGroupsGroupCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerGroupsGroupCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomersListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomerGroupsGroupCustomerBatchResponse parses an HTTP response from a DeleteCustomerGroupsGroupCustomerBatchWithResponse call
func ParseDeleteCustomerGroupsGroupCustomerBatchResponse(rsp *http.Response) (*DeleteCustomerGroupsGroupCustomerBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomerGroupsGroupCustomerBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomerGroupsGroupCustomersBatchResponse parses an HTTP response from a PostCustomerGroupsGroupCustomersBatchWithResponse call
func ParsePostCustomerGroupsGroupCustomersBatchResponse(rsp *http.Response) (*PostCustomerGroupsGroupCustomersBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomerGroupsGroupCustomersBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomerGroupsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomersResponse parses an HTTP response from a GetCustomersWithResponse call
func ParseGetCustomersResponse(rsp *http.Response) (*GetCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomersListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomersResponse parses an HTTP response from a PostCustomersWithResponse call
func ParsePostCustomersResponse(rsp *http.Response) (*PostCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AdminCustomersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomersCustomerResponse parses an HTTP response from a GetCustomersCustomerWithResponse call
func ParseGetCustomersCustomerResponse(rsp *http.Response) (*GetCustomersCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCustomersCustomerResponse parses an HTTP response from a PostCustomersCustomerWithResponse call
func ParsePostCustomersCustomerResponse(rsp *http.Response) (*PostCustomersCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCustomersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDiscountsResponse parses an HTTP response from a GetDiscountsWithResponse call
func ParseGetDiscountsResponse(rsp *http.Response) (*GetDiscountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsResponse parses an HTTP response from a PostDiscountsWithResponse call
func ParsePostDiscountsResponse(rsp *http.Response) (*PostDiscountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDiscountsDiscountCodeResponse parses an HTTP response from a GetDiscountsDiscountCodeWithResponse call
func ParseGetDiscountsDiscountCodeResponse(rsp *http.Response) (*GetDiscountsDiscountCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscountsDiscountCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsDiscountConditionsResponse parses an HTTP response from a PostDiscountsDiscountConditionsWithResponse call
func ParsePostDiscountsDiscountConditionsResponse(rsp *http.Response) (*PostDiscountsDiscountConditionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsDiscountConditionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDiscountsDiscountConditionsConditionResponse parses an HTTP response from a DeleteDiscountsDiscountConditionsConditionWithResponse call
func ParseDeleteDiscountsDiscountConditionsConditionResponse(rsp *http.Response) (*DeleteDiscountsDiscountConditionsConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDiscountsDiscountConditionsConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountConditionsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDiscountsDiscountConditionsConditionResponse parses an HTTP response from a GetDiscountsDiscountConditionsConditionWithResponse call
func ParseGetDiscountsDiscountConditionsConditionResponse(rsp *http.Response) (*GetDiscountsDiscountConditionsConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscountsDiscountConditionsConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountConditionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsDiscountConditionsConditionResponse parses an HTTP response from a PostDiscountsDiscountConditionsConditionWithResponse call
func ParsePostDiscountsDiscountConditionsConditionResponse(rsp *http.Response) (*PostDiscountsDiscountConditionsConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsDiscountConditionsConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDiscountsDiscountConditionsConditionBatchResponse parses an HTTP response from a DeleteDiscountsDiscountConditionsConditionBatchWithResponse call
func ParseDeleteDiscountsDiscountConditionsConditionBatchResponse(rsp *http.Response) (*DeleteDiscountsDiscountConditionsConditionBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDiscountsDiscountConditionsConditionBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsDiscountConditionsConditionBatchResponse parses an HTTP response from a PostDiscountsDiscountConditionsConditionBatchWithResponse call
func ParsePostDiscountsDiscountConditionsConditionBatchResponse(rsp *http.Response) (*PostDiscountsDiscountConditionsConditionBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsDiscountConditionsConditionBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDiscountsDiscountResponse parses an HTTP response from a DeleteDiscountsDiscountWithResponse call
func ParseDeleteDiscountsDiscountResponse(rsp *http.Response) (*DeleteDiscountsDiscountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDiscountsDiscountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDiscountsDiscountResponse parses an HTTP response from a GetDiscountsDiscountWithResponse call
func ParseGetDiscountsDiscountResponse(rsp *http.Response) (*GetDiscountsDiscountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiscountsDiscountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsDiscountResponse parses an HTTP response from a PostDiscountsDiscountWithResponse call
func ParsePostDiscountsDiscountResponse(rsp *http.Response) (*PostDiscountsDiscountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsDiscountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsDiscountDynamicCodesResponse parses an HTTP response from a PostDiscountsDiscountDynamicCodesWithResponse call
func ParsePostDiscountsDiscountDynamicCodesResponse(rsp *http.Response) (*PostDiscountsDiscountDynamicCodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsDiscountDynamicCodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDiscountsDiscountDynamicCodesCodeResponse parses an HTTP response from a DeleteDiscountsDiscountDynamicCodesCodeWithResponse call
func ParseDeleteDiscountsDiscountDynamicCodesCodeResponse(rsp *http.Response) (*DeleteDiscountsDiscountDynamicCodesCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDiscountsDiscountDynamicCodesCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDiscountsDiscountRegionsRegionResponse parses an HTTP response from a DeleteDiscountsDiscountRegionsRegionWithResponse call
func ParseDeleteDiscountsDiscountRegionsRegionResponse(rsp *http.Response) (*DeleteDiscountsDiscountRegionsRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDiscountsDiscountRegionsRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDiscountsDiscountRegionsRegionResponse parses an HTTP response from a PostDiscountsDiscountRegionsRegionWithResponse call
func ParsePostDiscountsDiscountRegionsRegionResponse(rsp *http.Response) (*PostDiscountsDiscountRegionsRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDiscountsDiscountRegionsRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDiscountsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDraftOrdersResponse parses an HTTP response from a GetDraftOrdersWithResponse call
func ParseGetDraftOrdersResponse(rsp *http.Response) (*GetDraftOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDraftOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDraftOrdersResponse parses an HTTP response from a PostDraftOrdersWithResponse call
func ParsePostDraftOrdersResponse(rsp *http.Response) (*PostDraftOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDraftOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDraftOrdersDraftOrderResponse parses an HTTP response from a DeleteDraftOrdersDraftOrderWithResponse call
func ParseDeleteDraftOrdersDraftOrderResponse(rsp *http.Response) (*DeleteDraftOrdersDraftOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDraftOrdersDraftOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDraftOrdersDraftOrderResponse parses an HTTP response from a GetDraftOrdersDraftOrderWithResponse call
func ParseGetDraftOrdersDraftOrderResponse(rsp *http.Response) (*GetDraftOrdersDraftOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDraftOrdersDraftOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDraftOrdersDraftOrderResponse parses an HTTP response from a PostDraftOrdersDraftOrderWithResponse call
func ParsePostDraftOrdersDraftOrderResponse(rsp *http.Response) (*PostDraftOrdersDraftOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDraftOrdersDraftOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDraftOrdersDraftOrderLineItemsResponse parses an HTTP response from a PostDraftOrdersDraftOrderLineItemsWithResponse call
func ParsePostDraftOrdersDraftOrderLineItemsResponse(rsp *http.Response) (*PostDraftOrdersDraftOrderLineItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDraftOrdersDraftOrderLineItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDraftOrdersDraftOrderLineItemsItemResponse parses an HTTP response from a DeleteDraftOrdersDraftOrderLineItemsItemWithResponse call
func ParseDeleteDraftOrdersDraftOrderLineItemsItemResponse(rsp *http.Response) (*DeleteDraftOrdersDraftOrderLineItemsItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDraftOrdersDraftOrderLineItemsItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDraftOrdersDraftOrderLineItemsItemResponse parses an HTTP response from a PostDraftOrdersDraftOrderLineItemsItemWithResponse call
func ParsePostDraftOrdersDraftOrderLineItemsItemResponse(rsp *http.Response) (*PostDraftOrdersDraftOrderLineItemsItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDraftOrdersDraftOrderLineItemsItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDraftOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDraftOrdersDraftOrderRegisterPaymentResponse parses an HTTP response from a PostDraftOrdersDraftOrderRegisterPaymentWithResponse call
func ParsePostDraftOrdersDraftOrderRegisterPaymentResponse(rsp *http.Response) (*PostDraftOrdersDraftOrderRegisterPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDraftOrdersDraftOrderRegisterPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPostDraftOrdersDraftOrderRegisterPaymentRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGiftCardsResponse parses an HTTP response from a GetGiftCardsWithResponse call
func ParseGetGiftCardsResponse(rsp *http.Response) (*GetGiftCardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGiftCardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGiftCardsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostGiftCardsResponse parses an HTTP response from a PostGiftCardsWithResponse call
func ParsePostGiftCardsResponse(rsp *http.Response) (*PostGiftCardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGiftCardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGiftCardsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGiftCardsGiftCardResponse parses an HTTP response from a DeleteGiftCardsGiftCardWithResponse call
func ParseDeleteGiftCardsGiftCardResponse(rsp *http.Response) (*DeleteGiftCardsGiftCardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGiftCardsGiftCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGiftCardsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGiftCardsGiftCardResponse parses an HTTP response from a GetGiftCardsGiftCardWithResponse call
func ParseGetGiftCardsGiftCardResponse(rsp *http.Response) (*GetGiftCardsGiftCardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGiftCardsGiftCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGiftCardsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostGiftCardsGiftCardResponse parses an HTTP response from a PostGiftCardsGiftCardWithResponse call
func ParsePostGiftCardsGiftCardResponse(rsp *http.Response) (*PostGiftCardsGiftCardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGiftCardsGiftCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGiftCardsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemsResponse parses an HTTP response from a GetInventoryItemsWithResponse call
func ParseGetInventoryItemsResponse(rsp *http.Response) (*GetInventoryItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsListWithVariantsAndLocationLevelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsResponse parses an HTTP response from a PostInventoryItemsWithResponse call
func ParsePostInventoryItemsResponse(rsp *http.Response) (*PostInventoryItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryItemsInventoryItemResponse parses an HTTP response from a DeleteInventoryItemsInventoryItemWithResponse call
func ParseDeleteInventoryItemsInventoryItemResponse(rsp *http.Response) (*DeleteInventoryItemsInventoryItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryItemsInventoryItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemsInventoryItemResponse parses an HTTP response from a GetInventoryItemsInventoryItemWithResponse call
func ParseGetInventoryItemsInventoryItemResponse(rsp *http.Response) (*GetInventoryItemsInventoryItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemsInventoryItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsInventoryItemResponse parses an HTTP response from a PostInventoryItemsInventoryItemWithResponse call
func ParsePostInventoryItemsInventoryItemResponse(rsp *http.Response) (*PostInventoryItemsInventoryItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsInventoryItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInventoryItemsInventoryItemLocationLevelsResponse parses an HTTP response from a GetInventoryItemsInventoryItemLocationLevelsWithResponse call
func ParseGetInventoryItemsInventoryItemLocationLevelsResponse(rsp *http.Response) (*GetInventoryItemsInventoryItemLocationLevelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInventoryItemsInventoryItemLocationLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsLocationLevelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsInventoryItemLocationLevelsResponse parses an HTTP response from a PostInventoryItemsInventoryItemLocationLevelsWithResponse call
func ParsePostInventoryItemsInventoryItemLocationLevelsResponse(rsp *http.Response) (*PostInventoryItemsInventoryItemLocationLevelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsInventoryItemLocationLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInventoryItemsInventoryIteLocationLevelsLocationResponse parses an HTTP response from a DeleteInventoryItemsInventoryIteLocationLevelsLocationWithResponse call
func ParseDeleteInventoryItemsInventoryIteLocationLevelsLocationResponse(rsp *http.Response) (*DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInventoryItemsInventoryIteLocationLevelsLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse parses an HTTP response from a PostInventoryItemsInventoryItemLocationLevelsLocationLevelWithResponse call
func ParsePostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse(rsp *http.Response) (*PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInventoryItemsInventoryItemLocationLevelsLocationLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInventoryItemsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInvitesResponse parses an HTTP response from a GetInvitesWithResponse call
func ParseGetInvitesResponse(rsp *http.Response) (*GetInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminListInvitesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInvitesResponse parses an HTTP response from a PostInvitesWithResponse call
func ParsePostInvitesResponse(rsp *http.Response) (*PostInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInvitesInviteAcceptResponse parses an HTTP response from a PostInvitesInviteAcceptWithResponse call
func ParsePostInvitesInviteAcceptResponse(rsp *http.Response) (*PostInvitesInviteAcceptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInvitesInviteAcceptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInvitesInviteResponse parses an HTTP response from a DeleteInvitesInviteWithResponse call
func ParseDeleteInvitesInviteResponse(rsp *http.Response) (*DeleteInvitesInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInvitesInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminInviteDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostInvitesInviteResendResponse parses an HTTP response from a PostInvitesInviteResendWithResponse call
func ParsePostInvitesInviteResendResponse(rsp *http.Response) (*PostInvitesInviteResendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostInvitesInviteResendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotesResponse parses an HTTP response from a GetNotesWithResponse call
func ParseGetNotesResponse(rsp *http.Response) (*GetNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotesListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNotesResponse parses an HTTP response from a PostNotesWithResponse call
func ParsePostNotesResponse(rsp *http.Response) (*PostNotesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNotesNoteResponse parses an HTTP response from a DeleteNotesNoteWithResponse call
func ParseDeleteNotesNoteResponse(rsp *http.Response) (*DeleteNotesNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotesNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotesDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotesNoteResponse parses an HTTP response from a GetNotesNoteWithResponse call
func ParseGetNotesNoteResponse(rsp *http.Response) (*GetNotesNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotesNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNotesNoteResponse parses an HTTP response from a PostNotesNoteWithResponse call
func ParsePostNotesNoteResponse(rsp *http.Response) (*PostNotesNoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNotesNoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationsResponse parses an HTTP response from a GetNotificationsWithResponse call
func ParseGetNotificationsResponse(rsp *http.Response) (*GetNotificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotificationsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostNotificationsNotificationResendResponse parses an HTTP response from a PostNotificationsNotificationResendWithResponse call
func ParsePostNotificationsNotificationResendResponse(rsp *http.Response) (*PostNotificationsNotificationResendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNotificationsNotificationResendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminNotificationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrderEditsResponse parses an HTTP response from a GetOrderEditsWithResponse call
func ParseGetOrderEditsResponse(rsp *http.Response) (*GetOrderEditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderEditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsResponse parses an HTTP response from a PostOrderEditsWithResponse call
func ParsePostOrderEditsResponse(rsp *http.Response) (*PostOrderEditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrderEditsOrderEditResponse parses an HTTP response from a DeleteOrderEditsOrderEditWithResponse call
func ParseDeleteOrderEditsOrderEditResponse(rsp *http.Response) (*DeleteOrderEditsOrderEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderEditsOrderEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOrderEditsOrderEditResponse parses an HTTP response from a GetOrderEditsOrderEditWithResponse call
func ParseGetOrderEditsOrderEditResponse(rsp *http.Response) (*GetOrderEditsOrderEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderEditsOrderEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsOrderEditResponse parses an HTTP response from a PostOrderEditsOrderEditWithResponse call
func ParsePostOrderEditsOrderEditResponse(rsp *http.Response) (*PostOrderEditsOrderEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsOrderEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsOrderEditCancelResponse parses an HTTP response from a PostOrderEditsOrderEditCancelWithResponse call
func ParsePostOrderEditsOrderEditCancelResponse(rsp *http.Response) (*PostOrderEditsOrderEditCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsOrderEditCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrderEditsOrderEditItemChangeResponse parses an HTTP response from a DeleteOrderEditsOrderEditItemChangeWithResponse call
func ParseDeleteOrderEditsOrderEditItemChangeResponse(rsp *http.Response) (*DeleteOrderEditsOrderEditItemChangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderEditsOrderEditItemChangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditItemChangeDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsOrderEditConfirmResponse parses an HTTP response from a PostOrderEditsOrderEditConfirmWithResponse call
func ParsePostOrderEditsOrderEditConfirmResponse(rsp *http.Response) (*PostOrderEditsOrderEditConfirmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsOrderEditConfirmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsEditLineItemsResponse parses an HTTP response from a PostOrderEditsEditLineItemsWithResponse call
func ParsePostOrderEditsEditLineItemsResponse(rsp *http.Response) (*PostOrderEditsEditLineItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsEditLineItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrderEditsOrderEditLineItemsLineItemResponse parses an HTTP response from a DeleteOrderEditsOrderEditLineItemsLineItemWithResponse call
func ParseDeleteOrderEditsOrderEditLineItemsLineItemResponse(rsp *http.Response) (*DeleteOrderEditsOrderEditLineItemsLineItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrderEditsOrderEditLineItemsLineItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsEditLineItemsLineItemResponse parses an HTTP response from a PostOrderEditsEditLineItemsLineItemWithResponse call
func ParsePostOrderEditsEditLineItemsLineItemResponse(rsp *http.Response) (*PostOrderEditsEditLineItemsLineItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsEditLineItemsLineItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrderEditsOrderEditRequestResponse parses an HTTP response from a PostOrderEditsOrderEditRequestWithResponse call
func ParsePostOrderEditsOrderEditRequestResponse(rsp *http.Response) (*PostOrderEditsOrderEditRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrderEditsOrderEditRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrderEditsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersResponse parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResponse(rsp *http.Response) (*GetOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersOrderResponse parses an HTTP response from a GetOrdersOrderWithResponse call
func ParseGetOrdersOrderResponse(rsp *http.Response) (*GetOrdersOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderResponse parses an HTTP response from a PostOrdersOrderWithResponse call
func ParsePostOrdersOrderResponse(rsp *http.Response) (*PostOrdersOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderArchiveResponse parses an HTTP response from a PostOrdersOrderArchiveWithResponse call
func ParsePostOrdersOrderArchiveResponse(rsp *http.Response) (*PostOrdersOrderArchiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderArchiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderCancelResponse parses an HTTP response from a PostOrdersOrderCancelWithResponse call
func ParsePostOrdersOrderCancelResponse(rsp *http.Response) (*PostOrdersOrderCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderCaptureResponse parses an HTTP response from a PostOrdersOrderCaptureWithResponse call
func ParsePostOrdersOrderCaptureResponse(rsp *http.Response) (*PostOrdersOrderCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderClaimsResponse parses an HTTP response from a PostOrdersOrderClaimsWithResponse call
func ParsePostOrdersOrderClaimsResponse(rsp *http.Response) (*PostOrdersOrderClaimsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderClaimsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderClaimsClaimResponse parses an HTTP response from a PostOrdersOrderClaimsClaimWithResponse call
func ParsePostOrdersOrderClaimsClaimResponse(rsp *http.Response) (*PostOrdersOrderClaimsClaimResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderClaimsClaimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersClaimCancelResponse parses an HTTP response from a PostOrdersClaimCancelWithResponse call
func ParsePostOrdersClaimCancelResponse(rsp *http.Response) (*PostOrdersClaimCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersClaimCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderClaimsClaimFulfillmentsResponse parses an HTTP response from a PostOrdersOrderClaimsClaimFulfillmentsWithResponse call
func ParsePostOrdersOrderClaimsClaimFulfillmentsResponse(rsp *http.Response) (*PostOrdersOrderClaimsClaimFulfillmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderClaimsClaimFulfillmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersClaimFulfillmentsCancelResponse parses an HTTP response from a PostOrdersClaimFulfillmentsCancelWithResponse call
func ParsePostOrdersClaimFulfillmentsCancelResponse(rsp *http.Response) (*PostOrdersClaimFulfillmentsCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersClaimFulfillmentsCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderClaimsClaimShipmentsResponse parses an HTTP response from a PostOrdersOrderClaimsClaimShipmentsWithResponse call
func ParsePostOrdersOrderClaimsClaimShipmentsResponse(rsp *http.Response) (*PostOrdersOrderClaimsClaimShipmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderClaimsClaimShipmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderCompleteResponse parses an HTTP response from a PostOrdersOrderCompleteWithResponse call
func ParsePostOrdersOrderCompleteResponse(rsp *http.Response) (*PostOrdersOrderCompleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderCompleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderFulfillmentsResponse parses an HTTP response from a PostOrdersOrderFulfillmentsWithResponse call
func ParsePostOrdersOrderFulfillmentsResponse(rsp *http.Response) (*PostOrdersOrderFulfillmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderFulfillmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderFulfillmentsCancelResponse parses an HTTP response from a PostOrdersOrderFulfillmentsCancelWithResponse call
func ParsePostOrdersOrderFulfillmentsCancelResponse(rsp *http.Response) (*PostOrdersOrderFulfillmentsCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderFulfillmentsCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderLineItemReservationsResponse parses an HTTP response from a PostOrdersOrderLineItemReservationsWithResponse call
func ParsePostOrdersOrderLineItemReservationsResponse(rsp *http.Response) (*PostOrdersOrderLineItemReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderLineItemReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPostReservationsReq
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderRefundsResponse parses an HTTP response from a PostOrdersOrderRefundsWithResponse call
func ParsePostOrdersOrderRefundsResponse(rsp *http.Response) (*PostOrdersOrderRefundsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderRefundsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrdersOrderReservationsResponse parses an HTTP response from a GetOrdersOrderReservationsWithResponse call
func ParseGetOrdersOrderReservationsResponse(rsp *http.Response) (*GetOrdersOrderReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersOrderReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderReturnsResponse parses an HTTP response from a PostOrdersOrderReturnsWithResponse call
func ParsePostOrdersOrderReturnsResponse(rsp *http.Response) (*PostOrdersOrderReturnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderReturnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderShipmentResponse parses an HTTP response from a PostOrdersOrderShipmentWithResponse call
func ParsePostOrdersOrderShipmentResponse(rsp *http.Response) (*PostOrdersOrderShipmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderShipmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderShippingMethodsResponse parses an HTTP response from a PostOrdersOrderShippingMethodsWithResponse call
func ParsePostOrdersOrderShippingMethodsResponse(rsp *http.Response) (*PostOrdersOrderShippingMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderShippingMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderSwapsResponse parses an HTTP response from a PostOrdersOrderSwapsWithResponse call
func ParsePostOrdersOrderSwapsResponse(rsp *http.Response) (*PostOrdersOrderSwapsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderSwapsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersSwapCancelResponse parses an HTTP response from a PostOrdersSwapCancelWithResponse call
func ParsePostOrdersSwapCancelResponse(rsp *http.Response) (*PostOrdersSwapCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersSwapCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderSwapsSwapFulfillmentsResponse parses an HTTP response from a PostOrdersOrderSwapsSwapFulfillmentsWithResponse call
func ParsePostOrdersOrderSwapsSwapFulfillmentsResponse(rsp *http.Response) (*PostOrdersOrderSwapsSwapFulfillmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderSwapsSwapFulfillmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersSwapFulfillmentsCancelResponse parses an HTTP response from a PostOrdersSwapFulfillmentsCancelWithResponse call
func ParsePostOrdersSwapFulfillmentsCancelResponse(rsp *http.Response) (*PostOrdersSwapFulfillmentsCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersSwapFulfillmentsCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderSwapsSwapProcessPaymentResponse parses an HTTP response from a PostOrdersOrderSwapsSwapProcessPaymentWithResponse call
func ParsePostOrdersOrderSwapsSwapProcessPaymentResponse(rsp *http.Response) (*PostOrdersOrderSwapsSwapProcessPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderSwapsSwapProcessPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostOrdersOrderSwapsSwapShipmentsResponse parses an HTTP response from a PostOrdersOrderSwapsSwapShipmentsWithResponse call
func ParsePostOrdersOrderSwapsSwapShipmentsResponse(rsp *http.Response) (*PostOrdersOrderSwapsSwapShipmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOrdersOrderSwapsSwapShipmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminOrdersRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePaymentCollectionsPaymentCollectionResponse parses an HTTP response from a DeletePaymentCollectionsPaymentCollectionWithResponse call
func ParseDeletePaymentCollectionsPaymentCollectionResponse(rsp *http.Response) (*DeletePaymentCollectionsPaymentCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePaymentCollectionsPaymentCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentCollectionDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPaymentCollectionsPaymentCollectionResponse parses an HTTP response from a GetPaymentCollectionsPaymentCollectionWithResponse call
func ParseGetPaymentCollectionsPaymentCollectionResponse(rsp *http.Response) (*GetPaymentCollectionsPaymentCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentCollectionsPaymentCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentCollectionsPaymentCollectionResponse parses an HTTP response from a PostPaymentCollectionsPaymentCollectionWithResponse call
func ParsePostPaymentCollectionsPaymentCollectionResponse(rsp *http.Response) (*PostPaymentCollectionsPaymentCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentCollectionsPaymentCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentCollectionsPaymentCollectionAuthorizeResponse parses an HTTP response from a PostPaymentCollectionsPaymentCollectionAuthorizeWithResponse call
func ParsePostPaymentCollectionsPaymentCollectionAuthorizeResponse(rsp *http.Response) (*PostPaymentCollectionsPaymentCollectionAuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentCollectionsPaymentCollectionAuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentCollectionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPaymentsPaymentResponse parses an HTTP response from a GetPaymentsPaymentWithResponse call
func ParseGetPaymentsPaymentResponse(rsp *http.Response) (*GetPaymentsPaymentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentsPaymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentsPaymentCaptureResponse parses an HTTP response from a PostPaymentsPaymentCaptureWithResponse call
func ParsePostPaymentsPaymentCaptureResponse(rsp *http.Response) (*PostPaymentsPaymentCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentsPaymentCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPaymentsPaymentRefundsResponse parses an HTTP response from a PostPaymentsPaymentRefundsWithResponse call
func ParsePostPaymentsPaymentRefundsResponse(rsp *http.Response) (*PostPaymentsPaymentRefundsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPaymentsPaymentRefundsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRefundRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPriceListsResponse parses an HTTP response from a GetPriceListsWithResponse call
func ParseGetPriceListsResponse(rsp *http.Response) (*GetPriceListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPriceListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsPriceListResponse parses an HTTP response from a PostPriceListsPriceListWithResponse call
func ParsePostPriceListsPriceListResponse(rsp *http.Response) (*PostPriceListsPriceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsPriceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePriceListsPriceListResponse parses an HTTP response from a DeletePriceListsPriceListWithResponse call
func ParseDeletePriceListsPriceListResponse(rsp *http.Response) (*DeletePriceListsPriceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePriceListsPriceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPriceListsPriceListResponse parses an HTTP response from a GetPriceListsPriceListWithResponse call
func ParseGetPriceListsPriceListResponse(rsp *http.Response) (*GetPriceListsPriceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPriceListsPriceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsPriceListPriceListResponse parses an HTTP response from a PostPriceListsPriceListPriceListWithResponse call
func ParsePostPriceListsPriceListPriceListResponse(rsp *http.Response) (*PostPriceListsPriceListPriceListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsPriceListPriceListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePriceListsPriceListPricesBatchResponse parses an HTTP response from a DeletePriceListsPriceListPricesBatchWithResponse call
func ParseDeletePriceListsPriceListPricesBatchResponse(rsp *http.Response) (*DeletePriceListsPriceListPricesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePriceListsPriceListPricesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListDeleteBatchRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPriceListsPriceListPricesBatchResponse parses an HTTP response from a PostPriceListsPriceListPricesBatchWithResponse call
func ParsePostPriceListsPriceListPricesBatchResponse(rsp *http.Response) (*PostPriceListsPriceListPricesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPriceListsPriceListPricesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPriceListsPriceListProductsResponse parses an HTTP response from a GetPriceListsPriceListProductsWithResponse call
func ParseGetPriceListsPriceListProductsResponse(rsp *http.Response) (*GetPriceListsPriceListProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPriceListsPriceListProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListsProductsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePriceListsPriceListProductsPricesBatchResponse parses an HTTP response from a DeletePriceListsPriceListProductsPricesBatchWithResponse call
func ParseDeletePriceListsPriceListProductsPricesBatchResponse(rsp *http.Response) (*DeletePriceListsPriceListProductsPricesBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePriceListsPriceListProductsPricesBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListDeleteProductPricesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePriceListsPriceListProductsProductPricesResponse parses an HTTP response from a DeletePriceListsPriceListProductsProductPricesWithResponse call
func ParseDeletePriceListsPriceListProductsProductPricesResponse(rsp *http.Response) (*DeletePriceListsPriceListProductsProductPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePriceListsPriceListProductsProductPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListDeleteProductPricesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePriceListsPriceListVariantsVariantPricesResponse parses an HTTP response from a DeletePriceListsPriceListVariantsVariantPricesWithResponse call
func ParseDeletePriceListsPriceListVariantsVariantPricesResponse(rsp *http.Response) (*DeletePriceListsPriceListVariantsVariantPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePriceListsPriceListVariantsVariantPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPriceListDeleteVariantPricesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductCategoriesResponse parses an HTTP response from a GetProductCategoriesWithResponse call
func ParseGetProductCategoriesResponse(rsp *http.Response) (*GetProductCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductCategoriesResponse parses an HTTP response from a PostProductCategoriesWithResponse call
func ParsePostProductCategoriesResponse(rsp *http.Response) (*PostProductCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesCategoryRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductCategoriesCategoryResponse parses an HTTP response from a DeleteProductCategoriesCategoryWithResponse call
func ParseDeleteProductCategoriesCategoryResponse(rsp *http.Response) (*DeleteProductCategoriesCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductCategoriesCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesCategoryDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductCategoriesCategoryResponse parses an HTTP response from a GetProductCategoriesCategoryWithResponse call
func ParseGetProductCategoriesCategoryResponse(rsp *http.Response) (*GetProductCategoriesCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductCategoriesCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesCategoryRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductCategoriesCategoryResponse parses an HTTP response from a PostProductCategoriesCategoryWithResponse call
func ParsePostProductCategoriesCategoryResponse(rsp *http.Response) (*PostProductCategoriesCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductCategoriesCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesCategoryRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductCategoriesCategoryProductsBatchResponse parses an HTTP response from a DeleteProductCategoriesCategoryProductsBatchWithResponse call
func ParseDeleteProductCategoriesCategoryProductsBatchResponse(rsp *http.Response) (*DeleteProductCategoriesCategoryProductsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductCategoriesCategoryProductsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesCategoryRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductCategoriesCategoryProductsBatchResponse parses an HTTP response from a PostProductCategoriesCategoryProductsBatchWithResponse call
func ParsePostProductCategoriesCategoryProductsBatchResponse(rsp *http.Response) (*PostProductCategoriesCategoryProductsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductCategoriesCategoryProductsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductCategoriesCategoryRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductTagsResponse parses an HTTP response from a GetProductTagsWithResponse call
func ParseGetProductTagsResponse(rsp *http.Response) (*GetProductTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTagsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductTypesResponse parses an HTTP response from a GetProductTypesWithResponse call
func ParseGetProductTypesResponse(rsp *http.Response) (*GetProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductTypesListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsResponse parses an HTTP response from a GetProductsWithResponse call
func ParseGetProductsResponse(rsp *http.Response) (*GetProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsResponse parses an HTTP response from a PostProductsWithResponse call
func ParsePostProductsResponse(rsp *http.Response) (*PostProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsTagUsageResponse parses an HTTP response from a GetProductsTagUsageWithResponse call
func ParseGetProductsTagUsageResponse(rsp *http.Response) (*GetProductsTagUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsTagUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsListTagsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsTypesResponse parses an HTTP response from a GetProductsTypesWithResponse call
func ParseGetProductsTypesResponse(rsp *http.Response) (*GetProductsTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsListTypesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsProductResponse parses an HTTP response from a DeleteProductsProductWithResponse call
func ParseDeleteProductsProductResponse(rsp *http.Response) (*DeleteProductsProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsProductResponse parses an HTTP response from a GetProductsProductWithResponse call
func ParseGetProductsProductResponse(rsp *http.Response) (*GetProductsProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductResponse parses an HTTP response from a PostProductsProductWithResponse call
func ParsePostProductsProductResponse(rsp *http.Response) (*PostProductsProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductMetadataResponse parses an HTTP response from a PostProductsProductMetadataWithResponse call
func ParsePostProductsProductMetadataResponse(rsp *http.Response) (*PostProductsProductMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductOptionsResponse parses an HTTP response from a PostProductsProductOptionsWithResponse call
func ParsePostProductsProductOptionsResponse(rsp *http.Response) (*PostProductsProductOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsProductOptionsOptionResponse parses an HTTP response from a DeleteProductsProductOptionsOptionWithResponse call
func ParseDeleteProductsProductOptionsOptionResponse(rsp *http.Response) (*DeleteProductsProductOptionsOptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsProductOptionsOptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsDeleteOptionRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductOptionsOptionResponse parses an HTTP response from a PostProductsProductOptionsOptionWithResponse call
func ParsePostProductsProductOptionsOptionResponse(rsp *http.Response) (*PostProductsProductOptionsOptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductOptionsOptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductsProductVariantsResponse parses an HTTP response from a GetProductsProductVariantsWithResponse call
func ParseGetProductsProductVariantsResponse(rsp *http.Response) (*GetProductsProductVariantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductsProductVariantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsListVariantsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductVariantsResponse parses an HTTP response from a PostProductsProductVariantsWithResponse call
func ParsePostProductsProductVariantsResponse(rsp *http.Response) (*PostProductsProductVariantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductVariantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductsProductVariantsVariantResponse parses an HTTP response from a DeleteProductsProductVariantsVariantWithResponse call
func ParseDeleteProductsProductVariantsVariantResponse(rsp *http.Response) (*DeleteProductsProductVariantsVariantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductsProductVariantsVariantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsDeleteVariantRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostProductsProductVariantsVariantResponse parses an HTTP response from a PostProductsProductVariantsVariantWithResponse call
func ParsePostProductsProductVariantsVariantResponse(rsp *http.Response) (*PostProductsProductVariantsVariantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostProductsProductVariantsVariantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminProductsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPublishableApiKeysResponse parses an HTTP response from a GetPublishableApiKeysWithResponse call
func ParseGetPublishableApiKeysResponse(rsp *http.Response) (*GetPublishableApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublishableApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPublishableApiKeysResponse parses an HTTP response from a PostPublishableApiKeysWithResponse call
func ParsePostPublishableApiKeysResponse(rsp *http.Response) (*PostPublishableApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPublishableApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePublishableApiKeysPublishableApiKeyResponse parses an HTTP response from a DeletePublishableApiKeysPublishableApiKeyWithResponse call
func ParseDeletePublishableApiKeysPublishableApiKeyResponse(rsp *http.Response) (*DeletePublishableApiKeysPublishableApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublishableApiKeysPublishableApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeyDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPublishableApiKeysPublishableApiKeyResponse parses an HTTP response from a GetPublishableApiKeysPublishableApiKeyWithResponse call
func ParseGetPublishableApiKeysPublishableApiKeyResponse(rsp *http.Response) (*GetPublishableApiKeysPublishableApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublishableApiKeysPublishableApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPublishableApiKysPublishableApiKeyResponse parses an HTTP response from a PostPublishableApiKysPublishableApiKeyWithResponse call
func ParsePostPublishableApiKysPublishableApiKeyResponse(rsp *http.Response) (*PostPublishableApiKysPublishableApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPublishableApiKysPublishableApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPublishableApiKeysPublishableApiKeyRevokeResponse parses an HTTP response from a PostPublishableApiKeysPublishableApiKeyRevokeWithResponse call
func ParsePostPublishableApiKeysPublishableApiKeyRevokeResponse(rsp *http.Response) (*PostPublishableApiKeysPublishableApiKeyRevokeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPublishableApiKeysPublishableApiKeyRevokeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPublishableApiKeySalesChannelsResponse parses an HTTP response from a GetPublishableApiKeySalesChannelsWithResponse call
func ParseGetPublishableApiKeySalesChannelsResponse(rsp *http.Response) (*GetPublishableApiKeySalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublishableApiKeySalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysListSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePublishableApiKeySalesChannelsChannelsBatchResponse parses an HTTP response from a DeletePublishableApiKeySalesChannelsChannelsBatchWithResponse call
func ParseDeletePublishableApiKeySalesChannelsChannelsBatchResponse(rsp *http.Response) (*DeletePublishableApiKeySalesChannelsChannelsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePublishableApiKeySalesChannelsChannelsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostPublishableApiKeySalesChannelsChannelsBatchResponse parses an HTTP response from a PostPublishableApiKeySalesChannelsChannelsBatchWithResponse call
func ParsePostPublishableApiKeySalesChannelsChannelsBatchResponse(rsp *http.Response) (*PostPublishableApiKeySalesChannelsChannelsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPublishableApiKeySalesChannelsChannelsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPublishableApiKeysRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionsResponse parses an HTTP response from a GetRegionsWithResponse call
func ParseGetRegionsResponse(rsp *http.Response) (*GetRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsResponse parses an HTTP response from a PostRegionsWithResponse call
func ParsePostRegionsResponse(rsp *http.Response) (*PostRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRegionsRegionResponse parses an HTTP response from a DeleteRegionsRegionWithResponse call
func ParseDeleteRegionsRegionResponse(rsp *http.Response) (*DeleteRegionsRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRegionsRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionsRegionResponse parses an HTTP response from a GetRegionsRegionWithResponse call
func ParseGetRegionsRegionResponse(rsp *http.Response) (*GetRegionsRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionsRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionResponse parses an HTTP response from a PostRegionsRegionWithResponse call
func ParsePostRegionsRegionResponse(rsp *http.Response) (*PostRegionsRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionCountriesResponse parses an HTTP response from a PostRegionsRegionCountriesWithResponse call
func ParsePostRegionsRegionCountriesResponse(rsp *http.Response) (*PostRegionsRegionCountriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionCountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionCountriesCountryResponse parses an HTTP response from a PostRegionsRegionCountriesCountryWithResponse call
func ParsePostRegionsRegionCountriesCountryResponse(rsp *http.Response) (*PostRegionsRegionCountriesCountryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionCountriesCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRegionsRegionFulfillmentOptionsResponse parses an HTTP response from a GetRegionsRegionFulfillmentOptionsWithResponse call
func ParseGetRegionsRegionFulfillmentOptionsResponse(rsp *http.Response) (*GetRegionsRegionFulfillmentOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionsRegionFulfillmentOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGetRegionsRegionFulfillmentOptionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionFulfillmentProvidersResponse parses an HTTP response from a PostRegionsRegionFulfillmentProvidersWithResponse call
func ParsePostRegionsRegionFulfillmentProvidersResponse(rsp *http.Response) (*PostRegionsRegionFulfillmentProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionFulfillmentProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionFulfillmentProvidersProviderResponse parses an HTTP response from a PostRegionsRegionFulfillmentProvidersProviderWithResponse call
func ParsePostRegionsRegionFulfillmentProvidersProviderResponse(rsp *http.Response) (*PostRegionsRegionFulfillmentProvidersProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionFulfillmentProvidersProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionPaymentProvidersResponse parses an HTTP response from a PostRegionsRegionPaymentProvidersWithResponse call
func ParsePostRegionsRegionPaymentProvidersResponse(rsp *http.Response) (*PostRegionsRegionPaymentProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionPaymentProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostRegionsRegionPaymentProvidersProviderResponse parses an HTTP response from a PostRegionsRegionPaymentProvidersProviderWithResponse call
func ParsePostRegionsRegionPaymentProvidersProviderResponse(rsp *http.Response) (*PostRegionsRegionPaymentProvidersProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegionsRegionPaymentProvidersProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminRegionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReservationsResponse parses an HTTP response from a GetReservationsWithResponse call
func ParseGetReservationsResponse(rsp *http.Response) (*GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReservationsResponse parses an HTTP response from a PostReservationsWithResponse call
func ParsePostReservationsResponse(rsp *http.Response) (*PostReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReservationsReservationResponse parses an HTTP response from a DeleteReservationsReservationWithResponse call
func ParseDeleteReservationsReservationResponse(rsp *http.Response) (*DeleteReservationsReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservationsReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReservationsReservationResponse parses an HTTP response from a GetReservationsReservationWithResponse call
func ParseGetReservationsReservationResponse(rsp *http.Response) (*GetReservationsReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservationsReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReservationsReservationResponse parses an HTTP response from a PostReservationsReservationWithResponse call
func ParsePostReservationsReservationResponse(rsp *http.Response) (*PostReservationsReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservationsReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReservationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnReasonsResponse parses an HTTP response from a GetReturnReasonsWithResponse call
func ParseGetReturnReasonsResponse(rsp *http.Response) (*GetReturnReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnReasonsResponse parses an HTTP response from a PostReturnReasonsWithResponse call
func ParsePostReturnReasonsResponse(rsp *http.Response) (*PostReturnReasonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnReasonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteReturnReasonResponse parses an HTTP response from a DeleteReturnReasonWithResponse call
func ParseDeleteReturnReasonResponse(rsp *http.Response) (*DeleteReturnReasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReturnReasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnReasonsReasonResponse parses an HTTP response from a GetReturnReasonsReasonWithResponse call
func ParseGetReturnReasonsReasonResponse(rsp *http.Response) (*GetReturnReasonsReasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnReasonsReasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnReasonsReasonResponse parses an HTTP response from a PostReturnReasonsReasonWithResponse call
func ParsePostReturnReasonsReasonResponse(rsp *http.Response) (*PostReturnReasonsReasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnReasonsReasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnReasonsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReturnsResponse parses an HTTP response from a GetReturnsWithResponse call
func ParseGetReturnsResponse(rsp *http.Response) (*GetReturnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReturnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsReturnCancelResponse parses an HTTP response from a PostReturnsReturnCancelWithResponse call
func ParsePostReturnsReturnCancelResponse(rsp *http.Response) (*PostReturnsReturnCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsReturnCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnsCancelRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostReturnsReturnReceiveResponse parses an HTTP response from a PostReturnsReturnReceiveWithResponse call
func ParsePostReturnsReturnReceiveResponse(rsp *http.Response) (*PostReturnsReturnReceiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReturnsReturnReceiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminReturnsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSalesChannelsResponse parses an HTTP response from a GetSalesChannelsWithResponse call
func ParseGetSalesChannelsResponse(rsp *http.Response) (*GetSalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsResponse parses an HTTP response from a PostSalesChannelsWithResponse call
func ParsePostSalesChannelsResponse(rsp *http.Response) (*PostSalesChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSalesChannelsSalesChannelResponse parses an HTTP response from a DeleteSalesChannelsSalesChannelWithResponse call
func ParseDeleteSalesChannelsSalesChannelResponse(rsp *http.Response) (*DeleteSalesChannelsSalesChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSalesChannelsSalesChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSalesChannelsSalesChannelResponse parses an HTTP response from a GetSalesChannelsSalesChannelWithResponse call
func ParseGetSalesChannelsSalesChannelResponse(rsp *http.Response) (*GetSalesChannelsSalesChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSalesChannelsSalesChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsSalesChannelResponse parses an HTTP response from a PostSalesChannelsSalesChannelWithResponse call
func ParsePostSalesChannelsSalesChannelResponse(rsp *http.Response) (*PostSalesChannelsSalesChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsSalesChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSalesChannelsChannelProductsBatchResponse parses an HTTP response from a DeleteSalesChannelsChannelProductsBatchWithResponse call
func ParseDeleteSalesChannelsChannelProductsBatchResponse(rsp *http.Response) (*DeleteSalesChannelsChannelProductsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSalesChannelsChannelProductsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsChannelProductsBatchResponse parses an HTTP response from a PostSalesChannelsChannelProductsBatchWithResponse call
func ParsePostSalesChannelsChannelProductsBatchResponse(rsp *http.Response) (*PostSalesChannelsChannelProductsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsChannelProductsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSalesChannelsSalesChannelStockLocationResponse parses an HTTP response from a DeleteSalesChannelsSalesChannelStockLocationWithResponse call
func ParseDeleteSalesChannelsSalesChannelStockLocationResponse(rsp *http.Response) (*DeleteSalesChannelsSalesChannelStockLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSalesChannelsSalesChannelStockLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsDeleteLocationRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSalesChannelsSalesChannelStockLocationResponse parses an HTTP response from a PostSalesChannelsSalesChannelStockLocationWithResponse call
func ParsePostSalesChannelsSalesChannelStockLocationResponse(rsp *http.Response) (*PostSalesChannelsSalesChannelStockLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSalesChannelsSalesChannelStockLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSalesChannelsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingOptionsResponse parses an HTTP response from a GetShippingOptionsWithResponse call
func ParseGetShippingOptionsResponse(rsp *http.Response) (*GetShippingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingOptionsResponse parses an HTTP response from a PostShippingOptionsWithResponse call
func ParsePostShippingOptionsResponse(rsp *http.Response) (*PostShippingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteShippingOptionsOptionResponse parses an HTTP response from a DeleteShippingOptionsOptionWithResponse call
func ParseDeleteShippingOptionsOptionResponse(rsp *http.Response) (*DeleteShippingOptionsOptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShippingOptionsOptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingOptionsOptionResponse parses an HTTP response from a GetShippingOptionsOptionWithResponse call
func ParseGetShippingOptionsOptionResponse(rsp *http.Response) (*GetShippingOptionsOptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingOptionsOptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingOptionsOptionResponse parses an HTTP response from a PostShippingOptionsOptionWithResponse call
func ParsePostShippingOptionsOptionResponse(rsp *http.Response) (*PostShippingOptionsOptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingOptionsOptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingOptionsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingProfilesResponse parses an HTTP response from a GetShippingProfilesWithResponse call
func ParseGetShippingProfilesResponse(rsp *http.Response) (*GetShippingProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfilesListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingProfilesResponse parses an HTTP response from a PostShippingProfilesWithResponse call
func ParsePostShippingProfilesResponse(rsp *http.Response) (*PostShippingProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfilesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteShippingProfilesProfileResponse parses an HTTP response from a DeleteShippingProfilesProfileWithResponse call
func ParseDeleteShippingProfilesProfileResponse(rsp *http.Response) (*DeleteShippingProfilesProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteShippingProfilesProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDeleteShippingProfileRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetShippingProfilesProfileResponse parses an HTTP response from a GetShippingProfilesProfileWithResponse call
func ParseGetShippingProfilesProfileResponse(rsp *http.Response) (*GetShippingProfilesProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShippingProfilesProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfilesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostShippingProfilesProfileResponse parses an HTTP response from a PostShippingProfilesProfileWithResponse call
func ParsePostShippingProfilesProfileResponse(rsp *http.Response) (*PostShippingProfilesProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostShippingProfilesProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminShippingProfilesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStockLocationsResponse parses an HTTP response from a GetStockLocationsWithResponse call
func ParseGetStockLocationsResponse(rsp *http.Response) (*GetStockLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStockLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsResponse parses an HTTP response from a PostStockLocationsWithResponse call
func ParsePostStockLocationsResponse(rsp *http.Response) (*PostStockLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteStockLocationsStockLocationResponse parses an HTTP response from a DeleteStockLocationsStockLocationWithResponse call
func ParseDeleteStockLocationsStockLocationResponse(rsp *http.Response) (*DeleteStockLocationsStockLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStockLocationsStockLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationsDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetStockLocationsStockLocationResponse parses an HTTP response from a GetStockLocationsStockLocationWithResponse call
func ParseGetStockLocationsStockLocationResponse(rsp *http.Response) (*GetStockLocationsStockLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStockLocationsStockLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostStockLocationsStockLocationResponse parses an HTTP response from a PostStockLocationsStockLocationWithResponse call
func ParsePostStockLocationsStockLocationResponse(rsp *http.Response) (*PostStockLocationsStockLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStockLocationsStockLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStockLocationsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStoreResponse parses an HTTP response from a GetStoreWithResponse call
func ParseGetStoreResponse(rsp *http.Response) (*GetStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminExtendedStoresRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStoreResponse parses an HTTP response from a PostStoreWithResponse call
func ParsePostStoreResponse(rsp *http.Response) (*PostStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStoresRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteStoreCurrenciesCodeResponse parses an HTTP response from a DeleteStoreCurrenciesCodeWithResponse call
func ParseDeleteStoreCurrenciesCodeResponse(rsp *http.Response) (*DeleteStoreCurrenciesCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoreCurrenciesCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStoresRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostStoreCurrenciesCodeResponse parses an HTTP response from a PostStoreCurrenciesCodeWithResponse call
func ParsePostStoreCurrenciesCodeResponse(rsp *http.Response) (*PostStoreCurrenciesCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostStoreCurrenciesCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminStoresRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStorePaymentProvidersResponse parses an HTTP response from a GetStorePaymentProvidersWithResponse call
func ParseGetStorePaymentProvidersResponse(rsp *http.Response) (*GetStorePaymentProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorePaymentProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminPaymentProvidersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStoreTaxProvidersResponse parses an HTTP response from a GetStoreTaxProvidersWithResponse call
func ParseGetStoreTaxProvidersResponse(rsp *http.Response) (*GetStoreTaxProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoreTaxProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxProvidersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSwapsResponse parses an HTTP response from a GetSwapsWithResponse call
func ParseGetSwapsResponse(rsp *http.Response) (*GetSwapsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSwapsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSwapsSwapResponse parses an HTTP response from a GetSwapsSwapWithResponse call
func ParseGetSwapsSwapResponse(rsp *http.Response) (*GetSwapsSwapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapsSwapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSwapsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaxRatesResponse parses an HTTP response from a GetTaxRatesWithResponse call
func ParseGetTaxRatesResponse(rsp *http.Response) (*GetTaxRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesResponse parses an HTTP response from a PostTaxRatesWithResponse call
func ParsePostTaxRatesResponse(rsp *http.Response) (*PostTaxRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRatesTaxRateResponse parses an HTTP response from a DeleteTaxRatesTaxRateWithResponse call
func ParseDeleteTaxRatesTaxRateResponse(rsp *http.Response) (*DeleteTaxRatesTaxRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRatesTaxRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesDeleteRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTaxRatesTaxRateResponse parses an HTTP response from a GetTaxRatesTaxRateWithResponse call
func ParseGetTaxRatesTaxRateResponse(rsp *http.Response) (*GetTaxRatesTaxRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaxRatesTaxRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesTaxRateResponse parses an HTTP response from a PostTaxRatesTaxRateWithResponse call
func ParsePostTaxRatesTaxRateResponse(rsp *http.Response) (*PostTaxRatesTaxRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesTaxRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRatesTaxRateProductTypesResponse parses an HTTP response from a DeleteTaxRatesTaxRateProductTypesWithResponse call
func ParseDeleteTaxRatesTaxRateProductTypesResponse(rsp *http.Response) (*DeleteTaxRatesTaxRateProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRatesTaxRateProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesTaxRateProductTypesResponse parses an HTTP response from a PostTaxRatesTaxRateProductTypesWithResponse call
func ParsePostTaxRatesTaxRateProductTypesResponse(rsp *http.Response) (*PostTaxRatesTaxRateProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesTaxRateProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRatesTaxRateProductsResponse parses an HTTP response from a DeleteTaxRatesTaxRateProductsWithResponse call
func ParseDeleteTaxRatesTaxRateProductsResponse(rsp *http.Response) (*DeleteTaxRatesTaxRateProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRatesTaxRateProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesTaxRateProductsResponse parses an HTTP response from a PostTaxRatesTaxRateProductsWithResponse call
func ParsePostTaxRatesTaxRateProductsResponse(rsp *http.Response) (*PostTaxRatesTaxRateProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesTaxRateProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTaxRatesTaxRateShippingOptionsResponse parses an HTTP response from a DeleteTaxRatesTaxRateShippingOptionsWithResponse call
func ParseDeleteTaxRatesTaxRateShippingOptionsResponse(rsp *http.Response) (*DeleteTaxRatesTaxRateShippingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTaxRatesTaxRateShippingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostTaxRatesTaxRateShippingOptionsResponse parses an HTTP response from a PostTaxRatesTaxRateShippingOptionsWithResponse call
func ParsePostTaxRatesTaxRateShippingOptionsResponse(rsp *http.Response) (*PostTaxRatesTaxRateShippingOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTaxRatesTaxRateShippingOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminTaxRatesRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUploadsResponse parses an HTTP response from a DeleteUploadsWithResponse call
func ParseDeleteUploadsResponse(rsp *http.Response) (*DeleteUploadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUploadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDeleteUploadsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUploadsResponse parses an HTTP response from a PostUploadsWithResponse call
func ParsePostUploadsResponse(rsp *http.Response) (*PostUploadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUploadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUploadsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUploadsDownloadUrlResponse parses an HTTP response from a PostUploadsDownloadUrlWithResponse call
func ParsePostUploadsDownloadUrlResponse(rsp *http.Response) (*PostUploadsDownloadUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUploadsDownloadUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUploadsDownloadUrlRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUploadsProtectedResponse parses an HTTP response from a PostUploadsProtectedWithResponse call
func ParsePostUploadsProtectedResponse(rsp *http.Response) (*PostUploadsProtectedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUploadsProtectedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUploadsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUsersListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUsersResponse parses an HTTP response from a PostUsersWithResponse call
func ParsePostUsersResponse(rsp *http.Response) (*PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUsersUserPasswordTokenResponse parses an HTTP response from a PostUsersUserPasswordTokenWithResponse call
func ParsePostUsersUserPasswordTokenResponse(rsp *http.Response) (*PostUsersUserPasswordTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersUserPasswordTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUsersUserPasswordResponse parses an HTTP response from a PostUsersUserPasswordWithResponse call
func ParsePostUsersUserPasswordResponse(rsp *http.Response) (*PostUsersUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUsersUserResponse parses an HTTP response from a DeleteUsersUserWithResponse call
func ParseDeleteUsersUserResponse(rsp *http.Response) (*DeleteUsersUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUsersUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminDeleteUserRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersUserResponse parses an HTTP response from a GetUsersUserWithResponse call
func ParseGetUsersUserResponse(rsp *http.Response) (*GetUsersUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostUsersUserResponse parses an HTTP response from a PostUsersUserWithResponse call
func ParsePostUsersUserResponse(rsp *http.Response) (*PostUsersUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUsersUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminUserRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVariantsResponse parses an HTTP response from a GetVariantsWithResponse call
func ParseGetVariantsResponse(rsp *http.Response) (*GetVariantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminVariantsListRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVariantsVariantResponse parses an HTTP response from a GetVariantsVariantWithResponse call
func ParseGetVariantsVariantResponse(rsp *http.Response) (*GetVariantsVariantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariantsVariantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminVariantsRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVariantsVariantInventoryResponse parses an HTTP response from a GetVariantsVariantInventoryWithResponse call
func ParseGetVariantsVariantInventoryResponse(rsp *http.Response) (*GetVariantsVariantInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariantsVariantInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGetVariantsVariantInventoryRes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest InvalidStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InvalidRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
